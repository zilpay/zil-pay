Project Path: zil-pay

Source Tree:

```txt
zil-pay
├── __tests__
│   ├── array
│   │   └── array.test.ts
│   ├── crypto
│   │   ├── aes256.test.ts
│   │   ├── bip32.test.ts
│   │   ├── bip39.test.ts
│   │   ├── number.test.ts
│   │   ├── pbkdf2.test.ts
│   │   ├── pubkey.test.ts
│   │   ├── random.test.ts
│   │   ├── schnorr.test.ts
│   │   ├── sha256.test.ts
│   │   ├── sha512.test.ts
│   │   └── word_list.ts
│   ├── setupTests.ts
│   ├── storage
│   │   └── storage.test.ts
│   ├── stream
│   │   └── stream.test.ts
│   ├── types
│   │   └── checker.test.ts
│   └── zilliqa
│       └── address.test.ts
├── background
│   └── index.ts
├── config
│   ├── errors.ts
│   ├── fields.ts
│   ├── pbkdf2.ts
│   └── sha.ts
├── content
│   └── index.ts
├── crypto
│   ├── aes256.ts
│   ├── bip32.ts
│   ├── bip39.ts
│   ├── index.ts
│   ├── number.ts
│   ├── pbkdf2.ts
│   ├── proto
│   │   └── zq1.ts
│   ├── pubkey.ts
│   ├── random.ts
│   ├── sha256.ts
│   ├── sha512.ts
│   ├── uuid.ts
│   └── zilliqa
│       ├── pubkey.ts
│       └── schnorr.ts
├── lib
│   ├── array
│   │   ├── chunk.ts
│   │   └── shuffle.ts
│   ├── popup
│   │   ├── clipboard.ts
│   │   ├── printer.ts
│   │   └── warp-message.ts
│   ├── runtime
│   │   ├── assert.ts
│   │   ├── ext-id.ts
│   │   ├── extensionizer.ts
│   │   ├── get-url.ts
│   │   └── manifest.ts
│   ├── storage
│   │   ├── builder.ts
│   │   └── storage.ts
│   ├── streem
│   │   ├── TabsMessage.ts
│   │   ├── keys.ts
│   │   ├── message.ts
│   │   ├── secure-message.ts
│   │   ├── tab-stream.ts
│   │   └── tabs-message.ts
│   ├── types
│   │   └── checker.ts
│   └── zilliqa
│       ├── bech32.ts
│       ├── checksum.ts
│       ├── config.ts
│       └── pubkey.ts
├── popup
│   ├── index.ts
│   └── main.ts
└── vitest.config.ts

```

`zil-pay/__tests__/array/array.test.ts`:

```ts
import { describe, expect, it } from 'vitest';
import { shuffle } from '../../lib/array/shuffle';
import { chunk } from '../../lib/array/chunk';

describe('shuffle', () => {
  it('should shuffle an array of numbers', () => {
    const array = [1, 2, 3, 4, 5];
    const shuffledArray = shuffle([...array]);

    expect(shuffledArray).toHaveLength(array.length);
    expect(shuffledArray).not.toEqual(array);
    expect(shuffledArray.sort()).toEqual(array.sort());
  });

  it('should shuffle an array of strings', () => {
    const array = ['a', 'b', 'c', 'd', 'e'];
    const shuffledArray = shuffle([...array]);

    expect(shuffledArray).toHaveLength(array.length);
    expect(shuffledArray).not.toEqual(array);
    expect(shuffledArray.sort()).toEqual(array.sort());
  });

  it('should handle an empty array', () => {
    const array: number[] = [];
    const shuffledArray = shuffle([...array]);
    expect(shuffledArray).toEqual([]);
  });

  it('should handle an array with one element', () => {
    const array = [1];
    const shuffledArray = shuffle([...array]);
    expect(shuffledArray).toEqual([1]);
  });
});

describe('chunk', () => {
  it('should chunk an array into smaller arrays of the specified size', () => {
    const array = [1, 2, 3, 4, 5, 6, 7, 8];
    const chunkSize = 3;
    const result = chunk(array, chunkSize);
    expect(result).toEqual([[1, 2, 3], [4, 5, 6], [7, 8]]);
  });

  it('should handle a chunk size larger than the array length', () => {
    const array = [1, 2, 3, 4, 5];
    const chunkSize = 10;
    const result = chunk(array, chunkSize);
    expect(result).toEqual([[1, 2, 3, 4, 5]]);
  });

  it('should handle an array with a length that is a multiple of the chunk size', () => {
    const array = [1, 2, 3, 4, 5, 6];
    const chunkSize = 2;
    const result = chunk(array, chunkSize);
    expect(result).toEqual([[1, 2], [3, 4], [5, 6]]);
  });

  it('should handle an empty array', () => {
    const array: number[] = [];
    const chunkSize = 3;
    const result = chunk(array, chunkSize);
    expect(result).toEqual([]);
  });

  it('should throw an error if the chunk size is zero', () => {
    const array = [1, 2, 3, 4, 5];
    const chunkSize = 0;
    expect(() => chunk(array, chunkSize)).toThrowError("Size must be a positive number.");
  });

  it('should throw an error if the chunk size is negative', () => {
    const array = [1, 2, 3, 4, 5];
    const chunkSize = -1;
    expect(() => chunk(array, chunkSize)).toThrowError("Size must be a positive number.");
  });
});


```

`zil-pay/__tests__/crypto/aes256.test.ts`:

```ts
import { test, expect } from 'vitest';
import { Cipher } from '../../crypto/aes256';
import { ErrorMessages } from '../../config/errors';

test('encrypt encrypts data and decrypt successfully recovers it', () => {
  const key = new TextEncoder().encode('1234567890123456'); // 16-byte key
  const content = new TextEncoder().encode('Hello, ZilPay!');

  const encrypted = Cipher.encrypt(content, key);
  const decrypted = Cipher.decrypt(encrypted, key);

  expect(new TextDecoder().decode(decrypted)).toBe('Hello, ZilPay!');
});

test('decrypt with wrong key does not return original content', () => {
  const key = new TextEncoder().encode('correctKey123456'); // 16-byte key
  const wrongKey = new TextEncoder().encode('wrongKey12345678'); // 16-byte key

  const content = new TextEncoder().encode('Secret message');
  const encrypted = Cipher.encrypt(content, key);

  const decrypted = Cipher.decrypt(encrypted, wrongKey);

  expect(decrypted).not.toEqual(content);
  expect(new TextDecoder().decode(decrypted)).not.toBe(
    new TextDecoder().decode(content)
  );
});

test('encrypt throws if key length is invalid', () => {
  const invalidKey = new TextEncoder().encode('shortkey'); // <16 bytes
  const content = new TextEncoder().encode('Data');

  expect(() => Cipher.encrypt(content, invalidKey)).toThrowError(
    ErrorMessages.InvalidKeyLength
  );
});

```

`zil-pay/__tests__/crypto/bip32.test.ts`:

```ts
import { describe, it, expect } from 'vitest';
import { derivePrivateKey } from '../../crypto/bip32';
import { Bip39 } from '../../crypto/bip39';
import { WORD_LIST } from './word_list';
import { utils } from 'aes-js';

describe('BIP-32 Derivation', () => {
  it('should derive correct private key from BIP-39 mnemonic', async () => {
    const phrase = 'panda eyebrow bullet gorilla call smoke muffin taste mesh discover soft ostrich alcohol speed nation flash devote level hobby quick inner drive ghost inside';
    const expectedSecretKey = utils.hex.toBytes("ff1e68eb7bf2f48651c47ef0177eb815857322257c5894bb4cfd1176c9989314");
    const seed = await Bip39.mnemonicToSeed(phrase, '', WORD_LIST);
    const privateKey = await derivePrivateKey(seed, "m/44'/60'/0'/0/0");

    expect(privateKey).toEqual(expectedSecretKey);
  });
});

```

`zil-pay/__tests__/crypto/bip39.test.ts`:

```ts
import { describe, expect, it } from 'vitest';
import { Bip39, Bip39Error } from '../../crypto/bip39';
import { utils } from 'aes-js';
import { sha256 } from '../../crypto/sha256';
import { WORD_LIST } from './word_list';

const TEST_VECTORS = [
  {
    entropy: '00000000000000000000000000000000',
    mnemonic:
      'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about',
    seed: 'c55257c360c07c72029aebc1b53c05ed0362ada38ead3e3e9efa3708e53495531f09a6987599d18264c1e1c92f2cf141630c7a3c4ab7c81b2f001698e7463b04',
  },
  {
    entropy: '7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f',
    mnemonic: 'legal winner thank year wave sausage worth useful legal winner thank yellow',
    seed: '2e8905819b8723fe2c1d161860e5ee1830318dbf49a83bd451cfb8440c28bd6fa457fe1296106559a3c80937a1c1069be3a3a5bd381ee6260e8d9739fce1f607',
  },
  {
    entropy: '80808080808080808080808080808080',
    mnemonic: 'letter advice cage absurd amount doctor acoustic avoid letter advice cage above',
    seed: 'd71de856f81a8acc65e6fc851a38d4d7ec216fd0796d0a6827a3ad6ed5511a30fa280f12eb2e47ed2ac03b5c462a0358d18d69fe4f985ec81778c1b370b652a8',
  },
  {
    entropy: 'ffffffffffffffffffffffffffffffff',
    mnemonic: 'zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong',
    seed: 'ac27495480225222079d7be181583751e86f571027b0497b5b5d11218e0a8a13332572917f0f8e5a589620c6f15b11c61dee327651a14c34e18231052e48c069',
  },
  {
    entropy: '000000000000000000000000000000000000000000000000',
    mnemonic:
      'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon agent',
    seed: '035895f2f481b1b0f01fcf8c289c794660b289981a78f8106447707fdd9666ca06da5a9a565181599b79f53b844d8a71dd9f439c52a3d7b3e8a79c906ac845fa',
  },
  {
    entropy: '7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f',
    mnemonic:
      'legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal will',
    seed: 'f2b94508732bcbacbcc020faefecfc89feafa6649a5491b8c952cede496c214a0c7b3c392d168748f2d4a612bada0753b52a1c7ac53c1e93abd5c6320b9e95dd',
  },
  {
    entropy: '808080808080808080808080808080808080808080808080',
    mnemonic:
      'letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter always',
    seed: '107d7c02a5aa6f38c58083ff74f04c607c2d2c0ecc55501dadd72d025b751bc27fe913ffb796f841c49b1d33b610cf0e91d3aa239027f5e99fe4ce9e5088cd65',
  },
  {
    entropy: 'ffffffffffffffffffffffffffffffffffffffffffffffff',
    mnemonic:
      'zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo when',
    seed: '0cd6e5d827bb62eb8fc1e262254223817fd068a74b5b449cc2f667c3f1f985a76379b43348d952e2265b4cd129090758b3e3c2c49103b5051aac2eaeb890a528',
  },
  {
    entropy: '0000000000000000000000000000000000000000000000000000000000000000',
    mnemonic:
      'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art',
    seed: 'bda85446c68413707090a52022edd26a1c9462295029f2e60cd7c4f2bbd3097170af7a4d73245cafa9c3cca8d561a7c3de6f5d4a10be8ed2a5e608d68f92fcc8',
  },
  {
    entropy: '7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f',
    mnemonic:
      'legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth title',
    seed: 'bc09fca1804f7e69da93c2f2028eb238c227f2e9dda30cd63699232578480a4021b146ad717fbb7e451ce9eb835f43620bf5c514db0f8add49f5d121449d3e87',
  },
  {
    entropy: '8080808080808080808080808080808080808080808080808080808080808080',
    mnemonic:
      'letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic bless',
    seed: 'c0c519bd0e91a2ed54357d9d1ebef6f5af218a153624cf4f2da911a0ed8f7a09e2ef61af0aca007096df430022f7a2b6fb91661a9589097069720d015e4e982f',
  },
  {
    entropy: 'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
    mnemonic:
      'zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo vote',
    seed: 'dd48c104698c30cfe2b6142103248622fb7bb0ff692eebb00089b32d22484e1613912f0a5b694407be899ffd31ed3992c456cdf60f5d4564b8ba3f05a69890ad',
  },
  {
    entropy: '9e885d952ad362caeb4efe34a8e91bd2',
    mnemonic: 'ozone drill grab fiber curtain grace pudding thank cruise elder eight picnic',
    seed: '274ddc525802f7c828d8ef7ddbcdc5304e87ac3535913611fbbfa986d0c9e5476c91689f9c8a54fd55bd38606aa6a8595ad213d4c9c9f9aca3fb217069a41028',
  },
  {
    entropy: '6610b25967cdcca9d59875f5cb50b0ea75433311869e930b',
    mnemonic:
      'gravity machine north sort system female filter attitude volume fold club stay feature office ecology stable narrow fog',
    seed: '628c3827a8823298ee685db84f55caa34b5cc195a778e52d45f59bcf75aba68e4d7590e101dc414bc1bbd5737666fbbef35d1f1903953b66624f910feef245ac',
  },
  {
    entropy: '68a79eaca2324873eacc50cb9c6eca8cc68ea5d936f98787c60c7ebc74e6ce7c',
    mnemonic:
      'hamster diagram private dutch cause delay private meat slide toddler razor book happy fancy gospel tennis maple dilemma loan word shrug inflict delay length',
    seed: '64c87cde7e12ecf6704ab95bb1408bef047c22db4cc7491c4271d170a1b213d20b385bc1588d9c7b38f1b39d415665b8a9030c9ec653d75e65f847d8fc1fc440',
  },
  {
    entropy: 'c0ba5a8e914111210f2bd131f3d5e08d',
    mnemonic: 'scheme spot photo card baby mountain device kick cradle pact join borrow',
    seed: 'ea725895aaae8d4c1cf682c1bfd2d358d52ed9f0f0591131b559e2724bb234fca05aa9c02c57407e04ee9dc3b454aa63fbff483a8b11de949624b9f1831a9612',
  },
  {
    entropy: '6d9be1ee6ebd27a258115aad99b7317b9c8d28b6d76431c3',
    mnemonic:
      'horn tenant knee talent sponsor spell gate clip pulse soap slush warm silver nephew swap uncle crack brave',
    seed: 'fd579828af3da1d32544ce4db5c73d53fc8acc4ddb1e3b251a31179cdb71e853c56d2fcb11aed39898ce6c34b10b5382772db8796e52837b54468aeb312cfc3d',
  },
  {
    entropy: '9f6a2878b2520799a44ef18bc7df394e7061a224d2c33cd015b157d746869863',
    mnemonic:
      'panda eyebrow bullet gorilla call smoke muffin taste mesh discover soft ostrich alcohol speed nation flash devote level hobby quick inner drive ghost inside',
    seed: '72be8e052fc4919d2adf28d5306b5474b0069df35b02303de8c1729c9538dbb6fc2d731d5f832193cd9fb6aeecbc469594a70e3dd50811b5067f3b88b28c3e8d',
  },
  {
    entropy: '23db8160a31d3e0dca3688ed941adbf3',
    mnemonic: 'cat swing flag economy stadium alone churn speed unique patch report train',
    seed: 'deb5f45449e615feff5640f2e49f933ff51895de3b4381832b3139941c57b59205a42480c52175b6efcffaa58a2503887c1e8b363a707256bdd2b587b46541f5',
  },
  {
    entropy: '8197a4a47f0425faeaa69deebc05ca29c0a5b5cc76ceacc0',
    mnemonic:
      'light rule cinnamon wrap drastic word pride squirrel upgrade then income fatal apart sustain crack supply proud access',
    seed: '4cbdff1ca2db800fd61cae72a57475fdc6bab03e441fd63f96dabd1f183ef5b782925f00105f318309a7e9c3ea6967c7801e46c8a58082674c860a37b93eda02',
  },
  {
    entropy: '066dca1a2bb7e8a1db2832148ce9933eea0f3ac9548d793112d9a95c9407efad',
    mnemonic:
      'all hour make first leader extend hole alien behind guard gospel lava path output census museum junior mass reopen famous sing advance salt reform',
    seed: '26e975ec644423f4a4c4f4215ef09b4bd7ef924e85d1d17c4cf3f136c2863cf6df0a475045652c57eb5fb41513ca2a2d67722b77e954b4b3fc11f7590449191d',
  },
  {
    entropy: 'f30f8c1da665478f49b001d94c5fc452',
    mnemonic: 'vessel ladder alter error federal sibling chat ability sun glass valve picture',
    seed: '2aaa9242daafcee6aa9d7269f17d4efe271e1b9a529178d7dc139cd18747090bf9d60295d0ce74309a78852a9caadf0af48aae1c6253839624076224374bc63f',
  },
  {
    entropy: 'c10ec20dc3cd9f652c7fac2f1230f7a3c828389a14392f05',
    mnemonic:
      'scissors invite lock maple supreme raw rapid void congress muscle digital elegant little brisk hair mango congress clump',
    seed: '7b4a10be9d98e6cba265566db7f136718e1398c71cb581e1b2f464cac1ceedf4f3e274dc270003c670ad8d02c4558b2f8e39edea2775c9e232c7cb798b069e88',
  },
  {
    entropy: 'f585c11aec520db57dd353c69554b21a89b20fb0650966fa0a9d6f74fd989d8f',
    mnemonic:
      'void come effort suffer camp survey warrior heavy shoot primary clutch crush open amazing screen patrol group space point ten exist slush involve unfold',
    seed: '01f5bced59dec48e362f2c45b5de68b9fd6c92c6634f44d6d40aab69056506f0e35524a518034ddc1192e1dacd32c1ed3eaa3c3b131c88ed8e7e54c49a5d0998',
  },
];

describe('bip39', () => {
  it('test entropyToMnemonic', async () => {
    const entropy = utils.hex.toBytes('ffffffffffffffffffffffffffffffff');
    const mnemonic = await Bip39.entropyToMnemonic(entropy, WORD_LIST);

    expect(mnemonic.phrase).equal('zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong');
  });


    it.each(TEST_VECTORS)(
      'validates vector: $mnemonic',
      async ({ entropy, mnemonic, seed }) => {
        const entropyBytes = Uint8Array.from(
          entropy.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16))
        );
        const seedBytes = Uint8Array.from(
          seed.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16))
        );

        // Test entropy to mnemonic
        const generatedMnemonic = await Bip39.entropyToMnemonic(entropyBytes, WORD_LIST);
        expect(generatedMnemonic.phrase).toBe(mnemonic);

        // Test mnemonic validation
        await expect(Bip39.validateMnemonic(mnemonic, WORD_LIST)).resolves.toBe(true);

        // Test mnemonic to seed
        const generatedSeed = await Bip39.mnemonicToSeed(mnemonic, 'TREZOR', WORD_LIST);
        expect(generatedSeed).toEqual(seedBytes);

        // // Test mnemonic to entropy
        const recoveredEntropy = await Bip39.mnemonicToEntropy(mnemonic, WORD_LIST);
        expect(recoveredEntropy).toEqual(entropyBytes);
      }
    );

  it.each([12, 15, 18, 21, 24])(
      'generates mnemonic with %i words',
      async (wordCount) => {
        const entropyBits = (wordCount * 11 * 32) / 33;
        const mnemonic = await Bip39.generateMnemonic(entropyBits, WORD_LIST);

        expect(mnemonic.words.length).toBe(wordCount);
        expect(mnemonic.phrase.split(' ').length).toBe(wordCount);
      }
    );
});

describe('bip39_checksum', () => {
    const vectors = [
      '00000000000000000000000000000000',
      '7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f',
      '80808080808080808080808080808080',
      'ffffffffffffffffffffffffffffffff',
      '000000000000000000000000000000000000000000000000',
      '7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f',
      '808080808080808080808080808080808080808080808080',
      'ffffffffffffffffffffffffffffffffffffffffffffffff',
      '0000000000000000000000000000000000000000000000000000000000000000',
      '7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f',
      '8080808080808080808080808080808080808080808080808080808080808080',
      'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
      '9e885d952ad362caeb4efe34a8e91bd2',
      '6610b25967cdcca9d59875f5cb50b0ea75433311869e930b',
      '68a79eaca2324873eacc50cb9c6eca8cc68ea5d936f98787c60c7ebc74e6ce7c',
      'c0ba5a8e914111210f2bd131f3d5e08d',
      '6d9be1ee6ebd27a258115aad99b7317b9c8d28b6d76431c3',
      '9f6a2878b2520799a44ef18bc7df394e7061a224d2c33cd015b157d746869863',
      '23db8160a31d3e0dca3688ed941adbf3',
      '8197a4a47f0425faeaa69deebc05ca29c0a5b5cc76ceacc0',
      '066dca1a2bb7e8a1db2832148ce9933eea0f3ac9548d793112d9a95c9407efad',
      'f30f8c1da665478f49b001d94c5fc452',
      'c10ec20dc3cd9f652c7fac2f1230f7a3c828389a14392f05',
      'f585c11aec520db57dd353c69554b21a89b20fb0650966fa0a9d6f74fd989d8f',
    ];

    it.each(vectors)('verifies checksum for entropy: %s', async (entropyHex) => {
        const entropy = Uint8Array.from(
            entropyHex.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16))
        );
        const mnemonic = await Bip39.entropyToMnemonic(entropy, WORD_LIST);

        const ENT = entropy.length * 8; // Длина энтропии в битах
        const CS = ENT / 32; // Длина контрольной суммы

        const hash = await sha256(entropy);
        const computedChecksum = hash[0] >> (8 - CS);

        const bits = mnemonic.words
            .map((word) => {
                const index = WORD_LIST.indexOf(word);
                return index.toString(2).padStart(11, '0');
            })
            .join('');
        const checksum = parseInt(bits.slice(ENT, ENT + CS), 2);

        expect(computedChecksum).toBe(checksum);
    });
});

describe('bip39_invalid_mnemonic', () => {
    it('should throw UnknownWord error for invalid word at position 0', async () => {
        const invalidMnemonic = 'getter advice cage absurd amount doctor acoustic avoid letter advice cage above';
        await expect(Bip39.validateMnemonic(invalidMnemonic, WORD_LIST)).rejects.toThrow(Bip39Error.InvalidWord);
    });

    it('should throw UnknownWord error for invalid word at position 2', async () => {
        const invalidMnemonic = 'letter advice cagex absurd amount doctor acoustic avoid letter advice cage above';
        await expect(Bip39.validateMnemonic(invalidMnemonic, WORD_LIST)).rejects.toThrow(Bip39Error.InvalidWord);
    });

    it('should throw BadWordCount error for 11 words', async () => {
        const invalidMnemonic = 'advice cage absurd amount doctor acoustic avoid letter advice cage above';
        await expect(Bip39.validateMnemonic(invalidMnemonic, WORD_LIST)).rejects.toThrow(Bip39Error.InvalidWordCount);
    });

    it('should throw InvalidChecksum error for invalid checksum', async () => {
        const invalidMnemonic = 'primary advice cage absurd amount doctor acoustic avoid letter advice cage above';
        await expect(Bip39.validateMnemonic(invalidMnemonic, WORD_LIST)).rejects.toThrow(Bip39Error.InvalidChecksum);
    });
});

describe('bip39_invalid_entropy', () => {
    it('should throw BadEntropyBitCount for entropy not divisible by 32 bits', async () => {
        const entropy = new Uint8Array(17); // 136 бит
        await expect(Bip39.entropyToMnemonic(entropy, WORD_LIST)).rejects.toThrow(Bip39Error.InvalidEntropy);
    });

    it('should throw BadEntropyBitCount for entropy less than 128 bits', async () => {
        const entropy = new Uint8Array(4); // 32 бита
        await expect(Bip39.entropyToMnemonic(entropy, WORD_LIST)).rejects.toThrow(Bip39Error.InvalidEntropy);
    });

    it('should throw BadEntropyBitCount for entropy greater than 256 bits', async () => {
        const entropy = new Uint8Array(36); // 288 бит
        await expect(Bip39.entropyToMnemonic(entropy, WORD_LIST)).rejects.toThrow(Bip39Error.InvalidEntropy);
    });
});

```

`zil-pay/__tests__/crypto/number.test.ts`:

```ts
import { describe, expect, it } from 'vitest';
import { uint8ArrayToBigIntBigEndian, uint8ArrayToBigIntLittleEndian } from '../../crypto/number';
import { randomBytes } from '../../crypto/random';

describe('uint8ArrayToBigIntBigEndian', () => {
  it('should correctly convert a non-empty big-endian Uint8Array to bigint', () => {
    const length = 8;
    const byteArray = randomBytes(length);
    const bigIntValue = uint8ArrayToBigIntBigEndian(byteArray);
    expect(typeof bigIntValue).toBe('bigint');
  });

  it('should return 0n for an empty Uint8Array', () => {
    const emptyArray = new Uint8Array([]);
    expect(uint8ArrayToBigIntBigEndian(emptyArray)).toBe(0n);
  });
});

describe('uint8ArrayToBigIntLittleEndian', () => {
  it('should correctly convert a non-empty little-endian Uint8Array to bigint', () => {
    const length = 8;
    const byteArray = randomBytes(length);
    const littleEndianArray = new Uint8Array([...byteArray].reverse());
    const bigIntValue = uint8ArrayToBigIntLittleEndian(littleEndianArray);
    expect(typeof bigIntValue).toBe('bigint');
  });

  it('should return 0n for an empty Uint8Array', () => {
    const emptyArray = new Uint8Array([]);
    expect(uint8ArrayToBigIntLittleEndian(emptyArray)).toBe(0n);
  });
});

```

`zil-pay/__tests__/crypto/pbkdf2.test.ts`:

```ts

import { test, expect, vi } from 'vitest';
import { pbkdf2 } from '../../crypto/pbkdf2';
import { ShaAlgorithms } from '../../config/pbkdf2';
import { utils } from 'aes-js';

test('pbkdf2 calls Web Crypto API correctly with default SHA-512', async () => {
  const password = new TextEncoder().encode('password');
  const salt = new TextEncoder().encode('salt');
  const iterations = 1000;
  const result = await pbkdf2(password, salt, iterations, ShaAlgorithms.Sha512);
  const shouldBe = "afe6c5530785b6cc6b1c6453384731bd5ee432ee549fd42fb6695779ad8a1c5bf59de69c48f774efc4007d5298f9033c0241d5ab69305e7b64eceeb8d834cfec";
 
  expect(utils.hex.fromBytes(result)).toBe(shouldBe);
});

```

`zil-pay/__tests__/crypto/pubkey.test.ts`:

```ts
import { describe, expect, it } from 'vitest';
import { fromZILPrivateKey } from '../../crypto/zilliqa/pubkey';
import { utils } from 'aes-js';

describe('test cases pubkey', () => {
  it('test zil private key to pub key', async() => {
    let sk = Uint8Array.from(utils.hex.toBytes("3a649fbe8198729669affd1e9ae93e9e81fd25b71ea5f79792bec9fa6ac9ed92"));
    let pk = fromZILPrivateKey(sk);
    let pkHex = utils.hex.fromBytes(pk); 

    expect(pkHex).toEqual("025ded2f80f60d6c98d16ea5e1b2787427f44b8fcf11b5cacd56911e6c0e4c184c");
  });
});


```

`zil-pay/__tests__/crypto/random.test.ts`:

```ts
import { test, expect, vi } from 'vitest';
import { randomBytes } from '../../crypto/random';

test('randomBytes generates a non-zero Uint8Array of the specified length', () => {
  const length = 16;
  const result = randomBytes(length);

  expect(result).toBeInstanceOf(Uint8Array);
  expect(result.length).toBe(length);

  const zeroArray = new Uint8Array(length);
  expect(result).not.toEqual(zeroArray);

  expect(result.some((byte) => byte !== 0)).toBe(true);
});

test('randomBytes uses window.crypto.getRandomValues to seed the ChaCha20 RNG', () => {
  const spyGetRandomValues = vi.spyOn(window.crypto, 'getRandomValues');
  const length = 8;
  
  randomBytes(length);
  
  expect(spyGetRandomValues).toHaveBeenCalled();
  spyGetRandomValues.mockRestore();
});

```

`zil-pay/__tests__/crypto/schnorr.test.ts`:

```ts
import { describe, expect, it } from 'vitest';
import { signInner, verify } from '../../crypto/zilliqa/schnorr';
import { utils } from 'aes-js';
import { uint8ArrayToBigIntBigEndian } from '../../crypto/number';

describe('Schnorr Signature Tests', () => {
 it('should sign and verify correctly', async () => {
    const cases: [
      message: string,
      publicKey: string,
      secretKey: string,
      k: string,
      r: string,
      s: string
    ][] = [
      [
        "A7F1D92A82C8D8FE434D98558CE2B347171198542F112D0558F56BD68807999248336241F30D23E55F30D1C8ED610C4B0235398184B814A29CB45A672ACAE548E9C5F1B0C4158AE59B4D39F6F7E8A105D3FEEDA5D5F3D9E45BFA6CC351E220AE0CE106986D61FF34A11E19FD3650E9B7818FC33A1E0FC02C44557AC8AB50C9B2DEB2F6B5E24C4FDD9F8867BDCE1FF261008E7897970E346207D75E47A158298E5BA2F56246869CC42E362A02731264E60687EF5309D108534F51F8658FB4F080B7CB19EE9AEBD718CC4FA27C8C37DFC1ADA5D133D13ABE03F021E9B1B78CCBD82F7FF2B38C6D48D01E481B2D4FAF7171805FD7F2D39EF4C4F19B9496E81DAB8193B3737E1B27D9C43957166441B93515E8F03C95D8E8CE1E1864FAAD68DDFC5932130109390B0F1FE5CA716805F8362E98DCCAADC86ADBED25801A9A9DCFA6264319DDAFE83A89C51F3C6D199D38DE10E660C37BE872C3F2B31660DE8BC95902B9103262CDB941F77376F5D3DBB7A3D5A387797FC4819A035ECA704CEDB37110EE7F206B0C8805AAEBF4963E7C4708CE8D4E092366E71792A8A3B2BBCDEE321B3E15380C541EF0930888969F7457AFE18588826A419D58311C1784B5484EECDB393F6A0ACA11B91DF0866B500B8DEE501FD7EB9BCE09A17D74124B4605ADFC0777BED9816D8D7E8488544A18D8045CB3283B0A752B881B5F500FADB59010E63D",
        "039E43C9810E6CC09F46AAD38E716DAE3191629534967DC457D3A687D2E2CDDC6A",
        "0F494B8312E8D257E51730C78F8FE3B47B6840C59AAAEC7C2EBE404A2DE8B25A",
        "532B2267C4A3054F380B3357339BDFB379E88366FE61B42ACA05F69BC3F6F54E",
        "3AF3D288E830E96FF8ED0769F45ABDA774CD989E2AE32EF9E985C8505F14FF98",
        "E191EB14A70B5B53ADA45AFFF4A04578F5D8BB2B1C8A22985EA159B53826CDE7",
      ],
      [
        "1B664F8BDA2DBF33CB6BE21C8EB3ECA9D9D5BF144C08E9577ED0D1E5E560875109B340980580473DBC2E689A3BE838E77A0A3348FE960EC9BF81DA36F1868CA5D24788FA4C0C778BF0D12314285495636516CF40861B3D737FD35DBB591C5B5D25916EB1D86176B14E0E67D2D03957F0CF6C87834BF328540588360BA7C7C5F88541634FB7BADE5F94FF671D1FEBDCBDA116D2DA779038ED7679896C29198B2657B58C50EA054F644F4129C8BA8D8D544B727633DD40754398046796E038626FEF9237CE5B615BC08677EE5ABFBD85F73F7F8868CB1B5FBA4C1309F16061AA133821FBE2A758D2BBE6AA040A940D41B7D3B869CEE945150AA4A40E6FF719EEC24B2681CD5CE06B50273436584066046656D5EFED7315759189D68815DDB9E5F8D7FD53B6EC096616A773B9421F6704CED36EF4E484BA0C6C5A4855C71C33A54AC82BE803E5CFD175779FC444B7E6AA9001EEFABEBC0CF99754887C7B0A27AFDDC415F8A02C5AF1EFEA26AD1E5D92B1E29A8FAF5B2186C3094F4A137BCFAA65D7B274214DB64C86F3085B24938E1832FB310A6F064181E298D23062ABC817BA173023C8C04C5C3A1ECBF4AF72372B381FF69865C8F0E3C70B931C45A7419B3C441842EBFACC3D070AC3B433CD120B6E85B72DADCF40B23B173C34F6BE1B1901F6621F1497B085CF8E999D986EF8FF3A889A0238979983A8686F69E10EF9249A87",
        "0245DC2911EDC02F2774E0A40FBEB0112EA60BF513F9EC50889D59FC94C97EC18F",
        "8D566BB87EF69FFDA622E0A59FBAAFE57F486CE65844343A5D9B97DE9C4F619A",
        "948AFFFF6E068CA2F2757BFD6085D6E4C3084B038E5533C5927ECB19EA0D329C",
        "DFEE66E2C4799E73F0F778126A23032608408C27C2E7B3FA45A626BB9BDEB53C",
        "75445CC9DBFE4E7BC64E020FA22CACFA4C40D5AA84DD6AEF661564FCA9746C40",
      ],
      [
        "3444C8501F19A8A78670F748FA401C4020AE086D7157A3837EC721DEF0D6E095928C5B78ED9B95560CE33D5B22778BE66DCEF2D21878D481DFF41A4DEDCAFDCAEAB4BD78629D7EC40FD26F1DD954CA84A3B53B84E9903056E840837A1390F37BB8ADE799DAC1E465D811916547EB4B6A163082E9833634A1224C54F681B8DC70A792C0CB4671D4970CCC80E2168CE920CC8FA07B1F90E9898D16019913ED5B8EE8A8DE7AB6F7895601FD20E49FD73E6F5D24C0D97E67871539F0E4E32CCB6677AFF03356D1F3790945E94039E51A63B3C840B74E3053D95CA71C0D3AC20A9065828D30AB5BFB6188A8F291FB1EB4E1EED03E2F5F558C00D8E3084120DEEB8BFE908429B36A896A45D624E79372CC18DF37DB2D20C9726D4FEF7BECF220138B53BC54C2DA461A9955AFF33F2F93DD96464BF3E883FC5750BDBE79BC2F82427F41DE42659AC4B111D7CEF8085003469DF8C9D3541480C6841707CE4C8F3D003AF982AD35C2733D0FA3B1EE52A6DAB36203D99AEC179A565B5050F480235C3BC560AA28EF5DD5525BFA254E584A86FDBD4BCC5B56551BAD00255CB72F806D7F3C533321B0864007AFBA4E0FF9638517FA8D788F52766F3A28C57C428BFDD4234AA760CE8044DF1E1FBA58E8B1D9C5A79D2AC4592FC31702F7E83351D2160C09C5CEA554F2C93A61C040E225612DF2B550900B097E18638350E3BA15C9AD53CE1861",
        "02237627FE7374061FBD80AEA842DCE76D9206F0DDC7B319F3B30FA75DBD4F009A",
        "009755F442D66585A10B80A49850C77764AD029D1BEA73F4DA45AB331306E6E5",
        "2D78C77B736AD0A00FDF60695C01E96520656C13DC890A5B864672C6CED1C49A",
        "4B73D4D919D7B4DEF330391899EA02023851CABE044E34E18EAE3E10588CECCD",
        "D5DE85C4BDEA5910DC36AEF5660774D65291322C1E87FDA0D00C864E8C5FED29",
      ]
    ];

    for (const [messageHex, publicKeyHex, secretKeyHex, kHex, expectedR, expectedS] of cases) {
      const message = utils.hex.toBytes(messageHex);
      const publicKey = utils.hex.toBytes(publicKeyHex);
      const secretKey = utils.hex.toBytes(secretKeyHex);
      const kBytes = utils.hex.toBytes(kHex);
      const k = uint8ArrayToBigIntBigEndian(kBytes);

      const signature = await signInner(k, message, secretKey);

      expect(signature?.r.toString(16)).toBe(expectedR.toLowerCase());
      expect(signature?.s.toString(16)).toBe(expectedS.toLowerCase());

      const isValid = await verify(message, publicKey, signature!);
      expect(isValid).toBe(true);
    }
  });
});

```

`zil-pay/__tests__/crypto/sha256.test.ts`:

```ts
import { test, expect } from 'vitest';
import { sha256 } from '../../crypto/sha256';
import { utils } from 'aes-js';

test('sha256 hashes "test" correctly', async () => {
  const input = new TextEncoder().encode('test');
  const hash = await sha256(input);
  const hexString = utils.hex.fromBytes(hash);

  expect(hexString).toBe('9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08');
});

```

`zil-pay/__tests__/crypto/sha512.test.ts`:

```ts
import { test, expect } from 'vitest';
import { sha512 } from '../../crypto/sha512';
import { utils } from 'aes-js';

test('sha512 hashes "test" correctly', async () => {
  const input = new TextEncoder().encode('test');
  const buffer = await sha512(input);
  const hashArray = new Uint8Array(buffer);
  const hexString = utils.hex.fromBytes(hashArray);
  expect(hexString).toBe('ee26b0dd4af7e749aa1a8ee3c10ae9923f618980772e473f8819a5d4940e0db27ac185f8a0e1d5f84f88bc887fd67b143732c304cc5fa9ad8e6f57f50028a8ff');
});

```

`zil-pay/__tests__/crypto/word_list.ts`:

```ts
export const WORD_LIST = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
];

```

`zil-pay/__tests__/setupTests.ts`:

```ts
import { vi } from "vitest";
import sinonChrome from "sinon-chrome";

global.chrome = sinonChrome;

const mockGetRandomValues = (array: Uint8Array): Uint8Array => {
  for (let i = 0; i < array.length; i++) {
    array[i] = Math.floor(Math.random() * 256);
  }
  return array;
};

(global as any).window = {
  crypto: {
    getRandomValues: vi.fn(mockGetRandomValues),
  },
};

```

`zil-pay/__tests__/storage/storage.test.ts`:

```ts
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { BrowserStorage } from '../../lib/storage/storage';
import type { StorageKeyValue } from '../../lib/storage/builder';

describe('BrowserStorage - Basic Operations', () => {
  beforeEach(() => {
    chrome.storage.local.set.reset();
    chrome.storage.local.get.reset();
    chrome.storage.local.remove.reset();
    chrome.storage.local.clear.reset();
    chrome.runtime.lastError = undefined;
  });

  it('sets a single key-value pair', async () => {
    const mockData: StorageKeyValue = { key: 'value' };
    chrome.storage.local.set.callsFake((data, callback) => callback());

    await BrowserStorage.set(mockData);

    expect(chrome.storage.local.set.calledWith(mockData)).toBe(true);
  });

  it('sets multiple key-value pairs', async () => {
    const mockData1: StorageKeyValue = { key1: 'value1' };
    const mockData2: StorageKeyValue = { key2: 'value2' };
    chrome.storage.local.set.callsFake((data, callback) => callback());

    await BrowserStorage.set(mockData1, mockData2);

    expect(chrome.storage.local.set.calledWith({ key1: 'value1', key2: 'value2' })).toBe(true);
  });

  it('rejects on set error', async () => {
    const mockData: StorageKeyValue = { key: 'value' };
    chrome.storage.local.set.callsFake((data, callback) => {
      chrome.runtime.lastError = { message: 'Storage set failed' };
      callback();
    });

    await expect(BrowserStorage.set(mockData)).rejects.toThrow('Storage set failed');
  });

  it('gets a single key', async () => {
    const key = 'key';
    const mockResult = { key: 'value' };
    chrome.storage.local.get.callsFake((keys, callback) => callback(mockResult));

    const result = await BrowserStorage.get(key);

    expect(chrome.storage.local.get.calledWith([key])).toBe(true);
    expect(result).toBe(mockResult[key]);
  });

  it('gets multiple keys', async () => {
    const keys = ['key1', 'key2'];
    const mockResult = { key1: 'value1', key2: 'value2' };
    chrome.storage.local.get.callsFake((keys, callback) => callback(mockResult));

    const result = await BrowserStorage.get(...keys);

    expect(chrome.storage.local.get.calledWith(keys)).toBe(true);
    expect(result).toEqual(mockResult);
  });

  it('rejects on get error', async () => {
    const key = 'key';
    chrome.storage.local.get.callsFake((keys, callback) => {
      chrome.runtime.lastError = { message: 'Storage get failed' };
      callback();
    });

    await expect(BrowserStorage.get(key)).rejects.toThrow('Storage get failed');
  });

  it('gets all items', async () => {
    const mockResult = { key1: 'value1', key2: 'value2' };
    chrome.storage.local.get.callsFake((keys, callback) => callback(mockResult));

    const result = await BrowserStorage.getAll();

    expect(chrome.storage.local.get.calledWith(null)).toBe(true);
    expect(result).toEqual(mockResult);
  });

  it('removes keys', async () => {
    const keys = ['key1', 'key2'];
    chrome.storage.local.remove.callsFake((keys, callback) => callback());

    await BrowserStorage.rm(...keys);

    expect(chrome.storage.local.remove.calledWith(keys)).toBe(true);
  });

  it('rejects on remove error', async () => {
    const key = 'key';
    chrome.storage.local.remove.callsFake((keys, callback) => {
      chrome.runtime.lastError = { message: 'Storage remove failed' };
      callback();
    });

    await expect(BrowserStorage.rm(key)).rejects.toThrow('Storage remove failed');
  });

  it('clears storage', async () => {
    chrome.storage.local.clear.callsFake((callback) => callback());

    await BrowserStorage.clear();

    expect(chrome.storage.local.clear.called).toBe(true);
  });

  it('rejects on clear error', async () => {
    chrome.storage.local.clear.callsFake((callback) => {
      chrome.runtime.lastError = { message: 'Storage clear failed' };
      callback();
    });

    await expect(BrowserStorage.clear()).rejects.toThrow('Storage clear failed');
  });
});

describe('BrowserStorage - Subscription', () => {
  beforeEach(() => {
    chrome.storage.onChanged.addListener.resetHistory();
    chrome.storage.onChanged.removeListener.resetHistory();
    chrome.runtime.lastError = undefined;
  });

  it('subscribes to storage changes and calls callback', () => {
    const mockCallback = vi.fn();
    const mockChanges = { key: { oldValue: 'old', newValue: 'new' } };

    const { unsubscribe } = BrowserStorage.subscribe(mockCallback);
    const listener = chrome.storage.onChanged.addListener.firstCall.args[0];

    listener(mockChanges);

    expect(chrome.storage.onChanged.addListener.called).toBe(true);
    expect(mockCallback).toHaveBeenCalledWith(mockChanges);

    unsubscribe();
    expect(chrome.storage.onChanged.removeListener.called).toBe(true);
  });

  it('handles errors in subscription callback', () => {
    const mockCallback = vi.fn(() => {
      throw new Error('Callback error');
    });
    const mockConsoleError = vi.fn();
    console.error = mockConsoleError;
    const mockChanges = { key: { oldValue: 'old', newValue: 'new' } };

    const { unsubscribe } = BrowserStorage.subscribe(mockCallback);
    const listener = chrome.storage.onChanged.addListener.firstCall.args[0];

    listener(mockChanges);

    expect(mockCallback).toHaveBeenCalledWith(mockChanges);
    expect(mockConsoleError).toHaveBeenCalledWith('Error in storage change callback:', expect.any(Error));

    unsubscribe();
    expect(chrome.storage.onChanged.removeListener.called).toBe(true);
    console.error = console.error;
  });
});

```

`zil-pay/__tests__/stream/stream.test.ts`:

```ts
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { Message, ReqBody } from 'lib/streem/message';
import { Runtime } from 'lib/runtime/extensionizer';

vi.mock('lib/runtime/extensionizer', () => ({
  Runtime: {
    runtime: {
      sendMessage: vi.fn(),
    },
  },
}));

describe('Basic Test Message - Error Handling', () => {
  const mockConsoleError = vi.fn();

  beforeEach(() => {
    console.error = mockConsoleError;
    (Runtime.runtime.sendMessage as ReturnType<typeof vi.fn>).mockClear();
  });

  it('should catch sendMessage error and log it', async () => {
    const message = Message.signal("ERROR_MESSAGE");
    const sendMessageMock = Runtime.runtime.sendMessage as ReturnType<typeof vi.fn>;
    const errorMessage = 'Simulated send error';
    sendMessageMock.mockImplementation(() => {
      throw new Error(errorMessage);
    });

    await expect(message.send()).rejects.toThrow('service_worker_stopped');
    expect(sendMessageMock).toHaveBeenCalledTimes(10);
    expect(mockConsoleError).toHaveBeenCalledWith(message, new Error(errorMessage));
  });
});

describe('Basic Test Message - Successful Send and Receive', () => {
  beforeEach(() => {
    (Runtime.runtime.sendMessage as ReturnType<typeof vi.fn>).mockClear();
  });

  it('should send the message and receive a response', async () => {
    const body: ReqBody<{ data: string }> = { type: 'TEST_MESSAGE', payload: { data: 'test' } };
    const message = new Message(body);
    const mockResponse = { result: 'success' };

    (Runtime.runtime.sendMessage as ReturnType<typeof vi.fn>).mockImplementation((_msg, callback) => {
      callback(mockResponse);
    });

    const response = await message.send();

    expect(Runtime.runtime.sendMessage).toHaveBeenCalledOnce();
    expect(Runtime.runtime.sendMessage).toHaveBeenCalledWith(body, expect.any(Function));
    expect(response).toEqual(mockResponse);
  });
});

```

`zil-pay/__tests__/types/checker.test.ts`:

```ts
import { describe, expect, it } from 'vitest';
import { TypeOf } from 'lib/types/checker.ts';

describe('TypeOf', () => {
    it('should correctly identify arrays', () => {
        expect(TypeOf.isArray([])).toBe(true);
        expect(TypeOf.isArray([1, 2, 3])).toBe(true);
        expect(TypeOf.isArray(new Array(3))).toBe(true);
        expect(TypeOf.isArray({})).toBe(false);
        expect(TypeOf.isArray(null)).toBe(false);
        expect(TypeOf.isArray(undefined)).toBe(false);
        expect(TypeOf.isArray('abc')).toBe(false);
    });

    it('should correctly identify plain objects', () => {
        expect(TypeOf.isObject({})).toBe(true);
        expect(TypeOf.isObject({ a: 1, b: 2 })).toBe(true);
        expect(TypeOf.isObject(new Object())).toBe(true);
        expect(TypeOf.isObject([])).toBe(false);
        expect(TypeOf.isObject(null)).toBe(false);
        expect(TypeOf.isObject(undefined)).toBe(false);
        expect(TypeOf.isObject('abc')).toBe(false);
        expect(TypeOf.isObject(new Date())).toBe(false);
        expect(TypeOf.isObject(new Error())).toBe(false);
        class MyClass {}
        expect(TypeOf.isObject(new MyClass())).toBe(false);
    });

    it('should correctly identify numbers', () => {
        expect(TypeOf.isNumber(0)).toBe(true);
        expect(TypeOf.isNumber(10)).toBe(true);
        expect(TypeOf.isNumber(-5)).toBe(true);
        expect(TypeOf.isNumber(3.14)).toBe(true);
        expect(TypeOf.isNumber(NaN)).toBe(false);
        expect(TypeOf.isNumber(Infinity)).toBe(true);
        expect(TypeOf.isNumber(-Infinity)).toBe(true);
        expect(TypeOf.isNumber('10')).toBe(false);
        expect(TypeOf.isNumber(null)).toBe(false);
        expect(TypeOf.isNumber(undefined)).toBe(false);
        expect(TypeOf.isNumber({})).toBe(false);
    });

    it('should correctly identify integers', () => {
        expect(TypeOf.isInt(0)).toBe(true);
        expect(TypeOf.isInt(10)).toBe(true);
        expect(TypeOf.isInt(-5)).toBe(true);
        expect(TypeOf.isInt(3.14)).toBe(false);
        expect(TypeOf.isInt(NaN)).toBe(false);
        expect(TypeOf.isInt(Infinity)).toBe(false);
        expect(TypeOf.isInt('10')).toBe(false);
        expect(TypeOf.isInt(null)).toBe(false);
        expect(TypeOf.isInt(undefined)).toBe(false);
        expect(TypeOf.isInt({})).toBe(false);
        expect(TypeOf.isInt(Number.MAX_SAFE_INTEGER)).toBe(true);
        expect(TypeOf.isInt(Number.MIN_SAFE_INTEGER)).toBe(true);
    });

    it('should correctly identify error objects', () => {
        expect(TypeOf.isError(new Error())).toBe(true);
        expect(TypeOf.isError(new TypeError())).toBe(true);
        expect(TypeOf.isError(new SyntaxError())).toBe(true);
        expect(TypeOf.isError({})).toBe(false);
        expect(TypeOf.isError(null)).toBe(false);
        expect(TypeOf.isError(undefined)).toBe(false);
        expect(TypeOf.isError('Error')).toBe(false);
    });

    it('should correctly identify strings', () => {
        expect(TypeOf.isString('')).toBe(true);
        expect(TypeOf.isString('abc')).toBe(true);
        expect(TypeOf.isString(new String('abc'))).toBe(true);
        expect(TypeOf.isString(123)).toBe(false);
        expect(TypeOf.isString(null)).toBe(false);
        expect(TypeOf.isString(undefined)).toBe(false);
        expect(TypeOf.isString({})).toBe(false);
    });

    it('should correctly identify booleans', () => {
        expect(TypeOf.isBoolean(true)).toBe(true);
        expect(TypeOf.isBoolean(false)).toBe(true);
        expect(TypeOf.isBoolean(new Boolean(true))).toBe(true);
        expect(TypeOf.isBoolean(0)).toBe(false);
        expect(TypeOf.isBoolean(1)).toBe(false);
        expect(TypeOf.isBoolean(null)).toBe(false);
        expect(TypeOf.isBoolean(undefined)).toBe(false);
        expect(TypeOf.isBoolean({})).toBe(false);
    });

    it('should correctly identify null', () => {
        expect(TypeOf.isNull(null)).toBe(true);
        expect(TypeOf.isNull(undefined)).toBe(false);
        expect(TypeOf.isNull(0)).toBe(false);
        expect(TypeOf.isNull('')).toBe(false);
        expect(TypeOf.isNull({})).toBe(false);
    });

    it('should correctly identify undefined', () => {
        expect(TypeOf.isUndefined(undefined)).toBe(true);
        expect(TypeOf.isUndefined(null)).toBe(false);
        expect(TypeOf.isUndefined(0)).toBe(false);
        expect(TypeOf.isUndefined('')).toBe(false);
        expect(TypeOf.isUndefined({})).toBe(false);
    });

    it('should correctly identify empty objects', () => {
        expect(TypeOf.isEmptyObject({})).toBe(true);
        expect(TypeOf.isEmptyObject({ a: 1 })).toBe(false);
        expect(TypeOf.isEmptyObject(new Object())).toBe(true);
        expect(TypeOf.isEmptyObject(null)).toBe(false);
        expect(TypeOf.isEmptyObject(undefined)).toBe(false);
        expect(TypeOf.isEmptyObject([])).toBe(false);
    });

    it('should correctly identify empty arrays', () => {
        expect(TypeOf.isEmptyArray([])).toBe(true);
        expect(TypeOf.isEmptyArray([1, 2, 3])).toBe(false);
        expect(TypeOf.isEmptyArray(new Array(0))).toBe(true);
        expect(TypeOf.isEmptyArray(null)).toBe(false);
        expect(TypeOf.isEmptyArray(undefined)).toBe(false);
        expect(TypeOf.isEmptyArray({})).toBe(false);
    });
});


```

`zil-pay/__tests__/zilliqa/address.test.ts`:

```ts
import { describe, expect, it } from 'vitest';
import { toChecksumHexAddress, toChecksumBytesAddress } from 'lib/zilliqa/checksum';
import { fromZilPubKey } from 'lib/zilliqa/pubkey.ts';
import { utils } from 'aes-js';
import { toBech32Address, fromBech32Address } from 'lib/zilliqa/bech32';

describe('Address Conversion Tests', () => {
    describe('toChecksumAddress', () => {
        it('should correctly checksum a valid lowercase address', async () => {
            const address = '8617b72e22090f0c13167865147ec48a6db788ff';
            const checksummed = await toChecksumHexAddress(address);
            expect(checksummed).toBe('0x8617B72E22090f0c13167865147eC48a6dB788ff');
        });

        it('should correctly checksum another valid address', async () => {
            const address = '0000000000000000000000000000000000000000';
            const checksummed = await toChecksumHexAddress(address);
            expect(checksummed).toBe('0x0000000000000000000000000000000000000000');
        });

        it('should correctly derive a bech32 address from a public key', async () => {
            const pubkeyHex = '03150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da';
            const pubkeyBytes = utils.hex.toBytes(pubkeyHex);
            const addrBytes = await fromZilPubKey(pubkeyBytes);
            const checksummed = await toChecksumBytesAddress(addrBytes);

            expect(checksummed).toBe('0xEBd8b370Dddb636FAF641040D2181c55190840fb');
        });
    });

    describe('toBech32Address', () => {
        it('should correctly encode a valid hexadecimal address to Bech32', async () => {
            const hexAddress = '0x7793a8e8c09d189d4d421ce5bc5b3674656c5ac1';
            const bech32Address = await toBech32Address(hexAddress);
            expect(bech32Address).toBe('zil1w7f636xqn5vf6n2zrnjmckekw3jkckkpyrd6z8');
        });
    });

    describe('fromBech32Address', () => {
        it('should correctly decode a valid Bech32 address to a checksummed hexadecimal address', async () => {
            const bech32Address = 'zil1w7f636xqn5vf6n2zrnjmckekw3jkckkpyrd6z8';
            const hexAddress = await fromBech32Address(bech32Address);
            expect(hexAddress).toBe('0x7793a8e8c09D189D4d421CE5Bc5b3674656C5Ac1');
        });

        it('should throw an error for an invalid Bech32 address length', async () => {
            const invalidBech32 = 'zi21w7f636xqn5vf6n2zrnjmckekw3jkckkpyrd6z8';
            await expect(fromBech32Address(invalidBech32)).rejects.toThrow('Invalid Bech32 address.');
        });

        it('should throw an error for a Bech32 address with an incorrect HRP', async () => {
            const wrongHRP = 'btc1qwertzuiopasdfghjklmnbvcxy';
            await expect(fromBech32Address(wrongHRP)).rejects.toThrow("Invalid Bech32 address.");
        });
    });
});

```

`zil-pay/config/errors.ts`:

```ts
export enum ErrorMessages {
  IncorrectParams = "Incorrect or missing parameters provided.",
  InvalidFormat = "Invalid data format encountered during decryption.",
  InvalidKeyLength = "Invalid key length provided. Key must be 16, 24, or 32 bytes.",
}

```

`zil-pay/config/fields.ts`:

```ts
export enum Fields {
  VAULT = "vault",
  VAULT_IMPORTED = "importedvault",
  CONFIG = "config",
  OLD_WALLET = "wallet",
  WALLET = "wallet-identities",
  SELECTED_NET = "selectednet",
  BLOCK_NUMBER = "blocknumber",
  TRANSACTIONS = "transactions",
  ENCRYPT_DATA = "encryption-data",
  DECRYPT_DATA = "decryption-data",
  CONFIRM_TX = "confirm",
  CONFIRM_MESSAGE = "confirm-message",
  STATIC = "static",
  LOCK_TIME = "time_before_lock",
  GUARD_CONFIG = "guard-configuration",
  CONNECT_DAPP = "connect",
  CONNECT_LIST = "connection-list",
  THEME = "theme",
  CONTACTS = "contacts",
  SELECTED_COIN = "selectedcoin",
  TOKENS = "tokens-list",
  COLLECTION = "collections-list",
  SSN = "ssn-list",
  GAS = "chain-gas",
  RATE_CURRENCIES = "rate-of-currencies",
  SELECTED_CURRENCY = "selected-currency",
  LOCALE = "selected-local",
  FORMAT = "address-format",
  POPUP_ENABLED = "popup-enabled",
  PHISHING = "phishing-detection",
  DEX = "dex-proto",
  BADGE_COUNTER = "badge-counter",
}

```

`zil-pay/config/pbkdf2.ts`:

```ts
export enum ShaAlgorithms {
  Sha512 = "SHA-512",
  sha256 = "SHA-256",
}

```

`zil-pay/config/sha.ts`:

```ts
export enum ShaAlgorithms {
  Sha512 = "SHA-512",
  sha256 = "SHA-256",
}

```

`zil-pay/crypto/aes256.ts`:

```ts
import { Counter, ModeOfOperation, utils } from "aes-js";
import { ErrorMessages } from "../config/errors";
import { randomBytes } from "crypto/random";
import { assert } from "lib/runtime/assert";

export const Cipher = Object.freeze({
  encrypt(content: Uint8Array, key: Uint8Array): Uint8Array {
    assert(Boolean(content), ErrorMessages.IncorrectParams);
    assert(Boolean(key), ErrorMessages.IncorrectParams);

    if (![16, 24, 32].includes(key.length)) {
      throw new Error(ErrorMessages.InvalidKeyLength);
    }

    const entropy = randomBytes(16);
    const iv = new Counter(entropy);
    const aesCtr = new ModeOfOperation.ctr(key, iv);
    const encrypted = aesCtr.encrypt(content);
    const bytes = utils.utf8.toBytes(
      `${utils.hex.fromBytes(encrypted)}/${utils.hex.fromBytes(entropy)}`,
    );
    return bytes;
  },
  decrypt(bytes: Uint8Array, key: Uint8Array): Uint8Array {
    assert(Boolean(bytes), ErrorMessages.IncorrectParams);
    assert(Boolean(key), ErrorMessages.IncorrectParams);

    if (![16, 24, 32].includes(key.length)) {
      throw new Error(ErrorMessages.InvalidKeyLength);
    }

    const [encrypted, iv] = utils.utf8.fromBytes(bytes).split("/");
    const counter = new Counter(utils.hex.toBytes(iv));
    const aesCtr = new ModeOfOperation.ctr(key, counter);
    return aesCtr.decrypt(utils.hex.toBytes(encrypted));
  },
});

```

`zil-pay/crypto/bip32.ts`:

```ts
import { pbkdf2 } from "../crypto/pbkdf2";
import * as secp256k1 from "noble-secp256k1";
import {
  bigIntToUint8ArrayBigEndian,
  uint8ArrayToBigIntBigEndian,
} from "./number";
import { ShaAlgorithms } from "../config/pbkdf2";

// Constants
const HARDENED_BIT = 0x80000000;
const BITCOIN_SEED = new TextEncoder().encode("Bitcoin seed");

// Error enum
export enum Bip32ErrorCode {
  InvalidChild = "InvalidChild",
  InvalidPath = "InvalidPath",
  InvalidKey = "InvalidKey",
  HmacError = "HmacError",
}

// Error class
export class Bip32Error extends Error {
  constructor(code: Bip32ErrorCode, message: string) {
    super(message);
    this.name = `Bip32Error:${code}`;
  }
}

// ChildNumber class
class ChildNumber {
  constructor(public value: number) {}

  isHardened(): boolean {
    return (this.value & HARDENED_BIT) === HARDENED_BIT;
  }

  toBytes(): Uint8Array {
    const buffer = new Uint8Array(4);
    buffer[0] = (this.value >>> 24) & 0xff;
    buffer[1] = (this.value >>> 16) & 0xff;
    buffer[2] = (this.value >>> 8) & 0xff;
    buffer[3] = this.value & 0xff;
    return buffer;
  }

  static fromString(s: string): ChildNumber {
    let numStr = s;
    let hardened = false;
    if (s.endsWith("'")) {
      numStr = s.slice(0, -1);
      hardened = true;
    }
    const index = parseInt(numStr, 10);
    if (isNaN(index) || index < 0) {
      throw new Bip32Error(
        Bip32ErrorCode.InvalidChild,
        `Failed to parse child number: ${s}`,
      );
    }
    if (index >= HARDENED_BIT) {
      throw new Bip32Error(
        Bip32ErrorCode.InvalidChild,
        "Child number too large",
      );
    }
    const value = hardened ? index | HARDENED_BIT : index;
    return new ChildNumber(value);
  }
}

/**
 * Computes an HMAC-SHA512 hash of the data using the provided key.
 * @param key - The key for HMAC computation.
 * @param data - The data to hash.
 * @returns A 64-byte Uint8Array containing the HMAC-SHA512 result.
 * @throws Bip32Error if the HMAC computation fails.
 */
async function hmacSha512(
  key: Uint8Array,
  data: Uint8Array,
): Promise<Uint8Array> {
  try {
    const result = await pbkdf2(data, key, 1, ShaAlgorithms.Sha512);
    return new Uint8Array(result);
  } catch (error) {
    throw new Bip32Error(
      Bip32ErrorCode.HmacError,
      `HMAC computation failed: ${error}`,
    );
  }
}

/**
 * Derives the master private key and chain code from a seed.
 * @param seed - The seed bytes (typically 16-64 bytes).
 * @returns An object containing the master private key and chain code.
 * @throws Bip32Error if the key is invalid or HMAC fails.
 */
async function deriveMasterKey(
  seed: Uint8Array,
): Promise<{ key: Uint8Array; chainCode: Uint8Array }> {
  const hmacResult = await hmacSha512(BITCOIN_SEED, seed);
  const [key, chainCode] = [hmacResult.slice(0, 32), hmacResult.slice(32, 64)];

  if (!secp256k1.utils.isValidPrivateKey(key)) {
    throw new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid master key");
  }

  return { key, chainCode };
}

/**
 * Derives a child private key and chain code from a parent key, chain code, and child number.
 * @param parentKey - The parent private key.
 * @param chainCode - The parent chain code.
 * @param child - The child number (hardened or non-hardened).
 * @returns An object containing the child private key and chain code.
 * @throws Bip32Error if the key is invalid or HMAC fails.
 */
async function deriveChildKey(
  parentKey: Uint8Array,
  chainCode: Uint8Array,
  child: ChildNumber,
): Promise<{ key: Uint8Array; chainCode: Uint8Array }> {
  const data = new Uint8Array(
    child.isHardened()
      ? [0, ...parentKey]
      : [...secp256k1.getPublicKey(parentKey, true)],
  );
  data.set(child.toBytes(), data.length);

  const hmacResult = await hmacSha512(chainCode, data);
  const [childKeyPart, newChainCode] = [
    hmacResult.slice(0, 32),
    hmacResult.slice(32, 64),
  ];

  // Add parent key and child key part (modulo curve order)
  const parentScalar = uint8ArrayToBigIntBigEndian(parentKey);
  const childScalar = uint8ArrayToBigIntBigEndian(childKeyPart);
  const curveOrder = BigInt(
    "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141",
  );
  const sum = (parentScalar + childScalar) % curveOrder;
  const resultKey = bigIntToUint8ArrayBigEndian(sum, 32);

  if (!secp256k1.utils.isValidPrivateKey(resultKey)) {
    throw new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid child key");
  }

  return { key: resultKey, chainCode: newChainCode };
}

/**
 * Derives a private key from a seed and a BIP-32 derivation path.
 * @param seed - The seed bytes (typically 16-64 bytes).
 * @param path - The derivation path (e.g., "m/44'/60'/0'/0/0").
 * @returns The derived private key as a Uint8Array.
 * @throws Bip32Error if the path is invalid, key derivation fails, or inputs are invalid.
 */
export async function derivePrivateKey(
  seed: Uint8Array,
  path: string,
): Promise<Uint8Array> {
  if (!path.startsWith("m/")) {
    throw new Bip32Error(
      Bip32ErrorCode.InvalidPath,
      "Path must start with 'm/'",
    );
  }

  const pathParts = path
    .slice(2)
    .split("/")
    .filter((part) => part !== "");
  let { key, chainCode } = await deriveMasterKey(seed);

  for (const part of pathParts) {
    const childNumber = ChildNumber.fromString(part);
    const result = await deriveChildKey(key, chainCode, childNumber);
    key = result.key;
    chainCode = result.chainCode;
  }

  return key;
}

```

`zil-pay/crypto/bip39.ts`:

```ts
import { pbkdf2 } from "./pbkdf2";
import { ShaAlgorithms } from "../config/pbkdf2";
import { randomBytes } from "./random";
import { assert } from "../lib/runtime/assert";
import { sha256 } from "./sha256";

// BIP-39 constants
const ENTROPY_BITS = [128, 160, 192, 224, 256];
const PBKDF2_ITERATIONS = 2048;
const SEED_LENGTH = 64; // 512 bits

export interface Mnemonic {
  phrase: string;
  words: string[];
}

export enum Bip39Error {
  InvalidEntropy = "Invalid entropy length. Must be 128, 160, 192, 224, or 256 bits.",
  InvalidMnemonic = "Invalid mnemonic phrase.",
  InvalidWord = "Mnemonic contains invalid word(s) not in wordlist.",
  InvalidWordCount = "Invalid number of words. Must be 12, 15, 18, 21, or 24.",
  InvalidChecksum = "Mnemonic checksum is invalid.",
}

export const Bip39 = Object.freeze({
  /**
   * Generates a BIP-39 mnemonic from random entropy.
   * @param entropyBits - Number of entropy bits (128, 160, 192, 224, or 256).
   * @returns A mnemonic object with phrase and words.
   * @throws Error if entropyBits is invalid.
   */
  async generateMnemonic(
    entropyBits: number = 128,
    wordList: string[],
  ): Promise<Mnemonic> {
    assert(ENTROPY_BITS.includes(entropyBits), Bip39Error.InvalidEntropy);

    const entropyBytes = entropyBits / 8;
    const entropy = randomBytes(entropyBytes);
    const checksumBits = entropyBits / 32;
    const totalBits = entropyBits + checksumBits;
    const wordCount = totalBits / 11;

    // Compute SHA-256 checksum
    const hash = await sha256(entropy);
    const checksum = hash[0] >> (8 - checksumBits);

    // Combine entropy and checksum
    const entropyBitsStr = Array.from(entropy)
      .map((byte) => byte.toString(2).padStart(8, "0"))
      .join("");
    const checksumBitsStr = checksum.toString(2).padStart(checksumBits, "0");
    const bits = entropyBitsStr + checksumBitsStr;

    // Split into 11-bit chunks to select words
    const words: string[] = [];
    for (let i = 0; i < wordCount; i++) {
      const start = i * 11;
      const chunk = bits.slice(start, start + 11);
      const index = parseInt(chunk, 2);
      words.push(wordList[index]);
    }

    return {
      phrase: words.join(" "),
      words,
    };
  },

  /**
   * Validates a BIP-39 mnemonic phrase.
   * @param mnemonic - The mnemonic phrase to validate.
   * @returns True if valid, throws error otherwise.
   * @throws Error if mnemonic is invalid.
   */
  async validateMnemonic(
    mnemonic: string,
    wordList: string[],
  ): Promise<boolean> {
    const words = mnemonic.trim().split(/\s+/);
    const wordCount = words.length;
    const validWordCounts = [12, 15, 18, 21, 24];

    assert(validWordCounts.includes(wordCount), Bip39Error.InvalidWordCount);

    // Verify all words are in wordlist
    for (const word of words) {
      assert(wordList.includes(word), `${Bip39Error.InvalidWord}, ${word}`);
    }

    // Reconstruct entropy and checksum
    const bits = words
      .map((word) => {
        const index = wordList.indexOf(word);
        return index.toString(2).padStart(11, "0");
      })
      .join("");

    const entropyBits = wordCount * 11 - wordCount / 3;
    const entropy = bits.slice(0, entropyBits);
    const checksum = bits.slice(entropyBits);

    // Convert entropy bits to bytes
    const entropyBytes = new Uint8Array(entropyBits / 8);
    for (let i = 0; i < entropyBytes.length; i++) {
      entropyBytes[i] = parseInt(entropy.slice(i * 8, (i + 1) * 8), 2);
    }

    // Verify checksum
    const hash = await sha256(entropyBytes);
    const computedChecksum = hash[0] >> (8 - wordCount / 3);
    const expectedChecksum = parseInt(checksum, 2);

    assert(computedChecksum === expectedChecksum, Bip39Error.InvalidChecksum);

    return true;
  },

  /**
   * Derives a seed from a BIP-39 mnemonic using PBKDF2.
   * @param mnemonic - The mnemonic phrase.
   * @param passphrase - Optional passphrase (default: empty string).
   * @returns A 512-bit seed as Uint8Array.
   * @throws Error if mnemonic is invalid.
   */
  async mnemonicToSeed(
    mnemonic: string,
    passphrase: string = "",
    wordList: string[],
  ): Promise<Uint8Array> {
    assert(
      await Bip39.validateMnemonic(mnemonic, wordList),
      Bip39Error.InvalidMnemonic,
    );

    const password = new TextEncoder().encode(mnemonic);
    const salt = new TextEncoder().encode(`mnemonic${passphrase}`);
    const seed = await pbkdf2(
      password,
      salt,
      PBKDF2_ITERATIONS,
      ShaAlgorithms.Sha512,
    );

    assert(seed.length === SEED_LENGTH, "Invalid seed length.");

    return seed;
  },

  /**
   * Converts a mnemonic to entropy.
   * @param mnemonic - The mnemonic phrase.
   * @returns The original entropy as Uint8Array.
   * @throws Error if mnemonic is invalid.
   */
  async mnemonicToEntropy(
    mnemonic: string,
    wordList: string[],
  ): Promise<Uint8Array> {
    assert(
      await Bip39.validateMnemonic(mnemonic, wordList),
      Bip39Error.InvalidMnemonic,
    );

    const words = mnemonic.trim().split(/\s+/);
    const wordCount = words.length;
    const entropyBits = wordCount * 11 - wordCount / 3;

    const bits = words
      .map((word) => {
        const index = wordList.indexOf(word);
        return index.toString(2).padStart(11, "0");
      })
      .join("");

    const entropy = bits.slice(0, entropyBits);
    const entropyBytes = new Uint8Array(entropyBits / 8);
    for (let i = 0; i < entropyBytes.length; i++) {
      entropyBytes[i] = parseInt(entropy.slice(i * 8, (i + 1) * 8), 2);
    }

    return entropyBytes;
  },

  /**
   * Converts entropy to a BIP-39 mnemonic phrase.
   * @param entropy - The entropy as a Uint8Array (must be 16, 20, 24, 28, or 32 bytes).
   * @param wordList - The BIP-39 wordlist.
   * @returns A mnemonic object with phrase and words.
   * @throws Error if entropy length is invalid.
   */
  async entropyToMnemonic(
    entropy: Uint8Array,
    wordList: string[],
  ): Promise<Mnemonic> {
    const entropyBits = entropy.length * 8;
    assert(ENTROPY_BITS.includes(entropyBits), Bip39Error.InvalidEntropy);

    const checksumBits = entropyBits / 32;
    const totalBits = entropyBits + checksumBits;
    const wordCount = totalBits / 11;

    // Compute SHA-256 checksum
    const hash = await sha256(entropy);
    const checksum = hash[0] >> (8 - checksumBits);

    // Combine entropy and checksum
    const entropyBitsStr = Array.from(entropy)
      .map((byte) => byte.toString(2).padStart(8, "0"))
      .join("");
    const checksumBitsStr = checksum.toString(2).padStart(checksumBits, "0");
    const bits = entropyBitsStr + checksumBitsStr;

    // Split into 11-bit chunks to select words
    const words: string[] = [];
    for (let i = 0; i < wordCount; i++) {
      const start = i * 11;
      const chunk = bits.slice(start, start + 11);
      const index = parseInt(chunk, 2);
      words.push(wordList[index]);
    }

    return {
      phrase: words.join(" "),
      words,
    };
  },
});

```

`zil-pay/crypto/number.ts`:

```ts
/**
 * Converts a Uint8Array to a bigint, assuming big-endian byte order.
 * In big-endian, the most significant byte is placed at the beginning of the array.
 * This format is commonly used in network protocols and cryptography.
 *
 * @param array - The Uint8Array to convert to a bigint.
 * @returns The bigint representation of the input Uint8Array.
 * @throws TypeError if the input parameter is not an instance of Uint8Array.
 */
export function uint8ArrayToBigIntBigEndian(array: Uint8Array): bigint {
  if (!(array instanceof Uint8Array)) {
    array = Uint8Array.from(array);
  }

  let result: bigint = 0n;
  for (const byte of array) {
    result = (result << 8n) | BigInt(byte);
  }
  return result;
}

/**
 * Converts a Uint8Array to a bigint, assuming little-endian byte order.
 * In little-endian, the least significant byte is placed at the beginning of the array.
 * This format is sometimes used for representing numbers in computer memory.
 *
 * @param array - The Uint8Array to convert to a bigint.
 * @returns The bigint representation of the input Uint8Array.
 * @throws TypeError if the input parameter is not an instance of Uint8Array.
 */
export function uint8ArrayToBigIntLittleEndian(array: Uint8Array): bigint {
  if (!(array instanceof Uint8Array)) {
    array = Uint8Array.from(array);
  }

  let result: bigint = 0n;
  for (let i = array.length - 1; i >= 0; i--) {
    result = (result << 8n) | BigInt(array[i]);
  }
  return result;
}

/**
 * Converts a bigint to a big-endian Uint8Array of specified length.
 * @param value - The bigint to convert.
 * @param length - The desired length of the output array.
 * @returns The Uint8Array representation of the bigint.
 */
export function bigIntToUint8ArrayBigEndian(
  value: bigint,
  length: number,
): Uint8Array {
  const hex = value.toString(16).padStart(length * 2, "0");
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    bytes[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
  }
  return bytes;
}

```

`zil-pay/crypto/pbkdf2.ts`:

```ts
import { ShaAlgorithms } from "../config/pbkdf2";

export async function pbkdf2(
  password: Uint8Array,
  salt: Uint8Array,
  iterations: number,
  algorithms = ShaAlgorithms.Sha512,
) {
  const passphraseKey = await globalThis.crypto.subtle.importKey(
    "raw",
    password,
    { name: "PBKDF2" },
    false,
    ["deriveBits", "deriveKey"],
  );
  const webKey = await globalThis.crypto.subtle.deriveKey(
    {
      salt,
      iterations,
      name: "PBKDF2",
      hash: algorithms,
    },
    passphraseKey,
    {
      name: "HMAC",
      hash: algorithms,
      length: 512,
    },
    true,
    ["sign", "verify"],
  );
  const hash = await globalThis.crypto.subtle.exportKey("raw", webKey);

  return new Uint8Array(hash);
}

```

`zil-pay/crypto/proto/zq1.ts`:

```ts
export interface ByteArray {
  data: Uint8Array;
}

export function encodeByteArray(message: ByteArray): Uint8Array {
  let bb = popByteBuffer();
  _encodeByteArray(message, bb);
  return toUint8Array(bb);
}

function _encodeByteArray(message: ByteArray, bb: ByteBuffer): void {
  // required bytes data = 1;
  let $data = message.data;
  if ($data !== undefined) {
    writeVarint32(bb, 10);
    writeVarint32(bb, $data.length), writeBytes(bb, $data);
  }
}

export function decodeByteArray(binary: Uint8Array): ByteArray {
  return _decodeByteArray(wrapByteBuffer(binary));
}

function _decodeByteArray(bb: ByteBuffer): ByteArray {
  let message: ByteArray = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required bytes data = 1;
      case 1: {
        message.data = readBytes(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.data === undefined)
    throw new Error("Missing required field: data");

  return message;
}

export interface ProtoTransactionCoreInfo {
  version?: number;
  nonce?: Long;
  toaddr?: Uint8Array;
  senderpubkey?: ByteArray;
  amount?: ByteArray;
  gasprice?: ByteArray;
  gaslimit?: Long;
  code?: Uint8Array;
  data?: Uint8Array;
}

export function encodeProtoTransactionCoreInfo(message: ProtoTransactionCoreInfo): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransactionCoreInfo(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransactionCoreInfo(message: ProtoTransactionCoreInfo, bb: ByteBuffer): void {
  // optional uint32 version = 1;
  let $version = message.version;
  if ($version !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32(bb, $version);
  }

  // optional uint64 nonce = 2;
  let $nonce = message.nonce;
  if ($nonce !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $nonce);
  }

  // optional bytes toaddr = 3;
  let $toaddr = message.toaddr;
  if ($toaddr !== undefined) {
    writeVarint32(bb, 26);
    writeVarint32(bb, $toaddr.length), writeBytes(bb, $toaddr);
  }

  // optional ByteArray senderpubkey = 4;
  let $senderpubkey = message.senderpubkey;
  if ($senderpubkey !== undefined) {
    writeVarint32(bb, 34);
    let nested = popByteBuffer();
    _encodeByteArray($senderpubkey, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ByteArray amount = 5;
  let $amount = message.amount;
  if ($amount !== undefined) {
    writeVarint32(bb, 42);
    let nested = popByteBuffer();
    _encodeByteArray($amount, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ByteArray gasprice = 6;
  let $gasprice = message.gasprice;
  if ($gasprice !== undefined) {
    writeVarint32(bb, 50);
    let nested = popByteBuffer();
    _encodeByteArray($gasprice, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional uint64 gaslimit = 7;
  let $gaslimit = message.gaslimit;
  if ($gaslimit !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, $gaslimit);
  }

  // optional bytes code = 8;
  let $code = message.code;
  if ($code !== undefined) {
    writeVarint32(bb, 66);
    writeVarint32(bb, $code.length), writeBytes(bb, $code);
  }

  // optional bytes data = 9;
  let $data = message.data;
  if ($data !== undefined) {
    writeVarint32(bb, 74);
    writeVarint32(bb, $data.length), writeBytes(bb, $data);
  }
}

export function decodeProtoTransactionCoreInfo(binary: Uint8Array): ProtoTransactionCoreInfo {
  return _decodeProtoTransactionCoreInfo(wrapByteBuffer(binary));
}

function _decodeProtoTransactionCoreInfo(bb: ByteBuffer): ProtoTransactionCoreInfo {
  let message: ProtoTransactionCoreInfo = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional uint32 version = 1;
      case 1: {
        message.version = readVarint32(bb) >>> 0;
        break;
      }

      // optional uint64 nonce = 2;
      case 2: {
        message.nonce = readVarint64(bb, /* unsigned */ true);
        break;
      }

      // optional bytes toaddr = 3;
      case 3: {
        message.toaddr = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional ByteArray senderpubkey = 4;
      case 4: {
        let limit = pushTemporaryLength(bb);
        message.senderpubkey = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      // optional ByteArray amount = 5;
      case 5: {
        let limit = pushTemporaryLength(bb);
        message.amount = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      // optional ByteArray gasprice = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        message.gasprice = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      // optional uint64 gaslimit = 7;
      case 7: {
        message.gaslimit = readVarint64(bb, /* unsigned */ true);
        break;
      }

      // optional bytes code = 8;
      case 8: {
        message.code = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional bytes data = 9;
      case 9: {
        message.data = readBytes(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface ProtoTransaction {
  tranid?: Uint8Array;
  info?: ProtoTransactionCoreInfo;
  signature?: ByteArray;
}

export function encodeProtoTransaction(message: ProtoTransaction): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransaction(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransaction(message: ProtoTransaction, bb: ByteBuffer): void {
  // optional bytes tranid = 1;
  let $tranid = message.tranid;
  if ($tranid !== undefined) {
    writeVarint32(bb, 10);
    writeVarint32(bb, $tranid.length), writeBytes(bb, $tranid);
  }

  // optional ProtoTransactionCoreInfo info = 2;
  let $info = message.info;
  if ($info !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodeProtoTransactionCoreInfo($info, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ByteArray signature = 3;
  let $signature = message.signature;
  if ($signature !== undefined) {
    writeVarint32(bb, 26);
    let nested = popByteBuffer();
    _encodeByteArray($signature, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }
}

export function decodeProtoTransaction(binary: Uint8Array): ProtoTransaction {
  return _decodeProtoTransaction(wrapByteBuffer(binary));
}

function _decodeProtoTransaction(bb: ByteBuffer): ProtoTransaction {
  let message: ProtoTransaction = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional bytes tranid = 1;
      case 1: {
        message.tranid = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional ProtoTransactionCoreInfo info = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.info = _decodeProtoTransactionCoreInfo(bb);
        bb.limit = limit;
        break;
      }

      // optional ByteArray signature = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        message.signature = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface ProtoTransactionReceipt {
  receipt?: Uint8Array;
  cumgas?: Long;
}

export function encodeProtoTransactionReceipt(message: ProtoTransactionReceipt): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransactionReceipt(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransactionReceipt(message: ProtoTransactionReceipt, bb: ByteBuffer): void {
  // optional bytes receipt = 1;
  let $receipt = message.receipt;
  if ($receipt !== undefined) {
    writeVarint32(bb, 10);
    writeVarint32(bb, $receipt.length), writeBytes(bb, $receipt);
  }

  // optional uint64 cumgas = 2;
  let $cumgas = message.cumgas;
  if ($cumgas !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $cumgas);
  }
}

export function decodeProtoTransactionReceipt(binary: Uint8Array): ProtoTransactionReceipt {
  return _decodeProtoTransactionReceipt(wrapByteBuffer(binary));
}

function _decodeProtoTransactionReceipt(bb: ByteBuffer): ProtoTransactionReceipt {
  let message: ProtoTransactionReceipt = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional bytes receipt = 1;
      case 1: {
        message.receipt = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional uint64 cumgas = 2;
      case 2: {
        message.cumgas = readVarint64(bb, /* unsigned */ true);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface ProtoTransactionWithReceipt {
  transaction?: ProtoTransaction;
  receipt?: ProtoTransactionReceipt;
}

export function encodeProtoTransactionWithReceipt(message: ProtoTransactionWithReceipt): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransactionWithReceipt(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransactionWithReceipt(message: ProtoTransactionWithReceipt, bb: ByteBuffer): void {
  // optional ProtoTransaction transaction = 1;
  let $transaction = message.transaction;
  if ($transaction !== undefined) {
    writeVarint32(bb, 10);
    let nested = popByteBuffer();
    _encodeProtoTransaction($transaction, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ProtoTransactionReceipt receipt = 2;
  let $receipt = message.receipt;
  if ($receipt !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodeProtoTransactionReceipt($receipt, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }
}

export function decodeProtoTransactionWithReceipt(binary: Uint8Array): ProtoTransactionWithReceipt {
  return _decodeProtoTransactionWithReceipt(wrapByteBuffer(binary));
}

function _decodeProtoTransactionWithReceipt(bb: ByteBuffer): ProtoTransactionWithReceipt {
  let message: ProtoTransactionWithReceipt = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional ProtoTransaction transaction = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        message.transaction = _decodeProtoTransaction(bb);
        bb.limit = limit;
        break;
      }

      // optional ProtoTransactionReceipt receipt = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.receipt = _decodeProtoTransactionReceipt(bb);
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface Long {
  low: number;
  high: number;
  unsigned: boolean;
}

interface ByteBuffer {
  bytes: Uint8Array;
  offset: number;
  limit: number;
}

function pushTemporaryLength(bb: ByteBuffer): number {
  let length = readVarint32(bb);
  let limit = bb.limit;
  bb.limit = bb.offset + length;
  return limit;
}

function skipUnknownField(bb: ByteBuffer, type: number): void {
  switch (type) {
    case 0: while (readByte(bb) & 0x80) { } break;
    case 2: skip(bb, readVarint32(bb)); break;
    case 5: skip(bb, 4); break;
    case 1: skip(bb, 8); break;
    default: throw new Error("Unimplemented type: " + type);
  }
}

function stringToLong(value: string): Long {
  return {
    low: value.charCodeAt(0) | (value.charCodeAt(1) << 16),
    high: value.charCodeAt(2) | (value.charCodeAt(3) << 16),
    unsigned: false,
  };
}

function longToString(value: Long): string {
  let low = value.low;
  let high = value.high;
  return String.fromCharCode(
    low & 0xFFFF,
    low >>> 16,
    high & 0xFFFF,
    high >>> 16);
}

// The code below was modified from https://github.com/protobufjs/bytebuffer.js
// which is under the Apache License 2.0.

let f32 = new Float32Array(1);
let f32_u8 = new Uint8Array(f32.buffer);

let f64 = new Float64Array(1);
let f64_u8 = new Uint8Array(f64.buffer);

function intToLong(value: number): Long {
  value |= 0;
  return {
    low: value,
    high: value >> 31,
    unsigned: value >= 0,
  };
}

let bbStack: ByteBuffer[] = [];

function popByteBuffer(): ByteBuffer {
  const bb = bbStack.pop();
  if (!bb) return { bytes: new Uint8Array(64), offset: 0, limit: 0 };
  bb.offset = bb.limit = 0;
  return bb;
}

function pushByteBuffer(bb: ByteBuffer): void {
  bbStack.push(bb);
}

function wrapByteBuffer(bytes: Uint8Array): ByteBuffer {
  return { bytes, offset: 0, limit: bytes.length };
}

function toUint8Array(bb: ByteBuffer): Uint8Array {
  let bytes = bb.bytes;
  let limit = bb.limit;
  return bytes.length === limit ? bytes : bytes.subarray(0, limit);
}

function skip(bb: ByteBuffer, offset: number): void {
  if (bb.offset + offset > bb.limit) {
    throw new Error('Skip past limit');
  }
  bb.offset += offset;
}

function isAtEnd(bb: ByteBuffer): boolean {
  return bb.offset >= bb.limit;
}

function grow(bb: ByteBuffer, count: number): number {
  let bytes = bb.bytes;
  let offset = bb.offset;
  let limit = bb.limit;
  let finalOffset = offset + count;
  if (finalOffset > bytes.length) {
    let newBytes = new Uint8Array(finalOffset * 2);
    newBytes.set(bytes);
    bb.bytes = newBytes;
  }
  bb.offset = finalOffset;
  if (finalOffset > limit) {
    bb.limit = finalOffset;
  }
  return offset;
}

function advance(bb: ByteBuffer, count: number): number {
  let offset = bb.offset;
  if (offset + count > bb.limit) {
    throw new Error('Read past limit');
  }
  bb.offset += count;
  return offset;
}

function readBytes(bb: ByteBuffer, count: number): Uint8Array {
  let offset = advance(bb, count);
  return bb.bytes.subarray(offset, offset + count);
}

function writeBytes(bb: ByteBuffer, buffer: Uint8Array): void {
  let offset = grow(bb, buffer.length);
  bb.bytes.set(buffer, offset);
}

function readString(bb: ByteBuffer, count: number): string {
  // Sadly a hand-coded UTF8 decoder is much faster than subarray+TextDecoder in V8
  let offset = advance(bb, count);
  let fromCharCode = String.fromCharCode;
  let bytes = bb.bytes;
  let invalid = '\uFFFD';
  let text = '';

  for (let i = 0; i < count; i++) {
    let c1 = bytes[i + offset], c2: number, c3: number, c4: number, c: number;

    // 1 byte
    if ((c1 & 0x80) === 0) {
      text += fromCharCode(c1);
    }

    // 2 bytes
    else if ((c1 & 0xE0) === 0xC0) {
      if (i + 1 >= count) text += invalid;
      else {
        c2 = bytes[i + offset + 1];
        if ((c2 & 0xC0) !== 0x80) text += invalid;
        else {
          c = ((c1 & 0x1F) << 6) | (c2 & 0x3F);
          if (c < 0x80) text += invalid;
          else {
            text += fromCharCode(c);
            i++;
          }
        }
      }
    }

    // 3 bytes
    else if ((c1 & 0xF0) == 0xE0) {
      if (i + 2 >= count) text += invalid;
      else {
        c2 = bytes[i + offset + 1];
        c3 = bytes[i + offset + 2];
        if (((c2 | (c3 << 8)) & 0xC0C0) !== 0x8080) text += invalid;
        else {
          c = ((c1 & 0x0F) << 12) | ((c2 & 0x3F) << 6) | (c3 & 0x3F);
          if (c < 0x0800 || (c >= 0xD800 && c <= 0xDFFF)) text += invalid;
          else {
            text += fromCharCode(c);
            i += 2;
          }
        }
      }
    }

    // 4 bytes
    else if ((c1 & 0xF8) == 0xF0) {
      if (i + 3 >= count) text += invalid;
      else {
        c2 = bytes[i + offset + 1];
        c3 = bytes[i + offset + 2];
        c4 = bytes[i + offset + 3];
        if (((c2 | (c3 << 8) | (c4 << 16)) & 0xC0C0C0) !== 0x808080) text += invalid;
        else {
          c = ((c1 & 0x07) << 0x12) | ((c2 & 0x3F) << 0x0C) | ((c3 & 0x3F) << 0x06) | (c4 & 0x3F);
          if (c < 0x10000 || c > 0x10FFFF) text += invalid;
          else {
            c -= 0x10000;
            text += fromCharCode((c >> 10) + 0xD800, (c & 0x3FF) + 0xDC00);
            i += 3;
          }
        }
      }
    }

    else text += invalid;
  }

  return text;
}

function writeString(bb: ByteBuffer, text: string): void {
  // Sadly a hand-coded UTF8 encoder is much faster than TextEncoder+set in V8
  let n = text.length;
  let byteCount = 0;

  // Write the byte count first
  for (let i = 0; i < n; i++) {
    let c = text.charCodeAt(i);
    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {
      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;
    }
    byteCount += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }
  writeVarint32(bb, byteCount);

  let offset = grow(bb, byteCount);
  let bytes = bb.bytes;

  // Then write the bytes
  for (let i = 0; i < n; i++) {
    let c = text.charCodeAt(i);
    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {
      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;
    }
    if (c < 0x80) {
      bytes[offset++] = c;
    } else {
      if (c < 0x800) {
        bytes[offset++] = ((c >> 6) & 0x1F) | 0xC0;
      } else {
        if (c < 0x10000) {
          bytes[offset++] = ((c >> 12) & 0x0F) | 0xE0;
        } else {
          bytes[offset++] = ((c >> 18) & 0x07) | 0xF0;
          bytes[offset++] = ((c >> 12) & 0x3F) | 0x80;
        }
        bytes[offset++] = ((c >> 6) & 0x3F) | 0x80;
      }
      bytes[offset++] = (c & 0x3F) | 0x80;
    }
  }
}

function writeByteBuffer(bb: ByteBuffer, buffer: ByteBuffer): void {
  let offset = grow(bb, buffer.limit);
  let from = bb.bytes;
  let to = buffer.bytes;

  // This for loop is much faster than subarray+set on V8
  for (let i = 0, n = buffer.limit; i < n; i++) {
    from[i + offset] = to[i];
  }
}

function readByte(bb: ByteBuffer): number {
  return bb.bytes[advance(bb, 1)];
}

function writeByte(bb: ByteBuffer, value: number): void {
  let offset = grow(bb, 1);
  bb.bytes[offset] = value;
}

function readFloat(bb: ByteBuffer): number {
  let offset = advance(bb, 4);
  let bytes = bb.bytes;

  // Manual copying is much faster than subarray+set in V8
  f32_u8[0] = bytes[offset++];
  f32_u8[1] = bytes[offset++];
  f32_u8[2] = bytes[offset++];
  f32_u8[3] = bytes[offset++];
  return f32[0];
}

function writeFloat(bb: ByteBuffer, value: number): void {
  let offset = grow(bb, 4);
  let bytes = bb.bytes;
  f32[0] = value;

  // Manual copying is much faster than subarray+set in V8
  bytes[offset++] = f32_u8[0];
  bytes[offset++] = f32_u8[1];
  bytes[offset++] = f32_u8[2];
  bytes[offset++] = f32_u8[3];
}

function readDouble(bb: ByteBuffer): number {
  let offset = advance(bb, 8);
  let bytes = bb.bytes;

  // Manual copying is much faster than subarray+set in V8
  f64_u8[0] = bytes[offset++];
  f64_u8[1] = bytes[offset++];
  f64_u8[2] = bytes[offset++];
  f64_u8[3] = bytes[offset++];
  f64_u8[4] = bytes[offset++];
  f64_u8[5] = bytes[offset++];
  f64_u8[6] = bytes[offset++];
  f64_u8[7] = bytes[offset++];
  return f64[0];
}

function writeDouble(bb: ByteBuffer, value: number): void {
  let offset = grow(bb, 8);
  let bytes = bb.bytes;
  f64[0] = value;

  // Manual copying is much faster than subarray+set in V8
  bytes[offset++] = f64_u8[0];
  bytes[offset++] = f64_u8[1];
  bytes[offset++] = f64_u8[2];
  bytes[offset++] = f64_u8[3];
  bytes[offset++] = f64_u8[4];
  bytes[offset++] = f64_u8[5];
  bytes[offset++] = f64_u8[6];
  bytes[offset++] = f64_u8[7];
}

function readInt32(bb: ByteBuffer): number {
  let offset = advance(bb, 4);
  let bytes = bb.bytes;
  return (
    bytes[offset] |
    (bytes[offset + 1] << 8) |
    (bytes[offset + 2] << 16) |
    (bytes[offset + 3] << 24)
  );
}

function writeInt32(bb: ByteBuffer, value: number): void {
  let offset = grow(bb, 4);
  let bytes = bb.bytes;
  bytes[offset] = value;
  bytes[offset + 1] = value >> 8;
  bytes[offset + 2] = value >> 16;
  bytes[offset + 3] = value >> 24;
}

function readInt64(bb: ByteBuffer, unsigned: boolean): Long {
  return {
    low: readInt32(bb),
    high: readInt32(bb),
    unsigned,
  };
}

function writeInt64(bb: ByteBuffer, value: Long): void {
  writeInt32(bb, value.low);
  writeInt32(bb, value.high);
}

function readVarint32(bb: ByteBuffer): number {
  let c = 0;
  let value = 0;
  let b: number;
  do {
    b = readByte(bb);
    if (c < 32) value |= (b & 0x7F) << c;
    c += 7;
  } while (b & 0x80);
  return value;
}

function writeVarint32(bb: ByteBuffer, value: number): void {
  value >>>= 0;
  while (value >= 0x80) {
    writeByte(bb, (value & 0x7f) | 0x80);
    value >>>= 7;
  }
  writeByte(bb, value);
}

function readVarint64(bb: ByteBuffer, unsigned: boolean): Long {
  let part0 = 0;
  let part1 = 0;
  let part2 = 0;
  let b: number;

  b = readByte(bb); part0 = (b & 0x7F); if (b & 0x80) {
    b = readByte(bb); part0 |= (b & 0x7F) << 7; if (b & 0x80) {
      b = readByte(bb); part0 |= (b & 0x7F) << 14; if (b & 0x80) {
        b = readByte(bb); part0 |= (b & 0x7F) << 21; if (b & 0x80) {

          b = readByte(bb); part1 = (b & 0x7F); if (b & 0x80) {
            b = readByte(bb); part1 |= (b & 0x7F) << 7; if (b & 0x80) {
              b = readByte(bb); part1 |= (b & 0x7F) << 14; if (b & 0x80) {
                b = readByte(bb); part1 |= (b & 0x7F) << 21; if (b & 0x80) {

                  b = readByte(bb); part2 = (b & 0x7F); if (b & 0x80) {
                    b = readByte(bb); part2 |= (b & 0x7F) << 7;
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return {
    low: part0 | (part1 << 28),
    high: (part1 >>> 4) | (part2 << 24),
    unsigned,
  };
}

function writeVarint64(bb: ByteBuffer, value: Long): void {
  let part0 = value.low >>> 0;
  let part1 = ((value.low >>> 28) | (value.high << 4)) >>> 0;
  let part2 = value.high >>> 24;

  // ref: src/google/protobuf/io/coded_stream.cc
  let size =
    part2 === 0 ?
      part1 === 0 ?
        part0 < 1 << 14 ?
          part0 < 1 << 7 ? 1 : 2 :
          part0 < 1 << 21 ? 3 : 4 :
        part1 < 1 << 14 ?
          part1 < 1 << 7 ? 5 : 6 :
          part1 < 1 << 21 ? 7 : 8 :
      part2 < 1 << 7 ? 9 : 10;

  let offset = grow(bb, size);
  let bytes = bb.bytes;

  switch (size) {
    case 10: bytes[offset + 9] = (part2 >>> 7) & 0x01;
    case 9: bytes[offset + 8] = size !== 9 ? part2 | 0x80 : part2 & 0x7F;
    case 8: bytes[offset + 7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
    case 7: bytes[offset + 6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
    case 6: bytes[offset + 5] = size !== 6 ? (part1 >>> 7) | 0x80 : (part1 >>> 7) & 0x7F;
    case 5: bytes[offset + 4] = size !== 5 ? part1 | 0x80 : part1 & 0x7F;
    case 4: bytes[offset + 3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
    case 3: bytes[offset + 2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
    case 2: bytes[offset + 1] = size !== 2 ? (part0 >>> 7) | 0x80 : (part0 >>> 7) & 0x7F;
    case 1: bytes[offset] = size !== 1 ? part0 | 0x80 : part0 & 0x7F;
  }
}

function readVarint32ZigZag(bb: ByteBuffer): number {
  let value = readVarint32(bb);

  // ref: src/google/protobuf/wire_format_lite.h
  return (value >>> 1) ^ -(value & 1);
}

function writeVarint32ZigZag(bb: ByteBuffer, value: number): void {
  // ref: src/google/protobuf/wire_format_lite.h
  writeVarint32(bb, (value << 1) ^ (value >> 31));
}

function readVarint64ZigZag(bb: ByteBuffer): Long {
  let value = readVarint64(bb, /* unsigned */ false);
  let low = value.low;
  let high = value.high;
  let flip = -(low & 1);

  // ref: src/google/protobuf/wire_format_lite.h
  return {
    low: ((low >>> 1) | (high << 31)) ^ flip,
    high: (high >>> 1) ^ flip,
    unsigned: false,
  };
}

function writeVarint64ZigZag(bb: ByteBuffer, value: Long): void {
  let low = value.low;
  let high = value.high;
  let flip = high >> 31;

  // ref: src/google/protobuf/wire_format_lite.h
  writeVarint64(bb, {
    low: (low << 1) ^ flip,
    high: ((high << 1) | (low >>> 31)) ^ flip,
    unsigned: false,
  });
}

```

`zil-pay/crypto/pubkey.ts`:

```ts
import { utils } from "aes-js";

const SECRET_KEY_SIZE = 32;

export enum SecretKeyType {
  Secp256k1Sha256Zilliqa,
  Secp256k1Keccak256Ethereum,
}

export enum SecretKeyError {
  SecretKeySliceError = "Secret key slice error",
  InvalidHex = "Invalid hex string",
  InvalidLength = "Invalid key length",
  InvalidKeyType = "Invalid key type",
}

export class SecretKey {
  public type: SecretKeyType;
  public data: Uint8Array;

  constructor(type: SecretKeyType, data: Uint8Array) {
    this.type = type;
    this.data = data;

    if (data.length !== SECRET_KEY_SIZE) {
      throw new Error(SecretKeyError.InvalidLength);
    }
  }

  toBytes(): Uint8Array {
    const result = new Uint8Array(SECRET_KEY_SIZE + 1);
    result[0] = this.type === SecretKeyType.Secp256k1Sha256Zilliqa ? 0 : 1;
    result.set(this.data, 1);
    return result;
  }

  static fromBytes(bytes: Uint8Array): SecretKey {
    const keyType = bytes[0];
    const keyData = bytes.slice(1);

    if (keyData.length !== SECRET_KEY_SIZE) {
      throw new Error(SecretKeyError.SecretKeySliceError);
    }

    const keyDataArray = new Uint8Array(keyData);

    switch (keyType) {
      case 0:
        return new SecretKey(
          SecretKeyType.Secp256k1Sha256Zilliqa,
          keyDataArray,
        );
      case 1:
        return new SecretKey(
          SecretKeyType.Secp256k1Keccak256Ethereum,
          keyDataArray,
        );
      default:
        throw new Error(SecretKeyError.InvalidKeyType);
    }
  }

  toHexString(): string {
    return utils.hex.fromBytes(this.toBytes());
  }

  static fromString(s: string): SecretKey {
    try {
      const data = utils.hex.toBytes(s);

      if (!data || data.length === 0) {
        throw new Error(SecretKeyError.InvalidHex);
      }

      const prefix = data[0];
      const keyData = data.slice(1);

      if (keyData.length !== SECRET_KEY_SIZE) {
        throw new Error(SecretKeyError.InvalidLength);
      }

      const keyDataArray = new Uint8Array(keyData);

      let type: SecretKeyType;
      switch (prefix) {
        case 0:
          type = SecretKeyType.Secp256k1Sha256Zilliqa;
          break;
        case 1:
          type = SecretKeyType.Secp256k1Keccak256Ethereum;
          break;
        default:
          throw new Error(SecretKeyError.InvalidKeyType);
      }

      return new SecretKey(type, keyDataArray);
    } catch (error) {
      throw new Error(SecretKeyError.InvalidHex);
    }
  }
}

```

`zil-pay/crypto/random.ts`:

```ts
import { ChaCha20Rng } from "@hicaru/chacharand.js";

export function randomBytes(length: number): Uint8Array {
  const buffer = new Uint8Array(length);
  const randomSeed = new Uint8Array(32);

  window.crypto.getRandomValues(randomSeed);

  const rng = ChaCha20Rng(randomSeed);

  rng.fillBytes(buffer);

  return buffer;
}

```

`zil-pay/crypto/sha256.ts`:

```ts
import { ShaAlgorithms } from "config/pbkdf2";

export async function sha256(value: Uint8Array) {
  if (!(value instanceof Uint8Array)) {
    value = Uint8Array.from(value);
  }

  const crypto = globalThis.crypto;
  const hash = await crypto.subtle.digest(ShaAlgorithms.sha256, value);
  return new Uint8Array(hash);
}

```

`zil-pay/crypto/sha512.ts`:

```ts
import { ShaAlgorithms } from "config/pbkdf2";

export async function sha512(value: Uint8Array) {
  const crypto = globalThis.crypto;
  return crypto.subtle.digest(ShaAlgorithms.Sha512, value);
}

```

`zil-pay/crypto/uuid.ts`:

```ts
export function uuid(): string {
  return window.crypto.randomUUID();
}

```

`zil-pay/crypto/zilliqa/pubkey.ts`:

```ts
import { getPublicKey } from 'noble-secp256k1';

export function fromZILPrivateKey(privateKey: Uint8Array): Uint8Array {
  const publicKey = getPublicKey(Uint8Array.from(privateKey), true);
  return publicKey;
}


```

`zil-pay/crypto/zilliqa/schnorr.ts`:

```ts
import * as secp256k1 from 'noble-secp256k1';
import { randomBytes } from '../random';
import { sha256 } from '../sha256';
import { uint8ArrayToBigIntBigEndian } from '../number';
import { fromZILPrivateKey } from './pubkey';

const MAX_TRY_SIGN = 100_000_000;

export async function sign(message: Uint8Array, secretKey: Uint8Array): Promise<secp256k1.Signature> {
  let safeCounter = 0;

  while (safeCounter < MAX_TRY_SIGN) {
    // Generate random k (nonce) as a 32-byte array
    const kBytes = randomBytes(32);
    // Convert to scalar (bigint) modulo curve order n
    const k = uint8ArrayToBigIntBigEndian(kBytes) % secp256k1.CURVE.n;

    const signature = await signInner(k, message, secretKey);
    if (signature) {
      return signature;
    }

    safeCounter++;
  }

  throw new Error('InvalidSignTry: Exceeded maximum signing attempts');
}

export async function signInner(k: bigint, message: Uint8Array, secretKey: Uint8Array): Promise<secp256k1.Signature | null> {
  // Compute public key from secret key (compressed, 33 bytes)
  const publicKey = fromZILPrivateKey(secretKey);

  // Compute commitment Q = k * G (where G is the generator point)
  const QPoint = secp256k1.Point.BASE.multiply(k);
  const Q = QPoint.toRawBytes(true); // Compressed Q

  // Compute challenge r = H(Q || publicKey || message) mod n
  const hasherInput = new Uint8Array([...Q, ...publicKey, ...message]);
  const hash = await sha256(hasherInput);
  const r = uint8ArrayToBigIntBigEndian(hash) % secp256k1.CURVE.n;

  // If r = 0 mod n, signature is invalid, return null
  if (r === 0n) {
    return null;
  }

  // Compute s = k - r * secretKey mod n
  const secretKeyScalar = uint8ArrayToBigIntBigEndian(secretKey);
  const rTimesSecret = (r * secretKeyScalar) % secp256k1.CURVE.n;
  const s = (k - rTimesSecret + secp256k1.CURVE.n) % secp256k1.CURVE.n;

  // If s = 0 mod n, signature is invalid, return null
  if (s === 0n) {
    return null;
  }

  // Return signature (r, s)
  return new secp256k1.Signature(r, s);
}

export async function verify(
  message: Uint8Array,
  publicKey: Uint8Array,
  signature: secp256k1.Signature
): Promise<boolean> {
  const r = signature.r;
  const s = signature.s;

  // Compute Q = s * G + r * publicKey
  const sG = secp256k1.Point.BASE.multiply(s); // s * G
  const publicKeyPoint = secp256k1.Point.fromHex(Uint8Array.from(publicKey));
  const rPub = publicKeyPoint.multiply(r); // r * publicKey
  const QPoint = sG.add(rPub);
  const Q = QPoint.toRawBytes(true); // Compressed Q

  // If Q is the point at infinity, verification fails
  if (QPoint.equals(secp256k1.Point.ZERO)) {
    return false;
  }

  // Compute r' = H(Q || publicKey || message) mod n
  const hasherInput = new Uint8Array([...Q, ...publicKey, ...message]);
  const hash = await sha256(hasherInput);
  const rDash = uint8ArrayToBigIntBigEndian(hash) % secp256k1.CURVE.n;

  // Verification succeeds if r' == r
  return rDash === r;
}



```

`zil-pay/lib/array/chunk.ts`:

```ts
/**
 * Splits an array into chunks of a specified size.
 * @template T - The type of elements in the input array.
 * @param array - The input array to be chunked.
 * @param size - The size of each chunk (must be greater than 0).
 * @returns A new array containing the chunks.
 * @throws {Error} If the size is not a positive number.
 */
export function chunk<T>(array: T[], size: number): T[][] {
    if (size <= 0) {
        throw new Error("Size must be a positive number.");
    }

    const result: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
        result.push(array.slice(i, i + size));
    }
    return result;
}


```

`zil-pay/lib/array/shuffle.ts`:

```ts
/**
 * Shuffles the elements of an array in place using the Fisher-Yates algorithm.
 * @template T - The type of elements in the array.
 * @param array - The array to shuffle.
 */
export function shuffle<T>(array: T[]): T[] {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}


```

`zil-pay/lib/popup/clipboard.ts`:

```ts
/**
 * Asynchronously copies the provided text to the user's clipboard using the modern
 * `navigator.clipboard` API. If the modern API is not available, it attempts
 * to use the deprecated `document.execCommand('copy')` as a fallback.
 *
 * @param text The string to be copied to the clipboard.
 * @returns A Promise that resolves to `true` if the copy operation was successful,
 * or `false` if it failed (e.g., due to browser limitations or user denial of permissions).
 */
export async function clipboardCopy(text: string): Promise<boolean> {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (_) {
      return fallbackCopyToClipboard(text);
    }
  } else {
    // Fallback for browsers that do not support the modern Clipboard API.
    return fallbackCopyToClipboard(text);
  }
}

/**
 * Attempts to copy text to the clipboard using the deprecated `document.execCommand('copy')` method.
 * This method is less reliable and may require user interaction or specific browser permissions.
 *
 * @param text The string to be copied to the clipboard.
 * @returns `true` if the copy command was successful, `false` otherwise.
 */
function fallbackCopyToClipboard(text: string): boolean {
  try {
    const span = document.createElement('span');
    span.textContent = text;
    span.style.whiteSpace = 'pre';
    span.style.userSelect = 'all';
    document.body.appendChild(span);
    const selection = window.getSelection();
    const range = window.document.createRange();
    selection?.removeAllRanges();
    range.selectNode(span);
    selection?.addRange(range);
    const successful = window.document.execCommand('copy');
    selection?.removeAllRanges();
    document.body.removeChild(span);
    return successful;
  } catch (err) {
    console.error('Failed to copy text using document.execCommand:', err);
    return false;
  }
}

```

`zil-pay/lib/popup/printer.ts`:

```ts
interface PrintMnemonicOptions {
  phrase: string;
  translations: string[];
  title: string;
}

export const printMnemonic = (options: PrintMnemonicOptions) => {
  const { phrase, translations, title } = options;
  return `<!DOCTYPE html>
<html id="print-wallet">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f8f9fa; /* Light background for printing */
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
    }

    .print-container {
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      width: 80%; /* Occupies most of the width */
      max-width: 700px; /* Limits maximum width */
      padding: 30px;
      margin-bottom: 50px; /* Bottom margin */
    }

    .print-text {
      text-align: center;
    }

    p {
      margin-bottom: 1em;
      font-size: 1rem;
    }

    h3 {
      color: #555;
      letter-spacing: 0.03rem;
      margin-top: 1.5em;
      margin-bottom: 1em;
      font-size: 1.4rem;
      font-weight: 500;
    }

    .phrase {
      font-family: Menlo, Monaco, Consolas, 'Courier New', monospace !important;
      font-weight: bold !important;
      font-size: 1.2rem;
      background-color: #f0f8ff; /* Light background for the phrase */
      color: #1e3a8a; /* Accent color for the phrase */
      padding: 1rem;
      border: 1px solid #aed9fe;
      border-radius: 4px;
      margin: 2rem auto;
      max-width: 90%;
      word-break: break-word;
    }

    .footer {
      margin-top: 2em;
      font-size: 0.9rem;
      color: #777;
    }

    .footer a {
      color: #777;
      text-decoration: none;
    }

    @media print {
      body {
        background-color: #fff; /* White background when printing */
      }
      .print-container {
        border: 1px solid #000; /* Black border when printing */
        box-shadow: none; /* Removes shadow when printing */
      }
    }
  </style>
</head>
<body>
  <main class="print-container" id="print-container">
    <article class="print-text">
      <p>
        ${translations[0]}<br>
        ${translations[1]}<br>
        ${translations[2]}
      </p>
      <h3>${translations[3]}</h3>
      <div class="phrase">${phrase}</div>
      <p>
        ${translations[4]}
      </p>
      <p>
        ${translations[5]}
      </p>
      <p>
        ${translations[6]}
      </p>
      <aside class="footer">
        <a href="https://zilpay.io/" rel="noopener noreferrer" target="_blank">ZilPay Wallet</a>
      </aside>
    </article>
  </main>
</body>
</html>
`;
};

```

`zil-pay/lib/popup/warp-message.ts`:

```ts
import type { SendResponseParams } from 'types/stream';

export function warpMessage<T>(msg: SendResponseParams): T | undefined {
  if (!msg) {
    return;
  }

  if (msg.reject) {
    throw new Error(String(msg.reject));
  }

  return msg.resolve;
}

```

`zil-pay/lib/runtime/assert.ts`:

```ts
export function assert(expressions: boolean, msg: string) {
  if (!expressions) {
    throw new Error(msg);
  }
}

```

`zil-pay/lib/runtime/ext-id.ts`:

```ts
import { Runtime } from "./extensionizer";

export const EXTENSION_ID = Runtime.runtime.id;

```

`zil-pay/lib/runtime/extensionizer.ts`:

```ts
export const Runtime = globalThis.chrome;

```

`zil-pay/lib/runtime/get-url.ts`:

```ts
import { Runtime } from "./extensionizer";

export function getExtensionURL(content: string) {
  return Runtime.runtime.getURL(content);
}


```

`zil-pay/lib/runtime/manifest.ts`:

```ts
import { Runtime } from './extensionizer';

export function getManifestVersion() {
  return Runtime.runtime.getManifest().manifest_version;
}

```

`zil-pay/lib/storage/builder.ts`:

```ts
import type { Fields } from 'config/fields';
import { TypeOf } from '../types/checker';

export type StorageKeyValue = {
    [key: string]: string;
};

/**
 * Builds a payload object for writing to browser storage.
 * Serializes objects and arrays to JSON strings.
 *
 * @example
 * import { buildObject, BrowserStorage } from 'lib/storage';
 *
 * const storage = Object.freeze(new BrowserStorage()); // Предполагается, что BrowserStorage - Singleton
 * storage.set(buildObject('key', 'any payload'));
 * storage.set(buildObject('objectKey', { a: 1, b: 2 }));
 * storage.set(buildObject('arrayKey', [1, 2, 3]));
 */
export function buildObject(key: Fields | string, value: string | object | any[]): StorageKeyValue { // Added any[]
    let data: string;

    if (TypeOf.isObject(value) || TypeOf.isArray(value)) {
        try {
            data = JSON.stringify(value);
        } catch (error) {
            // Handle the error appropriately.  For example:
            console.error('Error serializing value to JSON:', error);
            // Consider throwing the error, returning a default value, or logging.
            return { [key]: '' }; // Return empty string,  or throw error.  IMPORTANT
        }
    } else {
        data = String(value);
    }

    return {
        [key]: data,
    };
}


```

`zil-pay/lib/storage/storage.ts`:

```ts
import type { StorageKeyValue } from './builder';
import type { Fields } from 'config/fields';
import { Runtime } from 'lib/runtime/extensionizer';

type StorageChangesCallback = { [key: string]: chrome.storage.StorageChange; };

/**
 * Default class for working with browser Storage.
 * @example
 * import { BrowserStorage } from 'lib/storage'
 * BrowserStorage.get('KEY').then(data => { ... });
 */
export const BrowserStorage = Object.freeze({
    /**
     * Subscribes to storage changes.
     * @param callback - The callback function to be called when storage changes.
     * @returns An object with an unsubscribe method.
     */
    subscribe(callback: (changes: StorageChangesCallback) => void) {
        const listener = (changes: StorageChangesCallback) => {
            try {
                callback(changes);
            } catch (error) {
                console.error("Error in storage change callback:", error);
            }
        };

        Runtime.storage.onChanged.addListener(listener);

        return {
            unsubscribe() {
                Runtime.storage.onChanged.removeListener(listener);
            },
        };
    },

    /**
     * Sets multiple key-value pairs in storage.
     * @param items - An array of key-value objects to be stored.
     * @returns A promise that resolves when all items are set.
     */
    async set(...items: StorageKeyValue[]): Promise<void> {
        if (items.length === 0) return;

        const data: StorageKeyValue = {};
        for (const item of items) {
            Object.assign(data, item); // Merge all items into a single object.  Handles duplicate keys.
        }

        return new Promise((resolve, reject) => {
            Runtime.storage.local.set(data, () => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError); // Reject on error
                } else {
                    resolve();
                }
            });
        });
    },

    /**
     * Gets values from storage for the given keys.
     * @param keys - An array of keys to retrieve from storage.
     * @returns A promise that resolves with the retrieved data.  If one key is provided, the value is returned.  If multiple, an object is returned.
     */
    async get(...keys: (Fields | string)[]): Promise<StorageKeyValue | any> { // Use 'any' for more flexibility
        return new Promise((resolve, reject) => {
            Runtime.storage.local.get(keys, (result) => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                  if (keys.length === 1) {
                    resolve(result[keys[0]]);
                  } else {
                    resolve(result);
                  }
                }
            });
        });
    },

    /**
     * Gets all items from storage.
     * @returns A promise that resolves with an object containing all stored items.
     */
    async getAll(): Promise<StorageKeyValue> {
        return new Promise((resolve, reject) => {
            Runtime.storage.local.get(null, (items) => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    resolve(items);
                }
            });
        });
    },

    /**
     * Removes items from storage for the given keys.
     * @param keys - An array of keys to remove from storage.
     * @returns A promise that resolves when the items are removed.
     */
    async rm(...keys: (Fields | string)[]): Promise<void> {
        return new Promise((resolve, reject) => {
            Runtime.storage.local.remove(keys, () => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    resolve();
                }
            });
        });
    },

    /**
     * Clears all items from storage.
     * @returns A promise that resolves when the storage is cleared.
     */
    async clear(): Promise<void> {
        return new Promise((resolve, reject) => {
            Runtime.storage.local.clear(() => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    resolve();
                }
            });
        });
    },
});


```

`zil-pay/lib/streem/keys.ts`:

```ts
const app = 'zil-pay';

export const MTypeTabContent = {
  CONTENT: `@/${app}/content-script`,
  INJECTED: `@/${app}/injected-script`
};

export const MTypePopupWallet = {
  GET_RANDOM_SEED: `@/${app}/generate-random-seed`,
  CREATE_ACCOUNT_BY_SEED: `@/${app}/set-account-by-seed-words`,
  SET_PASSWORD: `@/${app}/popup-set-password`,
  LOG_OUT: `@/${app}/popup-logout`,
  SET_SEED_AND_PASSWORD: `@/${app}/popup-set-seed-words-and-password`,
  WALET_PASSWORD_CHANGE: `@/${app}/change-password`,
  GET_WALLET_STATE: `@/${app}/get-wallet-state`,
  EXPORT_SEED: `@/${app}/popup-export-seed-words`,
  EXPORT_PRIVATE_KEY: `@/${app}/popup-export-private-key`,
  EXPORT_QR_CODE_WALLET: `@/${app}/export-qr-code-wallet`,
  IMPORT_PRIVATE_KEY: `@/${app}/popup-import-private-key`,
  IMPORT_TRACK_ACCOUNT: `@/${app}/popup-import-track-account`,
  IMPORT_KEYSTORE: `@/${app}/popup-import-keystore`,
  ENCRYPT_WALLET: `@/${app}/encrypt-wallet-aes`,
  RES_ENCRYPTION: `@/${app}/response-encryption`,
  RES_DECRYPTION: `@/${app}/response-decryption`,
};

export const MTypePopupAccount = {
  RM_ACCOUNT: `@/${app}/remove-selected-account`,
  SELECT_ACCOUNT: `@/${app}/select-account`,
  SET_ACCOUNT_NAME: `@/${app}/set-account-name`,
  UPDATE_BALANCE: `@/${app}/popup-account-balance-upadte`,
};

export const MTypePopupTransaction = {
  UPDATE_TXNS: `@/${app}/check-processed-txns`,
  REJECT_CONFIRM_TX: `@/${app}/popup-reject-confirm-tx`,
  REJECT_ALL_CONFIRM_TXNS: `@/${app}/popup-reject-al-confirm-txns`,
  SEND_TO_SIGN_TX: `@/${app}/popup-send-to-sign-tx`,
  GET_REQUIRED_PARAMS: `@/${app}/get-required-params`,
  CLEAR_ALL_TXNS: `@/${app}/clear-all-txns`,
  GET_CURRENT_NONCE: `@/${app}/get-current-nonce`,
  RESET_NONCE: `@/${app}/reset-nonce`,
};

export const MTypePopupToken = {
  GET_ZRC2_STATE: `@/${app}/get-zrc2-token-info`,
  ADD_ZRC2_TOKEN: `@/${app}/add-new-zrc2-token`,
  RM_TOKEN: `@/${app}/remove-token`,
  GET_ZRC2_ALLOWANCES_FOR_SWAP: `@/${app}/get-zrc2-allowances-for-swap`,
};

export const MTypePopupNFT = {
  UPDATE_NFT_LIST: `@/${app}/update-nft-list`,
  GET_NFT_LIST: `@/${app}/get-nft-list`,
  FETCH_NFT: `@/${app}/fetch-nft`,
  ADD_NFT: `@/${app}/add-nft`,
  REMOVE_NFT: `@/${app}/remove-nft`,
};

export const MTypePopupNetwork = {
  SELECT_SSN: `@/${app}/select-from-ssn-list`,
  RESET_NETWROK: `@/${app}/reset-netwrok-settings`,
  SET_NET_CONFIG: `@/${app}/set-netwrok-config`,
  SELECT_NETWORK: `@/${app}/select-network`,
  UPDATE_SSN_LIST: `@/${app}/update-ssn-list`,
  GET_LATEST_BLOCK: `@/${app}/get-latest-block-number`,
};

export const MTypePopupDApp = {
  USER_RESPONSE_DAPP: `@/${app}/user-response-connect-dapp`,
  RM_APP: `@/${app}/remove-dapp`,
  CLEAR_APPS: `@/${app}/clear-all-apps`,
  SET_PHISHING_DETECTION: `@/${app}/set-phishing-detection`,
};

export const MTypePopupContact = {
  ADD_CONTACT: `@/${app}/add-a-contact`,
  RM_CONTACT: `@/${app}/remove-a-contact`,
};

export const MTypePopupSettings = {
  CHANGE_CURRENCY: `@/${app}/change-currency`,
  UPDATE_RATE: `@/${app}/update-rate`,
  RESET_CURRENCY: `@/${app}/reset-currency`,
  SET_THEME: `@/${app}/set-theme-mode`,
  RESET_THEME: `@/${app}/reset-theme`,
  SET_LOCALE: `@/${app}/set-locale`,
  RESET_LOCALE: `@/${app}/reset-locale`,
  SET_GAS_MULTIPLIER: `@/${app}/set-gas-multiplier`,
  RESET_GAS: `@/${app}/reset-gas`,
  SET_LOCK_TIME: `@/${app}/set-lock-timer`,
  SET_ADDRESS_FORMAT: `@/${app}/set-address-format`,
  SET_PROMT_ENABLED: `@/${app}/set-promt-enabled`,
};

export const MTypePopupSign = {
  REJECT_SIGN_MESSAGE: `@/${app}/reject-sign-message`,
  SIGN_MESSAGE_APPROVE: `@/${app}/approve-sign-message`,
};

export const MTypePopupUtil = {
  FROM_BECH32: `@/${app}/convert-from-bech32`,
};

export const MTypePopupDex = {
  UPDATE_DEX_DATA: `@/${app}/update-dex-data`,
  UPDATE_DEX_SETTINGS: `@/${app}/update-dex-settings`,
};

export const MTypePopupStake = {
  GET_STAKE_PROPS: `@/${app}/get-stake-props`,
};

export const MTypePopupLedger = {
  ADD_LEDGER_ACCOUNT: `@/${app}/add-ledger-account`,
};

export const MTypeTab = {
  GET_WALLET_DATA: `@/${app}/injected-get-wallet-data`,
  ADDRESS_CHANGED: `@/${app}/address-changed`,
  NETWORK_CHANGED: `@/${app}/network-changed`,
  LOCK_STAUS: `@/${app}/lack-status-updated`,
  CONTENT_PROXY_MEHTOD: `@/${app}/request-through-content`,
  CONTENT_PROXY_RESULT: `@/${app}/response-from-content`,
  CALL_TO_SIGN_TX: `@/${app}/request-to-sign-tx`,
  TX_RESULT: `@/${app}/response-tx-result`,
  SIGN_MESSAGE: `@/${app}/request-to-sign-message`,
  SING_MESSAGE_RES: `@/${app}/response-sign-message`,
  NEW_BLOCK: `@/${app}/new-block-created`,
  ADD_ENCRYPTION: `@/${app}/request-add-encryption`,
  RES_ENCRYPTION: `@/${app}/response-encryption`,
  ADD_DECRYPTION: `@/${app}/add-decryption`,
  RES_DECRYPTION: `@/${app}/response-decryption`,
  CONNECT_APP: `@/${app}/request-to-connect-dapp`,
  RESPONSE_TO_DAPP: `@/${app}/response-dapp-connect`,
  DISCONNECT_APP: `@/${app}/request-to-disconnect-dapp`
};


```

`zil-pay/lib/streem/message.ts`:

```ts
import { Runtime } from "lib/runtime/extensionizer";


export interface ReqBody<T = unknown> {
    type: string;
    payload?: T;
    domain?: string;
    from?: string;
}

export class Message<T = unknown> {
    constructor(public readonly body: ReqBody<T>) {}

    static signal(type: string): Message<object> {
        return new Message({ type });
    }

    async send(): Promise<T> {
        for (let i = 0; i < 10; i++) {
            try {
                const res = await this.#trySend();
                if (res) return res;
            } catch {}
        }
        throw new Error("service_worker_stopped");
    }

    #trySend(): Promise<T> {
        return new Promise((resolve) => {
          try {
            let data = JSON.parse(JSON.stringify(this.body));
            Runtime.runtime.sendMessage(data, resolve);
          } catch (err) {
            console.error(this, err);
            window.location.reload();
          }
        });
    }
}

```

`zil-pay/lib/streem/secure-message.ts`:

```ts
import type { ReqBody } from './message';
import type { TabStream } from './tab-stream';

export class SecureContentMessage<T = unknown> {
    constructor(public readonly body: ReqBody<T>) {}

    get type() { return this.body.type; }
    get payload() { return this.body.payload; }

    send(stream: TabStream, recipient: string) {
        stream.send(this.body, recipient);
    }
}

```

`zil-pay/lib/streem/tab-stream.ts`:

```ts
import type { ReqBody } from './message';
import { Runtime } from "lib/runtime";
import { MTypeTabContent } from './keys';

export class TabStream {
    constructor(public readonly eventName: string) {}

    listen(cb: (payload: ReqBody) => void) {
        globalThis.document?.addEventListener(this.eventName, (event: Event) => {
            const detail = (event as CustomEvent).detail;
            if (detail) {
                try {
                    cb(JSON.parse(detail));
                } catch (e) {
                    console.error("Error parsing event detail", e, event);
                }
            }
        });
    }

    send(data: ReqBody, to: string) {
        data.from = this.eventName;
        if (Object.values(MTypeTabContent).includes(to)) {
            this.#dispatch(JSON.stringify(data), to);
        }
    }

    #dispatch(data: string, to: string) {
        globalThis.document?.dispatchEvent(this.#getEvent(data, to));
    }

    #getEvent(detail: string, to: string) {
        return new CustomEvent(to, { detail });
    }

    /**
     * Sends a signal message to the specified tab.
     * @param tabId - The ID of the tab.
     * @param message - The message to send.
     */
    async sendSignalToTab(tabId: number, message: ReqBody): Promise<void> {
        try {
            await Runtime.tabs.sendMessage(tabId, message);
        } catch (error) {
            console.error(`Failed to send signal to tab ${tabId}:`, error);
            throw error; // Re-throw the error to be handled by the caller
        }
    }

    /**
      * Sends message to all tabs except the excluded tabIds
      * @param message
      * @param excludedTabIds
      */
    async sendToAllTabs(message: ReqBody, excludedTabIds: number[] = []): Promise<void> {
        try {
            const tabs = await Runtime.tabs.query({});
            for (const tab of tabs) {
                if (tab?.id && !excludedTabIds.includes(tab.id)) {
                    await Runtime.tabs.sendMessage(tab.id, message);
                }
            }
        } catch (error) {
            console.error("Failed to send message to all tabs:", error);
            throw error; // Re-throw the error
        }
    }
}

```

`zil-pay/lib/streem/tabs-message.ts`:

```ts
import type { ReqBody } from './message';
import { Runtime } from "lib/runtime";


export class TabsMessage<T = any> {
    constructor(public readonly body: ReqBody<T>) {}

    static async getTabs(): Promise<chrome.tabs.Tab[]> {
        return Runtime.tabs.query({});
    }

    async signal(domain: string): Promise<string> {
        return new Promise<string>((resolve, reject) => {
            Runtime.tabs.query({ active: true, currentWindow: true }, (tabs: chrome.tabs.Tab[]) => {
                const tab = tabs[0];
                if (!tab) {
                    reject(new Error("no active tabs"));
                    return;
                }

                const { hostname } = new URL(tab.url!);

                if (hostname !== domain) {
                    reject(new Error("invalid domain"));
                    return;
                }
                Runtime.tabs.sendMessage(Number(tab.id), this.body)
                    .then(() => resolve(""))
                    .catch(reject);
            });
        });
    }



    async send(...domains: string[]): Promise<void> {
        const tabs = await TabsMessage.getTabs();

        tabs.forEach(async (tab) => {
            if (tab?.url && domains.includes(new URL(tab.url).hostname)) {
                try {
                    await Runtime.tabs.sendMessage(Number(tab.id), this.body);
                } catch (err) {
                    console.error(`Failed to send message to tab ${tab.id}`, err);
                }
            }
        });
    }

    async sendAll(): Promise<void> {
        const tabs = (await TabsMessage.getTabs())
            .filter((tab) => tab?.url && !tab.url.startsWith("chrome://"));

        try {
            for (const tab of tabs) {
                await Runtime.tabs.sendMessage(Number(tab.id), this.body);
            }
        } catch (err) {
            console.error("TabsMessage", err);
        }
    }
}

```

`zil-pay/lib/types/checker.ts`:

```ts
type Arg = unknown;

export const TypeOf = Object.freeze({
    /**
     * Checks if the given argument is an array.
     * @param arg The argument to check.
     * @returns True if the argument is an array, false otherwise.
     */
    isArray(arg: Arg): boolean {
        return Array.isArray(arg);
    },

    /**
     * Checks if the given argument is a plain object.
     * @param arg The argument to check.
     * @returns True if the argument is a plain object, false otherwise.
     */
    isObject(arg: Arg): boolean {
        return typeof arg === 'object' && arg !== null && !Array.isArray(arg) && !(arg instanceof Date) && !(arg instanceof Error) && Object.getPrototypeOf(arg) === Object.prototype;
    },

    /**
     * Checks if the given argument is a number.
     * @param arg The argument to check.
     * @returns True if the argument is a number, false otherwise.
     */
    isNumber(arg: Arg): boolean {
        return typeof arg === 'number' && !isNaN(arg as number);
    },

    /**
     * Checks if the given argument is an integer.
     * @param arg The argument to check.
     * @returns True if the argument is an integer, false otherwise.
     */
    isInt(arg: Arg): boolean {
        return Number.isInteger(arg as number);
    },

    /**
     * Checks if the given argument is an error object.
     * @param arg The argument to check.
     * @returns True if the argument is an error object, false otherwise.
     */
    isError(arg: Arg): boolean {
        return arg instanceof Error;
    },

    /**
     * Checks if the given argument is a string.
     * @param arg The argument to check.
     * @returns True if the argument is a string, false otherwise.
     */
    isString(arg: Arg): boolean {
        return typeof arg === 'string' || arg instanceof String;
    },

    /**
     * Checks if the given argument is a boolean.
     * @param arg The argument to check.
     * @returns True if the argument is a boolean, false otherwise.
     */
    isBoolean(arg: Arg): boolean {
        return typeof arg === 'boolean' || arg instanceof Boolean;
    },

    /**
     * Checks if the given argument is null.
     * @param arg The argument to check.
     * @returns True if the argument is null, false otherwise.
     */
    isNull(arg: Arg): boolean {
        return arg === null;
    },

    /**
     * Checks if the given argument is undefined.
     * @param arg The argument to check.
     * @returns True if the argument is undefined, false otherwise.
     */
    isUndefined(arg: Arg): boolean {
        return arg === undefined;
    },

    /**
     * Checks if the given argument is an empty object.
     * @param arg The argument to check.
     * @returns True if the argument is an empty object, false otherwise.
     */
    isEmptyObject(arg: Arg): boolean {
        return this.isObject(arg) && Object.keys(arg as object).length === 0;
    },

    /**
     * Checks if the given argument is an empty array.
     * @param arg The argument to check.
     * @returns True if the argument is an empty array, false otherwise.
     */
    isEmptyArray(arg: Arg): boolean {
        return this.isArray(arg) && (arg as Array<unknown>).length === 0;
    },
});


```

`zil-pay/lib/zilliqa/bech32.ts`:

```ts
import { assert } from 'lib/runtime/assert';
import { CHARSET, HRP, GENERATOR } from 'lib/zilliqa/config';
import { toChecksumHexAddress } from 'lib/zilliqa/checksum';
import { utils } from 'aes-js';


/**
 * Calculates the polynomial modulo for Bech32 checksum calculation.
 *
 * @param values The Uint8Array of input values.
 * @returns The polynomial modulo result.
 */
const polymod = (values: Uint8Array): number => {
    let chk: number = 1;
    for (let p: number = 0; p < values.length; ++p) {
        const top: number = chk >> 25;
        chk = ((chk & 0x1ffffff) << 5) ^ values[p];
        for (let i: number = 0; i < 5; ++i) {
            if ((top >> i) & 1) {
                chk ^= GENERATOR[i];
            }
        }
    }
    return chk;
};

/**
 * Expands the Human-Readable Part (HRP) into a Uint8Array for checksum calculation.
 *
 * @param hrp The Human-Readable Part string.
 * @returns The Uint8Array representation of the expanded HRP.
 */
const hrpExpand = (hrp: string): Uint8Array => {
    const ret: number[] = [];
    for (let i: number = 0; i < hrp.length; ++i) {
        ret.push(hrp.charCodeAt(i) >> 5);
    }
    ret.push(0);
    for (let i: number = 0; i < hrp.length; ++i) {
        ret.push(hrp.charCodeAt(i) & 31);
    }
    return new Uint8Array(ret);
};

/**
 * Converts an array of numbers of `fromWidth` bits to an array of numbers of `toWidth` bits.
 *
 * @param data The input array of numbers.
 * @param fromWidth The number of bits per input number.
 * @param toWidth The number of bits per output number.
 * @param pad Whether to pad the output if the input is not a multiple of `fromWidth`.
 * @returns A new Uint8Array containing the converted bits, or null if input is invalid.
 */
export function convertBits(data: Uint8Array, fromWidth: number, toWidth: number, pad: boolean = true): Uint8Array | null {
    let acc: number = 0;
    let bits: number = 0;
    const ret: number[] = [];
    const maxv: number = (1 << toWidth) - 1;

    for (const value of data) {
        if (value < 0 || (value >> fromWidth) !== 0) {
            return null;
        }
        acc = (acc << fromWidth) | value;
        bits += fromWidth;
        while (bits >= toWidth) {
            bits -= toWidth;
            ret.push((acc >> bits) & maxv);
        }
    }

    if (pad) {
        if (bits > 0) {
            ret.push((acc << (toWidth - bits)) & maxv);
        }
    } else if (bits >= fromWidth || (acc << (toWidth - bits)) & maxv) {
        return null;
    }

    return new Uint8Array(ret);
}

/**
 * Verifies the checksum of a Bech32 encoded string.
 *
 * @param hrp The Human-Readable Part of the Bech32 string.
 * @param data The Uint8Array of the data part of the Bech32 string.
 * @returns True if the checksum is valid, false otherwise.
 */
function verifyChecksum(hrp: string, data: Uint8Array): boolean {
    return polymod(new Uint8Array([...hrpExpand(hrp), ...data])) === 1;
}

/**
 * Creates the checksum for a given HRP and data.
 *
 * @param hrp The Human-Readable Part string.
 * @param data The Uint8Array of the data to be checksummed.
 * @returns A Uint8Array representing the checksum.
 */
function createChecksum(hrp: string, data: Uint8Array): Uint8Array {
    const values: Uint8Array = new Uint8Array([...hrpExpand(hrp), ...data, 0, 0, 0, 0, 0, 0]);
    const mod: number = polymod(values) ^ 1;
    const ret: number[] = [];
    for (let p: number = 0; p < 6; ++p) {
        ret.push((mod >> (5 * (5 - p))) & 31);
    }
    return new Uint8Array(ret);
}

/**
 * Encodes data with a Human-Readable Part (HRP) into a Bech32 string.
 *
 * @param hrp The Human-Readable Part string.
 * @param data The Uint8Array of data to encode.
 * @returns The Bech32 encoded string.
 */
export const encode = (hrp: string, data: Uint8Array): string => {
    const checksum: Uint8Array = createChecksum(hrp, data);
    const combined: Uint8Array = new Uint8Array([...data, ...checksum]);
    let ret: string = hrp + '1';
    for (const value of combined) {
        ret += CHARSET.charAt(value);
    }
    return ret;
};

/**
 * Decodes a Bech32 encoded string into its Human-Readable Part (HRP) and data.
 *
 * @param bechString The Bech32 encoded string to decode.
 * @returns An object containing the HRP and the Uint8Array of data, or null if decoding fails.
 */
export const decode = (bechString: string): { hrp: string; data: Uint8Array } | null => {
    let hasLower: boolean = false;
    let hasUpper: boolean = false;
    for (let i: number = 0; i < bechString.length; ++i) {
        const charCode: number = bechString.charCodeAt(i);
        if (charCode < 33 || charCode > 126) {
            return null;
        }
        if (charCode >= 97 && charCode <= 122) {
            hasLower = true;
        }
        if (charCode >= 65 && charCode <= 90) {
            hasUpper = true;
        }
    }

    if (hasLower && hasUpper) {
        return null;
    }

    const lowerBechString: string = bechString.toLowerCase();
    const pos: number = lowerBechString.lastIndexOf('1');

    if (pos < 1 || pos + 7 > lowerBechString.length || lowerBechString.length > 90) {
        return null;
    }

    const hrp: string = lowerBechString.substring(0, pos);
    const data: number[] = [];
    for (let i: number = pos + 1; i < lowerBechString.length; ++i) {
        const d: number = CHARSET.indexOf(lowerBechString.charAt(i));
        if (d === -1) {
            return null;
        }
        data.push(d);
    }

    const dataBytes: Uint8Array = new Uint8Array(data);
    if (!verifyChecksum(hrp, dataBytes)) {
        return null;
    }

    return { hrp, data: dataBytes.slice(0, dataBytes.length - 6) };
};

/**
 * Checks if a string starts with the '0x' prefix (case-insensitive).
 *
 * @param str The string to check.
 * @returns True if the string starts with '0x', false otherwise.
 */
function hasHexPrefix(str: string): boolean {
    return str.toLowerCase().startsWith('0x');
}

/**
 * Validates if a string is a valid hexadecimal Zilliqa address.
 *
 * @param address The string to validate.
 * @returns True if the string is a valid hexadecimal address, false otherwise.
 */
function isValidHexAddress(address: string): boolean {
    return !address || typeof address !== 'string' || (!hasHexPrefix(address) ? address.length !== 40 : address.length !== 42) || !/^[0-9a-fA-F]+$/.test(hasHexPrefix(address) ? address.slice(2) : address);
}

/**
 * Converts a hexadecimal address to a Bech32 encoded Zilliqa address.
 *
 * @param address The hexadecimal address string (with or without '0x' prefix).
 * @returns The Bech32 encoded Zilliqa address.
 * @throws {Error} If the provided address is invalid or conversion fails.
 */
export const toBech32Address = async (address: string): Promise<string> => {
    assert(!isValidHexAddress(address), 'Invalid address provided.');

    const hexString: string = hasHexPrefix(address) ? address.slice(2) : address;
    const addressBytes: Uint8Array | null = utils.hex.toBytes(hexString);
    assert(addressBytes !== null, 'Cannot convert hex string to bytes.');

    const addrBz: Uint8Array | null = convertBits(addressBytes, 8, 5);
    assert(addrBz !== null, 'Cannot convert bytes to Bech32 bits.');

    return encode(HRP, addrBz!);
};

/**
 * Converts a Bech32 encoded Zilliqa address to a checksummed hexadecimal address.
 *
 * @param address The Bech32 encoded Zilliqa address.
 * @returns The checksummed hexadecimal address string with the '0x' prefix.
 * @throws {Error} If the provided Bech32 address is invalid or conversion fails.
 */
export const fromBech32Address = async (address: string): Promise<string> => {
    const res = decode(address);
    assert(res !== null, 'Invalid Bech32 address.');

    // Explicitly assert the type of 'res' after the null check
    const { hrp, data } = res as { hrp: string; data: Uint8Array };
    assert(hrp === HRP, `Expected HRP '${HRP}', but got '${hrp}'.`);

    const buf: Uint8Array | null = convertBits(data, 5, 8, false);
    assert(buf !== null, 'Cannot convert Bech32 bits to bytes.');

    const hexAddress: string = Array.from(buf!)
        .map((b: number) => b.toString(16).padStart(2, '0'))
        .join('');

    return toChecksumHexAddress(`0x${hexAddress}`);
};

```

`zil-pay/lib/zilliqa/checksum.ts`:

```ts
import { sha256 } from 'crypto/sha256';
import { utils } from 'aes-js';

/**
 * Checks if a string starts with the '0x' prefix (case-insensitive).
 *
 * @param str The string to check.
 * @returns True if the string starts with '0x', false otherwise.
 */
export function hasHexPrefix(str: string): boolean {
  return str.toLowerCase().startsWith('0x');
}

/**
 * Calculates the checksummed hexadecimal address from a byte array.
 *
 * @param addressBytes The address as a Uint8Array.
 * @returns The checksummed hexadecimal address string with the '0x' prefix.
 */
export async function toChecksumBytesAddress(addressBytes: Uint8Array): Promise<string> {
  const addressHex = utils.hex.fromBytes(addressBytes);
  const hashBytes = await sha256(addressBytes);
  const hashBigInt = BigInt(`0x${utils.hex.fromBytes(hashBytes)}`);
  let checksumAddress = '0x';

  for (let i = 0; i < addressHex.length; i++) {
    const char = addressHex[i];
    if (/[0-9]/.test(char)) {
      checksumAddress += char;
    } else {
      const bitPosition = BigInt(255 - 6 * i);
      const mask = BigInt(2) ** bitPosition;
      const shouldBeUpper = (hashBigInt & mask) >= BigInt(1);

      if (shouldBeUpper) {
        checksumAddress += char.toUpperCase();
      } else {
        checksumAddress += char.toLowerCase();
      }
    }
  }

  return checksumAddress;
}

/**
 * Calculates the checksummed hexadecimal address from a hexadecimal string.
 *
 * @param address The hexadecimal address string, optionally with the '0x' prefix.
 * @returns The checksummed hexadecimal address string with the '0x' prefix.
 */
export async function toChecksumHexAddress(address: string): Promise<string> {
  let lowerCaseAddress = address.toLowerCase();
  if (hasHexPrefix(address)) {
    lowerCaseAddress = lowerCaseAddress.slice(2);
  }

  const addressBytes = new Uint8Array(utils.hex.toBytes(lowerCaseAddress));
  return toChecksumBytesAddress(addressBytes);
}

```

`zil-pay/lib/zilliqa/config.ts`:

```ts
export const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
export const HRP = 'zil';
export const GENERATOR = [
  0x3b6a57b2,
  0x26508e6d,
  0x1ea119fa,
  0x3d4233dd,
  0x2a1462b3
];

```

`zil-pay/lib/zilliqa/pubkey.ts`:

```ts
import { sha256 } from 'crypto/sha256';

export async function fromZilPubKey(pubKey: Uint8Array): Promise<Uint8Array> {
  const hashBytes = await sha256(pubKey);
  const addressBytes = hashBytes.slice(12);

  if (addressBytes.length !== 20) {
    throw new Error('Invalid public key length or unexpected hash output length.');
  }

  return addressBytes;
}

```

`zil-pay/popup/main.ts`:

```ts
import { mount } from "svelte";
import App from "./App.svelte";

export default mount(App, {
  target: document.body,
});

```

`zil-pay/vitest.config.ts`:

```ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    setupFiles: '__tests__/setupTests.ts',
    include: ['__tests__/**/*.test.{ts,tsx}'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html'],
      reportsDirectory: 'stats/coverage',
    },
    reporters: [
      'default',
      ['html', { outputDir: 'stats/report' }]
    ],
  },
});

```