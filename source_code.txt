Project Path: zil-pay

Source Tree:

```txt
zil-pay
├── background
│   ├── background.ts
│   ├── index.ts
│   ├── rpc
│   │   ├── block.ts
│   │   ├── ft_parser.ts
│   │   ├── gas_parse.ts
│   │   ├── history_tx.ts
│   │   ├── index.ts
│   │   ├── nonce_parser.ts
│   │   ├── provider.ts
│   │   ├── rpc.ts
│   │   └── tx_parse.ts
│   ├── secure
│   │   ├── index.ts
│   │   ├── migrator.ts
│   │   └── session.ts
│   ├── services
│   │   ├── index.ts
│   │   ├── provider.ts
│   │   ├── tx.ts
│   │   └── wallet.ts
│   ├── state.ts
│   └── storage
│       ├── account.ts
│       ├── argon.ts
│       ├── background.ts
│       ├── chain.ts
│       ├── confirm.ts
│       ├── explorer.ts
│       ├── ftoken.ts
│       ├── index.ts
│       ├── notification.ts
│       ├── settings.ts
│       └── wallet.ts
├── config
│   ├── api.ts
│   ├── argon2.ts
│   ├── bip39.ts
│   ├── common.ts
│   ├── errors.ts
│   ├── fields.ts
│   ├── jsonrpc.ts
│   ├── locale.ts
│   ├── manifest.ts
│   ├── pbkdf2.ts
│   ├── sha.ts
│   ├── slip44.ts
│   ├── stream.ts
│   ├── theme.ts
│   └── wallet.ts
├── content
│   └── index.ts
├── crypto
│   ├── address.ts
│   ├── aes256.ts
│   ├── argon2.ts
│   ├── b64.ts
│   ├── bip32.ts
│   ├── bip39.ts
│   ├── bip49.ts
│   ├── index.ts
│   ├── keychain.ts
│   ├── keypair.ts
│   ├── kuznechik.ts
│   ├── ntrup.ts
│   ├── number.ts
│   ├── pbkdf2.ts
│   ├── proto
│   │   └── zq1.ts
│   ├── random.ts
│   ├── sha256.ts
│   ├── sha512.ts
│   ├── tx.ts
│   ├── uuid.ts
│   ├── zilliqa
│   │   ├── pubkey.ts
│   │   └── schnorr.ts
│   └── zilliqa_tx.ts
├── lib
│   ├── array
│   │   ├── chunk.ts
│   │   └── shuffle.ts
│   ├── popup
│   │   ├── clipboard.ts
│   │   ├── url.ts
│   │   └── warp-message.ts
│   ├── runtime
│   │   ├── assert.ts
│   │   ├── ext-id.ts
│   │   ├── extensionizer.ts
│   │   ├── fingerprint.ts
│   │   ├── get-url.ts
│   │   ├── index.ts
│   │   └── manifest.ts
│   ├── storage
│   │   ├── builder.ts
│   │   ├── index.ts
│   │   └── storage.ts
│   ├── streem
│   │   ├── index.ts
│   │   ├── keys.ts
│   │   ├── message.ts
│   │   ├── secure-message.ts
│   │   ├── tab-stream.ts
│   │   └── tabs-message.ts
│   ├── types
│   │   ├── checker.ts
│   │   └── index.ts
│   ├── utils
│   │   ├── hex.ts
│   │   ├── locale.ts
│   │   └── utf8.ts
│   └── zilliqa
│       ├── bech32.ts
│       ├── checksum.ts
│       ├── config.ts
│       ├── index.ts
│       └── pubkey.ts
├── popup
│   ├── App.svelte
│   ├── Router.svelte
│   ├── background
│   │   └── wallet.ts
│   ├── components
│   │   ├── Button.svelte
│   │   ├── CopyButton.svelte
│   │   ├── Dropdown.svelte
│   │   ├── HexKey.svelte
│   │   ├── LanguageSelectorButton.svelte
│   │   ├── LittleButton.svelte
│   │   ├── MnemonicWord.svelte
│   │   ├── MnemonicWordInput.svelte
│   │   ├── Modal.svelte
│   │   ├── NavBar.svelte
│   │   ├── PrintButton.svelte
│   │   ├── RadioOption.svelte
│   │   ├── ReloadButton.svelte
│   │   ├── SmartInput.svelte
│   │   ├── SvgLoad.svelte
│   │   ├── Switch.svelte
│   │   ├── WalletOption.svelte
│   │   ├── WordCountSelector.svelte
│   │   └── icons
│   │       ├── Appearance.svelte
│   │       ├── BincodeIcon.svelte
│   │       ├── Bip39Icon.svelte
│   │       ├── Close.svelte
│   │       ├── GridIcon.svelte
│   │       ├── Language.svelte
│   │       ├── LockIcon.svelte
│   │       ├── PuzzleIcon.svelte
│   │       ├── QRCodeIcon.svelte
│   │       └── ReloadIcon.svelte
│   ├── i18n.ts
│   ├── index.ts
│   ├── main.ts
│   ├── mixins
│   │   ├── chains.ts
│   │   └── theme.ts
│   ├── modals
│   │   └── CipherOptions.svelte
│   ├── pages
│   │   ├── Bip39Generate.svelte
│   │   ├── Bip39Restore.svelte
│   │   ├── Bip39Verify.svelte
│   │   ├── ConfirmPopup.svelte
│   │   ├── Connect.svelte
│   │   ├── GenerateWallet.svelte
│   │   ├── Home.svelte
│   │   ├── KeyPairGen.svelte
│   │   ├── KeyPairRestore.svelte
│   │   ├── Locale.svelte
│   │   ├── Lock.svelte
│   │   ├── NetworkSetup.svelte
│   │   ├── NewWalletOptions.svelte
│   │   ├── NotFoundPage.svelte
│   │   ├── PasswordSetup.svelte
│   │   ├── RestoreWallet.svelte
│   │   ├── SignMessagePopup.svelte
│   │   └── Start.svelte
│   ├── router
│   │   ├── guard.ts
│   │   ├── index.ts
│   │   └── navigation.ts
│   ├── store
│   │   ├── cache.ts
│   │   ├── global.ts
│   │   └── route.ts
│   └── styles
│       ├── global.scss
│       ├── mixins.scss
│       └── theme.scss
├── types
│   ├── micro-eth-signer.d.ts
│   ├── tx.d.ts
│   └── wallet.d.ts
└── vitest.config.ts

```

`zil-pay/background/background.ts`:

```ts
import { MTypePopup } from "config/stream";
import type { GlobalState } from "./state";
import { Runtime } from "lib/runtime";

export function startBackground(core: GlobalState) {
  Runtime.runtime.onMessage.addListener((msg, sender, sendResponse) => {
    if (sender.id !== Runtime.runtime.id) {
      sendResponse(null);
      return true;
    }

    switch (msg.type) {
      case MTypePopup.GET_GLOBAL_STATE:
        core.wallet.getGlobalState(sendResponse);
        return true;
      case MTypePopup.SET_GLOBAL_STATE:
        core.wallet.setGlobalState(msg.payload, sendResponse);
        return true;
      case MTypePopup.GEN_BIP39:
        core.wallet.genBip39Words(msg.payload.count, msg.payload.wordList, sendResponse);
        return true;
      case MTypePopup.VALIDATE_BIP39_CHECK_SUM:
        core.wallet.validateBip39CheckSum(msg.payload.phrase, msg.payload.wordList, sendResponse);
        return true;
      case MTypePopup.GEN_KEYPAIR:
        core.wallet.genKeyPair(msg.payload.slip44, sendResponse);
        return true;
      case MTypePopup.FROM_PRIV_KEY:
        core.wallet.keyPairFromPrivateKey(msg.payload.slip44, msg.payload.key, sendResponse);
        return true;
      default:
        sendResponse(null);
        return true;
    }
  });
}

```

`zil-pay/background/index.ts`:

```ts
import { startBackground } from "background/background";
import { GlobalState } from "background/state";

(async function () {
  const state = await GlobalState.fromStorage();

  startBackground(state);
})();

```

`zil-pay/background/rpc/block.ts`:

```ts
export interface EVMBlock {
  /** The hash of the block. null when it's a pending block. */
  hash: string;
  /** The hash of the parent block. */
  parentHash: string;
  /** The SHA3 of the uncles data in the block. */
  sha3Uncles: string;
  /** The address of the beneficiary to whom the mining rewards were given. */
  miner: string;
  /** The root of the state trie of the block. */
  stateRoot: string;
  /** The root of the transaction trie of the block. */
  transactionsRoot: string;
  /** The root of the receipts trie of the block. */
  receiptsRoot: string;
  /** The bloom filter for the logs of the block. null when it's a pending block. */
  logsBloom: string;
  /** The total difficulty of the chain until this block. */
  totalDifficulty: string;
  /** The block number. null when it's a pending block. */
  number: string;
  /** The maximum gas allowed in this block. */
  gasLimit: string;
  /** The total used gas by all transactions in this block. */
  gasUsed: string;
  /** The unix timestamp for when the block was collated. */
  timestamp: string;
  /** The "extra data" field of this block. */
  extraData: string;
  /** The hash of the generated proof-of-work. null when it's a pending block. */
  mixHash: string;
  /** The nonce of the generated proof-of-work. null when it's a pending block. */
  nonce: string;
  /** The size of this block in bytes. */
  size: string;
  /** The difficulty for this block. */
  difficulty: string;
  /** Array of transaction objects, or 32-byte transaction hashes. */
  transactions: string[];
  /** Array of uncle hashes. */
  uncles: string[];
  /** The root of the withdrawals trie of the block. */
  withdrawalsRoot?: string;
  /** An array of withdrawal objects. */
  withdrawals?: any[];
  /** The base fee per gas. */
  baseFeePerGas?: string;
  /** The gas used for blobs. */
  blobGasUsed?: string;
  /** The excess blob gas. */
  excessBlobGas?: string;
  /** The parent beacon block root. */
  parentBeaconBlockRoot?: string;
}

```

`zil-pay/background/rpc/ft_parser.ts`:

```ts
import { RpcProvider, type JsonRPCRequest, type JsonRPCResponse } from './provider';
import { EvmMethods, ZilMethods } from 'config/jsonrpc';
import { createContract } from 'micro-eth-signer/abi.js';
import { hexToBigInt, hexToUint8Array, uint8ArrayToHex } from 'lib/utils/hex';
import { Address, AddressType } from 'crypto/address';
import { TypeOf } from 'lib/types';

const ERC20_ABI = [
  { name: 'name', type: 'function', outputs: [{ type: 'string' }] },
  { name: 'symbol', type: 'function', outputs: [{ type: 'string' }] },
  { name: 'decimals', type: 'function', outputs: [{ type: 'uint8' }] },
  {
    name: 'balanceOf',
    type: 'function',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    name: 'transfer',
    type: 'function',
    inputs: [
      { name: 'recipient', type: 'address' },
      { name: 'amount', type: 'uint256' },
    ],
    outputs: [{ type: 'bool' }],
  },
] as const;

export enum MetadataField {
  Name = 'name',
  Symbol = 'symbol',
  Decimals = 'decimals',
}

type FunctionName = 'name' | 'symbol' | 'decimals' | 'balanceOf' | 'transfer';
type FunctionArgs = {
  name: [];
  symbol: [];
  decimals: [];
  balanceOf: [string];
  transfer: [string, bigint];
};

export type RequestType =
  | { type: 'Metadata'; field: MetadataField; address?: Address }
  | { type: 'Balance'; address: Address };

export interface GetTokenInitItem {
  vname: string;
  type: string;
  value: string;
}

export interface ZilBalanceResponse {
  balance: string;
  nonce: number;
}

export interface ZilSmartContractSubStateResponse {
  balances: {
    [key: string]: string;
  };
}

function validateResponse<T>(response: JsonRPCResponse<T>): T {
  if (response.error) {
    throw new Error(
      `RPC Error (code: ${response.error.code}): ${response.error.message}`,
    );
  }
  if (TypeOf.isUndefined(response.result)) {
    throw new Error('RPC Error: Response missing result field');
  }

  return response.result as T;
}

export class ERC20Helper {
  readonly #contract;

  constructor() {
    this.#contract = createContract(ERC20_ABI);
  }

  encodeFunctionCall<T extends FunctionName>(
    functionName: T,
    args: FunctionArgs[T],
  ): string {
    let encodedData: Uint8Array;

    switch (functionName) {
      case 'name':
        encodedData = this.#contract.name.encodeInput();
        break;
      case 'symbol':
        encodedData = this.#contract.symbol.encodeInput();
        break;
      case 'decimals':
        encodedData = this.#contract.decimals.encodeInput();
        break;
      case 'balanceOf':
        encodedData = this.#contract.balanceOf.encodeInput(String(args[0]));
        break;
      case 'transfer':
        encodedData = this.#contract.transfer.encodeInput({
          recipient: String(args[0]),
          amount: BigInt(args[1] ?? 0), 
        });
        break;
      default:
        throw new Error(`Unsupported function: ${functionName}`);
    }

    return uint8ArrayToHex(encodedData, true);
  }

  decodeFunctionOutput(functionName: FunctionName, data: string) {
    const bytes = hexToUint8Array(data);

    switch (functionName) {
      case 'name':
        return this.#contract.name.decodeOutput(bytes);
      case 'symbol':
        return this.#contract.symbol.decodeOutput(bytes);
      case 'decimals':
        return this.#contract.decimals.decodeOutput(bytes);
      case 'balanceOf':
        return this.#contract.balanceOf.decodeOutput(bytes);
      case 'transfer':
        return this.#contract.transfer.decodeOutput(bytes);
      default:
        throw new Error(`Unsupported function: ${functionName}`);
    }
  }

  public generateTransferInput(to: string, amount: bigint): string {
    return this.encodeFunctionCall('transfer', [to, amount]);
  }
}

export function generateErc20TransferData(to: string, amount: bigint): string {
  const erc20 = new ERC20Helper();
  return erc20.generateTransferInput(to, amount);
}

export async function buildTokenRequests(
  contract: Address,
  accounts: Address[],
  native: boolean,
): Promise<{ payload: JsonRPCRequest; requestType: RequestType }[]> {
  const requests: { payload: JsonRPCRequest; requestType: RequestType }[] = [];
  if (contract.type === AddressType.Bech32) {
    await buildZilRequests(contract, accounts, native, requests);
  } else {
    await buildEthRequests(contract, accounts, native, requests);
  }

  return requests;
}

async function buildZilRequests(
  contract: Address,
  accounts: Address[],
  native: boolean,
  requests: { payload: JsonRPCRequest; requestType: RequestType }[],
): Promise<void> {
  const base16Contract = contract.toBase16();
  requests.push({
    payload: RpcProvider.buildPayload(ZilMethods.GetSmartContractInit, [
      base16Contract,
    ]),
    requestType: { type: 'Metadata', field: MetadataField.Name },
  });
  for (const account of accounts) {
    const base16Account = (await account.toZilChecksum()).toLowerCase();
    let payload;
    if (native) {
      payload = RpcProvider.buildPayload(ZilMethods.GetBalance, [
        base16Account,
      ]);
    } else {
      payload = RpcProvider.buildPayload(ZilMethods.GetSmartContractSubState, [
        base16Contract,
        'balances',
        [base16Account],
      ]);
    }
    requests.push({
      payload,
      requestType: { type: 'Balance', address: account },
    });
  }
}

async function buildEthRequests(
  contract: Address,
  accounts: Address[],
  native: boolean,
  requests: { payload: JsonRPCRequest; requestType: RequestType }[],
): Promise<void> {
  const erc20 = new ERC20Helper();
  const tokenAddr = await contract.toEthChecksum();

  const buildEthCall = (data: string): JsonRPCRequest => {
    return RpcProvider.buildPayload(EvmMethods.Call, [
      {
        to: tokenAddr,
        data,
      },
      'latest',
    ]);
  };

  const metadataFields: FunctionName[] = [
    'name',
    'symbol',
    'decimals',
  ];

  for (const field of metadataFields) {
    const data = erc20.encodeFunctionCall(field, []);
    requests.push({
      payload: buildEthCall(data),
      requestType: { type: 'Metadata', field: field as MetadataField },
    });
  }

  for (const account of accounts) {
    let payload;
    const ethAddress = await account.toEthChecksum();
    if (native) {
      payload = RpcProvider.buildPayload(EvmMethods.GetBalance, [
        ethAddress,
        'latest',
      ]);
    } else {
      const callData = erc20.encodeFunctionCall('balanceOf', [
        ethAddress,
      ]);
      payload = buildEthCall(callData);
    }
    requests.push({
      payload,
      requestType: { type: 'Balance', address: account },
    });
  }
}

export function processEthMetadataResponse(
  response: JsonRPCResponse<string>,
  field: MetadataField,
): string {
  const resultHex = validateResponse(response);
  const erc20 = new ERC20Helper();

  const decoded = erc20.decodeFunctionOutput(
    field as FunctionName,
    resultHex,
  );
  return String(decoded);
}

export function processZilMetadataResponse(
  response: JsonRPCResponse<GetTokenInitItem[]>,
): { name: string; symbol: string; decimals: number } {
  const initData = validateResponse(response);

  const getField = (fieldName: string): string => {
    const item = initData.find((item) => item.vname === fieldName);
    if (!item) {
      throw new Error(`Invalid contract init: missing ${fieldName}`);
    }
    return item.value;
  };

  const name = getField('name');
  const symbol = getField('symbol');
  const decimals = parseInt(getField('decimals'), 10);
  if (isNaN(decimals)) {
    throw new Error('Invalid decimals format in contract init');
  }

  return { name, symbol, decimals };
}

export function processEthBalanceResponse(response: JsonRPCResponse<string>): bigint {
  const resultHex = validateResponse(response);
  return hexToBigInt(resultHex);
}

export async function processZilBalanceResponse(
  response: JsonRPCResponse<ZilBalanceResponse | ZilSmartContractSubStateResponse>,
  account: Address,
  isNative: boolean,
): Promise<bigint> {
  try {
    const result = validateResponse(response);
    if (isNative) {
      return BigInt((result as ZilBalanceResponse).balance || '0');
    } else {
      const addr = (await account.toZilChecksum()).toLowerCase();
      const balances = (result as ZilSmartContractSubStateResponse).balances;
      return BigInt(balances?.[addr] || '0');
    }
  } catch (error) {
    return 0n;
  }
}


```

`zil-pay/background/rpc/gas_parse.ts`:

```ts
import { TransactionRequest } from 'crypto/tx';
import { EvmMethods, ZilMethods } from 'config/jsonrpc';
import { Address } from 'crypto/address';
import { buildNonceRequest } from 'background/rpc/nonce_parser';
import { RpcProvider, type JsonRPCRequest } from 'background/rpc/provider';
import { TypeOf } from 'lib/types';

export interface GasFeeHistory {
  maxFee: bigint;
  priorityFee: bigint;
  baseFee: bigint;
}

export interface RequiredTxParams {
  gasPrice: bigint;
  maxPriorityFee: bigint;
  feeHistory: GasFeeHistory;
  txEstimateGas: bigint;
  blobBaseFee: bigint;
  nonce: number;
}

export interface FeeHistoryResult {
  baseFeePerGas: string[];
  reward: string[][];
  oldestBlock: string;
  gasUsedRatio: number[];
}

export const EIP1559 = 1559;
export const EIP4844 = 4844;

class NetworkError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'NetworkError';
    }
}

class TransactionError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'TransactionError';
    }
}

export function buildFeeHistoryRequest(blockCount: number, percentiles: number[]): JsonRPCRequest {
    return RpcProvider.buildPayload(EvmMethods.FeeHistory, [`0x${blockCount.toString(16)}`, 'latest', percentiles]);
}

export function buildEvmEstimateGasRequest(tx: TransactionRequest): JsonRPCRequest {
    if (tx.scilla || !tx.evm) {
        throw new NetworkError("Zilliqa network doesn't support gas estimation or EVM transaction is missing");
    }
    
    try {
        return RpcProvider.buildPayload(EvmMethods.EstimateGas, [tx.evm]);
    } catch (e: any) {
        throw new TransactionError(`Failed to serialize transaction: ${e.message}`);
    }
}

export async function buildBatchGasRequest(
  tx: TransactionRequest,
  blockCount: number,
  percentiles: number[],
  features: number[],
  sender: Address,
): Promise<JsonRPCRequest[]> {
    const requests: JsonRPCRequest[] = [];

    if (tx.scilla) {
        const zilAddress = await sender.toZilBech32();
        requests.push(await buildNonceRequest(sender.type, zilAddress));
        requests.push(RpcProvider.buildPayload(ZilMethods.GetMinimumGasPrice, []));
        return requests;
    } else if (tx.evm) {
        const ethAddress = await sender.toEthChecksum();
        requests.push(await buildNonceRequest(sender.type, ethAddress));
        requests.push(RpcProvider.buildPayload(EvmMethods.GasPrice, []));

        const requestEstimateGas = RpcProvider.buildPayload(EvmMethods.EstimateGas, [tx.toJSON()]);
        requests.push(requestEstimateGas);

        if (features.includes(EIP1559)) {
            requests.push(RpcProvider.buildPayload(EvmMethods.MaxPriorityFeePerGas, []));
            requests.push(buildFeeHistoryRequest(blockCount, percentiles));
        }

        if (features.includes(EIP4844)) {
            requests.push(RpcProvider.buildPayload(EvmMethods.BlobBaseFee, []));
        }

        return requests;
    }
    
    throw new TransactionError('unsupported transaction.');
}

export function processParseFeeHistoryRequest(feeHistoryValue: FeeHistoryResult): GasFeeHistory {
    const lastBaseFeeStr = feeHistoryValue.baseFeePerGas[feeHistoryValue.baseFeePerGas.length - 1];
    if (!lastBaseFeeStr) {
        throw new Error('baseFeePerGas not found or empty in fee history');
    }
    const baseFee = BigInt(lastBaseFeeStr);
    const lastRewardArr = feeHistoryValue.reward[feeHistoryValue.reward.length - 1];

    if (!lastRewardArr || !TypeOf.isArray(lastRewardArr) || !TypeOf.isString(lastRewardArr[1])) {
        throw new Error('reward not found or has invalid format in fee history');
    }

    const priorityFee = BigInt(lastRewardArr[1]);
    const maxFee = baseFee * 2n + priorityFee;

    return {
        maxFee,
        priorityFee,
        baseFee,
    };
}


```

`zil-pay/background/rpc/history_tx.ts`:

```ts
import { TransactionReceipt } from 'crypto/tx';
import { uint8ArrayToBigIntBigEndian } from 'crypto/number';
import { HEX_PREFIX, uint8ArrayToHex } from 'lib/utils/hex';
import { Address, AddressType } from 'crypto/address';
import { uint8ArrayToUtf8 } from 'lib/utils/utf8';
import { ETHEREUM } from 'config/slip44';
import { initSig } from "micro-eth-signer/utils.js";


export enum TransactionStatus {
  Pending,
  Success,
  Failed,
}

export type ChainType = "EVM" | "Scilla";

export interface IHistoricalTransactionState {
  transaction_hash: string;
  amount: bigint;
  sender: string;
  recipient: string;
  contract_address: string | null;
  status: TransactionStatus;
  status_code: number | null;
  timestamp: number;
  block_number: bigint | null;
  gasUsed: bigint | null;
  gasLimit: bigint | null;
  gasPrice: bigint | null;
  blobGasUsed: bigint | null;
  blobGasPrice: bigint | null;
  effectiveGasPrice: bigint | null;
  fee: bigint;
  icon: string | null;
  title: string | null;
  error: string | null;
  sig: string;
  nonce: bigint;
  token_info: TokenInfo | null;
  chain_type: ChainType;
  chain_hash: number;
  data?: string;
  code?: string;
}

export interface TokenInfo {
  value: bigint;
  symbol: string;
  decimals: number;
}

export class HistoricalTransaction implements IHistoricalTransactionState {
  public transaction_hash: string;
  public amount: bigint;
  public sender: string;
  public recipient: string;
  public contract_address: string | null;
  public status: TransactionStatus;
  public status_code: number | null;
  public timestamp: number;
  public block_number: bigint | null;
  public gasUsed: bigint | null;
  public gasLimit: bigint | null;
  public gasPrice: bigint | null;
  public blobGasUsed: bigint | null;
  public blobGasPrice: bigint | null;
  public effectiveGasPrice: bigint | null;
  public fee: bigint;
  public icon: string | null;
  public title: string | null;
  public error: string | null;
  public sig: string;
  public nonce: bigint;
  public token_info: TokenInfo | null;
  public chain_type: ChainType;
  public chain_hash: number;
  public data?: string;
  public code?: string;

  constructor(data: IHistoricalTransactionState) {
    this.transaction_hash = data.transaction_hash;
    this.amount = data.amount;
    this.sender = data.sender;
    this.recipient = data.recipient;
    this.contract_address = data.contract_address;
    this.status = data.status;
    this.status_code = data.status_code;
    this.timestamp = data.timestamp;
    this.block_number = data.block_number;
    this.gasUsed = data.gasUsed;
    this.gasLimit = data.gasLimit;
    this.gasPrice = data.gasPrice;
    this.blobGasUsed = data.blobGasUsed;
    this.blobGasPrice = data.blobGasPrice;
    this.effectiveGasPrice = data.effectiveGasPrice;
    this.fee = data.fee;
    this.icon = data.icon;
    this.title = data.title;
    this.error = data.error;
    this.sig = data.sig;
    this.nonce = data.nonce;
    this.token_info = data.token_info;
    this.chain_type = data.chain_type;
    this.chain_hash = data.chain_hash;
    this.data= data.data;
    this.code = data.code;
  }

  public static async fromReceipt(
    receipt: TransactionReceipt
  ): Promise<HistoricalTransaction> {
    const { metadata } = receipt;

    if (!metadata.hash) {
      throw new Error("Invalid transaction hash");
    }

    if (receipt.scilla) {
      const zil_receipt = receipt.scilla;
      const gas_price = uint8ArrayToBigIntBigEndian(zil_receipt.gasPrice);
      const fee = gas_price * zil_receipt.gasLimit;
      const contract_address = zil_receipt.data.length > 0 ? await new Address(zil_receipt.toAddr, AddressType.Bech32).toZilBech32() : null;
      const data = zil_receipt.data.length > 0 ? uint8ArrayToUtf8(zil_receipt.data) : '';
      const code = zil_receipt.code.length > 0 ? uint8ArrayToUtf8(zil_receipt.code) : '';

      return new HistoricalTransaction({
        data,
        code,
        contract_address,
        sig: uint8ArrayToHex(zil_receipt.signature, true),
        error: null,
        status_code: null,
        gasPrice: gas_price,
        gasLimit: zil_receipt.gasLimit,
        chain_hash: metadata.chainHash,
        chain_type: "Scilla",
        block_number: null,
        transaction_hash: metadata.hash,
        amount: uint8ArrayToBigIntBigEndian(zil_receipt.amount),
        sender: uint8ArrayToHex(zil_receipt.pubKey),
        recipient: await new Address(zil_receipt.toAddr, AddressType.Bech32).toZilBech32(), // TODO: if token transfer need replace with recipient 
        status: TransactionStatus.Pending,
        timestamp: new Date().getTime(),
        fee: fee,
        icon: metadata.icon || null,
        title: metadata.title || null,
        nonce: zil_receipt.nonce,
        token_info: metadata.tokenInfo
          ? {
              value: BigInt(metadata.tokenInfo[0]),
              decimals: metadata.tokenInfo[1],
              symbol: metadata.tokenInfo[2],
            }
          : null,
        gasUsed: null,
        blobGasUsed: null,
        blobGasPrice: null,
        effectiveGasPrice: null,
      });
    }
    else if (receipt.evm) {
      const evm_tx = receipt.evm; 
      const txData = evm_tx.raw as any; // TODO: this is bad
      const data = txData.data;
      const txType = evm_tx.type;
      const sig = initSig({ r: txData.r!, s: txData.s!, }, txData.yParity!);
      let effectiveGasPrice: bigint;
      let gasPrice = null;

      if (
        txType === "legacy" ||
        txType === "eip2930" ||
        txData.gasPrice
      ) {
        effectiveGasPrice = txData.gasPrice ?? 0n;
      } else if (
        (txType === "eip1559" || txType === "eip4844") &&
        txData.maxFeePerGas !== undefined
      ) {
        const max_fee = txData.maxFeePerGas ?? 0n;
        const priority_fee = txData.maxPriorityFeePerGas ?? 0n;
        effectiveGasPrice = max_fee < priority_fee ? max_fee : priority_fee;
      } else {
        effectiveGasPrice = 0n;
      }

      const recipient = txData.to ?? await Address.empty(ETHEREUM).toEthChecksum();
      
      return new HistoricalTransaction({
        gasPrice,
        data,
        error: null,
        sig: HEX_PREFIX + sig.toCompactHex(), // TODO: fix it.
        block_number: null,
        status_code: null,
        contract_address: (txData.to && txData.data && txData.data.length > 2) ? txData.to : null,
        gasLimit: txData.gasLimit ?? null,
        chain_hash: metadata.chainHash,
        chain_type: "EVM",
        transaction_hash: metadata.hash,
        amount: txData.value ?? 0n,
        sender: evm_tx.sender,
        recipient,
        fee: receipt.evm.fee,
        status: TransactionStatus.Pending,
        timestamp: new Date().getTime(),
        icon: metadata.icon || null,
        title: metadata.title || null,
        gasUsed: null,
        blobGasUsed: null,
        blobGasPrice: null,
        effectiveGasPrice: effectiveGasPrice,
        nonce: BigInt(txData.nonce ?? 0),
        token_info: metadata.tokenInfo
          ? {
              value: BigInt(metadata.tokenInfo[0]),
              decimals: metadata.tokenInfo[1],
              symbol: metadata.tokenInfo[2],
            }
          : null,
      });
    }

    throw new Error("Unknown transaction receipt type");
  }

  toJSON(): Record<string, unknown> {
    return {
      transaction_hash: this.transaction_hash,
      amount: this.amount.toString(),
      sender: this.sender,
      recipient: this.recipient,
      contract_address: this.contract_address,
      status: this.status,
      status_code: this.status_code,
      timestamp: this.timestamp,
      block_number: this.block_number?.toString() ?? null,
      gasUsed: this.gasUsed?.toString() ?? null,
      gasLimit: this.gasLimit?.toString() ?? null,
      gasPrice: this.gasPrice?.toString() ?? null,
      blobGasUsed: this.blobGasUsed?.toString() ?? null,
      blobGasPrice: this.blobGasPrice?.toString() ?? null,
      effectiveGasPrice: this.effectiveGasPrice?.toString() ?? null,
      fee: this.fee.toString(),
      icon: this.icon,
      title: this.title,
      error: this.error,
      sig: this.sig,
      nonce: this.nonce.toString(),
      token_info: this.token_info ? {
        value: this.token_info.value.toString(),
        symbol: this.token_info.symbol,
        decimals: this.token_info.decimals
      } : null,
      chain_type: this.chain_type,
      chain_hash: this.chain_hash,
      data: this.data,
      code: this.code
    };
  }
}


```

`zil-pay/background/rpc/index.ts`:

```ts
export * from './provider';
export * from './rpc';
export * from './ft_parser';
export * from './gas_parse';
export * from './nonce_parser';

```

`zil-pay/background/rpc/nonce_parser.ts`:

```ts
import { RpcProvider, type JsonRPCRequest } from './provider';
import { EvmMethods, ZilMethods } from '../../config/jsonrpc';
import { AddressType } from '../../crypto/address';
import { addr } from 'micro-eth-signer';
import { fromBech32Address } from '../../lib/zilliqa';
import { TypeOf } from 'lib/types';
import { hexToBigInt, stripHexPrefix } from 'lib/utils/hex';

export interface ZilBalance {
  balance: string;
  nonce: number;
}

export type NonceResponse = string | ZilBalance;

export async function buildNonceRequest(addressType: AddressType, address: string): Promise<JsonRPCRequest> {
  switch (addressType) {
    case AddressType.Bech32:
      const base16 = await fromBech32Address(address);
      return RpcProvider.buildPayload(
        ZilMethods.GetBalance,
        [stripHexPrefix(base16).toLowerCase()]
      );
    case AddressType.EthCheckSum:
      const ethAddress = addr.addChecksum(address);
      return RpcProvider.buildPayload(
        EvmMethods.GetTransactionCount,
        [ethAddress, 'latest']
      );
    default:
      throw new Error('Unsupported address type');
  }
}

export function processNonceResponse(response: NonceResponse): number {
  if (TypeOf.isObject(response)) {
    const res = response as ZilBalance;
    return res.nonce || 0;
  } else if (TypeOf.isString(response)) {
    return Number(hexToBigInt(String(response)));
  }

  return 0;
}


```

`zil-pay/background/rpc/provider.ts`:

```ts
import type { ChainConfig } from "background/storage";

export interface JsonRPCRequest {
  id: number;
  jsonrpc: string;
  method: string;
  params: unknown[];
}

export interface JsonRPCResponse<T> {
  id: number | string;
  jsonrpc: string;
  result?: T;
  error?: {
    code: number;
    message: string;
    data?: unknown;
  };
}

export class RpcError extends Error {
  public code: number;
  public data?: unknown;

  constructor(message: string, code: number, data?: unknown) {
    super(message);
    this.name = 'RpcError';
    this.code = code;
    this.data = data;
  }
}

export class RpcProvider {
  public network: ChainConfig;

  constructor(network: ChainConfig) {
    this.network = network;
  }

  static buildPayload(method: string, params: unknown[]): JsonRPCRequest {
    return {
      id: 1,
      jsonrpc: '2.0',
      method,
      params,
    };
  }

  public async req<T>(payload: JsonRPCRequest | JsonRPCRequest[]): Promise<T> {
    const client = {
      timeout: 5000,
    };

    let lastError: RpcError | null = null;
    const allNodes = this.network.rpc;

    if (allNodes.length === 0) {
      throw new RpcError('No RPC nodes available in the network configuration.', -32000);
    }

    const batchSize = 3;
    const currentBatch = allNodes.slice(0, batchSize);
    const failedNodesInBatch: string[] = [];

    for (const url of currentBatch) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), client.timeout);

        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
          signal: controller.signal,
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          lastError = new RpcError(
            `Request failed with status ${response.status}`,
            response.status,
          );
          failedNodesInBatch.push(url);
          continue;
        }

        const text = await response.text();
        try {
          const json: JsonRPCResponse<T> | JsonRPCResponse<T>[] = JSON.parse(text);

          if (Array.isArray(json)) {
            const errors = json
              .map((res) => res.error)
              .filter((err): err is NonNullable<typeof err> => !!err);
            if (errors.length > 0) {
              const firstError = errors[0];
              lastError = new RpcError(
                firstError.message,
                firstError.code,
                firstError.data,
              );
              failedNodesInBatch.push(url);
              continue;
            }
          } else if (json.error) {
            lastError = new RpcError(
              json.error.message,
              json.error.code,
              json.error.data,
            );
            failedNodesInBatch.push(url);
            continue;
          }

          return json as T;
        } catch (e: unknown) {
          if (e instanceof Error) {
            lastError = new RpcError(`Failed to parse JSON: ${e.message}`, -32700, text);
          } else {
            lastError = new RpcError('Failed to parse JSON: An unknown error occurred', -32700, text);
          }
          failedNodesInBatch.push(url);
          continue;
        }
      } catch (e: unknown) {
        if (e instanceof Error) {
            if (e.name === 'AbortError') {
              lastError = new RpcError(`Request timed out to ${url}`, -32603);
            } else {
              lastError = new RpcError(`Request to ${url} failed: ${e.message}`, -32603);
            }
        } else {
             lastError = new RpcError(`An unknown error occurred during the request to ${url}`, -32603);
        }
        failedNodesInBatch.push(url);
        continue;
      }
    }

    if (this.network.fallbackEnabled && failedNodesInBatch.length === currentBatch.length && currentBatch.length > 0) {
        const remainingNodes = allNodes.slice(currentBatch.length);
        this.network.rpc = [...remainingNodes, ...failedNodesInBatch];
    }
    
    throw lastError || new RpcError('Network is down or all nodes in batch failed', -32000);
  }
}


```

`zil-pay/background/rpc/rpc.ts`:

```ts
import { ChainConfig, FToken } from '../storage';
import { RpcProvider, type JsonRPCResponse, type JsonRPCRequest } from './provider';
import { Address, AddressType } from '../../crypto/address';
import {
  buildTokenRequests,
  processZilMetadataResponse,
  processEthMetadataResponse,
  processZilBalanceResponse,
  processEthBalanceResponse,
  MetadataField,
  type RequestType
} from './ft_parser';
import type { TransactionReceipt, TransactionRequest } from 'crypto/tx';
import { buildBatchGasRequest, EIP1559, EIP4844, processParseFeeHistoryRequest, type GasFeeHistory, type RequiredTxParams } from './gas_parse';
import { processNonceResponse } from './nonce_parser';
import { bigintToHex, hexToBigInt } from 'lib/utils/hex';
import { EvmMethods } from 'config/jsonrpc';
import type { EVMBlock } from './block';
import { type HistoricalTransaction } from './history_tx';
import { buildPayloadTxReceipt, buildSendSignedTxRequest, processTxReceiptResponse, processTxSendResponse } from './tx_parse';

export class NetworkProvider {
  config: ChainConfig;

  constructor(config: ChainConfig) {
    this.config = config;
  }

  async proxyReq<T>(payload: JsonRPCRequest | JsonRPCRequest[]): Promise<JsonRPCResponse<unknown|T>> {
    const provider = new RpcProvider(this.config);
    return provider.req<JsonRPCResponse<unknown|T>>(payload);
  }

  async getCurrentBlockNumber(): Promise<bigint> {
    const provider = new RpcProvider(this.config);
    const payload = RpcProvider.buildPayload(EvmMethods.BlockNumber, []);
    const response = await provider.req<JsonRPCResponse<string>>(payload);

    if (response.error || !response.result) {
      throw new Error(response.error?.message);
    }

    return hexToBigInt(response.result);
  }

  async estimateBlockTime(): Promise<number> {
    const provider = new RpcProvider(this.config);

    const latestBlockPayload = RpcProvider.buildPayload(EvmMethods.GetBlockByNumber, ['latest', false]);
    const latestBlockResponse = await provider.req<JsonRPCResponse<EVMBlock>>(latestBlockPayload);

    if (latestBlockResponse.error || !latestBlockResponse.result) {
      throw new Error(latestBlockResponse.error?.message);
    }

    const latestBlock = latestBlockResponse.result;
    const latestTimestamp = hexToBigInt(latestBlock.timestamp);
    const latestBlockNumber = hexToBigInt(latestBlock.number);

    const previousBlockNumber = bigintToHex(latestBlockNumber - 1n, true);
    const previousBlockPayload = RpcProvider.buildPayload(EvmMethods.GetBlockByNumber, [previousBlockNumber, false]);
    const previousBlockResponse = await provider.req<JsonRPCResponse<EVMBlock>>(previousBlockPayload);

    if (previousBlockResponse.error || !previousBlockResponse.result) {
      throw new Error(previousBlockResponse.error?.message);
    }

    const previousBlock = previousBlockResponse.result;
    const previousTimestamp = hexToBigInt(previousBlock.timestamp);

    return Number(latestTimestamp - previousTimestamp);
  }

  async estimateParamsBatch(
    tx: TransactionRequest,
    sender: Address,
    blockCount: number,
    percentiles: number[] | null,
  ): Promise<RequiredTxParams> {
    const defaultPercentiles = [25.0, 50.0, 75.0];
    const percentilesToUse = percentiles || defaultPercentiles;
    const requests = await buildBatchGasRequest(
      tx,
      blockCount,
      percentilesToUse,
      this.config.features,
      sender
    );
    const provider = new RpcProvider(this.config);
    const responses = await provider.req<JsonRPCResponse<any>[]>(requests);

    if (responses.every(res => res.error)) {
        const allErrors = responses
            .map(res => res.error?.message)
            .filter(Boolean)
            .join(', ');
        throw new Error(`RPC Error: ${allErrors}`);
    }

    let nonce = 0;
    if (responses[0] && !responses[0].error) {
      nonce = processNonceResponse(responses[0].result);
    }
    
    let gasPrice = 0n;

    if (tx.evm) {
      gasPrice = responses[1]?.result ? hexToBigInt(responses[1].result) : 0n;
    } else if (tx.scilla) {
      gasPrice = BigInt(responses[1]?.result ?? 0);
    }

    const txEstimateGas = responses[2]?.result ? hexToBigInt(responses[2].result) : 0n;

    let maxPriorityFee = 0n;
    let feeHistory: GasFeeHistory = { maxFee: 0n, priorityFee: 0n, baseFee: 0n };
    let blobBaseFee = 0n;

    let responseIndex = 3;

    if (this.config.features.includes(EIP1559)) {
        if (responses[responseIndex] && responses[responseIndex].result) {
            maxPriorityFee = hexToBigInt(responses[responseIndex].result);
        }
        responseIndex++;
        if (responses[responseIndex] && responses[responseIndex].result) {
            feeHistory = processParseFeeHistoryRequest(responses[responseIndex].result);
        }
        responseIndex++;
    }

    if (this.config.features.includes(EIP4844)) {
        if (responses[responseIndex] && responses[responseIndex].result) {
             blobBaseFee = hexToBigInt(responses[responseIndex].result);
        }
    }
    
    return {
      nonce,
      gasPrice,
      txEstimateGas,
      maxPriorityFee,
      feeHistory,
      blobBaseFee
    };
  }

  async ftokenMeta(contract: Address, accounts: Address[]): Promise<FToken> {
    const requestsWithTypes = await buildTokenRequests(contract, accounts, false);
    const provider = new RpcProvider(this.config);

    const payloads = requestsWithTypes.map(r => r.payload);
    const responses = await provider.req<JsonRPCResponse<any>[]>(payloads);
    const balances: Record<number, string> = {};

    if (contract.type === AddressType.Bech32) {
      const { name, symbol, decimals } = processZilMetadataResponse(responses[0]);
      
      for (let i = 1; i < responses.length; i++) {
        const reqWithType = requestsWithTypes[i];

        if (reqWithType.requestType.type === 'Balance') {
          const addresss = reqWithType.requestType.address;
          const balance = await processZilBalanceResponse(responses[i], addresss, false);
          const accountIndex = accounts.findIndex(
            acc => acc === reqWithType.requestType.address
          );

          if (accountIndex !== -1) {
            balances[accountIndex] = balance.toString();
          }
        }
      }

      return new FToken({
        name,
        symbol,
        decimals,
        balances,
        addr: await contract.toZilBech32(),
        addrType: contract.type,
        chainHash: this.config.hash(),
        default_: false,
        native: false,
        logo: null,
        rate: 0
      });
    } else if (contract.type === AddressType.EthCheckSum) {
      let responseIterator = 0;
      const name = processEthMetadataResponse(responses[responseIterator++], MetadataField.Name);
      const symbol = processEthMetadataResponse(responses[responseIterator++], MetadataField.Symbol);
      const decimalsStr = processEthMetadataResponse(responses[responseIterator++], MetadataField.Decimals);
      const decimals = parseInt(decimalsStr, 10);

      requestsWithTypes.slice(3).forEach((reqWithType, index) => {
        if (reqWithType.requestType.type === 'Balance') {
          const response = responses[responseIterator + index];
          const balance = processEthBalanceResponse(response);
          if (reqWithType.requestType.type == 'Balance') {
            const accountIndex = accounts.findIndex(
              acc => acc === reqWithType.requestType.address,
            );
            if (accountIndex !== -1) {
              balances[accountIndex] = balance.toString();
            }
          }
        }
      });

      return new FToken({
        name,
        symbol,
        decimals,
        balances,
        addr: await contract.toEthChecksum(),
        addrType: contract.type,
        chainHash: this.config.hash(),
        default_: false,
        native: false,
        logo: null,
        rate: 0
      });
    }

    throw new Error("unsupported contract");
  }

  async updateTransactionsReceipt(txns: HistoricalTransaction[]): Promise<void> {
    if (txns.length === 0) {
      return;
    }

    const requests = txns.map(tx => buildPayloadTxReceipt(tx));
    const provider = new RpcProvider(this.config);
    const responses = await provider.req<JsonRPCResponse<unknown>[]>(requests);

    await Promise.all(responses.map((res, index) => {
      const tx = txns[index];
      return processTxReceiptResponse(res, tx);
    }));
  }

  async broadcastSignedTransactions(txns: TransactionReceipt[]): Promise<TransactionReceipt[]> {
    const allRequests: JsonRPCRequest[] = [];

    for (const tx of txns) {
      if (!(await tx.verify())) {
        throw new Error('Invalid signature');
      }
      allRequests.push(await buildSendSignedTxRequest(tx));
    }
  
    const provider = new RpcProvider(this.config);
    const responses = await provider.req<JsonRPCResponse<unknown>[]>(allRequests);

    responses.forEach((response, index) => {
      const tx = txns[index];
      processTxSendResponse(response, tx);
    });
  
    return txns;
  }

  async updateBalances(tokens: FToken[], accounts: Address[]): Promise<void> {
    const allRequests: { payload: JsonRPCRequest; requestType: RequestType; tokenIndex: number; }[] = [];

    for (let tokenIndex = 0; tokenIndex < tokens.length; tokenIndex++) {
      const token = tokens[tokenIndex];
      const tokenAddress = Address.fromStr(token.addr);
      const requests = await buildTokenRequests(tokenAddress, accounts, token.native);

      for (const req of requests) {
        if (req.requestType.type === 'Balance') {
          allRequests.push({ ...req, tokenIndex });
        }
      }
    }

    if (allRequests.length === 0) {
      return;
    }

    const provider = new RpcProvider(this.config);
    const payloads = allRequests.map(r => r.payload);
    const responses = await provider.req<JsonRPCResponse<any>[]>(payloads);

    for (let i = 0; i < allRequests.length; i++) {
      const requestInfo = allRequests[i];
      const response = responses[i];
      const token = tokens[requestInfo.tokenIndex];
      const tokenAddress = Address.fromStr(token.addr);
    
      if (requestInfo.requestType.type !== 'Balance') continue;

      const account = requestInfo.requestType.address;
    
      if (tokenAddress.type === AddressType.Bech32) {
        const balance = await processZilBalanceResponse(response, account, token.native);
        token.balances[await account.autoFormat()] = balance.toString();
      } else if (tokenAddress.type === AddressType.EthCheckSum) {
        const balance = processEthBalanceResponse(response);
        token.balances[await account.autoFormat()] = balance.toString();
      }
    }
  }
}

```

`zil-pay/background/rpc/tx_parse.ts`:

```ts
import { RpcProvider, type JsonRPCRequest, type JsonRPCResponse } from './provider';
import { EvmMethods, ZilMethods } from 'config/jsonrpc';
import { HistoricalTransaction, TransactionStatus } from './history_tx';
import { TransactionReceipt } from 'crypto/tx';
import { Address } from 'crypto/address';
import { ZILLIQA } from 'config/slip44';
import { stripHexPrefix } from 'lib/utils/hex';

const MINUTES_IN_SECONDS = 10 * 60;

export async function buildSendSignedTxRequest(tx: TransactionReceipt): Promise<JsonRPCRequest> {
  if (tx.scilla) {
    return RpcProvider.buildPayload(ZilMethods.CreateTransaction, [await tx.scilla.toJSON()]);
  } else if (tx.evm) {
    const encodedTx = tx.evm.toHex(true);
    return RpcProvider.buildPayload(EvmMethods.SendRawTransaction, [encodedTx]);
  }
  
  throw new Error('Invalid transaction type');
}

export function buildPayloadTxReceipt(tx: HistoricalTransaction): JsonRPCRequest {
  if (tx.chain_type === 'Scilla') {
    return RpcProvider.buildPayload(ZilMethods.GetTransactionStatus, [stripHexPrefix(tx.transaction_hash)]);
  } else if (tx.chain_type === 'EVM') {
    return RpcProvider.buildPayload(EvmMethods.GetTransactionReceipt, [tx.transaction_hash]);
  }
  
  throw new Error('Invalid chain type');
}

export async function processTxReceiptResponse(
  response: JsonRPCResponse<any>,
  tx: HistoricalTransaction
): Promise<void> {
  if (response.error) {
    const now = Math.floor(Date.now() / 1000);
    const cutoff = now - MINUTES_IN_SECONDS;

    if (tx.timestamp < cutoff) {
      tx.status = TransactionStatus.Failed;
      tx.error = response.error.message;
    }
    return;
  }

  if (!response.result) {
    throw new Error(`No transaction found with hash: ${tx.transaction_hash}`);
  }

  const result = response.result;

  if (tx.chain_type === 'Scilla') {
    const amount = result.amount ? BigInt(result.amount) : tx.amount;
    const gasLimit = result.gasLimit ? BigInt(result.gasLimit) : tx.gasLimit || 0n;
    const gasPrice = result.gasPrice ? BigInt(result.gasPrice) : tx.gasPrice || 0n;
    const nonce = result.nonce ? BigInt(result.nonce) : tx.nonce;
    const statusCode = result.status ? Number(result.status) : null;
    const pubKey = result.senderAddr;

    tx.amount = amount;
    tx.gasLimit = gasLimit;
    tx.gasPrice = gasPrice;
    tx.nonce = nonce;
    tx.fee = gasPrice * gasLimit;

    if (statusCode) {
      tx.status_code = statusCode;
      switch (statusCode) {
        case 1:
        case 2:
        case 4:
        case 5:
        case 6:
          tx.status = TransactionStatus.Pending;
          break;
        case 3:
          tx.status = TransactionStatus.Success;
          break;
        default:
          tx.status = TransactionStatus.Failed;
      }
    }

    if (tx.status === TransactionStatus.Pending) {
      const now = Math.floor(Date.now() / 1000);
      const cutoff = now - MINUTES_IN_SECONDS;

      if (tx.timestamp < cutoff) {
        tx.status = TransactionStatus.Failed;
        tx.error = 'timeout';
      }
    }

    if (pubKey) {
      tx.sender = await (await Address.fromPubKey(pubKey, ZILLIQA)).toZilBech32();
    }
  } else if (tx.chain_type === 'EVM') {
    tx.sender = result.from;
    tx.contract_address = result.contractAddress || null;

    if (result.to) {
      tx.recipient = result.to;
    }

    tx.block_number = result.blockNumber ? BigInt(result.blockNumber) : null;
    tx.gasUsed = result.gasUsed ? BigInt(result.gasUsed) : null;
    tx.blobGasUsed = result.blobGasUsed ? BigInt(result.blobGasUsed) : null;
    tx.blobGasPrice = result.blobGasPrice ? BigInt(result.blobGasPrice) : null;
    tx.effectiveGasPrice = result.effectiveGasPrice ? BigInt(result.effectiveGasPrice) : null;

    const isSuccess = result.status === '0x1' || result.status === 1;
    tx.status = isSuccess ? TransactionStatus.Success : TransactionStatus.Failed;

    let totalCost = BigInt(result.gasUsed || 0) * BigInt(result.effectiveGasPrice || 0);

    if (result.blobGasUsed && result.blobGasPrice) {
      totalCost += BigInt(result.blobGasUsed) * BigInt(result.blobGasPrice);
    }

    tx.fee = totalCost;
  }
}

export function processTxSendResponse(
  response: JsonRPCResponse<any>,
  tx: TransactionReceipt
): void {
  if (response.error) {
    throw new Error(`RPC Error: ${response.error.message}`);
  }

  if (!response.result) {
    throw new Error('Invalid response: missing result');
  }

  if (tx.scilla) {
    const result = response.result;
    const info = result.Info || '';
    const txId = result.TranID;

    if (!txId) {
      throw new Error('Invalid transaction hash');
    }

    tx.metadata.hash = txId;
    tx.metadata.info = info;
  } else if (tx.evm) {
    const hash = response.result;

    if (typeof hash !== 'string') {
      throw new Error('Invalid transaction hash');
    }

    tx.metadata.hash = hash;
  }
}

```

`zil-pay/background/secure/index.ts`:

```ts
export * from './migrator';
export * from './session';

```

`zil-pay/background/secure/migrator.ts`:

```ts
import { BackgroundState, type IBackgroundState } from '../storage/background';
import { ChainConfig } from '../storage/chain';
import { FToken } from '../storage/ftoken';
import { Wallet } from '../storage/wallet';
import { Account } from '../storage/account';
import { WalletSettings } from '../storage/settings';
import { HashTypes, WalletHashParams } from '../storage/argon';
import { CipherOrders } from '../../crypto/keychain';
import { ShaAlgorithms } from '../../config/pbkdf2';
import { AddressType } from 'crypto/address';
import { uuid } from 'crypto/uuid';
import { Themes } from 'config/theme';
import { RatesApiOptions } from 'config/api';
import { AuthMethod, WalletTypes } from 'config/wallet';
import { Locales } from 'config/locale';

interface WalletIdentities {
  selectedAddress: number;
  identities: {
    name: string;
    bech32: string;
    index: number;
    base16: string;
    type: number;
    pubKey: string;
    privKey?: string;
    zrc2: Record<string, string>;
    nft: Record<string, unknown>;
  }[];
}

interface TokenData {
  base16: string;
  bech32: string;
  decimals: number;
  name: string;
  symbol: string;
  rate: number;
  pool?: string[];
}

type TokenWithBase16 = { ftoken: FToken; base16: string };

const ZILLIQA_MAINNET_CHAIN = new ChainConfig({
    name: 'Zilliqa',
    chain: 'ZIL',
    logo: 'https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/%{shortName}%/chain/%{dark,light}%.svg',
    rpc: [
      'https://api.zilliqa.com',
      'https://ssn.zilpay.io/api',
      'https://zilliqa.avely.fi/api',
      'https://ssn.zillet.io',
    ],
    features: [],
    ftokens: [
      new FToken({
        native: true,
        logo: 'https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/%{contract_address}%/%{dark,light}%.webp',
        addr: '0x0000000000000000000000000000000000000000',
        name: 'Zilliqa',
        symbol: 'ZIL',
        decimals: 18,
        addrType: AddressType.EthCheckSum,
        balances: {},
        rate: 0,
        default_: true,
        chainHash: 1
      }),
      new FToken({
        native: true,
        logo: 'https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/%{contract_address}%/%{dark,light}%.webp',
        addr: 'zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz',
        name: 'Zilliqa',
        symbol: 'ZIL',
        decimals: 12,
        addrType: AddressType.Bech32,
        balances: {},
        rate: 0,
        default_: true,
        chainHash: 1
      }),
    ],
    chainIds: [32769, 1],
    shortName: 'zilliqa',
    slip44: 313,
    explorers: [
      {
        name: 'Viewblock',
        url: 'https://viewblock.io/zilliqa',
        icon: 'https://viewblock.io/apple-touch-icon.png',
        standard: 3091,
      },
      {
        name: 'Otterscan',
        icon: 'https://otterscan.zilliqa.com/assets/otter-DYFeLtFi.png',
        url: 'https://otterscan.zilliqa.com/',
        standard: 3091,
      },
    ],
    chainId: 1,
    diffBlockTime: 30,
    ens: null,
    fallbackEnabled: false,
    testnet: false
});

export function migrateToV4(storage: IBackgroundState): BackgroundState {
  if (storage.storageVersion == 4) {
    return new BackgroundState(storage);
  } else {
      return migrateFromV2orV3(storage as any);
  }
}

function parseTokens(tokensJson: string, chainHash: number): TokenWithBase16[] {
    const tokens: TokenData[] = JSON.parse(tokensJson);
    return tokens.map(token => ({
      ftoken: new FToken({
        name: token.name,
        symbol: token.symbol,
        decimals: token.decimals,
        addr: token.bech32,
        addrType: AddressType.Bech32,
        logo: `https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/${token.bech32}/%{dark,light}%.webp`,
        balances: {},
        rate: token.rate,
        default_: token.symbol === 'ZIL',
        native: token.base16 === '0x0000000000000000000000000000000000000000',
        chainHash,
      }),
      base16: token.base16,
    }));
  }

function migrateFromV2orV3(storage: Record<string, unknown>): BackgroundState {
    const walletIdentities: WalletIdentities = JSON.parse(storage['wallet-identities'] as string);
    const mainChain = ZILLIQA_MAINNET_CHAIN;
    const cipher = 'guard-configuration' in storage ? CipherOrders.AESGCM256 : CipherOrders.AESCBC;
    const parsedTokens = parseTokens(storage['tokens-list/mainnet'] as string, mainChain.hash());
    let [algorithm, iteractions] = String(storage["guard-configuration"]).split(":");

    if (!iteractions) {
      iteractions = '0';
    }

    if (!algorithm || (algorithm != ShaAlgorithms.sha256 && algorithm != ShaAlgorithms.Sha512)) {
      algorithm = ShaAlgorithms.sha256;
    }

    const accounts = walletIdentities.identities.map(identity => new Account({
        addr: identity.bech32,
        addrType: AddressType.Bech32,
        name: identity.name,
        pubKey: identity.pubKey,
        chainHash: mainChain.hash(),
        chainId: mainChain.chainId,
        slip44: mainChain.slip44,
        index: identity.index,
    }));

    const walletTokens = parsedTokens.map(({ ftoken, base16 }) => {
        const balances: Record<number, string> = {};
        accounts.forEach((_, index) => {
            const identity = walletIdentities.identities[index];
            balances[index] = identity.zrc2[base16.toLowerCase()] || '0';
        });
        return new FToken({ ...ftoken, balances });
    });

    const wallet = new Wallet({
        history: [],
        confirm: [],
        walletType: WalletTypes.SecretPhrase,
        walletName: 'Zilliqa Wallet',
        authType: AuthMethod.None,
        uuid: uuid(),
        accounts,
        selectedAccount: walletIdentities.selectedAddress,
        tokens: walletTokens, 
        settings: new WalletSettings({
            cipherOrders: [cipher],
            hashFnParams: new WalletHashParams({
                memory: 1024,
                iterations: Number(iteractions),
                threads: 1,
                secret: '',
                hashType: HashTypes.Pbkdf2, 
                hashSize: algorithm as ShaAlgorithms ?? ShaAlgorithms.sha256,
            }),
            currencyConvert: String(storage['selected-currency']),
            ipfsNode: null,
            ensEnabled: false,
            tokensListFetcher: false,
            nodeRankingEnabled: false,
            maxConnections: 10,
            requestTimeoutSecs: 30,
            ratesApiOptions: RatesApiOptions.CoinGecko,
                sessionTime: Number(storage['time_before_lock']) || 3600,
        }),
        defaultChainHash: mainChain.hash(),
        vault: String(storage.vault),
    });

    const backgroundState = new BackgroundState({
        storageVersion: 4,
        wallets: [wallet],
        selected_wallet: 0,
        notificationsGlobalEnabled: true,
        locale: Locales.Auto,
        appearances: Themes.System,
        abbreviatedNumber: true,
        hideBalance: false,
        chains: [mainChain], 
    });

    return backgroundState;
}


```

`zil-pay/background/secure/session.ts`:

```ts
import { AESCipherV3 } from '../../crypto/aes256';
import { uint8ArrayToBase64, base64ToUint8Array } from '../../crypto/b64';
import { randomBytes } from '../../crypto/random';
import { Runtime } from '../../lib/runtime';

export enum SessionStorageKeys {
  EndSession = 'SESSION_END',
  SessionKey = 'SESSION_KEY',
  VaultCipher = 'VAULT_CIPHER',
}

export class Session {
  #uuid: string;

  constructor(uuid: string) {
    Runtime.storage.session.setAccessLevel({ accessLevel: 'TRUSTED_CONTEXTS' });
    this.#uuid = uuid;
  }

  private getKey(key: SessionStorageKeys): string {
    return `${key}:${this.#uuid}`;
  }

  async setSession(sessionTime: number, vaultContent: Uint8Array): Promise<void> {
    const endSession = Date.now() + sessionTime * 1000;
    const key = randomBytes(32);
    const vaultCipher = AESCipherV3.encrypt(vaultContent, key);

    const data = {
      [this.getKey(SessionStorageKeys.EndSession)]: endSession,
      [this.getKey(SessionStorageKeys.SessionKey)]: uint8ArrayToBase64(key),
      [this.getKey(SessionStorageKeys.VaultCipher)]: uint8ArrayToBase64(vaultCipher),
    };
    await Runtime.storage.session.set(data);
  }

  async clearSession(): Promise<void> {
    await Runtime.storage.session.clear();
  }

  async getVault(): Promise<Uint8Array> {
    const data = await Runtime.storage.session.get([
      this.getKey(SessionStorageKeys.EndSession),
      this.getKey(SessionStorageKeys.SessionKey),
      this.getKey(SessionStorageKeys.VaultCipher),
    ]);

    const endSession = data[this.getKey(SessionStorageKeys.EndSession)];
    if (!endSession) {
      throw new Error('Session does not exist');
    }
    if (Date.now() > endSession) {
      await this.clearSession();
      throw new Error('Session has expired');
    }

    const sessionKeyBase64 = data[this.getKey(SessionStorageKeys.SessionKey)];
    const vaultCipherBase64 = data[this.getKey(SessionStorageKeys.VaultCipher)];

    if (!sessionKeyBase64 || !vaultCipherBase64) {
      throw new Error('Session data is incomplete');
    }

    const sessionKey = base64ToUint8Array(sessionKeyBase64);
    const vaultCipher = base64ToUint8Array(vaultCipherBase64);

    return AESCipherV3.decrypt(vaultCipher, sessionKey);
  }
}

```

`zil-pay/background/services/index.ts`:

```ts
export * from './wallet';
export * from './provider';
export * from './tx';



```

`zil-pay/background/services/provider.ts`:

```ts
import { NetworkProvider } from "background/rpc";
import type { BackgroundState } from "background/storage";
import { Address } from "crypto/address";
import type { StreamResponse } from "lib/streem";

export class ProviderService {
  #state: BackgroundState;

  constructor(state: BackgroundState) {
    this.#state = state;
  }

  async balanceUpdate(walletIndex: number, sendResponse: StreamResponse) {
    try {
      const wallet = this.#state.wallets[walletIndex];
      const account = wallet.accounts[wallet.selectedAccount];
      const chainConfig = this.#state.getChain(account.chainHash)!;
      const provider = new NetworkProvider(chainConfig);
      const addresses = wallet.accounts.map((a) => Address.fromStr(a.addr));

      await provider.updateBalances(wallet.tokens, addresses);
      this.#state.sync();

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async sendSignedTransaction(sendResponse: StreamResponse) {}

  async getCurrentBlock(walletIndex: number, accountIndex: number, sendResponse: StreamResponse) {
    try {
      const wallet = this.#state.wallets[walletIndex];
      const account = wallet.accounts[accountIndex];
      const chainConfig = this.#state.getChain(account.chainHash)!;
      const provider = new NetworkProvider(chainConfig);
      const blockNumber = await provider.getCurrentBlockNumber();

      sendResponse({
        resolve: blockNumber.toString(),
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async proxyChannel(sendResponse: StreamResponse) {}

  async estimateBlockTime(walletIndex: number, accountIndex: number, sendResponse: StreamResponse) {
    try {
      const wallet = this.#state.wallets[walletIndex];
      const account = wallet.accounts[accountIndex];
      const chainConfig = this.#state.getChain(account.chainHash)!;
      const provider = new NetworkProvider(chainConfig);
      const blockTime = await provider.estimateBlockTime();

      sendResponse({
        resolve: blockTime,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async estimateGasParamsBatch(sendResponse: StreamResponse) {}

  async fetchFtokenMeta(contract: string, walletIndex: number, accountIndex: number, sendResponse: StreamResponse) {
    try {
      const contractAddr = Address.fromStr(contract);
      const wallet = this.#state.wallets[walletIndex];
      const account = wallet.accounts[accountIndex];
      const chainConfig = this.#state.getChain(account.chainHash)!;
      const provider = new NetworkProvider(chainConfig);
      const addresses = wallet.accounts.map((a) => Address.fromStr(a.addr));
      const metadata = await provider.ftokenMeta(contractAddr, addresses);

      sendResponse({
        resolve: metadata,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }
}


```

`zil-pay/background/services/tx.ts`:

```ts
import type { BackgroundState } from "background/storage";
import type { StreamResponse } from "lib/streem";
import { ConfirmState, type IConfirmState } from "background/storage/confirm";

export class TransactionService {
  #state: BackgroundState;

  constructor(state: BackgroundState) {
    this.#state = state;
  }

  async add(payload: IConfirmState, walletIndex: number, sendResponse: StreamResponse) {
    try {
      const wallet = this.#state.wallets[walletIndex];
      const scillaTx = new ConfirmState(payload);

      wallet.confirm.push(scillaTx);
      await this.#state.sync();

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async reject(index: number, walletIndex: number, sendResponse: StreamResponse) {
    try {
      const wallet = this.#state.wallets[walletIndex];

      wallet.confirm.splice(index, 1);
      await this.#state.sync();
      // TODO: sending response to Tab with uuid.

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }
}

```

`zil-pay/background/services/wallet.ts`:

```ts
import { Wallet, WalletSettings, type BackgroundState, type IBackgroundState } from "background/storage";
import type { StreamResponse } from "lib/streem";
import { utf8ToUint8Array } from "lib/utils/utf8";
import { hexToUint8Array, uint8ArrayToHex } from "lib/utils/hex";
import type { SetPasswordPayload, WalletFromPrivateKeyParams } from "types/wallet";
import { TypeOf } from "lib/types";
import { KeyPair } from "crypto/keypair";
import { HistoricalTransaction } from "background/rpc/history_tx";
import { randomBytes } from "crypto/random";
import { Bip39 } from "crypto/bip39";

export class WalletService {
  #state: BackgroundState;

  constructor(state: BackgroundState) {
    this.#state = state;
  }

  async addLedgerWallet() {}

  async genBip39Words(count: number, wordList: string[], sendResponse: StreamResponse) {
    try {
      const entropyBits = (count * 11) - Math.floor(count / 3);
      const entropyBytes = entropyBits / 8;
      const entropy = randomBytes(entropyBytes);
      const mnemonic = await Bip39.entropyToMnemonic(entropy, wordList);

      sendResponse({
        resolve: mnemonic.phrase
      });
    } catch(err) {
      sendResponse({
        reject: String(err)
      });
    }
  }

    async validateBip39CheckSum(phrase: string, wordList: string[], sendResponse: StreamResponse) {
      try {
        const isValid = await Bip39.validateMnemonic(phrase, wordList);

        sendResponse({
          resolve: isValid
        });
      } catch {
        sendResponse({
          reject: false,
        });
      }
    }


  async genKeyPair(slip44: number, sendResponse: StreamResponse) {
    try {
      const keyPair = await KeyPair.generate( slip44);

      sendResponse({
        resolve: await keyPair.toJSON()
      });
    } catch(err) {
      sendResponse({
        reject: String(err)
      });
    }
  }

  async keyPairFromPrivateKey(slip44: number, key: string, sendResponse: StreamResponse) {
    try {
      const keyBuf = hexToUint8Array(key);
      const keyPair = await KeyPair.fromPrivateKey(keyBuf, slip44);

      sendResponse({
        resolve: await keyPair.toJSON()
      });
    } catch(err) {
      sendResponse({
        reject: String(err)
      });
    }
  }

  async getGlobalState(sendResponse: StreamResponse) {
    sendResponse({
      resolve: this.#state
    });
  }

  async setGlobalState(payload: IBackgroundState, sendResponse: StreamResponse) {
    this.#state.abbreviatedNumber = payload.abbreviatedNumber;
    this.#state.appearances = payload.appearances;
    this.#state.hideBalance = payload.hideBalance;
    this.#state.selected_wallet = payload.selected_wallet;
    this.#state.locale = payload.locale;
    this.#state.notificationsGlobalEnabled = payload.notificationsGlobalEnabled;

    payload.wallets.forEach((wallet, index) => {
      const currentWallet = this.#state.wallets[index];

      if (currentWallet) {
          currentWallet.accounts = wallet.accounts;
          currentWallet.confirm = wallet.confirm;
          currentWallet.history = wallet.history.map((h) =>  new HistoricalTransaction(h));
          currentWallet.selectedAccount = wallet.selectedAccount;
          currentWallet.settings = new WalletSettings(wallet.settings);
          currentWallet.tokens = wallet.tokens;
          currentWallet.walletName = wallet.walletName;
      }
    });

    await this.#state.sync();

    sendResponse({
      resolve: this.#state
    });
  }

  async walletFromPrivateKey(payload: WalletFromPrivateKeyParams, sendResponse: StreamResponse) {
    try {
      const chain = this.#state.getChain(payload.chainHash)!;
      const keyBytes = hexToUint8Array(payload.key);
      const kyepair = await KeyPair.fromPrivateKey(keyBytes, chain.slip44);
      const settings = new WalletSettings(payload.settings);
      const wallet = await Wallet.fromPrivateKey(
        kyepair,
        payload.walletName,
        payload.accountName,
        settings,
        chain,
        payload.password,
      );

      this.#state.wallets.push(wallet);
      await this.#state.sync();

      sendResponse({
        resolve: true
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async exportbip39Words(password: string, walletIndex: number, sendResponse: StreamResponse) {
    try {
      const passwordBytes = utf8ToUint8Array(password);
      const wallet = this.#state.wallets[walletIndex];

      const chain = this.#state.getChain(wallet.defaultChainHash)!;
      const mnemonic = await wallet.revealMnemonic(passwordBytes, chain);

      sendResponse({
        resolve: mnemonic
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async exportKeyPair(password: string, walletIndex: number, accountIndex: number, sendResponse: StreamResponse) {
    try {
      const passwordBytes = utf8ToUint8Array(password);
      const wallet = this.#state.wallets[walletIndex];

      await wallet.unlock(passwordBytes);

      const chain = this.#state.getChain(wallet.defaultChainHash)!;
      const keyPair = await wallet.revealKeypair(accountIndex, chain);

      sendResponse({
        resolve: {
          privKey: uint8ArrayToHex(keyPair.privateKey),
          pubKey: uint8ArrayToHex(keyPair.pubKey),
        }
      });
    } catch (err) {
      sendResponse({
        reject: String(err)
      });
    }
  }

  async changePassword(payload: SetPasswordPayload, sendResponse: StreamResponse) {
     try {
      const passwordBytes = utf8ToUint8Array(payload.currentPassword);
      const wallet = this.#state.wallets[payload.walletIndex];

      await wallet.clearSession();

      const vault = await wallet.decrypt(passwordBytes);
      const newPasswordBytes = utf8ToUint8Array(payload.newPassword);

      wallet.settings.cipherOrders = payload.cipherOrders;
      wallet.settings.hashFnParams.memory = payload.hashSettings.memory;
      wallet.settings.hashFnParams.iterations = payload.hashSettings.iterations;
      wallet.settings.hashFnParams.threads = payload.hashSettings.threads;
      wallet.settings.hashFnParams.secret = payload.hashSettings.secret;
      wallet.settings.hashFnParams.hashType = payload.hashSettings.hashType;
      wallet.settings.hashFnParams.hashSize = payload.hashSettings.hashSize;

      if (TypeOf.isString(vault)) {
        await wallet.encrypt(newPasswordBytes, utf8ToUint8Array(vault as string));
      } else if (vault instanceof Uint8Array) {
        await wallet.encrypt(newPasswordBytes, vault);
      }

      await wallet.unlock(newPasswordBytes);
      await this.#state.sync();

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err)
      });
    } 
  }

  async removeAccount(walletIndex: number, accountIndex: number, sendResponse: StreamResponse) {
    try {
      if (accountIndex == 0) {
        throw new Error(`invalid account index: ${accountIndex}`);
      }

      const wallet = this.#state.wallets[walletIndex];

      wallet.accounts.splice(accountIndex, 1);
      await this.#state.sync();

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async removeWallet(walletIndex: number, password: string, sendResponse: StreamResponse) {
    try {
      const passwordBytes = utf8ToUint8Array(password);
      const wallet = this.#state.wallets[walletIndex];

      await wallet.unlock(passwordBytes);
      this.#state.wallets.splice(walletIndex);
      await this.#state.sync();

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async setAccountName(walletIndex: number, accountIndex: number, name: string, sendResponse: StreamResponse) {
    try {
      const wallet = this.#state.wallets[walletIndex];
      const account = wallet.accounts[accountIndex];

      account.name = name;

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async selectAccount(walletIndex: number, accountIndex: number, sendResponse: StreamResponse) {
    try {
      const wallet = this.#state.wallets[walletIndex];

      if (accountIndex <= wallet.accounts.length - 1 && accountIndex >= 0) {
        wallet.selectedAccount = accountIndex;
      }

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }
}

```

`zil-pay/background/state.ts`:

```ts
import { BackgroundState } from "background/storage";
import { TransactionService, WalletService } from "background/services";
import { ProviderService } from "background/services";

export class GlobalState {
  state: BackgroundState;
  readonly wallet: WalletService;
  readonly provider: ProviderService;
  readonly transaction: TransactionService;

  static async fromStorage() {
    const state = await BackgroundState.fromStorage();

    return new GlobalState(state);
  }

  constructor(initialState: BackgroundState) {
    this.state = initialState;
    this.wallet = new WalletService(this.state);
    this.provider = new ProviderService(this.state);
    this.transaction = new TransactionService(this.state);
  }

  async sync() {
    await this.state.sync();
  }
}

```

`zil-pay/background/storage/account.ts`:

```ts
import type { AddressType } from 'crypto/address';
import { utils } from 'aes-js';
import { ChainConfig } from './chain';
import { KeyPair } from 'crypto/keypair';

export interface Bip32Account {
  name: string;
  index: number;
}

export interface IAccountState {
  addr: string;
  addrType: AddressType;
  name: string;
  pubKey: string;
  chainHash: number;
  chainId: number;
  slip44: number;
  index: number;
}

export class Account implements IAccountState {
  addr: string;
  addrType: AddressType;
  name: string;
  pubKey: string;
  chainHash: number;
  chainId: number;
  slip44: number;
  index: number;

  constructor(data: IAccountState) {
    this.addr = data.addr;
    this.addrType = data.addrType;
    this.name = data.name;
    this.pubKey = data.pubKey;
    this.chainHash = data.chainHash;
    this.chainId = data.chainId;
    this.slip44 = data.slip44;
    this.index = data.index;
  }

  static async fromBip39(bip32Account: Bip32Account, chain: ChainConfig, seed: Uint8Array): Promise<Account> {
    const keyPair = await KeyPair.fromSeed(seed, chain.slip44, bip32Account.index);
    const addrType = keyPair.addressType();
    const addr = await (await keyPair.address()).autoFormat();
    const account = new Account({
      addr,
      addrType,
      name: bip32Account.name,
      index: bip32Account.index,
      pubKey: utils.hex.fromBytes(keyPair.pubKey),
      chainHash: chain.hash(),
      slip44: chain.slip44,
      chainId: chain.chainId,
    });

    return account;
  }

  static async fromPrivateKey(privateKey: Uint8Array, chain: ChainConfig, name: string): Promise<Account> {
    const keyPair = await KeyPair.fromPrivateKey(privateKey, chain.slip44);
    const addrType = keyPair.addressType();
    const addr = await keyPair.address();
    const formated = await addr.autoFormat();

    const account = new Account({
      addrType,
      name: name,
      index: 0,
      addr: formated,
      pubKey: utils.hex.fromBytes(keyPair.pubKey),
      chainHash: chain.hash(),
      slip44: chain.slip44,
      chainId: chain.chainId,
    });

    return account;
  }
}

```

`zil-pay/background/storage/argon.ts`:

```ts
import type { Argon2Config } from '../../crypto/argon2';
import { Variant, Version, Config } from '@hicaru/argon2-pure.js';
import { APP_ID } from '../../config/argon2';
import { deriveArgon2Key } from '../../crypto/argon2';
import { ShaAlgorithms } from '../../config/pbkdf2';
import { KeyChain } from '../../crypto/keychain';
import { hexToUint8Array, uint8ArrayToHex } from 'lib/utils/hex';

export enum HashTypes {
  Argon2,
  Pbkdf2,
}

export interface IWalletHashParams {
  memory: number;
  iterations: number;
  threads: number;
  secret: string;
  hashType: HashTypes;
  hashSize: ShaAlgorithms;
}

export class WalletHashParams implements IWalletHashParams {
  memory: number;
  iterations: number;
  threads: number;
  secret: string;
  hashType: HashTypes;
  hashSize: ShaAlgorithms;

  get argon2(): Argon2Config {
    return new Config(
      APP_ID,
      64,
      this.threads,
      this.memory,
      hexToUint8Array(this.secret),
      this.iterations,
      Variant.Argon2id,
      Version.Version13,
    );
  }

  static default(): WalletHashParams {
    const original = Config.original();

    return new WalletHashParams({
      memory: original.memCost, 
      threads: original.lanes,
      secret: uint8ArrayToHex(original.secret),
      iterations: original.timeCost,
      hashType: HashTypes.Argon2,
      hashSize: ShaAlgorithms.Sha512,
    });
  }

  static pq(): WalletHashParams {
    return new WalletHashParams({
      memory: 2097152, 
      threads: 2,
      secret: uint8ArrayToHex(new Uint8Array()),
      iterations: 1,
      hashType: HashTypes.Argon2,
      hashSize: ShaAlgorithms.Sha512,
    });
  }


  constructor(data: IWalletHashParams) {
    this.memory = data.memory;
    this.iterations = data.iterations;
    this.threads = data.threads;
    this.secret = data.secret;
    this.hashType = data.hashType;
    this.hashSize = data.hashSize;
  }

  async deriveKey(password: Uint8Array, salt: Uint8Array): Promise<KeyChain> {
    if (this.hashType == HashTypes.Argon2) {
      const seed = deriveArgon2Key(password, salt, this.argon2);      
      return KeyChain.fromSeed(seed);
    } else if(ShaAlgorithms.Sha512 == this.hashSize) {
      return KeyChain.fromAesV3(password, this.hashSize, this.iterations);
    } else {
      return KeyChain.fromAesV2(password);
    }
  }
}

```

`zil-pay/background/storage/background.ts`:

```ts
import { BrowserStorage, buildObject } from 'lib/storage';
import { ChainConfig, type IChainConfigState } from './chain';
import { Wallet, type IWalletState } from './wallet';
import { Fields } from 'config/fields';
import { migrateToV4 } from 'background/secure';
import { Themes } from 'config/theme';
import { Locales } from 'config/locale';

export interface IBackgroundState {
  storageVersion: number;
  wallets: IWalletState[];
  selected_wallet: number;
  notificationsGlobalEnabled: boolean;
  locale: Locales;
  appearances: Themes;
  abbreviatedNumber: boolean;
  hideBalance: boolean;
  chains: IChainConfigState[];
}

export class BackgroundState implements IBackgroundState {
  readonly storageVersion  = 4;
  wallets: Wallet[];
  selected_wallet: number;
  notificationsGlobalEnabled: boolean;
  locale: Locales;
  appearances: Themes;
  abbreviatedNumber: boolean;
  hideBalance: boolean;
  chains: ChainConfig[];

  static default() {
    return new BackgroundState({
      wallets: [],
      selected_wallet: -1,
      notificationsGlobalEnabled: true,
      locale: Locales.Auto,
      appearances: Themes.System,
      abbreviatedNumber: true,
      hideBalance: false,
      chains: [],
      storageVersion: 4,
    });
  }

  static async fromStorage() {
    const recordsv4 = await BrowserStorage.get<string>(Fields.STORAGE_V4);
    let state: BackgroundState;

    if (!recordsv4) {
      const oldRecords = await BrowserStorage.getAll<IBackgroundState>();

      if (oldRecords) {
        try {
          state = migrateToV4(oldRecords);
          await BrowserStorage.clear();
          await state.sync();
        } catch {
          state = BackgroundState.default();
        }
      } else {
        state = BackgroundState.default();
      }
    } else {
      try {
        state = new BackgroundState(JSON.parse(recordsv4));
      } catch {
        state = BackgroundState.default();
      }
    }

    return state;
  }

  constructor(data: IBackgroundState) {
    this.wallets = (data.wallets ?? []).map(
      (w) => new Wallet(w)
    );
    this.notificationsGlobalEnabled = data.notificationsGlobalEnabled;
    this.locale = data.locale ?? Locales.Auto;
    this.appearances = data.appearances;
    this.abbreviatedNumber = data.abbreviatedNumber;
    this.hideBalance = data.hideBalance;
    this.selected_wallet = Number(data.selected_wallet);
    this.chains = (data.chains).map(
      (c) => new ChainConfig(c)
    );
  }

  getChain(hash: number) {
    return this.chains.find((c) => c.hash() == hash);
  }

  async sync() {
    await BrowserStorage.set(
      buildObject(Fields.STORAGE_V4, JSON.stringify(this)),
    );
  }
}

```

`zil-pay/background/storage/chain.ts`:

```ts
import { FToken, type IFTokenState } from './ftoken';
import { Explorer, type IExplorerState } from './explorer';
import { KeyPair } from 'crypto/keypair';

export interface IChainConfigState {
  name: string;
  logo: string;
  chain: string;
  shortName: string;
  rpc: string[];
  features: number[];
  chainId: number;
  chainIds: number[];
  slip44: number;
  diffBlockTime: number;
  ens: string | null;
  explorers: IExplorerState[];
  fallbackEnabled: boolean;
  testnet: boolean | null;
  ftokens: IFTokenState[];
}

function hashNumber(hash: number, value: number): number {
  hash = (hash << 5) - hash + value;
  return hash >>> 0; 
}

function hashString(hash: number, str: string): number {
  for (let i = 0; i < str.length; i++) {
    hash = (hash << 5) - hash + str.charCodeAt(i);
    hash = hash >>> 0; 
  }
  return hash;
}

function hashChainConfig(chainIds: number[], slip44: number, chain: string): number {
  let hash = 0;
  const chainIdsSum = chainIds[0] + chainIds[1];
  hash = hashNumber(hash, chainIdsSum);
  hash = hashNumber(hash, slip44);
  hash = hashString(hash, chain);
  return hash >>> 0;
}

export class ChainConfig implements IChainConfigState {
  name: string;
  logo: string;
  chain: string;
  shortName: string;
  rpc: string[];
  features: number[];
  chainId: number;
  chainIds: number[];
  slip44: number;
  diffBlockTime: number;
  ens: string | null;
  explorers: Explorer[];
  fallbackEnabled: boolean;
  testnet: boolean | null;
  ftokens: FToken[];

  constructor(data: IChainConfigState) {
    this.name = data.name;
    this.logo = data.logo;
    this.chain = data.chain;
    this.shortName = data.shortName;
    this.rpc = data.rpc;
    this.features = data.features;
    this.chainIds = data.chainIds;
    this.chainId = this.chainIds[0];
    this.slip44 = data.slip44;
    this.diffBlockTime = data.diffBlockTime;
    this.ens = data.ens ?? null;
    this.explorers = (data.explorers).map(
      (e) => new Explorer(e)
    );
    this.fallbackEnabled = data.fallbackEnabled;
    this.testnet = data.testnet ?? null;
    this.ftokens = (data.ftokens).map(
      (t) => new FToken({
        ...t,
        default_: true,
        rate: 0,
        chainHash: t.chainHash ?? hashChainConfig(this.chainIds, this.slip44, this.chain),
        addrType: KeyPair.addressType(this.slip44),
        balances: t.balances ?? {},
      })
    );
  }

  hash(): number {
    return hashChainConfig(this.chainIds, this.slip44, this.chain);
  }
}

```

`zil-pay/background/storage/confirm.ts`:

```ts
import type { MinScillaParams, TokenTransferMetadata, TransactionRequestEVM } from "types/tx";

export interface IConfirmState {
  uuid: string;
  title: string;
  icon: string;
  token?: TokenTransferMetadata;
  scilla?: MinScillaParams;
  signMessageScilla?: string;
  evm?: TransactionRequestEVM;
  signPersonalMessageEVM?: string;
  signTypedDataJsonEVM?: string;
}

export class ConfirmState implements IConfirmState {
  uuid: string;
  title: string;
  icon: string;
  token?: TokenTransferMetadata;
  scilla?: MinScillaParams;
  signMessageScilla?: string;
  evm?: TransactionRequestEVM;
  signPersonalMessageEVM?: string;
  signTypedDataJsonEVM?: string;

  constructor(data: IConfirmState) {
    this.uuid = data.uuid;
    this.title = data.title;
    this.icon = data.icon;

    if (data.token) {
      this.token = data.token;
    }

    if (data.scilla) {
      this.scilla = data.scilla;
    }

    if (data.evm) {
      this.evm = data.evm;
    }

    if (data.signPersonalMessageEVM) {
      this.signPersonalMessageEVM = data.signPersonalMessageEVM;
    }

    if (data.signPersonalMessageEVM) {
      this.signPersonalMessageEVM = data.signPersonalMessageEVM;
    }

    if (data.signTypedDataJsonEVM) {
      this.signTypedDataJsonEVM = data.signTypedDataJsonEVM;
    }
  }
}

```

`zil-pay/background/storage/explorer.ts`:

```ts
export interface IExplorerState {
  name: string;
  url: string;
  icon: string | null;
  standard: number;
} 

export class Explorer implements IExplorerState {
  name: string;
  url: string;
  icon: string | null;
  standard: number;

  constructor(data: IExplorerState) {
    this.name = data.name;
    this.url = data.url;
    this.icon = data.icon ?? null;
    this.standard = data.standard;
  }
}

```

`zil-pay/background/storage/ftoken.ts`:

```ts
import { type AddressType } from "crypto/address";

export interface IFTokenState {
  name: string;
  symbol: string;
  decimals: number;
  addr: string;
  addrType: AddressType;
  logo: string | null;
  balances: Record<string, string>;
  rate: number;
  default_: boolean;
  native: boolean;
  chainHash: number;
}

export class FToken implements IFTokenState {
  name: string;
  symbol: string;
  decimals: number;
  addr: string;
  addrType: AddressType;
  logo: string | null;
  balances: Record<string, string>;
  rate: number;
  default_: boolean;
  native: boolean;
  chainHash: number;

  constructor(data: IFTokenState) {
    this.name = data.name;
    this.symbol = data.symbol;
    this.decimals = data.decimals;
    this.addr = data.addr;
    this.addrType = data.addrType;
    this.logo = data.logo ?? null;
    this.balances = data.balances;
    this.rate = data.rate;
    this.default_ = data.default_;
    this.native = data.native;
    this.chainHash = data.chainHash;
  }
}

```

`zil-pay/background/storage/index.ts`:

```ts
export * from './account';
export * from './argon';
export * from './background';
export * from './chain';
export * from './explorer';
export * from './ftoken';
export * from './notification';
export * from './settings';
export * from './wallet';

```

`zil-pay/background/storage/notification.ts`:

```ts
export class Notification {
  transactions: boolean;

  constructor(data: Record<string, unknown>) {
    this.transactions = data.transactions as boolean;
  }
}

```

`zil-pay/background/storage/settings.ts`:

```ts
import { WalletHashParams, type IWalletHashParams } from './argon';
import { CipherOrders } from '../../crypto/keychain';
import type { RatesApiOptions } from 'config/api';

export interface IWalletSettingsState {
  cipherOrders: CipherOrders[];
  hashFnParams: IWalletHashParams;
  currencyConvert: string;
  ipfsNode: string | null;
  ensEnabled: boolean;
  tokensListFetcher: boolean;
  nodeRankingEnabled: boolean;
  maxConnections: number;
  requestTimeoutSecs: number;
  ratesApiOptions: RatesApiOptions;
  sessionTime: number;
}

export class WalletSettings implements IWalletSettingsState {
  cipherOrders: CipherOrders[];
  hashFnParams: WalletHashParams;
  currencyConvert: string;
  ipfsNode: string | null;
  ensEnabled: boolean;
  tokensListFetcher: boolean;
  nodeRankingEnabled: boolean;
  maxConnections: number;
  requestTimeoutSecs: number;
  ratesApiOptions: RatesApiOptions;
  sessionTime: number;

  constructor(data: IWalletSettingsState) {
    this.cipherOrders = data.cipherOrders;
    this.hashFnParams = new WalletHashParams(data.hashFnParams);
    this.currencyConvert = data.currencyConvert;
    this.ipfsNode = data.ipfsNode;
    this.ensEnabled = data.ensEnabled;
    this.tokensListFetcher = data.tokensListFetcher;
    this.nodeRankingEnabled = data.nodeRankingEnabled;
    this.maxConnections = data.maxConnections;
    this.requestTimeoutSecs = data.requestTimeoutSecs;
    this.ratesApiOptions = data.ratesApiOptions;
    this.sessionTime = data.sessionTime ?? 3600;
  }
}

```

`zil-pay/background/storage/wallet.ts`:

```ts
import type { Bip32Account, IAccountState } from './account';
import { base64ToUint8Array, uint8ArrayToBase64 } from '../../crypto/b64';
import { generateSalt } from '../../lib/runtime';
import { Account } from './account';
import { FToken, type IFTokenState } from './ftoken';
import { WalletSettings, type IWalletSettingsState } from './settings';
import { Session } from '../secure/session';
import { ChainConfig } from './chain';
import { Bip39 } from '../../crypto/bip39';
import { uuid } from '../../crypto/uuid';
import { TypeOf } from 'lib/types';
import { KeyPair } from 'crypto/keypair';
import { uint8ArrayToUtf8, utf8ToUint8Array } from 'lib/utils/utf8';
import { HistoricalTransaction, type IHistoricalTransactionState } from 'background/rpc/history_tx';
import { ConfirmState, type IConfirmState } from './confirm';
import { AuthMethod, WalletTypes } from 'config/wallet';

export interface IWalletState {
  uuid: string;
  walletType: WalletTypes;
  walletName: string;
  authType: AuthMethod;
  accounts: IAccountState[];
  selectedAccount: number;
  tokens: IFTokenState[];
  history: IHistoricalTransactionState[];
  confirm: IConfirmState[];
  settings: IWalletSettingsState;
  defaultChainHash: number;
  vault?: string;
}

export class Wallet implements IWalletState {
  #session: Session;
  #vault: string;

  uuid: string;
  walletType: WalletTypes;
  walletName: string;
  authType: AuthMethod;
  accounts: Account[];
  selectedAccount: number;
  tokens: FToken[];
  history: HistoricalTransaction[];
  confirm: ConfirmState[];
  settings: WalletSettings;
  defaultChainHash: number;

  constructor(data: IWalletState) {
    this.walletType = data.walletType as WalletTypes;
    this.walletName = data.walletName as string;
    this.authType = data.authType as AuthMethod;
    this.accounts = (data.accounts).map(
      (a) => new Account(a)
    );
    this.selectedAccount = data.selectedAccount as number;
    this.tokens = (data.tokens).map(
      (t) => new FToken(t)
    );
    this.settings = new WalletSettings(data.settings);
    this.defaultChainHash = data.defaultChainHash as number;
    this.uuid = data.uuid as string;
    this.history = TypeOf.isArray(data.history) ? data.history.map((h) => new HistoricalTransaction(h)) : [];
    this.confirm = TypeOf.isArray(data.confirm) ? data.confirm.map((c) => new ConfirmState(c)) : [];
    this.#session = new Session(this.uuid);

    this.#vault = data.vault as string ?? "";
  }

  static async fromPrivateKey(
    keyPair: KeyPair,
    walletName: string,
    accountName: string,
    settings: WalletSettings,
    chain: ChainConfig,
    password: string,
  ) {
    const passwordBytes = utf8ToUint8Array(password);
    const account = await Account.fromPrivateKey(keyPair.privateKey, chain, accountName);
    const wallet = new Wallet({
      settings,
      walletName,
      walletType: WalletTypes.SecretKey,
      selectedAccount: 0,
      tokens: chain.ftokens,
      defaultChainHash: chain.hash(),
      uuid: uuid(),
      accounts: [account],
      authType: AuthMethod.None,
      history: [],
      confirm: [],
    });

    await wallet.encrypt(passwordBytes, keyPair.privateKey);

    return wallet;
  }

  static async fromBip39(
    words: string,
    verifyCheckSum: boolean,
    walletName: string,
    bip32Accounts: Bip32Account[],
    settings: WalletSettings,
    chain: ChainConfig,
    password: string,
    wordList: string[],
    passphrase?: string
  ) {
    if (verifyCheckSum) {
      await Bip39.validateMnemonic(words, wordList);
    }

    const seed = await Bip39.mnemonicToSeed(words, passphrase);
    const wallet = new Wallet({
      settings,
      walletName,
      walletType: WalletTypes.SecretPhrase,
      selectedAccount: 0,
      tokens: chain.ftokens,
      defaultChainHash: chain.hash(),
      uuid: uuid(),
      accounts: [],
      authType: AuthMethod.None,
      history: [],
      confirm: [],
    });
    const passwordBytes = utf8ToUint8Array(password);
    const wordsBytes = utf8ToUint8Array(words);

    wallet.accounts = await Promise.all(bip32Accounts.map((acc) => Account.fromBip39(acc, chain, seed)));
    await wallet.encrypt(passwordBytes, wordsBytes);

    return wallet;
  }

  async decrypt(password: Uint8Array): Promise<Uint8Array | string> {
    const salt = await generateSalt();
    const keychain = await this.settings.hashFnParams.deriveKey(password, salt);
    const ciphertext = base64ToUint8Array(this.#vault);
    const decrypted = await keychain.decrypt(ciphertext, this.settings.cipherOrders);

    if (this.walletType == WalletTypes.SecretKey) {      
      return decrypted;
    } else if (this.walletType == WalletTypes.SecretPhrase) {
      return uint8ArrayToUtf8(decrypted);
    } else {
      throw new Error("unknown wallet type");
    }
  }

  async encrypt(password: Uint8Array, plaintext: Uint8Array) : Promise<Uint8Array>{
    const salt = await generateSalt();
    const keychain = await this.settings.hashFnParams.deriveKey(password, salt);
    const cipher = await keychain.encrypt(plaintext, this.settings.cipherOrders);

    this.#vault = uint8ArrayToBase64(cipher);

    return cipher;
  }

  async unlock(password: Uint8Array) {
    const wordsOrKey = await this.decrypt(password);
    const sessionTime = this.settings.sessionTime;

    if (TypeOf.isString(wordsOrKey)) {
      const seed = await Bip39.mnemonicToSeed(String(wordsOrKey));

      await this.#session.setSession(sessionTime, seed);
    } else if (wordsOrKey instanceof Uint8Array) {
      await this.#session.setSession(sessionTime, wordsOrKey);
    } else {
      throw new Error("unk vault");
    }
  }

  async revealKeypair(accountIndex: number, chain: ChainConfig): Promise<KeyPair> {
    if (chain.hash() !== this.defaultChainHash) {
      throw new Error("invlid chain");
    }

    switch (this.walletType) {
      case WalletTypes.SecretPhrase:
        const seed = await this.#session.getVault();
        return KeyPair.fromSeed(seed, chain.slip44, accountIndex);
      case WalletTypes.SecretKey:
        const privateKey = await this.#session.getVault();
        return KeyPair.fromPrivateKey(privateKey, chain.slip44);
      default:
        throw new Error(`Invalid wallet type ${WalletTypes[this.walletType]}`);
    }
  }

  async revealMnemonic(password: Uint8Array, chain: ChainConfig): Promise<string> {
    if (chain.hash() !== this.defaultChainHash) {
      throw new Error("invlid chain");
    }

    switch (this.walletType) {
      case WalletTypes.SecretPhrase:
        const words = await this.decrypt(password);

        return String(words);
      default:
        throw new Error(`Invalid wallet type ${WalletTypes[this.walletType]}`);
    }
  }

  async clearSession() {
    await this.#session.clearSession();
  }

  get vault() {
    return this.#vault;
  }
}

```

`zil-pay/config/api.ts`:

```ts
export enum RatesApiOptions {
  CoinGecko,
  None,
}

```

`zil-pay/config/argon2.ts`:

```ts
import { utils } from "aes-js";

export const WALLET_SALT = utils.utf8.toBytes(
  "ZILPAY:54040c2f-1ec1-4eb1-9595-6e4294d14fd6",
);
export const APP_ID = utils.utf8.toBytes("ZilPay-wallet-app");

```

`zil-pay/config/bip39.ts`:

```ts
export const LANGUAGE_OPTIONS = [
  { code: 'en', label: 'English' },
  { code: 'ja', label: '日本語' },
  { code: 'ko', label: '한국어' },
  { code: 'es', label: 'Español' }
];
export const ALLOWED_COUNTS = [12, 15, 18, 21, 24];

```

`zil-pay/config/common.ts`:

```ts
export enum Common {
  TIME_BEFORE_LOCK = 3,
  POPUP_WIDTH = 320,
  POPUP_HEIGHT = 600,
  PROMT_PAGE = "index.html",
  NONCE_DIFFICULTY = 10,
  MAX_TX_QUEUE = 20,
}

export const WORKER_POOLING = 8000; // Seconds

```

`zil-pay/config/fields.ts`:

```ts
export enum OldFields {
  VAULT = "vault",
  VAULT_IMPORTED = "importedvault",
  CONFIG = "config",
  OLD_WALLET = "wallet",
  WALLET = "wallet-identities",
  SELECTED_NET = "selectednet",
  BLOCK_NUMBER = "blocknumber",
  TRANSACTIONS = "transactions",
  ENCRYPT_DATA = "encryption-data",
  DECRYPT_DATA = "decryption-data",
  CONFIRM_TX = "confirm",
  CONFIRM_MESSAGE = "confirm-message",
  STATIC = "static",
  LOCK_TIME = "time_before_lock",
  GUARD_CONFIG = "guard-configuration",
  CONNECT_DAPP = "connect",
  CONNECT_LIST = "connection-list",
  THEME = "theme",
  CONTACTS = "contacts",
  SELECTED_COIN = "selectedcoin",
  TOKENS = "tokens-list",
  COLLECTION = "collections-list",
  SSN = "ssn-list",
  GAS = "chain-gas",
  RATE_CURRENCIES = "rate-of-currencies",
  SELECTED_CURRENCY = "selected-currency",
  LOCALE = "selected-local",
  FORMAT = "address-format",
  POPUP_ENABLED = "popup-enabled",
  PHISHING = "phishing-detection",
  DEX = "dex-proto",
  BADGE_COUNTER = "badge-counter",
}

export enum Fields {
  STORAGE_V4 = "storage-v4",
}

```

`zil-pay/config/jsonrpc.ts`:

```ts
/**
 * Enum for Zilliqa JSON-RPC methods.
 */
export enum ZilMethods {
  GetSmartContractInit = "GetSmartContractInit",
  GetBalance = "GetBalance",
  GetSmartContractSubState = "GetSmartContractSubState",
  GetNetworkId = "GetNetworkId",
  GetPendingTxn = "GetPendingTxn",
  GetTransaction = "GetTransaction",
  CreateTransaction = "CreateTransaction",
  GetTransactionStatus = "GetTransactionStatus",
  GetLatestTxBlock = "GetLatestTxBlock",
  GetTxBlock = "GetTxBlock",
  GetRecentTransactions = "GetRecentTransactions",
  GetMinimumGasPrice = "GetMinimumGasPrice",
}

/**
 * Enum for EVM-compatible JSON-RPC methods.
 */
export enum EvmMethods {
  // State Methods
  GetBalance = "eth_getBalance",
  GetStorageAt = "eth_getStorageAt",
  GetTransactionCount = "eth_getTransactionCount",
  GetBlockTransactionCountByHash = "eth_getBlockTransactionCountByHash",
  GetBlockTransactionCountByNumber = "eth_getBlockTransactionCountByNumber",
  GetCode = "eth_getCode",
  Call = "eth_call",
  EstimateGas = "eth_estimateGas",

  // Block Methods
  BlockNumber = "eth_blockNumber",
  GetBlockByHash = "eth_getBlockByHash",
  GetBlockByNumber = "eth_getBlockByNumber",
  GetBlockReceipts = "eth_getBlockReceipts",

  // Transaction Methods
  SendRawTransaction = "eth_sendRawTransaction",
  GetTransactionByHash = "eth_getTransactionByHash",
  GetTransactionByBlockHashAndIndex = "eth_getTransactionByBlockHashAndIndex",
  GetTransactionByBlockNumberAndIndex = "eth_getTransactionByBlockNumberAndIndex",
  GetTransactionReceipt = "eth_getTransactionReceipt",

  // Account Methods
  Accounts = "eth_accounts",
  GetProof = "eth_getProof",

  // Chain State
  ChainId = "eth_chainId",
  NetworkVersion = "net_version",
  Syncing = "eth_syncing",
  GasPrice = "eth_gasPrice",
  MaxPriorityFeePerGas = "eth_maxPriorityFeePerGas",
  FeeHistory = "eth_feeHistory",
  BlobBaseFee = "eth_blobBaseFee",

  // Filter Methods
  NewFilter = "eth_newFilter",
  NewBlockFilter = "eth_newBlockFilter",
  NewPendingTransactionFilter = "eth_newPendingTransactionFilter",
  UninstallFilter = "eth_uninstallFilter",
  GetFilterChanges = "eth_getFilterChanges",
  GetFilterLogs = "eth_getFilterLogs",
  GetLogs = "eth_getLogs",

  // Contract Methods
  Sign = "eth_sign",
  SignTransaction = "eth_signTransaction",
}

```

`zil-pay/config/locale.ts`:

```ts
export enum Locales {
  Auto = "auto",
  EN = "en",
  RU = "ru",
  JA = "ja",
  ZH = "zh",
}

```

`zil-pay/config/manifest.ts`:

```ts
export enum ManifestVersions {
  V2 = 2,
  V3 = 3,
}

```

`zil-pay/config/pbkdf2.ts`:

```ts
export enum ShaAlgorithms {
  Sha512 = "SHA-512",
  sha256 = "SHA-256",
}

```

`zil-pay/config/sha.ts`:

```ts
export enum ShaAlgorithms {
  Sha512 = "SHA-512",
  sha256 = "SHA-256",
}

```

`zil-pay/config/slip44.ts`:

```ts
export const ETHEREUM = 60;
export const ZILLIQA = 313;

```

`zil-pay/config/stream.ts`:

```ts
const app = "BearBy";

export const MTypePopup = {
  GET_GLOBAL_STATE: `@/${app}/get-global-state`,
  SET_GLOBAL_STATE: `@/${app}/set-global-state`,

  GEN_BIP39: `@/${app}/gen-bip39-words`,
  VALIDATE_BIP39_CHECK_SUM: `@/${app}/validate-bip39-checksum`,
  GEN_KEYPAIR: `@/${app}/gen-key-pair`,
  FROM_PRIV_KEY: `@/${app}/keypair-from-private-key`,
}


```

`zil-pay/config/theme.ts`:

```ts
export enum Themes {
  System = "system",
  Light = "light",
  Dark = "dark",
}

```

`zil-pay/config/wallet.ts`:

```ts
export enum WalletTypes {
    Ledger,
    SecretPhrase,
    SecretKey,
}

export enum AuthMethod {
    Biometric,
    None,
}

```

`zil-pay/crypto/address.ts`:

```ts
import { addr as ethAddr } from "micro-eth-signer";
import {
  fromBech32Address,
  fromZilPubKey,
  toBech32Address,
  toChecksumBytesAddress,
} from "lib/zilliqa";
import { KeyPair } from "./keypair";
import { HRP } from "lib/zilliqa/config";
import { hasHexPrefix, hexToUint8Array, uint8ArrayToHex } from "lib/utils/hex";

export enum AddressType {
  Bech32,
  EthCheckSum,
}

export class Address {
  readonly #bytes: Uint8Array;
  #type: AddressType;

  get bytes() {
    return this.#bytes;
  }

  get type() {
    return this.#type;
  }

  static empty(slip44: number) {
    const addressType = KeyPair.addressType(slip44);
    return new Address(new Uint8Array(20), addressType);
  }

  static fromStr(address: string) {
    if (hasHexPrefix(address)) {
      const ethCheckSumAddress = ethAddr.parse(address);
      const bytes = hexToUint8Array(ethCheckSumAddress.data);

      return new Address(bytes, AddressType.EthCheckSum);
    } else if (address.startsWith(HRP)) {
      const checkSumZil = fromBech32Address(address);
      const bytes = hexToUint8Array(checkSumZil);

      return new Address(bytes, AddressType.Bech32);
    }

    throw new Error("Unsupported address format");
  }

  static async fromPubKey(pubKey: Uint8Array, slip44: number) {
    const addressType = KeyPair.addressType(slip44);

    switch (addressType) {
      case AddressType.Bech32:
        const zilBytes = await fromZilPubKey(pubKey);

        return new Address(zilBytes, addressType);
      case AddressType.EthCheckSum:
        const ethChecsumAddress = ethAddr.fromPublicKey(pubKey);
        const ethBytes = hexToUint8Array(ethChecsumAddress);

        return new Address(ethBytes, addressType);
    }
  }

  static async fromPrivateKey(privateKey: Uint8Array, slip44: number) {
    const keypair = await KeyPair.fromPrivateKey(privateKey, slip44);
    const addressType = keypair.addressType();

    switch (addressType) {
      case AddressType.Bech32:
        const base16 = await fromZilPubKey(keypair.pubKey);
        return new Address(base16, addressType);

      case AddressType.EthCheckSum:
        const ethChecsumAddress = ethAddr.fromPublicKey(keypair.pubKey);
        const ethBytes = hexToUint8Array(ethChecsumAddress);

        return new Address(ethBytes, addressType);
    }
  }

  constructor(bytes: Uint8Array, type: AddressType) {
    this.#bytes = bytes;
    this.#type = type;
  }

  toBase16(): string {
    return uint8ArrayToHex(this.bytes);
  }

  async autoFormat() {
    switch (this.#type) {
      case AddressType.Bech32:
        return this.toZilBech32();
      case AddressType.EthCheckSum:
        return this.toEthChecksum();
    }
  }

  async toEthChecksum(): Promise<string> {
    const nonChecksummedAddress = uint8ArrayToHex(this.bytes);
    return ethAddr.addChecksum(nonChecksummedAddress);
  }

  async toZilChecksum(): Promise<string> {
    return toChecksumBytesAddress(this.bytes);
  }

  async toZilBech32(): Promise<string> {
    const zilChecSum = await this.toZilChecksum();

    return toBech32Address(zilChecSum);
  }
}

```

`zil-pay/crypto/aes256.ts`:

```ts
import { Counter, ModeOfOperation } from "aes-js";
import { randomBytes } from "../crypto/random";
import { md5 } from "js-md5";
import { uint8ArrayToUtf8, utf8ToUint8Array } from "lib/utils/utf8";
import { hexToUint8Array, uint8ArrayToHex } from "lib/utils/hex";

export enum ErrorMessages {
  InvalidKeyLength = "Invalid key length provided. Key must be 16, 24, or 32 bytes.",
  IncorrectParams = "Password is not correct",
}

export const AESCipherV3 = Object.freeze({
  encrypt(content: Uint8Array, key: Uint8Array): Uint8Array {
    if (![16, 24, 32].includes(key.length)) {
      throw new Error(ErrorMessages.InvalidKeyLength);
    }

    const entropy = randomBytes(16);
    const iv = new Counter(entropy);
    const aesCtr = new ModeOfOperation.ctr(key, iv);
    const encrypted = aesCtr.encrypt(content);
    const bytes = utf8ToUint8Array(
      `${uint8ArrayToHex(encrypted)}/${uint8ArrayToHex(entropy)}`,
    );
    return bytes;
  },
  decrypt(bytes: Uint8Array, key: Uint8Array): Uint8Array {
    if (![16, 24, 32].includes(key.length)) {
      throw new Error(ErrorMessages.InvalidKeyLength);
    }

    const [encrypted, iv] = uint8ArrayToUtf8(bytes).split("/");
    const counter = new Counter(hexToUint8Array(iv));
    const aesCtr = new ModeOfOperation.ctr(key, counter);
    return aesCtr.decrypt(hexToUint8Array(encrypted));
  },
});

export const AESCipherV2 = Object.freeze({
  async decrypt(data: Uint8Array, key: Uint8Array): Promise<any> {
    const combined = data;

    const prefix = new TextDecoder().decode(combined.slice(0, 8));
    if (prefix !== "Salted__") {
      throw new Error(ErrorMessages.IncorrectParams);
    }

    const salt = combined.slice(8, 16);
    const ciphertext = combined.slice(16);
    const passwordBytes = key;
    const { key: derivedKey, iv } = await AESCipherV2.evpKDF(
      passwordBytes,
      salt,
      32,
      16,
    );

    const cryptoKey = await crypto.subtle.importKey(
      "raw",
      derivedKey,
      { name: "AES-CBC" },
      false,
      ["decrypt"],
    );

    let decrypted: ArrayBuffer;
    try {
      decrypted = await crypto.subtle.decrypt(
        { name: "AES-CBC", iv },
        cryptoKey,
        ciphertext,
      );
    } catch {
      throw new Error("ErrorMessages.IncorrectPassword");
    }

    const content = new TextDecoder().decode(decrypted);
    if (!content) {
      throw new Error("ErrorMessages.IncorrectPassword");
    }

    try {
      return JSON.parse(content);
    } catch {
      return content;
    }
  },

  async evpKDF(
    password: Uint8Array,
    salt: Uint8Array,
    keySize: number,
    ivSize: number,
  ): Promise<{ key: Uint8Array; iv: Uint8Array }> {
    const totalSize = keySize + ivSize;
    let derived = new Uint8Array(0);
    let previousBlock = new Uint8Array(0);

    while (derived.length < totalSize) {
      const input = new Uint8Array([...previousBlock, ...password, ...salt]);
      const block = await AESCipherV2.md5Hash(input);
      derived = new Uint8Array([...derived, ...block]);
      previousBlock = Uint8Array.from(block);
    }

    const key = derived.slice(0, keySize);
    const iv = derived.slice(keySize, keySize + ivSize);
    return { key, iv };
  },

  async md5Hash(data: Uint8Array): Promise<Uint8Array> {
    const hasher = md5.create();
    hasher.update(data);
    const hash = hasher.arrayBuffer();
    return new Uint8Array(hash);
  },
});

```

`zil-pay/crypto/argon2.ts`:

```ts
import { Config, hashRaw } from "@hicaru/argon2-pure.js";
import { WALLET_SALT } from "../config/argon2";

export type Argon2Config = Config;

export function deriveArgon2Key(
  password: Uint8Array,
  saltBytes: Uint8Array,
  config: Argon2Config,
) {
  const combinedSalt = new Uint8Array(saltBytes.length + WALLET_SALT.length);

  combinedSalt.set(saltBytes, 0);
  combinedSalt.set(WALLET_SALT, saltBytes.length);

  const hash = hashRaw(password, combinedSalt, config);

  return hash;
}

```

`zil-pay/crypto/b64.ts`:

```ts
/**
 * Converts a base64 string to a Uint8Array.
 * @param base64 - The base64 string to convert.
 * @returns A Uint8Array containing the decoded data.
 * @throws {Error} If the input string is not a valid base64 string.
 */
export function base64ToUint8Array(base64: string): Uint8Array {
  try {
    const binaryString = atob(base64);
    const length = binaryString.length;
    const bytes = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  } catch (error) {
    throw new Error("Invalid base64 string");
  }
}

/**
 * Converts a Uint8Array to a base64 string.
 * @param uint8Array - The Uint8Array to convert.
 * @returns A base64 string representing the input data.
 */
export function uint8ArrayToBase64(uint8Array: Uint8Array): string {
  const binaryString = String.fromCharCode(...uint8Array);
  return btoa(binaryString);
}

```

`zil-pay/crypto/bip32.ts`:

```ts
import { getPublicKey } from "@noble/secp256k1";
import { utils } from "@noble/secp256k1";
import {
  bigIntToUint8ArrayBigEndian,
  uint8ArrayToBigIntBigEndian,
} from "./number";
import { ShaAlgorithms } from "../config/pbkdf2";
import { ETHEREUM, ZILLIQA } from "../config/slip44";

const HARDENED_BIT = 0x80000000;
const BITCOIN_SEED = new TextEncoder().encode("Bitcoin seed");

export enum Bip32ErrorCode {
  InvalidChild = "InvalidChild",
  InvalidPath = "InvalidPath",
  InvalidSlip44 = "invalid slip44",
  InvalidKey = "InvalidKey",
  HmacError = "HmacError",
}

export class Bip32Error extends Error {
  constructor(code: Bip32ErrorCode, message: string) {
    super(message);
    this.name = `Bip32Error:${code}`;
  }
}

export class ChildNumber {
  constructor(public value: number) {}

  isHardened(): boolean {
    return this.value < 0;
  }

  toBytes(): Uint8Array {
    const buffer = new Uint8Array(4);
    buffer[0] = (this.value >>> 24) & 0xff;
    buffer[1] = (this.value >>> 16) & 0xff;
    buffer[2] = (this.value >>> 8) & 0xff;
    buffer[3] = this.value & 0xff;
    return buffer;
  }

  static fromString(s: string): ChildNumber {
    let numStr = s;
    let hardened = false;
    if (s.endsWith("'")) {
      numStr = s.slice(0, -1);
      hardened = true;
    }
    const index = parseInt(numStr, 10);
    if (isNaN(index) || index < 0) {
      throw new Bip32Error(
        Bip32ErrorCode.InvalidChild,
        `Failed to parse child number: ${s}`,
      );
    }
    const value = hardened ? index | HARDENED_BIT : index;
    return new ChildNumber(value);
  }
}

async function hmacSha512(
  key: Uint8Array,
  data: Uint8Array,
): Promise<Uint8Array> {
  try {
    const importedKey = await globalThis.crypto.subtle.importKey(
      "raw",
      key,
      {
        name: "HMAC",
        hash: { name: ShaAlgorithms.Sha512 },
      },
      false,
      ["sign"],
    );

    const signature = await globalThis.crypto.subtle.sign(
      "HMAC",
      importedKey,
      data,
    );

    return new Uint8Array(signature);
  } catch (error) {
    throw new Bip32Error(
      Bip32ErrorCode.HmacError,
      `HMAC computation failed: ${error}`,
    );
  }
}

export async function deriveMasterKey(
  seed: Uint8Array,
): Promise<{ key: Uint8Array; chainCode: Uint8Array }> {
  const hmacResult = await hmacSha512(BITCOIN_SEED, seed);
  const key = new Uint8Array(hmacResult.slice(0, 32));
  const chainCode = new Uint8Array(hmacResult.slice(32, 64));

  if (!utils.isValidPrivateKey(key)) {
    throw new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid master key");
  }

  return { key, chainCode };
}

export async function deriveChildKey(
  parentKey: Uint8Array,
  chainCode: Uint8Array,
  child: ChildNumber,
): Promise<{ key: Uint8Array; chainCode: Uint8Array }> {
  if (!utils.isValidPrivateKey(parentKey)) {
    throw new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid parent key");
  }

  let dataToHash: Uint8Array;

  if (child.isHardened()) {
    dataToHash = new Uint8Array([0, ...parentKey, ...child.toBytes()]);
  } else {
    const publicKey = getPublicKey(parentKey, true);
    dataToHash = new Uint8Array([...publicKey, ...child.toBytes()]);
  }

  const hmacResult = await hmacSha512(chainCode, dataToHash);
  const childKeyPart = new Uint8Array(hmacResult.slice(0, 32));
  const newChainCode = new Uint8Array(hmacResult.slice(32, 64));

  const curveOrder = BigInt(
    "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141",
  );

  let parentScalar = uint8ArrayToBigIntBigEndian(parentKey);
  let childScalar = uint8ArrayToBigIntBigEndian(childKeyPart);

  childScalar = childScalar % curveOrder;

  let sum = (parentScalar + childScalar) % curveOrder;

  if (sum === 0n) {
    throw new Bip32Error(
      Bip32ErrorCode.InvalidKey,
      "Invalid child key: sum is zero",
    );
  }

  const resultKey = bigIntToUint8ArrayBigEndian(sum, 32);

  if (!utils.isValidPrivateKey(resultKey)) {
    throw new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid child key");
  }

  return { key: resultKey, chainCode: newChainCode };
}

export async function derivePrivateKey(
  seed: Uint8Array,
  path: string,
): Promise<Uint8Array> {
  if (!path.startsWith("m/")) {
    throw new Bip32Error(
      Bip32ErrorCode.InvalidPath,
      "Path must start with 'm/'",
    );
  }

  const pathParts = path
    .slice(2)
    .split("/")
    .filter((part) => part !== "");

  let { key, chainCode } = await deriveMasterKey(seed);

  for (const part of pathParts) {
    const childNumber = ChildNumber.fromString(part);
    const result = await deriveChildKey(key, chainCode, childNumber);
    key = result.key;
    chainCode = result.chainCode;
  }

  return key;
}

export async function deriveFromPrivateKeyPublicKey(
  privateKey: Uint8Array,
  slip44: number,
  compressed = true,
): Promise<Uint8Array> {
  if (slip44 == ZILLIQA || slip44 == ETHEREUM) {
    return getPublicKey(privateKey, compressed);
  }

  throw new Error(Bip32ErrorCode.InvalidSlip44);
}

```

`zil-pay/crypto/bip39.ts`:

```ts
import { pbkdf2 } from "./pbkdf2";
import { ShaAlgorithms } from "../config/pbkdf2";
import { randomBytes } from "./random";
import { assert } from "../lib/runtime/assert";
import { sha256 } from "./sha256";

// BIP-39 constants
const ENTROPY_BITS = [128, 160, 192, 224, 256];
const PBKDF2_ITERATIONS = 2048;
const SEED_LENGTH = 64; // 512 bits

export interface Mnemonic {
  phrase: string;
  words: string[];
}

export enum Bip39Error {
  InvalidEntropy = "Invalid entropy length. Must be 128, 160, 192, 224, or 256 bits.",
  InvalidMnemonic = "Invalid mnemonic phrase.",
  InvalidWord = "Mnemonic contains invalid word(s) not in wordlist.",
  InvalidWordCount = "Invalid number of words. Must be 12, 15, 18, 21, or 24.",
  InvalidChecksum = "Mnemonic checksum is invalid.",
}

export const Bip39 = Object.freeze({
  /**
   * Generates a BIP-39 mnemonic from random entropy.
   * @param entropyBits - Number of entropy bits (128, 160, 192, 224, or 256).
   * @returns A mnemonic object with phrase and words.
   * @throws Error if entropyBits is invalid.
   */
  async generateMnemonic(
    entropyBits: number = 128,
    wordList: string[],
  ): Promise<Mnemonic> {
    assert(ENTROPY_BITS.includes(entropyBits), Bip39Error.InvalidEntropy);

    const entropyBytes = entropyBits / 8;
    const entropy = randomBytes(entropyBytes);
    const checksumBits = entropyBits / 32;
    const totalBits = entropyBits + checksumBits;
    const wordCount = totalBits / 11;

    // Compute SHA-256 checksum
    const hash = await sha256(entropy);
    const checksum = hash[0] >> (8 - checksumBits);

    // Combine entropy and checksum
    const entropyBitsStr = Array.from(entropy)
      .map((byte) => byte.toString(2).padStart(8, "0"))
      .join("");
    const checksumBitsStr = checksum.toString(2).padStart(checksumBits, "0");
    const bits = entropyBitsStr + checksumBitsStr;

    // Split into 11-bit chunks to select words
    const words: string[] = [];
    for (let i = 0; i < wordCount; i++) {
      const start = i * 11;
      const chunk = bits.slice(start, start + 11);
      const index = parseInt(chunk, 2);
      words.push(wordList[index]);
    }

    return {
      phrase: words.join(" "),
      words,
    };
  },

  /**
   * Validates a BIP-39 mnemonic phrase.
   * @param mnemonic - The mnemonic phrase to validate.
   * @returns True if valid, throws error otherwise.
   * @throws Error if mnemonic is invalid.
   */
  async validateMnemonic(
    mnemonic: string,
    wordList: string[],
  ): Promise<boolean> {
    const words = mnemonic.trim().split(/\s+/);
    const wordCount = words.length;
    const validWordCounts = [12, 15, 18, 21, 24];

    assert(validWordCounts.includes(wordCount), Bip39Error.InvalidWordCount);

    // Verify all words are in wordlist
    for (const word of words) {
      assert(wordList.includes(word), `${Bip39Error.InvalidWord}, ${word}`);
    }

    // Reconstruct entropy and checksum
    const bits = words
      .map((word) => {
        const index = wordList.indexOf(word);
        return index.toString(2).padStart(11, "0");
      })
      .join("");

    const entropyBits = wordCount * 11 - wordCount / 3;
    const entropy = bits.slice(0, entropyBits);
    const checksum = bits.slice(entropyBits);

    // Convert entropy bits to bytes
    const entropyBytes = new Uint8Array(entropyBits / 8);
    for (let i = 0; i < entropyBytes.length; i++) {
      entropyBytes[i] = parseInt(entropy.slice(i * 8, (i + 1) * 8), 2);
    }

    // Verify checksum
    const hash = await sha256(entropyBytes);
    const computedChecksum = hash[0] >> (8 - wordCount / 3);
    const expectedChecksum = parseInt(checksum, 2);

    assert(computedChecksum === expectedChecksum, Bip39Error.InvalidChecksum);

    return true;
  },

  /**
   * Derives a seed from a BIP-39 mnemonic using PBKDF2.
   * @param mnemonic - The mnemonic phrase.
   * @param passphrase - Optional passphrase (default: empty string).
   * @returns A 512-bit seed as Uint8Array.
   * @throws Error if mnemonic is invalid.
   */
  async mnemonicToSeed(
    mnemonic: string,
    passphrase: string = "",
  ): Promise<Uint8Array> {
    const password = new TextEncoder().encode(mnemonic);
    const salt = new TextEncoder().encode(`mnemonic${passphrase}`);
    const seed = await pbkdf2(
      password,
      salt,
      PBKDF2_ITERATIONS,
      ShaAlgorithms.Sha512,
    );

    return seed;
  },

  /**
   * Converts a mnemonic to entropy.
   * @param mnemonic - The mnemonic phrase.
   * @returns The original entropy as Uint8Array.
   * @throws Error if mnemonic is invalid.
   */
  async mnemonicToEntropy(
    mnemonic: string,
    wordList: string[],
  ): Promise<Uint8Array> {
    assert(
      await Bip39.validateMnemonic(mnemonic, wordList),
      Bip39Error.InvalidMnemonic,
    );

    const words = mnemonic.trim().split(/\s+/);
    const wordCount = words.length;
    const entropyBits = wordCount * 11 - wordCount / 3;

    const bits = words
      .map((word) => {
        const index = wordList.indexOf(word);
        return index.toString(2).padStart(11, "0");
      })
      .join("");

    const entropy = bits.slice(0, entropyBits);
    const entropyBytes = new Uint8Array(entropyBits / 8);
    for (let i = 0; i < entropyBytes.length; i++) {
      entropyBytes[i] = parseInt(entropy.slice(i * 8, (i + 1) * 8), 2);
    }

    return entropyBytes;
  },

  /**
   * Converts entropy to a BIP-39 mnemonic phrase.
   * @param entropy - The entropy as a Uint8Array (must be 16, 20, 24, 28, or 32 bytes).
   * @param wordList - The BIP-39 wordlist.
   * @returns A mnemonic object with phrase and words.
   * @throws Error if entropy length is invalid.
   */
  async entropyToMnemonic(
    entropy: Uint8Array,
    wordList: string[],
  ): Promise<Mnemonic> {
    const entropyBits = entropy.length * 8;
    assert(ENTROPY_BITS.includes(entropyBits), Bip39Error.InvalidEntropy);

    const checksumBits = entropyBits / 32;
    const totalBits = entropyBits + checksumBits;
    const wordCount = totalBits / 11;

    // Compute SHA-256 checksum
    const hash = await sha256(entropy);
    const checksum = hash[0] >> (8 - checksumBits);

    // Combine entropy and checksum
    const entropyBitsStr = Array.from(entropy)
      .map((byte) => byte.toString(2).padStart(8, "0"))
      .join("");
    const checksumBitsStr = checksum.toString(2).padStart(checksumBits, "0");
    const bits = entropyBitsStr + checksumBitsStr;

    // Split into 11-bit chunks to select words
    const words: string[] = [];
    for (let i = 0; i < wordCount; i++) {
      const start = i * 11;
      const chunk = bits.slice(start, start + 11);
      const index = parseInt(chunk, 2);
      words.push(wordList[index]);
    }

    return {
      phrase: words.join(" "),
      words,
    };
  },
});

```

`zil-pay/crypto/bip49.ts`:

```ts
import { ZILLIQA, ETHEREUM } from "../config/slip44";

export class DerivationPath {
  private slip44: number;
  private index: number;

  constructor(slip44: number, index: number) {
    this.slip44 = slip44;
    this.index = index;
  }

  public getPath(): string {
    return `m/44'/${this.slip44}'/0'/0/${this.index}`;
  }

  public getBasePath(): string {
    return `m/44'/${this.slip44}'/0'/0/`;
  }

  public getIndex(): number {
    return this.index;
  }

  public toString(): string {
    return this.getPath();
  }
}

```

`zil-pay/crypto/keychain.ts`:

```ts
import type { Argon2Config } from "./argon2";
import { PrivKey, PubKey } from "@hicaru/ntrup.js";
import {
  NTRU_CONFIG,
  ntruDecrypt,
  ntruEncrypt,
  ntruKeysFromSeed,
} from "./ntrup";
import { sha256 } from "./sha256";
import { EXTENSION_ID } from "../lib/runtime";
import { deriveArgon2Key } from "./argon2";
import {
  kuznechikDecrypt,
  kuznechikEncrypt,
  KUZNECHIK_KEY_SIZE,
} from "./kuznechik";
import { AESCipherV3, AESCipherV2 } from "./aes256";
import { pbkdf2 } from "./pbkdf2";
import { ShaAlgorithms } from "../config/pbkdf2";
import { uint8ArrayToHex } from "lib/utils/hex";
import { utf8ToUint8Array } from "lib/utils/utf8";

export const PUBLICKEYS_BYTES = NTRU_CONFIG.PUBLICKEYS_BYTES;
export const SECRETKEYS_BYTES = NTRU_CONFIG.SECRETKEYS_BYTES;
export const AES_GCM_KEY_SIZE = KUZNECHIK_KEY_SIZE;
export const KEYCHAIN_BYTES_SIZE =
  PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE + KUZNECHIK_KEY_SIZE;

export async function deriveKeyFromSeed(
  seed: Uint8Array,
  idx: number,
): Promise<Uint8Array> {
  const hasher = new Uint8Array([...seed, idx]);
  return sha256(hasher);
}

export enum CipherOrders {
  AESCBC,
  AESGCM256,
  KUZNECHIK,
  NTRUP761,
}

export class KeyChain {
  public readonly ntrupKeys: { pk: PubKey; sk: PrivKey };
  public readonly aesKey: Uint8Array;
  public readonly kuznechikKey: Uint8Array;

  constructor(
    ntrupKeys: { pk: PubKey; sk: PrivKey },
    aesKey: Uint8Array,
    kuznechikKey: Uint8Array,
  ) {
    this.ntrupKeys = ntrupKeys;
    this.aesKey = aesKey;
    this.kuznechikKey = kuznechikKey;
  }

  static async fromSeed(seed: Uint8Array): Promise<KeyChain> {
    const ntrupKeys = ntruKeysFromSeed(seed);
    const aesKey = await deriveKeyFromSeed(seed, 0);
    const kuznechikKey = await deriveKeyFromSeed(seed, 1);

    return new KeyChain(ntrupKeys, aesKey, kuznechikKey);
  }

  static async fromAesV2(password: Uint8Array): Promise<KeyChain> {
    const keyHashBytes = await sha256(password);

    const keyHashHex = uint8ArrayToHex(keyHashBytes);
    const aesKeyForV2 = utf8ToUint8Array(keyHashHex);

    const ntrupKeys = ntruKeysFromSeed(
      Uint8Array.from([...keyHashBytes, ...keyHashBytes]),
    );

    return new KeyChain(ntrupKeys, aesKeyForV2, keyHashBytes);
  }

  static async fromAesV3(
    password: Uint8Array,
    algorithm: ShaAlgorithms,
    iteractions: number,
  ): Promise<KeyChain> {
    const salt = utf8ToUint8Array(EXTENSION_ID);
    const key = await pbkdf2(password, salt, iteractions, algorithm);
    const keyBytes = await sha256(key);
    const ntrupKeys = ntruKeysFromSeed(
      Uint8Array.from([...keyBytes, ...keyBytes]),
    );

    return new KeyChain(ntrupKeys, keyBytes, keyBytes);
  }

  static async fromPass(
    password: Uint8Array,
    fingerprint: Uint8Array,
    argonConfig: Argon2Config,
  ): Promise<KeyChain> {
    const seed = deriveArgon2Key(password, fingerprint, argonConfig);
    return KeyChain.fromSeed(seed);
  }

  static async fromBytes(bytes: Uint8Array): Promise<KeyChain> {
    if (bytes.length !== KEYCHAIN_BYTES_SIZE) {
      throw new Error("Invalid byte length");
    }
    const pkBytes = bytes.slice(0, PUBLICKEYS_BYTES);
    const skBytes = bytes.slice(
      PUBLICKEYS_BYTES,
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES,
    );
    const aesKey = bytes.slice(
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES,
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE,
    );
    const kuznechikKey = bytes.slice(
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE,
      KEYCHAIN_BYTES_SIZE,
    );

    const pk = PubKey.import(pkBytes, NTRU_CONFIG);
    const sk = PrivKey.import(skBytes, NTRU_CONFIG);

    return new KeyChain({ pk, sk }, aesKey, kuznechikKey);
  }

  toBytes(): Uint8Array {
    const pkBytes = this.ntrupKeys.pk.toBytes(NTRU_CONFIG);
    const skBytes = this.ntrupKeys.sk.toBytes(NTRU_CONFIG);
    const aesKey = this.aesKey;
    const kuznechikKey = this.kuznechikKey;

    const res = new Uint8Array(KEYCHAIN_BYTES_SIZE);
    res.set(pkBytes, 0);
    res.set(skBytes, PUBLICKEYS_BYTES);
    res.set(aesKey, PUBLICKEYS_BYTES + SECRETKEYS_BYTES);
    res.set(
      kuznechikKey,
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE,
    );
    return res;
  }

  async encrypt(
    plaintext: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    let data = plaintext;
    for (const o of options) {
      switch (o) {
        case CipherOrders.AESCBC:
          throw new Error("OLD method, AESCBC");
        case CipherOrders.AESGCM256:
          data = AESCipherV3.encrypt(data, this.aesKey);
          break;
        case CipherOrders.KUZNECHIK:
          data = kuznechikEncrypt(this.kuznechikKey, data);
          break;
        case CipherOrders.NTRUP761:
          data = ntruEncrypt(this.ntrupKeys.pk, data);
          break;
      }
    }
    return data;
  }

  async decrypt(
    ciphertext: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    let data = ciphertext;
    for (const o of options.slice().reverse()) {
      switch (o) {
        case CipherOrders.AESCBC:
          const decryptedString = await AESCipherV2.decrypt(data, this.aesKey);
          data = new TextEncoder().encode(decryptedString);
          break;
        case CipherOrders.AESGCM256:
          data = AESCipherV3.decrypt(data, this.aesKey);
          break;
        case CipherOrders.KUZNECHIK:
          data = kuznechikDecrypt(this.kuznechikKey, data);
          break;
        case CipherOrders.NTRUP761:
          data = ntruDecrypt(this.ntrupKeys.sk, data);
          break;
      }
    }
    return data;
  }

  async makeProof(
    seed: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    return this.encrypt(seed, options);
  }

  async getProof(
    cipherProof: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    return this.decrypt(cipherProof, options);
  }
}

```

`zil-pay/crypto/keypair.ts`:

```ts
import type { TypedData } from "micro-eth-signer/typed-data.js";

import { ETHEREUM, ZILLIQA } from "config/slip44";
import { deriveFromPrivateKeyPublicKey, derivePrivateKey } from "./bip32";
import { DerivationPath } from "./bip49";
import { sign, verify } from "./zilliqa/schnorr";
import {
  personal,
  signTyped,
  verifyTyped,
} from "micro-eth-signer/typed-data.js";
import { hexToUint8Array, uint8ArrayToHex } from "lib/utils/hex";
import { Signature } from "@noble/secp256k1";
import { randomBytes } from "./random";
import { Address, AddressType } from "./address";

export class KeyPair {
  #privateKey: Uint8Array;
  #pubKey: Uint8Array;
  #slip44: number;

  static addressType(slip44: number): AddressType {
    switch (slip44) {
      case ZILLIQA:
        return AddressType.Bech32;
      case ETHEREUM:
        return AddressType.EthCheckSum;
      default:
        return AddressType.EthCheckSum;
    }
  }

  static async fromPrivateKey(privateKey: Uint8Array, slip44: number) {
    const pubKey = await deriveFromPrivateKeyPublicKey(privateKey, slip44);

    return new KeyPair(privateKey, pubKey, slip44);
  }

  static async generate(slip44: number) {
    const privateKey = randomBytes(32);
    const pubKey = await deriveFromPrivateKeyPublicKey(privateKey, slip44);

    return new KeyPair(privateKey, pubKey, slip44);
  }

  static async fromSeed(seed: Uint8Array, slip44: number, index: number) {
    const hdPath = new DerivationPath(slip44, index);
    const privateKey = await derivePrivateKey(seed, hdPath.getPath());
    const pubKey = await deriveFromPrivateKeyPublicKey(privateKey, slip44);

    return new KeyPair(privateKey, pubKey, slip44);
  }

  get privateKey() {
    return this.#privateKey;
  }

  get pubKey() {
    return this.#pubKey;
  }

  get slip44() {
    return this.#slip44;
  }

  constructor(privateKey: Uint8Array, pubKey: Uint8Array, slip44: number) {
    this.#privateKey = privateKey;
    this.#pubKey = pubKey;
    this.#slip44 = slip44;
  }

  addressType(): AddressType {
    return KeyPair.addressType(this.#slip44);
  }

  async address(): Promise<Address> {
    return await Address.fromPubKey(this.pubKey, this.slip44);
  }

  async signMessage(msg: Uint8Array) {
    switch (this.addressType()) {
      case AddressType.Bech32:
        const sigZil = await sign(msg, this.privateKey);
        return Uint8Array.from(sigZil.toBytes());
      case AddressType.EthCheckSum:
        const sigEth = personal.sign(msg, this.privateKey);
        return hexToUint8Array(sigEth);
    }
  }

  signDataEIP712(typedData: TypedData<any, any>): Uint8Array {
    switch (this.addressType()) {
      case AddressType.EthCheckSum:
        const signature = signTyped(typedData, this.privateKey);
        return hexToUint8Array(signature);
      default:
        throw new Error("Unsupported");
    }
  }

  async verifyTypedEIP712(
    signature: Uint8Array,
    typedData: TypedData<any, any>,
    address: Address,
  ): Promise<boolean> {
    switch (this.addressType()) {
      case AddressType.EthCheckSum:
        const sigHex = uint8ArrayToHex(signature, true);
        const ethChecsumAddr = await address.toEthChecksum();

        return verifyTyped(sigHex, typedData, ethChecsumAddr);
      default:
        throw new Error("Unsupported");
    }
  }

  async verifySig(msg: Uint8Array, sig: Uint8Array): Promise<boolean> {
    switch (this.addressType()) {
      case AddressType.Bech32:
        return await verify(msg, this.pubKey, Signature.fromBytes(sig));
      case AddressType.EthCheckSum:
        const address = await this.address();
        const ethChecsum = await address.toEthChecksum();
        const sigHex = uint8ArrayToHex(sig);

        return personal.verify(sigHex, msg, ethChecsum);
    }
  }

  async toJSON() {
    return {
      address: await (await this.address()).autoFormat(),
      privateKey: uint8ArrayToHex(this.#privateKey),
      publicKey: uint8ArrayToHex(this.#pubKey),
      slip44: this.#slip44,
    };
  }
}

```

`zil-pay/crypto/kuznechik.ts`:

```ts
import {
  KeyStore,
  AlgOfb,
  MIN_GAMMA_SIZE,
  MASTER_KEY_SIZE,
} from "@hicaru/kuznechik.js";
import { randomBytes } from "./random";

export const KUZNECHIK_KEY_SIZE = MASTER_KEY_SIZE;

export function kuznechikEncrypt(
  key: Uint8Array,
  plaintext: Uint8Array,
): Uint8Array {
  const keyStore = new KeyStore();
  keyStore.setMasterKey(key);
  const gamma = randomBytes(MIN_GAMMA_SIZE);
  const alg = new AlgOfb(keyStore);
  alg.setGamma(gamma);
  const encrypted = alg.encrypt(plaintext);
  const finalCiphertext = new Uint8Array(encrypted.length + gamma.length);
  finalCiphertext.set(encrypted, 0);
  finalCiphertext.set(gamma, encrypted.length);
  return finalCiphertext;
}

export function kuznechikDecrypt(
  key: Uint8Array,
  ciphertext: Uint8Array,
): Uint8Array {
  const gamma = ciphertext.slice(ciphertext.length - MIN_GAMMA_SIZE);
  const actualCiphertext = ciphertext.slice(
    0,
    ciphertext.length - MIN_GAMMA_SIZE,
  );
  const keyStore = new KeyStore();
  keyStore.setMasterKey(key);
  const alg = new AlgOfb(keyStore);
  alg.setGamma(gamma);
  const plaintext = alg.decrypt(actualCiphertext);
  return plaintext;
}

```

`zil-pay/crypto/ntrup.ts`:

```ts
import type { ParamsConfig } from "@hicaru/ntrup.js";
import { ChaCha20Rng, ChaChaRng } from "@hicaru/chacharand.js";
import {
  bytesRqDecode,
  ErrorType,
  generateKeyPair,
  packBytes,
  params761,
  PrivKey,
  PubKey,
  R3,
  r3DecodeChunks,
  r3EncodeChunks,
  r3Encrypt,
  r3MergeWChunks,
  r3SplitWChunks,
  Rq,
  rqDecrypt,
  unpackBytes,
} from "@hicaru/ntrup.js";

import { randomBytes } from "../crypto/random";

export const NTRU_CONFIG = params761;

function bytesEncrypt(
  rng: ChaChaRng,
  plaintext: Uint8Array,
  pubKey: PubKey,
  params: ParamsConfig,
): Uint8Array {
  const unlimitedPoly = r3DecodeChunks(plaintext);
  const getU32 = () => rng.nextU32();
  const { chunks, size, seed } = r3SplitWChunks(unlimitedPoly, getU32, params);
  const encryptedBytes: Uint8Array[] = [];

  for (const chunk of chunks) {
    const r3 = R3.from(chunk, params);
    const hr = r3Encrypt(r3, pubKey, params);
    const rqBytes = hr.toBytes(params);
    encryptedBytes.push(rqBytes);
  }

  const totalLength = encryptedBytes.reduce((sum, arr) => sum + arr.length, 0);
  const dataBytes = new Uint8Array(totalLength);

  let offset = 0;

  for (const arr of encryptedBytes) {
    dataBytes.set(arr, offset);
    offset += arr.length;
  }

  return packBytes(dataBytes, size, seed);
}

function bytesDecrypt(
  cipher: Uint8Array,
  privKey: PrivKey,
  params: ParamsConfig,
): Uint8Array {
  const { dataBytes, size, seed } = unpackBytes(cipher);
  const chunkCount = Math.floor(dataBytes.length / params.RQ_BYTES);

  if (dataBytes.length % params.RQ_BYTES !== 0) {
    throw ErrorType.InvalidRqChunkSize;
  }

  const decryptedChunks: Int8Array[] = [];

  for (let i = 0; i < chunkCount; i++) {
    const start = i * params.RQ_BYTES;
    const end = start + params.RQ_BYTES;
    const chunkBytes = dataBytes.subarray(start, end);
    if (chunkBytes.length !== params.RQ_BYTES) {
      throw ErrorType.InvalidRqChunkSize;
    }
    const coeffs = bytesRqDecode(chunkBytes, params);
    const rq = Rq.from(coeffs, params);
    const r3 = rqDecrypt(rq, privKey, params);
    decryptedChunks.push(r3.coeffs);
  }

  const outR3 = r3MergeWChunks(decryptedChunks, size, seed, params);

  return r3EncodeChunks(outR3);
}

export function ntruKeysFromSeed(seedBytes: Uint8Array): {
  pk: PubKey;
  sk: PrivKey;
} {
  const seedPq = seedBytes.slice(0, 32);
  const pqRng = ChaCha20Rng(seedPq);

  return generateKeyPair(pqRng, NTRU_CONFIG);
}

export function ntruEncrypt(pk: PubKey, plaintext: Uint8Array) {
  const seed = randomBytes(32);
  const rng = ChaCha20Rng(seed);
  return bytesEncrypt(rng, plaintext, pk, NTRU_CONFIG);
}

export function ntruDecrypt(sk: PrivKey, ciphertext: Uint8Array) {
  return bytesDecrypt(ciphertext, sk, NTRU_CONFIG);
}

```

`zil-pay/crypto/number.ts`:

```ts
/**
 * Converts a Uint8Array to a bigint, assuming big-endian byte order.
 * In big-endian, the most significant byte is placed at the beginning of the array.
 * This format is commonly used in network protocols and cryptography.
 *
 * @param array - The Uint8Array to convert to a bigint.
 * @returns The bigint representation of the input Uint8Array.
 * @throws TypeError if the input parameter is not an instance of Uint8Array.
 */
export function uint8ArrayToBigIntBigEndian(array: Uint8Array): bigint {
  if (!(array instanceof Uint8Array)) {
    array = Uint8Array.from(array);
  }

  let result: bigint = 0n;
  for (const byte of array) {
    result = (result << 8n) | BigInt(byte);
  }
  return result;
}

/**
 * Converts a Uint8Array to a bigint, assuming little-endian byte order.
 * In little-endian, the least significant byte is placed at the beginning of the array.
 * This format is sometimes used for representing numbers in computer memory.
 *
 * @param array - The Uint8Array to convert to a bigint.
 * @returns The bigint representation of the input Uint8Array.
 * @throws TypeError if the input parameter is not an instance of Uint8Array.
 */
export function uint8ArrayToBigIntLittleEndian(array: Uint8Array): bigint {
  if (!(array instanceof Uint8Array)) {
    array = Uint8Array.from(array);
  }

  let result: bigint = 0n;
  for (let i = array.length - 1; i >= 0; i--) {
    result = (result << 8n) | BigInt(array[i]);
  }
  return result;
}

/**
 * Converts a bigint to a big-endian Uint8Array of specified length.
 * @param value - The bigint to convert.
 * @param length - The desired length of the output array.
 * @returns The Uint8Array representation of the bigint.
 */
export function bigIntToUint8ArrayBigEndian(
  value: bigint,
  length: number,
): Uint8Array {
  const hex = value.toString(16).padStart(length * 2, "0");
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    bytes[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
  }
  return bytes;
}

```

`zil-pay/crypto/pbkdf2.ts`:

```ts
import { ShaAlgorithms } from "../config/pbkdf2";

export async function pbkdf2(
  password: Uint8Array,
  salt: Uint8Array,
  iterations: number,
  algorithms = ShaAlgorithms.Sha512,
) {
  const passphraseKey = await globalThis.crypto.subtle.importKey(
    "raw",
    password,
    { name: "PBKDF2" },
    false,
    ["deriveBits", "deriveKey"],
  );
  const webKey = await globalThis.crypto.subtle.deriveKey(
    {
      salt,
      iterations,
      name: "PBKDF2",
      hash: algorithms,
    },
    passphraseKey,
    {
      name: "HMAC",
      hash: algorithms,
      length: 512,
    },
    true,
    ["sign", "verify"],
  );
  const hash = await globalThis.crypto.subtle.exportKey("raw", webKey);

  return new Uint8Array(hash);
}

```

`zil-pay/crypto/proto/zq1.ts`:

```ts
export interface ByteArray {
  data: Uint8Array;
}

export function encodeByteArray(message: ByteArray): Uint8Array {
  let bb = popByteBuffer();
  _encodeByteArray(message, bb);
  return toUint8Array(bb);
}

function _encodeByteArray(message: ByteArray, bb: ByteBuffer): void {
  // required bytes data = 1;
  let $data = message.data;
  if ($data !== undefined) {
    writeVarint32(bb, 10);
    writeVarint32(bb, $data.length), writeBytes(bb, $data);
  }
}

export function decodeByteArray(binary: Uint8Array): ByteArray {
  return _decodeByteArray(wrapByteBuffer(binary));
}

function _decodeByteArray(bb: ByteBuffer): ByteArray {
  let message: ByteArray = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required bytes data = 1;
      case 1: {
        message.data = readBytes(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.data === undefined)
    throw new Error("Missing required field: data");

  return message;
}

export interface ProtoTransactionCoreInfo {
  version?: number;
  nonce?: Long;
  toaddr?: Uint8Array;
  senderpubkey?: ByteArray;
  amount?: ByteArray;
  gasprice?: ByteArray;
  gaslimit?: Long;
  code?: Uint8Array;
  data?: Uint8Array;
}

export function encodeProtoTransactionCoreInfo(message: ProtoTransactionCoreInfo): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransactionCoreInfo(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransactionCoreInfo(message: ProtoTransactionCoreInfo, bb: ByteBuffer): void {
  // optional uint32 version = 1;
  let $version = message.version;
  if ($version !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32(bb, $version);
  }

  // optional uint64 nonce = 2;
  let $nonce = message.nonce;
  if ($nonce !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $nonce);
  }

  // optional bytes toaddr = 3;
  let $toaddr = message.toaddr;
  if ($toaddr !== undefined) {
    writeVarint32(bb, 26);
    writeVarint32(bb, $toaddr.length), writeBytes(bb, $toaddr);
  }

  // optional ByteArray senderpubkey = 4;
  let $senderpubkey = message.senderpubkey;
  if ($senderpubkey !== undefined) {
    writeVarint32(bb, 34);
    let nested = popByteBuffer();
    _encodeByteArray($senderpubkey, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ByteArray amount = 5;
  let $amount = message.amount;
  if ($amount !== undefined) {
    writeVarint32(bb, 42);
    let nested = popByteBuffer();
    _encodeByteArray($amount, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ByteArray gasprice = 6;
  let $gasprice = message.gasprice;
  if ($gasprice !== undefined) {
    writeVarint32(bb, 50);
    let nested = popByteBuffer();
    _encodeByteArray($gasprice, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional uint64 gaslimit = 7;
  let $gaslimit = message.gaslimit;
  if ($gaslimit !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, $gaslimit);
  }

  // optional bytes code = 8;
  let $code = message.code;
  if ($code !== undefined) {
    writeVarint32(bb, 66);
    writeVarint32(bb, $code.length), writeBytes(bb, $code);
  }

  // optional bytes data = 9;
  let $data = message.data;
  if ($data !== undefined) {
    writeVarint32(bb, 74);
    writeVarint32(bb, $data.length), writeBytes(bb, $data);
  }
}

export function decodeProtoTransactionCoreInfo(binary: Uint8Array): ProtoTransactionCoreInfo {
  return _decodeProtoTransactionCoreInfo(wrapByteBuffer(binary));
}

function _decodeProtoTransactionCoreInfo(bb: ByteBuffer): ProtoTransactionCoreInfo {
  let message: ProtoTransactionCoreInfo = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional uint32 version = 1;
      case 1: {
        message.version = readVarint32(bb) >>> 0;
        break;
      }

      // optional uint64 nonce = 2;
      case 2: {
        message.nonce = readVarint64(bb, /* unsigned */ true);
        break;
      }

      // optional bytes toaddr = 3;
      case 3: {
        message.toaddr = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional ByteArray senderpubkey = 4;
      case 4: {
        let limit = pushTemporaryLength(bb);
        message.senderpubkey = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      // optional ByteArray amount = 5;
      case 5: {
        let limit = pushTemporaryLength(bb);
        message.amount = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      // optional ByteArray gasprice = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        message.gasprice = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      // optional uint64 gaslimit = 7;
      case 7: {
        message.gaslimit = readVarint64(bb, /* unsigned */ true);
        break;
      }

      // optional bytes code = 8;
      case 8: {
        message.code = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional bytes data = 9;
      case 9: {
        message.data = readBytes(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface ProtoTransaction {
  tranid?: Uint8Array;
  info?: ProtoTransactionCoreInfo;
  signature?: ByteArray;
}

export function encodeProtoTransaction(message: ProtoTransaction): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransaction(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransaction(message: ProtoTransaction, bb: ByteBuffer): void {
  // optional bytes tranid = 1;
  let $tranid = message.tranid;
  if ($tranid !== undefined) {
    writeVarint32(bb, 10);
    writeVarint32(bb, $tranid.length), writeBytes(bb, $tranid);
  }

  // optional ProtoTransactionCoreInfo info = 2;
  let $info = message.info;
  if ($info !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodeProtoTransactionCoreInfo($info, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ByteArray signature = 3;
  let $signature = message.signature;
  if ($signature !== undefined) {
    writeVarint32(bb, 26);
    let nested = popByteBuffer();
    _encodeByteArray($signature, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }
}

export function decodeProtoTransaction(binary: Uint8Array): ProtoTransaction {
  return _decodeProtoTransaction(wrapByteBuffer(binary));
}

function _decodeProtoTransaction(bb: ByteBuffer): ProtoTransaction {
  let message: ProtoTransaction = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional bytes tranid = 1;
      case 1: {
        message.tranid = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional ProtoTransactionCoreInfo info = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.info = _decodeProtoTransactionCoreInfo(bb);
        bb.limit = limit;
        break;
      }

      // optional ByteArray signature = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        message.signature = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface ProtoTransactionReceipt {
  receipt?: Uint8Array;
  cumgas?: Long;
}

export function encodeProtoTransactionReceipt(message: ProtoTransactionReceipt): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransactionReceipt(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransactionReceipt(message: ProtoTransactionReceipt, bb: ByteBuffer): void {
  // optional bytes receipt = 1;
  let $receipt = message.receipt;
  if ($receipt !== undefined) {
    writeVarint32(bb, 10);
    writeVarint32(bb, $receipt.length), writeBytes(bb, $receipt);
  }

  // optional uint64 cumgas = 2;
  let $cumgas = message.cumgas;
  if ($cumgas !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $cumgas);
  }
}

export function decodeProtoTransactionReceipt(binary: Uint8Array): ProtoTransactionReceipt {
  return _decodeProtoTransactionReceipt(wrapByteBuffer(binary));
}

function _decodeProtoTransactionReceipt(bb: ByteBuffer): ProtoTransactionReceipt {
  let message: ProtoTransactionReceipt = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional bytes receipt = 1;
      case 1: {
        message.receipt = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional uint64 cumgas = 2;
      case 2: {
        message.cumgas = readVarint64(bb, /* unsigned */ true);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface ProtoTransactionWithReceipt {
  transaction?: ProtoTransaction;
  receipt?: ProtoTransactionReceipt;
}

export function encodeProtoTransactionWithReceipt(message: ProtoTransactionWithReceipt): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransactionWithReceipt(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransactionWithReceipt(message: ProtoTransactionWithReceipt, bb: ByteBuffer): void {
  // optional ProtoTransaction transaction = 1;
  let $transaction = message.transaction;
  if ($transaction !== undefined) {
    writeVarint32(bb, 10);
    let nested = popByteBuffer();
    _encodeProtoTransaction($transaction, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ProtoTransactionReceipt receipt = 2;
  let $receipt = message.receipt;
  if ($receipt !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodeProtoTransactionReceipt($receipt, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }
}

export function decodeProtoTransactionWithReceipt(binary: Uint8Array): ProtoTransactionWithReceipt {
  return _decodeProtoTransactionWithReceipt(wrapByteBuffer(binary));
}

function _decodeProtoTransactionWithReceipt(bb: ByteBuffer): ProtoTransactionWithReceipt {
  let message: ProtoTransactionWithReceipt = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional ProtoTransaction transaction = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        message.transaction = _decodeProtoTransaction(bb);
        bb.limit = limit;
        break;
      }

      // optional ProtoTransactionReceipt receipt = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.receipt = _decodeProtoTransactionReceipt(bb);
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface Long {
  low: number;
  high: number;
  unsigned: boolean;
}

interface ByteBuffer {
  bytes: Uint8Array;
  offset: number;
  limit: number;
}

function pushTemporaryLength(bb: ByteBuffer): number {
  let length = readVarint32(bb);
  let limit = bb.limit;
  bb.limit = bb.offset + length;
  return limit;
}

function skipUnknownField(bb: ByteBuffer, type: number): void {
  switch (type) {
    case 0: while (readByte(bb) & 0x80) { } break;
    case 2: skip(bb, readVarint32(bb)); break;
    case 5: skip(bb, 4); break;
    case 1: skip(bb, 8); break;
    default: throw new Error("Unimplemented type: " + type);
  }
}

// The code below was modified from https://github.com/protobufjs/bytebuffer.js
// which is under the Apache License 2.0.

let bbStack: ByteBuffer[] = [];

function popByteBuffer(): ByteBuffer {
  const bb = bbStack.pop();
  if (!bb) return { bytes: new Uint8Array(64), offset: 0, limit: 0 };
  bb.offset = bb.limit = 0;
  return bb;
}

function pushByteBuffer(bb: ByteBuffer): void {
  bbStack.push(bb);
}

function wrapByteBuffer(bytes: Uint8Array): ByteBuffer {
  return { bytes, offset: 0, limit: bytes.length };
}

function toUint8Array(bb: ByteBuffer): Uint8Array {
  let bytes = bb.bytes;
  let limit = bb.limit;
  return bytes.length === limit ? bytes : bytes.subarray(0, limit);
}

function skip(bb: ByteBuffer, offset: number): void {
  if (bb.offset + offset > bb.limit) {
    throw new Error('Skip past limit');
  }
  bb.offset += offset;
}

function isAtEnd(bb: ByteBuffer): boolean {
  return bb.offset >= bb.limit;
}

function grow(bb: ByteBuffer, count: number): number {
  let bytes = bb.bytes;
  let offset = bb.offset;
  let limit = bb.limit;
  let finalOffset = offset + count;
  if (finalOffset > bytes.length) {
    let newBytes = new Uint8Array(finalOffset * 2);
    newBytes.set(bytes);
    bb.bytes = newBytes;
  }
  bb.offset = finalOffset;
  if (finalOffset > limit) {
    bb.limit = finalOffset;
  }
  return offset;
}

function advance(bb: ByteBuffer, count: number): number {
  let offset = bb.offset;
  if (offset + count > bb.limit) {
    throw new Error('Read past limit');
  }
  bb.offset += count;
  return offset;
}

function readBytes(bb: ByteBuffer, count: number): Uint8Array {
  let offset = advance(bb, count);
  return bb.bytes.subarray(offset, offset + count);
}

function writeBytes(bb: ByteBuffer, buffer: Uint8Array): void {
  let offset = grow(bb, buffer.length);
  bb.bytes.set(buffer, offset);
}



function writeByteBuffer(bb: ByteBuffer, buffer: ByteBuffer): void {
  let offset = grow(bb, buffer.limit);
  let from = bb.bytes;
  let to = buffer.bytes;

  // This for loop is much faster than subarray+set on V8
  for (let i = 0, n = buffer.limit; i < n; i++) {
    from[i + offset] = to[i];
  }
}

function readByte(bb: ByteBuffer): number {
  return bb.bytes[advance(bb, 1)];
}

function writeByte(bb: ByteBuffer, value: number): void {
  let offset = grow(bb, 1);
  bb.bytes[offset] = value;
}
function readVarint32(bb: ByteBuffer): number {
  let c = 0;
  let value = 0;
  let b: number;
  do {
    b = readByte(bb);
    if (c < 32) value |= (b & 0x7F) << c;
    c += 7;
  } while (b & 0x80);
  return value;
}

function writeVarint32(bb: ByteBuffer, value: number): void {
  value >>>= 0;
  while (value >= 0x80) {
    writeByte(bb, (value & 0x7f) | 0x80);
    value >>>= 7;
  }
  writeByte(bb, value);
}

function readVarint64(bb: ByteBuffer, unsigned: boolean): Long {
  let part0 = 0;
  let part1 = 0;
  let part2 = 0;
  let b: number;

  b = readByte(bb); part0 = (b & 0x7F); if (b & 0x80) {
    b = readByte(bb); part0 |= (b & 0x7F) << 7; if (b & 0x80) {
      b = readByte(bb); part0 |= (b & 0x7F) << 14; if (b & 0x80) {
        b = readByte(bb); part0 |= (b & 0x7F) << 21; if (b & 0x80) {

          b = readByte(bb); part1 = (b & 0x7F); if (b & 0x80) {
            b = readByte(bb); part1 |= (b & 0x7F) << 7; if (b & 0x80) {
              b = readByte(bb); part1 |= (b & 0x7F) << 14; if (b & 0x80) {
                b = readByte(bb); part1 |= (b & 0x7F) << 21; if (b & 0x80) {

                  b = readByte(bb); part2 = (b & 0x7F); if (b & 0x80) {
                    b = readByte(bb); part2 |= (b & 0x7F) << 7;
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return {
    low: part0 | (part1 << 28),
    high: (part1 >>> 4) | (part2 << 24),
    unsigned,
  };
}

function writeVarint64(bb: ByteBuffer, value: Long): void {
  let part0 = value.low >>> 0;
  let part1 = ((value.low >>> 28) | (value.high << 4)) >>> 0;
  let part2 = value.high >>> 24;

  let size =
    part2 === 0 ?
      part1 === 0 ?
        part0 < 1 << 14 ?
          part0 < 1 << 7 ? 1 : 2 :
          part0 < 1 << 21 ? 3 : 4 :
        part1 < 1 << 14 ?
          part1 < 1 << 7 ? 5 : 6 :
          part1 < 1 << 21 ? 7 : 8 :
      part2 < 1 << 7 ? 9 : 10;

  let offset = grow(bb, size);
  let bytes = bb.bytes;

  switch (size) {
    case 10: bytes[offset + 9] = (part2 >>> 7) & 0x01;
    case 9: bytes[offset + 8] = size !== 9 ? part2 | 0x80 : part2 & 0x7F;
    case 8: bytes[offset + 7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
    case 7: bytes[offset + 6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
    case 6: bytes[offset + 5] = size !== 6 ? (part1 >>> 7) | 0x80 : (part1 >>> 7) & 0x7F;
    case 5: bytes[offset + 4] = size !== 5 ? part1 | 0x80 : part1 & 0x7F;
    case 4: bytes[offset + 3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
    case 3: bytes[offset + 2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
    case 2: bytes[offset + 1] = size !== 2 ? (part0 >>> 7) | 0x80 : (part0 >>> 7) & 0x7F;
    case 1: bytes[offset] = size !== 1 ? part0 | 0x80 : part0 & 0x7F;
  }
}

```

`zil-pay/crypto/random.ts`:

```ts
import { ChaCha20Rng } from "@hicaru/chacharand.js";

export function randomBytes(length: number): Uint8Array {
  const buffer = new Uint8Array(length);
  const randomSeed = new Uint8Array(32);

  globalThis.crypto.getRandomValues(randomSeed);

  const rng = ChaCha20Rng(randomSeed);

  rng.fillBytes(buffer);

  return buffer;
}

```

`zil-pay/crypto/sha256.ts`:

```ts
import { ShaAlgorithms } from "config/pbkdf2";

export async function sha256(value: Uint8Array) {
  if (!(value instanceof Uint8Array)) {
    value = Uint8Array.from(value);
  }

  const crypto = globalThis.crypto;
  const hash = await crypto.subtle.digest(ShaAlgorithms.sha256, value);
  return new Uint8Array(hash);
}

```

`zil-pay/crypto/sha512.ts`:

```ts
import { ShaAlgorithms } from "../config/pbkdf2";

export async function sha512(value: Uint8Array): Promise<Uint8Array> {
  const crypto = globalThis.crypto;
  const hash = await crypto.subtle.digest(ShaAlgorithms.Sha512, value);

  return new Uint8Array(hash);
}

```

`zil-pay/crypto/tx.ts`:

```ts
import type { TxType } from "micro-eth-signer/esm/tx";
import { ZILTransactionRequest, ZILTransactionReceipt } from "./zilliqa_tx";
import { Transaction } from "micro-eth-signer";
import { KeyPair } from "./keypair";
import { randomBytes } from "./random";
import { convertBigIntsToHex } from "lib/utils/hex";

export interface TransactionMetadata {
  chainHash: number;
  hash?: string;
  info?: string;
  icon?: string;
  title?: string;
  signer?: string;
  tokenInfo?: [string, number, string];
}

export class TransactionRequest {
  constructor(
    public metadata: TransactionMetadata,
    public scilla?: ZILTransactionRequest,
    public evm?: Transaction<TxType>,
  ) {}

  async sign(keypair: KeyPair) {
    if (this.scilla) {
      const receipt = await this.scilla.sign(keypair);

      return new TransactionReceipt(this.metadata, receipt);
    } else if (this.evm) {
      const entropy = randomBytes(128);
      const receipt = this.evm.signBy(keypair.privateKey, entropy);

      return new TransactionReceipt(this.metadata, undefined, receipt);
    }

    throw new Error("Invlid tx type");
  }

  toJSON() {
    if (this.scilla) {
      return this.scilla.toJSON();
    } else if (this.evm) {
      return convertBigIntsToHex(this.evm.raw);
    }

    throw new Error("Invlid tx type");
  }
}

export class TransactionReceipt {
  constructor(
    public metadata: TransactionMetadata,
    public scilla?: ZILTransactionReceipt,
    public evm?: Transaction<TxType>,
  ) {}

  async verify() {
    if (this.scilla) {
      return this.scilla.verify();
    } else if (this.evm) {
      return this.evm.verifySignature();
    }

    throw new Error("Invlid tx type");
  }
}

```

`zil-pay/crypto/uuid.ts`:

```ts
import { randomBytes } from "./random";

/**
 * Generates a version 4 UUID.
 * Uses the native `crypto.randomUUID` if available, otherwise falls back to a
 * custom implementation using the `randomBytes` function.
 * @returns A UUID string.
 */
export function uuid(): string {
  if (window.crypto.randomUUID) {
    return window.crypto.randomUUID();
  }

  const bytes = randomBytes(16);

  bytes[6] = (bytes[6] & 0x0f) | 0x40;
  bytes[8] = (bytes[8] & 0x3f) | 0x80;
  const hex = Array.from(bytes, (byte) =>
    byte.toString(16).padStart(2, "0"),
  ).join("");

  return `${hex.substring(0, 8)}-${hex.substring(8, 12)}-${hex.substring(12, 16)}-${hex.substring(16, 20)}-${hex.substring(20)}`;
}

```

`zil-pay/crypto/zilliqa/pubkey.ts`:

```ts
import { getPublicKey } from '@noble/secp256k1';

export function fromZILPrivateKey(privateKey: Uint8Array): Uint8Array {
  const publicKey = getPublicKey(Uint8Array.from(privateKey), true);
  return publicKey;
}


```

`zil-pay/crypto/zilliqa/schnorr.ts`:

```ts
import { Signature } from '@noble/secp256k1';
import { ProjectivePoint } from '@noble/secp256k1';
import { CURVE } from '@noble/secp256k1';
import { randomBytes } from '../random';
import { sha256 } from '../sha256';
import { uint8ArrayToBigIntBigEndian } from '../number';
import { fromZILPrivateKey } from './pubkey';

const MAX_TRY_SIGN = 100_000_000;

export async function sign(message: Uint8Array, secretKey: Uint8Array): Promise<Signature> {
  let safeCounter = 0;

  while (safeCounter < MAX_TRY_SIGN) {
    const kBytes = randomBytes(32);
    const k = uint8ArrayToBigIntBigEndian(kBytes) % CURVE.n;

    const signature = await signInner(k, message, secretKey);
    if (signature) {
      return signature;
    }

    safeCounter++;
  }

  throw new Error('InvalidSignTry: Exceeded maximum signing attempts');
}

export async function signInner(k: bigint, message: Uint8Array, secretKey: Uint8Array): Promise<Signature | null> {
  const publicKey = fromZILPrivateKey(secretKey);

  const QPoint = ProjectivePoint.BASE.multiply(k);
  const Q = QPoint.toRawBytes(true);

  const hasherInput = new Uint8Array([...Q, ...publicKey, ...message]);
  const hash = await sha256(hasherInput);
  const r = uint8ArrayToBigIntBigEndian(hash) % CURVE.n;

  if (r === 0n) {
    return null;
  }

  const secretKeyScalar = uint8ArrayToBigIntBigEndian(secretKey);
  const rTimesSecret = (r * secretKeyScalar) % CURVE.n;
  const s = (k - rTimesSecret + CURVE.n) % CURVE.n;

  if (s === 0n) {
    return null;
  }

  return new Signature(r, s);
}

export async function verify(
  message: Uint8Array,
  publicKey: Uint8Array,
  signature: Signature
): Promise<boolean> {
  const r = signature.r;
  const s = signature.s;

  const sG = ProjectivePoint.BASE.multiply(s);
  const publicKeyPoint = ProjectivePoint.fromHex(Uint8Array.from(publicKey));
  const rPub = publicKeyPoint.multiply(r);
  const QPoint = sG.add(rPub);
  const Q = QPoint.toRawBytes(true);

  if (QPoint.equals(ProjectivePoint.ZERO)) {
    return false;
  }

  const hasherInput = new Uint8Array([...Q, ...publicKey, ...message]);
  const hash = await sha256(hasherInput);
  const rDash = uint8ArrayToBigIntBigEndian(hash) % CURVE.n;

  return rDash === r;
}


```

`zil-pay/crypto/zilliqa_tx.ts`:

```ts
import { Signature } from "@noble/secp256k1";
import type { KeyPair } from "./keypair";
import {
  bigIntToUint8ArrayBigEndian,
  uint8ArrayToBigIntBigEndian,
} from "./number";
import {
  encodeProtoTransactionCoreInfo,
  type Long,
  type ProtoTransactionCoreInfo,
} from "./proto/zq1";
import { verify } from "./zilliqa/schnorr";
import { uint8ArrayToHex } from "lib/utils/hex";
import { uint8ArrayToUtf8 } from "lib/utils/utf8";
import { Address, AddressType } from "./address";

const U128LEN = 16;

export function bigintToLong(value: bigint): Long {
  const low = Number(value & 0xffffffffn);
  const high = Number((value >> 32n) & 0xffffffffn);
  return { low, high, unsigned: true };
}

export function versionFromChainId(chainId: number): number {
  return (chainId << 16) | 1;
}

export function chainIdFromVersion(version: number): number {
  return (version >> 16) & 0xffff;
}

export class ZILTransactionRequest {
  constructor(
    public chainId: number,
    public nonce: bigint,
    public gasPrice: bigint,
    public gasLimit: bigint,
    public toAddr: Uint8Array,
    public amount: bigint,
    public code: Uint8Array = new Uint8Array(),
    public data: Uint8Array = new Uint8Array(),
  ) {}

  toProto(pubKey: Uint8Array): ProtoTransactionCoreInfo {
    return {
      version: versionFromChainId(this.chainId),
      nonce: bigintToLong(this.nonce),
      toaddr: this.toAddr,
      senderpubkey: { data: pubKey },
      amount: { data: bigIntToUint8ArrayBigEndian(this.amount, U128LEN) },
      gasprice: { data: bigIntToUint8ArrayBigEndian(this.gasPrice, U128LEN) },
      gaslimit: bigintToLong(this.gasLimit),
      code: this.code.length > 0 ? this.code : undefined,
      data: this.data.length > 0 ? this.data : undefined,
    };
  }

  encode(pubKey: Uint8Array): Uint8Array {
    const proto = this.toProto(pubKey);
    return encodeProtoTransactionCoreInfo(proto);
  }

  async sign(keypair: KeyPair) {
    const proto = this.toProto(keypair.pubKey);
    const bytes = encodeProtoTransactionCoreInfo(proto);
    const sig = await keypair.signMessage(bytes);

    return new ZILTransactionReceipt(
      proto.version ?? versionFromChainId(this.chainId),
      this.nonce,
      bigIntToUint8ArrayBigEndian(this.gasPrice, U128LEN),
      this.gasLimit,
      this.toAddr,
      bigIntToUint8ArrayBigEndian(this.amount, U128LEN),
      keypair.pubKey,
      this.code,
      this.data,
      sig,
      false,
    );
  }

  toJSON() {
    return {
      chainId: this.chainId,
      nonce: this.nonce.toString(),
      toAddr: uint8ArrayToHex(this.toAddr),
      amount: this.amount.toString(),
      gasPrice: this.gasPrice.toString(),
      gasLimit: this.gasLimit.toString(),
      code: this.code.length > 0 ? uint8ArrayToUtf8(this.code) : "",
      data: this.data.length > 0 ? uint8ArrayToUtf8(this.data) : "",
    };
  }
}

export class ZILTransactionReceipt {
  constructor(
    public version: number,
    public nonce: bigint,
    public gasPrice: Uint8Array,
    public gasLimit: bigint,
    public toAddr: Uint8Array,
    public amount: Uint8Array,
    public pubKey: Uint8Array,
    public code: Uint8Array,
    public data: Uint8Array,
    public signature: Uint8Array,
    public priority: boolean,
  ) {}

  toProto(): ProtoTransactionCoreInfo {
    return {
      version: this.version,
      nonce: bigintToLong(this.nonce),
      toaddr: this.toAddr,
      senderpubkey: { data: this.pubKey },
      amount: { data: this.amount },
      gasprice: { data: this.gasPrice },
      gaslimit: bigintToLong(this.gasLimit),
      code: this.code.length > 0 ? this.code : undefined,
      data: this.data.length > 0 ? this.data : undefined,
    };
  }

  async verify(): Promise<boolean> {
    const proto = this.toProto();
    const bytes = encodeProtoTransactionCoreInfo(proto);
    const signature = Signature.fromBytes(this.signature);

    return verify(bytes, this.pubKey, signature);
  }

  async toJSON() {
    return {
      version: this.version,
      nonce: Number(this.nonce),
      toAddr: await new Address(
        this.toAddr,
        AddressType.Bech32,
      ).toZilChecksum(),
      amount: uint8ArrayToBigIntBigEndian(this.amount).toString(),
      pubKey: uint8ArrayToHex(this.pubKey),
      gasPrice: uint8ArrayToBigIntBigEndian(this.gasPrice).toString(),
      gasLimit: this.gasLimit.toString(),
      code: this.code.length > 0 ? uint8ArrayToUtf8(this.code) : "",
      data: this.data.length > 0 ? uint8ArrayToUtf8(this.data) : "",
      signature: uint8ArrayToHex(this.signature),
      priority: this.priority,
    };
  }
}

```

`zil-pay/lib/array/chunk.ts`:

```ts
/**
 * Splits an array into chunks of a specified size.
 * @template T - The type of elements in the input array.
 * @param array - The input array to be chunked.
 * @param size - The size of each chunk (must be greater than 0).
 * @returns A new array containing the chunks.
 * @throws {Error} If the size is not a positive number.
 */
export function chunk<T>(array: T[], size: number): T[][] {
    if (size <= 0) {
        throw new Error("Size must be a positive number.");
    }

    const result: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
        result.push(array.slice(i, i + size));
    }
    return result;
}


```

`zil-pay/lib/array/shuffle.ts`:

```ts
/**
 * Shuffles the elements of an array in place using the Fisher-Yates algorithm.
 * @template T - The type of elements in the array.
 * @param array - The array to shuffle.
 */
export function shuffle<T>(array: T[]): T[] {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}


```

`zil-pay/lib/popup/clipboard.ts`:

```ts
/**
 * Asynchronously copies the provided text to the user's clipboard using the modern
 * `navigator.clipboard` API. If the modern API is not available, it attempts
 * to use the deprecated `document.execCommand('copy')` as a fallback.
 *
 * @param text The string to be copied to the clipboard.
 * @returns A Promise that resolves to `true` if the copy operation was successful,
 * or `false` if it failed (e.g., due to browser limitations or user denial of permissions).
 */
export async function clipboardCopy(text: string): Promise<boolean> {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (_) {
      return fallbackCopyToClipboard(text);
    }
  } else {
    // Fallback for browsers that do not support the modern Clipboard API.
    return fallbackCopyToClipboard(text);
  }
}

/**
 * Attempts to copy text to the clipboard using the deprecated `document.execCommand('copy')` method.
 * This method is less reliable and may require user interaction or specific browser permissions.
 *
 * @param text The string to be copied to the clipboard.
 * @returns `true` if the copy command was successful, `false` otherwise.
 */
function fallbackCopyToClipboard(text: string): boolean {
  try {
    const span = document.createElement('span');
    span.textContent = text;
    span.style.whiteSpace = 'pre';
    span.style.userSelect = 'all';
    document.body.appendChild(span);
    const selection = window.getSelection();
    const range = window.document.createRange();
    selection?.removeAllRanges();
    range.selectNode(span);
    selection?.addRange(range);
    const successful = window.document.execCommand('copy');
    selection?.removeAllRanges();
    document.body.removeChild(span);
    return successful;
  } catch (err) {
    console.error('Failed to copy text using document.execCommand:', err);
    return false;
  }
}

```

`zil-pay/lib/popup/url.ts`:

```ts
import type { IExplorerState, IChainConfigState, IFTokenState } from "background/storage";
import { Themes } from "config/theme";

function selectVariant(theme: Themes, options: string[]): string {
  if (options.length === 0) return '';
  if (theme === Themes.Light) return options[0];
  if (theme === Themes.Dark && options.length >= 2) return options[1];
  return options[0];
}

function processUrlTemplate({
  template,
  theme,
  replacements = {},
}: {
  template: string;
  theme: Themes;
  replacements?: Record<string, string>;
}): string {
  if (!template.includes('%{')) return template;

  let processed = template;

  const funcRegex = /%\{(\w+)\(([^)]+)\)\}%/g;
  processed = processed.replace(funcRegex, (_match, _, optionsStr) => {
    const options = optionsStr.split(',').map((s: string) => s.trim());
    return selectVariant(theme, options);
  });

  if (processed.includes('%{dark,light}%')) {
    processed = processed.replace(/%\{dark,light\}%/g, theme === Themes.Dark ? 'light' : 'dark');
  }

  for (const [key, value] of Object.entries(replacements)) {
    processed = processed.replace(new RegExp(`%{${key}}%`, 'g'), value);
  }

  return processed;
}

export function processTokenLogo({
  token,
  shortName,
  theme,
}: {
  token: IFTokenState;
  shortName: string;
  theme: Themes;
}): string {
  if (!token.logo) return 'assets/icons/warning.svg';

  const replacements = {
    'symbol': token.symbol.toLowerCase(),
    'contract_address': token.addr.toLowerCase(),
    'name': token.name,
    'shortName': shortName,
  };

  return processUrlTemplate({
    template: token.logo,
    theme: theme,
    replacements: replacements,
  });
}

export function formExplorerUrl(explorer: IExplorerState, transactionHash: string): string {
  const baseUrl = explorer.url.endsWith('/')
    ? explorer.url.substring(0, explorer.url.length - 1)
    : explorer.url;

  return `${baseUrl}/tx/${transactionHash}`;
}

export function viewChain({
  network,
  theme,
}: {
  network: IChainConfigState;
  theme: Themes;
}): string {
  const defaultIcon = 'assets/icons/default_chain.svg';

  if (!network.logo) return defaultIcon;

  const replacements = {
    'shortName': network.shortName.toLowerCase(),
  };

  return processUrlTemplate({
    template: network.logo,
    theme: theme,
    replacements: replacements,
  });
}

```

`zil-pay/lib/popup/warp-message.ts`:

```ts
export type Params = object[] | string[] | number[] | (string | string[] | number[])[];

export interface SendResponseParams {
  resolve?: unknown;
  reject?: unknown;
}
export type StreamResponse = (params: SendResponseParams) => void;

export interface ProxyContentType {
  params: Params;
  method: string;
  uuid: string;
}

export function warpMessage<T>(msg: SendResponseParams): T | undefined {
  if (!msg) {
    return;
  }

  if (msg.reject) {
    throw new Error(String(msg.reject));
  }

  return msg.resolve as T;
}

```

`zil-pay/lib/runtime/assert.ts`:

```ts
export function assert(expressions: boolean, msg: string) {
  if (!expressions) {
    throw new Error(msg);
  }
}

```

`zil-pay/lib/runtime/ext-id.ts`:

```ts
import { Runtime } from "./extensionizer";

export const EXTENSION_ID = Runtime.runtime.id;

```

`zil-pay/lib/runtime/extensionizer.ts`:

```ts
export const Runtime = globalThis.chrome;

```

`zil-pay/lib/runtime/fingerprint.ts`:

```ts
import { utils } from 'aes-js';
import { EXTENSION_ID, Runtime } from './';

export async function generateSalt(): Promise<Uint8Array> {
  let salt = EXTENSION_ID;

  try {
    const dynamicId = await Runtime.runtime.getPlatformInfo();
    salt += `${dynamicId.arch}:${dynamicId.nacl_arch}:${dynamicId.os}`;
  } catch {
    //
  }

  return utils.utf8.toBytes(salt);
}

```

`zil-pay/lib/runtime/get-url.ts`:

```ts
import { Runtime } from "./extensionizer";

export function getExtensionURL(content: string) {
  return Runtime.runtime.getURL(content);
}


```

`zil-pay/lib/runtime/index.ts`:

```ts
export * from './assert';
export * from './ext-id';
export * from './extensionizer';
export * from './manifest';
export * from './get-url';
export * from './fingerprint';


```

`zil-pay/lib/runtime/manifest.ts`:

```ts
import { Runtime } from './extensionizer';

export function getManifestVersion() {
  return Runtime.runtime.getManifest().manifest_version;
}

```

`zil-pay/lib/storage/builder.ts`:

```ts
import type { OldFields } from 'config/fields';
import { TypeOf } from '../types/checker';

export type StorageKeyValue = Record<string, unknown>;

export function buildObject(key: OldFields | string, value: string | object | any[]): StorageKeyValue { 
    let data: string;

    if (TypeOf.isObject(value) || TypeOf.isArray(value)) {
        try {
            data = JSON.stringify(value);
        } catch (error) {
            console.error('Error serializing value to JSON:', error);
            return { [key]: '' };
        }
    } else {
        data = String(value);
    }

    return {
        [key]: data,
    };
}


```

`zil-pay/lib/storage/index.ts`:

```ts
export * from './builder';
export * from './storage';

```

`zil-pay/lib/storage/storage.ts`:

```ts
import type { StorageKeyValue } from './builder';
import type { OldFields } from 'config/fields';
import { Runtime } from 'lib/runtime/extensionizer';

type StorageChangesCallback = { [key: string]: chrome.storage.StorageChange; };

export const BrowserStorage = Object.freeze({
    subscribe(callback: (changes: StorageChangesCallback) => void) {
        const listener = (changes: StorageChangesCallback) => {
            try {
                callback(changes);
            } catch (error) {
                console.error("Error in storage change callback:", error);
            }
        };

        Runtime.storage.onChanged.addListener(listener);

        return {
            unsubscribe() {
                Runtime.storage.onChanged.removeListener(listener);
            },
        };
    },

    async set(...items: StorageKeyValue[]): Promise<void> {
        if (items.length === 0) return;

        const data: StorageKeyValue = {};
        for (const item of items) {
            Object.assign(data, item);
        }

        await Runtime.storage.local.set(data);
    },

    async get<T>(...keys: (OldFields | string)[]): Promise<T> { 
        const result = await Runtime.storage.local.get(keys);

        if (keys.length === 1 && result) {
            return result[keys[0]];
        }
        
        return result as T;
    },

    async getAll<T>(): Promise<T> {
        return Runtime.storage.local.get(null);
    },

    async rm(...keys: (OldFields | string)[]): Promise<void> {
        await Runtime.storage.local.remove(keys);
    },

    async clear(): Promise<void> {
        await Runtime.storage.local.clear();
    },
});

```

`zil-pay/lib/streem/index.ts`:

```ts
export * from './keys';
export * from './secure-message';

export interface SendResponseParams {
  resolve?: unknown;
  reject?: unknown;
}
export type StreamResponse = (params: SendResponseParams) => void;

```

`zil-pay/lib/streem/keys.ts`:

```ts
const app = 'zil-pay';

export const MTypeTabContent = {
  CONTENT: `@/${app}/content-script`,
  INJECTED: `@/${app}/injected-script`
};

export const MTypePopupWallet = {
  GET_RANDOM_SEED: `@/${app}/generate-random-seed`,
  CREATE_ACCOUNT_BY_SEED: `@/${app}/set-account-by-seed-words`,
  SET_PASSWORD: `@/${app}/popup-set-password`,
  LOG_OUT: `@/${app}/popup-logout`,
  SET_SEED_AND_PASSWORD: `@/${app}/popup-set-seed-words-and-password`,
  WALET_PASSWORD_CHANGE: `@/${app}/change-password`,
  GET_WALLET_STATE: `@/${app}/get-wallet-state`,
  EXPORT_SEED: `@/${app}/popup-export-seed-words`,
  EXPORT_PRIVATE_KEY: `@/${app}/popup-export-private-key`,
  EXPORT_QR_CODE_WALLET: `@/${app}/export-qr-code-wallet`,
  IMPORT_PRIVATE_KEY: `@/${app}/popup-import-private-key`,
  IMPORT_TRACK_ACCOUNT: `@/${app}/popup-import-track-account`,
  IMPORT_KEYSTORE: `@/${app}/popup-import-keystore`,
  ENCRYPT_WALLET: `@/${app}/encrypt-wallet-aes`,
  RES_ENCRYPTION: `@/${app}/response-encryption`,
  RES_DECRYPTION: `@/${app}/response-decryption`,
};

export const MTypePopupAccount = {
  RM_ACCOUNT: `@/${app}/remove-selected-account`,
  SELECT_ACCOUNT: `@/${app}/select-account`,
  SET_ACCOUNT_NAME: `@/${app}/set-account-name`,
  UPDATE_BALANCE: `@/${app}/popup-account-balance-upadte`,
};

export const MTypePopupTransaction = {
  UPDATE_TXNS: `@/${app}/check-processed-txns`,
  REJECT_CONFIRM_TX: `@/${app}/popup-reject-confirm-tx`,
  REJECT_ALL_CONFIRM_TXNS: `@/${app}/popup-reject-al-confirm-txns`,
  SEND_TO_SIGN_TX: `@/${app}/popup-send-to-sign-tx`,
  GET_REQUIRED_PARAMS: `@/${app}/get-required-params`,
  CLEAR_ALL_TXNS: `@/${app}/clear-all-txns`,
  GET_CURRENT_NONCE: `@/${app}/get-current-nonce`,
  RESET_NONCE: `@/${app}/reset-nonce`,
};

export const MTypePopupToken = {
  GET_ZRC2_STATE: `@/${app}/get-zrc2-token-info`,
  ADD_ZRC2_TOKEN: `@/${app}/add-new-zrc2-token`,
  RM_TOKEN: `@/${app}/remove-token`,
  GET_ZRC2_ALLOWANCES_FOR_SWAP: `@/${app}/get-zrc2-allowances-for-swap`,
};

export const MTypePopupNFT = {
  UPDATE_NFT_LIST: `@/${app}/update-nft-list`,
  GET_NFT_LIST: `@/${app}/get-nft-list`,
  FETCH_NFT: `@/${app}/fetch-nft`,
  ADD_NFT: `@/${app}/add-nft`,
  REMOVE_NFT: `@/${app}/remove-nft`,
};

export const MTypePopupNetwork = {
  SELECT_SSN: `@/${app}/select-from-ssn-list`,
  RESET_NETWROK: `@/${app}/reset-netwrok-settings`,
  SET_NET_CONFIG: `@/${app}/set-netwrok-config`,
  SELECT_NETWORK: `@/${app}/select-network`,
  UPDATE_SSN_LIST: `@/${app}/update-ssn-list`,
  GET_LATEST_BLOCK: `@/${app}/get-latest-block-number`,
};

export const MTypePopupDApp = {
  USER_RESPONSE_DAPP: `@/${app}/user-response-connect-dapp`,
  RM_APP: `@/${app}/remove-dapp`,
  CLEAR_APPS: `@/${app}/clear-all-apps`,
  SET_PHISHING_DETECTION: `@/${app}/set-phishing-detection`,
};

export const MTypePopupContact = {
  ADD_CONTACT: `@/${app}/add-a-contact`,
  RM_CONTACT: `@/${app}/remove-a-contact`,
};

export const MTypePopupSettings = {
  CHANGE_CURRENCY: `@/${app}/change-currency`,
  UPDATE_RATE: `@/${app}/update-rate`,
  RESET_CURRENCY: `@/${app}/reset-currency`,
  SET_THEME: `@/${app}/set-theme-mode`,
  RESET_THEME: `@/${app}/reset-theme`,
  SET_LOCALE: `@/${app}/set-locale`,
  RESET_LOCALE: `@/${app}/reset-locale`,
  SET_GAS_MULTIPLIER: `@/${app}/set-gas-multiplier`,
  RESET_GAS: `@/${app}/reset-gas`,
  SET_LOCK_TIME: `@/${app}/set-lock-timer`,
  SET_ADDRESS_FORMAT: `@/${app}/set-address-format`,
  SET_PROMT_ENABLED: `@/${app}/set-promt-enabled`,
};

export const MTypePopupSign = {
  REJECT_SIGN_MESSAGE: `@/${app}/reject-sign-message`,
  SIGN_MESSAGE_APPROVE: `@/${app}/approve-sign-message`,
};

export const MTypePopupUtil = {
  FROM_BECH32: `@/${app}/convert-from-bech32`,
};

export const MTypePopupDex = {
  UPDATE_DEX_DATA: `@/${app}/update-dex-data`,
  UPDATE_DEX_SETTINGS: `@/${app}/update-dex-settings`,
};

export const MTypePopupStake = {
  GET_STAKE_PROPS: `@/${app}/get-stake-props`,
};

export const MTypePopupLedger = {
  ADD_LEDGER_ACCOUNT: `@/${app}/add-ledger-account`,
};

export const MTypeTab = {
  GET_WALLET_DATA: `@/${app}/injected-get-wallet-data`,
  ADDRESS_CHANGED: `@/${app}/address-changed`,
  NETWORK_CHANGED: `@/${app}/network-changed`,
  LOCK_STAUS: `@/${app}/lack-status-updated`,
  CONTENT_PROXY_MEHTOD: `@/${app}/request-through-content`,
  CONTENT_PROXY_RESULT: `@/${app}/response-from-content`,
  CALL_TO_SIGN_TX: `@/${app}/request-to-sign-tx`,
  TX_RESULT: `@/${app}/response-tx-result`,
  SIGN_MESSAGE: `@/${app}/request-to-sign-message`,
  SING_MESSAGE_RES: `@/${app}/response-sign-message`,
  NEW_BLOCK: `@/${app}/new-block-created`,
  ADD_ENCRYPTION: `@/${app}/request-add-encryption`,
  RES_ENCRYPTION: `@/${app}/response-encryption`,
  ADD_DECRYPTION: `@/${app}/add-decryption`,
  RES_DECRYPTION: `@/${app}/response-decryption`,
  CONNECT_APP: `@/${app}/request-to-connect-dapp`,
  RESPONSE_TO_DAPP: `@/${app}/response-dapp-connect`,
  DISCONNECT_APP: `@/${app}/request-to-disconnect-dapp`
};


```

`zil-pay/lib/streem/message.ts`:

```ts
import { Runtime } from "lib/runtime/extensionizer";


export interface ReqBody<T = unknown> {
    type: string;
    payload?: T;
    domain?: string;
    from?: string;
}

export class Message<T = unknown> {
    constructor(public readonly body: ReqBody<unknown>) {}

    static signal(type: string): Message<object> {
        return new Message({ type });
    }

    async send(): Promise<T> {
        for (let i = 0; i < 10; i++) {
            try {
                const res = await this.#trySend();
                if (res) return res;
            } catch {}
        }
        throw new Error("service_worker_stopped");
    }

    #trySend(): Promise<T> {
        return new Promise((resolve) => {
            let data = JSON.parse(JSON.stringify(this.body));
            Runtime.runtime.sendMessage(data, resolve);
        });
    }
}

```

`zil-pay/lib/streem/secure-message.ts`:

```ts
import type { ReqBody } from './message';
import type { TabStream } from './tab-stream';

export class SecureContentMessage<T = unknown> {
    constructor(public readonly body: ReqBody<T>) {}

    get type() { return this.body.type; }
    get payload() { return this.body.payload; }

    send(stream: TabStream, recipient: string) {
        stream.send(this.body, recipient);
    }
}

```

`zil-pay/lib/streem/tab-stream.ts`:

```ts
import type { ReqBody } from './message';
import { Runtime } from "lib/runtime";
import { MTypeTabContent } from './keys';

export class TabStream {
    constructor(public readonly eventName: string) {}

    listen(cb: (payload: ReqBody) => void) {
        globalThis.document?.addEventListener(this.eventName, (event: Event) => {
            const detail = (event as CustomEvent).detail;
            if (detail) {
                try {
                    cb(JSON.parse(detail));
                } catch (e) {
                    console.error("Error parsing event detail", e, event);
                }
            }
        });
    }

    send(data: ReqBody, to: string) {
        data.from = this.eventName;
        if (Object.values(MTypeTabContent).includes(to)) {
            this.#dispatch(JSON.stringify(data), to);
        }
    }

    #dispatch(data: string, to: string) {
        globalThis.document?.dispatchEvent(this.#getEvent(data, to));
    }

    #getEvent(detail: string, to: string) {
        return new CustomEvent(to, { detail });
    }

    /**
     * Sends a signal message to the specified tab.
     * @param tabId - The ID of the tab.
     * @param message - The message to send.
     */
    async sendSignalToTab(tabId: number, message: ReqBody): Promise<void> {
        try {
            await Runtime.tabs.sendMessage(tabId, message);
        } catch (error) {
            console.error(`Failed to send signal to tab ${tabId}:`, error);
            throw error; // Re-throw the error to be handled by the caller
        }
    }

    /**
      * Sends message to all tabs except the excluded tabIds
      * @param message
      * @param excludedTabIds
      */
    async sendToAllTabs(message: ReqBody, excludedTabIds: number[] = []): Promise<void> {
        try {
            const tabs = await Runtime.tabs.query({});
            for (const tab of tabs) {
                if (tab?.id && !excludedTabIds.includes(tab.id)) {
                    await Runtime.tabs.sendMessage(tab.id, message);
                }
            }
        } catch (error) {
            console.error("Failed to send message to all tabs:", error);
            throw error; // Re-throw the error
        }
    }
}

```

`zil-pay/lib/streem/tabs-message.ts`:

```ts
import type { ReqBody } from './message';
import { Runtime } from "lib/runtime";


export class TabsMessage<T = any> {
    constructor(public readonly body: ReqBody<T>) {}

    static async getTabs(): Promise<chrome.tabs.Tab[]> {
        return Runtime.tabs.query({});
    }

    async signal(domain: string): Promise<string> {
        return new Promise<string>((resolve, reject) => {
            Runtime.tabs.query({ active: true, currentWindow: true }, (tabs: chrome.tabs.Tab[]) => {
                const tab = tabs[0];
                if (!tab) {
                    reject(new Error("no active tabs"));
                    return;
                }

                const { hostname } = new URL(tab.url!);

                if (hostname !== domain) {
                    reject(new Error("invalid domain"));
                    return;
                }
                Runtime.tabs.sendMessage(Number(tab.id), this.body)
                    .then(() => resolve(""))
                    .catch(reject);
            });
        });
    }



    async send(...domains: string[]): Promise<void> {
        const tabs = await TabsMessage.getTabs();

        tabs.forEach(async (tab) => {
            if (tab?.url && domains.includes(new URL(tab.url).hostname)) {
                try {
                    await Runtime.tabs.sendMessage(Number(tab.id), this.body);
                } catch (err) {
                    console.error(`Failed to send message to tab ${tab.id}`, err);
                }
            }
        });
    }

    async sendAll(): Promise<void> {
        const tabs = (await TabsMessage.getTabs())
            .filter((tab) => tab?.url && !tab.url.startsWith("chrome://"));

        try {
            for (const tab of tabs) {
                await Runtime.tabs.sendMessage(Number(tab.id), this.body);
            }
        } catch (err) {
            console.error("TabsMessage", err);
        }
    }
}

```

`zil-pay/lib/types/checker.ts`:

```ts
type Arg = unknown;

export const TypeOf = Object.freeze({
    /**
     * Checks if the given argument is an array.
     * @param arg The argument to check.
     * @returns True if the argument is an array, false otherwise.
     */
    isArray(arg: Arg): boolean {
        return Array.isArray(arg);
    },

    /**
     * Checks if the given argument is a plain object.
     * @param arg The argument to check.
     * @returns True if the argument is a plain object, false otherwise.
     */
    isObject(arg: Arg): boolean {
        return typeof arg === 'object' && arg !== null && !Array.isArray(arg) && !(arg instanceof Date) && !(arg instanceof Error) && Object.getPrototypeOf(arg) === Object.prototype;
    },

    /**
     * Checks if the given argument is a number.
     * @param arg The argument to check.
     * @returns True if the argument is a number, false otherwise.
     */
    isNumber(arg: Arg): boolean {
        return typeof arg === 'number' && !isNaN(arg as number);
    },

    /**
     * Checks if the given argument is an integer.
     * @param arg The argument to check.
     * @returns True if the argument is an integer, false otherwise.
     */
    isInt(arg: Arg): boolean {
        return Number.isInteger(arg as number);
    },

    /**
     * Checks if the given argument is a BigInt.
     * @param arg The argument to check.
     * @returns True if the argument is a BigInt, false otherwise.
     */
    isBigInt(arg: Arg): boolean {
        return typeof arg === 'bigint';
    },

    /**
     * Checks if the given argument is an error object.
     * @param arg The argument to check.
     * @returns True if the argument is an error object, false otherwise.
     */
    isError(arg: Arg): boolean {
        return arg instanceof Error;
    },

    /**
     * Checks if the given argument is a string.
     * @param arg The argument to check.
     * @returns True if the argument is a string, false otherwise.
     */
    isString(arg: Arg): boolean {
        return typeof arg === 'string' || arg instanceof String;
    },

    /**
     * Checks if the given argument is a boolean.
     * @param arg The argument to check.
     * @returns True if the argument is a boolean, false otherwise.
     */
    isBoolean(arg: Arg): boolean {
        return typeof arg === 'boolean' || arg instanceof Boolean;
    },

    /**
     * Checks if the given argument is null.
     * @param arg The argument to check.
     * @returns True if the argument is null, false otherwise.
     */
    isNull(arg: Arg): boolean {
        return arg === null;
    },

    /**
     * Checks if the given argument is undefined.
     * @param arg The argument to check.
     * @returns True if the argument is undefined, false otherwise.
     */
    isUndefined(arg: Arg): boolean {
        return arg === undefined;
    },

    /**
     * Checks if the given argument is an empty object.
     * @param arg The argument to check.
     * @returns True if the argument is an empty object, false otherwise.
     */
    isEmptyObject(arg: Arg): boolean {
        return this.isObject(arg) && Object.keys(arg as object).length === 0;
    },

    /**
     * Checks if the given argument is an empty array.
     * @param arg The argument to check.
     * @returns True if the argument is an empty array, false otherwise.
     */
    isEmptyArray(arg: Arg): boolean {
        return this.isArray(arg) && (arg as Array<unknown>).length === 0;
    },
});


```

`zil-pay/lib/types/index.ts`:

```ts
export * from './checker';


```

`zil-pay/lib/utils/hex.ts`:

```ts
import { TypeOf } from "lib/types";

export const HEX_PREFIX = "0x";

/**
 * Checks if a string starts with the '0x' prefix (case-insensitive).
 *
 * @param str The string to check.
 * @returns True if the string starts with '0x', false otherwise.
 */
export function hasHexPrefix(str: string): boolean {
  return str.toLowerCase().startsWith(HEX_PREFIX);
}


export function stripHexPrefix(hex: string): string {
  return hasHexPrefix(hex) ? hex.slice(2) : hex;
}

/**
 * A lookup table for fast number-to-hex conversion.
 */
const HEX_CHAR_TABLE: string[] = Array.from({ length: 256 }, (_, i) =>
    i.toString(16).padStart(2, '0')
);

/**
 * Efficiently converts a Uint8Array to a hexadecimal string.
 * This function uses a pre-computed lookup table for maximum performance.
 *
 * @param {Uint8Array} uint8Array The byte array (numbers 0-255) to convert.
 * @param {boolean} [prefix=false] Whether to include the '0x' prefix in the output.
 * @returns {string} The resulting hexadecimal string.
 */
export function uint8ArrayToHex(uint8Array: Uint8Array, prefix: boolean = false): string {
    const hexParts = new Array(uint8Array.length);
    for (let i = 0; i < uint8Array.length; i++) {
        hexParts[i] = HEX_CHAR_TABLE[uint8Array[i]];
    }
    const hexString = hexParts.join('');

    return prefix ? HEX_PREFIX + hexString : hexString;
}

/**
 * Efficiently converts a hexadecimal string to a Uint8Array.
 * This function is optimized to minimize memory allocation and avoid
 * unnecessary intermediate conversions.
 *
 * @param {string} hexString The hexadecimal string (may start with '0x').
 * @returns {Uint8Array} A Uint8Array representing the hexadecimal data.
 * @throws {Error} if the string has an odd number of characters or contains invalid hex characters.
 */
export function hexToUint8Array(hexString: string): Uint8Array {
    if (hexString == '' || hexString == HEX_PREFIX) {
        return new Uint8Array();
    }

    const str = stripHexPrefix(hexString);

    if (str.length % 2 !== 0) {
        throw new Error('Invalid hex string: must have an even number of characters.');
    }

    const arrayBuffer = new Uint8Array(str.length / 2);

    for (let i = 0; i < str.length; i += 2) {
        const byteString = str.substring(i, i + 2);
        const byteValue = parseInt(byteString, 16);

        if (isNaN(byteValue)) {
            throw new Error(`Invalid hex character "${byteString}" at position ${i}.`);
        }
        
        arrayBuffer[i / 2] = byteValue;
    }

    return Uint8Array.from(arrayBuffer);
}


/**
 * Converts a hexadecimal string to a BigInt.
 * This is the most direct and performant way to perform the conversion.
 *
 * @param {string} hexString The hexadecimal string (may start with '0x').
 * @returns {bigint} The BigInt representation of the hexadecimal string.
 * @throws {SyntaxError} if the string is not a valid hexadecimal number.
 */
export function hexToBigInt(hexString: string): bigint {
    const cleanHex = hexString.startsWith(HEX_PREFIX) ? hexString : `${HEX_PREFIX}${hexString}`;
    return BigInt(cleanHex);
}

export function bigintToHex(value: bigint, prefix = true): string {
    return (prefix ? HEX_PREFIX : '') + value.toString(16);
}


export function convertBigIntsToHex(obj: { [key: string]: unknown }): { [key: string]: unknown } {
  const newObj: { [key: string]: unknown } = {};

  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const value = obj[key];
      
      if (TypeOf.isBigInt(value)) {
        newObj[key] = HEX_PREFIX + (value as bigint).toString(16);
      } else {
        newObj[key] = value;
      }
    }
  }

  return newObj;
}

```

`zil-pay/lib/utils/locale.ts`:

```ts
export function detectLanguage(word: string): string {
  if (/^[a-zA-Z]+$/.test(word)) return 'en';
  if (/[\u0400-\u04FF]/.test(word)) return 'ru';
  if (/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF]/.test(word)) return 'ja';
  if (/[\uAC00-\uD7A3]/.test(word)) return 'ko';
  if (/[\u00C0-\u00FF]/.test(word)) return 'es';

  throw new Error('Unknown language');
}

```

`zil-pay/lib/utils/utf8.ts`:

```ts
export function utf8ToUint8Array(str: string): Uint8Array {
  const encoder = new TextEncoder();
  return encoder.encode(str);
}

export function uint8ArrayToUtf8(arr: Uint8Array): string {
  const decoder = new TextDecoder();
  return decoder.decode(arr);
}


```

`zil-pay/lib/zilliqa/bech32.ts`:

```ts
import { assert } from 'lib/runtime/assert';
import { CHARSET, HRP, GENERATOR } from 'lib/zilliqa/config';
import { toChecksumHexAddress } from 'lib/zilliqa/checksum';
import { hexToUint8Array, uint8ArrayToHex } from '../utils/hex';

const polymod = (values: Uint8Array): number => {
    let chk: number = 1;
    for (let p: number = 0; p < values.length; ++p) {
        const top: number = chk >> 25;
        chk = ((chk & 0x1ffffff) << 5) ^ values[p];
        for (let i: number = 0; i < 5; ++i) {
            if ((top >> i) & 1) {
                chk ^= GENERATOR[i];
            }
        }
    }
    return chk;
};

const hrpExpand = (hrp: string): Uint8Array => {
    const ret: number[] = [];
    for (let i: number = 0; i < hrp.length; ++i) {
        ret.push(hrp.charCodeAt(i) >> 5);
    }
    ret.push(0);
    for (let i: number = 0; i < hrp.length; ++i) {
        ret.push(hrp.charCodeAt(i) & 31);
    }
    return new Uint8Array(ret);
};

export function convertBits(data: Uint8Array, fromWidth: number, toWidth: number, pad: boolean = true): Uint8Array | null {
    let acc: number = 0;
    let bits: number = 0;
    const ret: number[] = [];
    const maxv: number = (1 << toWidth) - 1;

    for (const value of data) {
        if (value < 0 || (value >> fromWidth) !== 0) {
            return null;
        }
        acc = (acc << fromWidth) | value;
        bits += fromWidth;
        while (bits >= toWidth) {
            bits -= toWidth;
            ret.push((acc >> bits) & maxv);
        }
    }

    if (pad) {
        if (bits > 0) {
            ret.push((acc << (toWidth - bits)) & maxv);
        }
    } else if (bits >= fromWidth || (acc << (toWidth - bits)) & maxv) {
        return null;
    }

    return new Uint8Array(ret);
}

function verifyChecksum(hrp: string, data: Uint8Array): boolean {
    return polymod(new Uint8Array([...hrpExpand(hrp), ...data])) === 1;
}

function createChecksum(hrp: string, data: Uint8Array): Uint8Array {
    const values: Uint8Array = new Uint8Array([...hrpExpand(hrp), ...data, 0, 0, 0, 0, 0, 0]);
    const mod: number = polymod(values) ^ 1;
    const ret: number[] = [];
    for (let p: number = 0; p < 6; ++p) {
        ret.push((mod >> (5 * (5 - p))) & 31);
    }
    return new Uint8Array(ret);
}

export const encode = (hrp: string, data: Uint8Array): string => {
    const checksum: Uint8Array = createChecksum(hrp, data);
    const combined: Uint8Array = new Uint8Array([...data, ...checksum]);
    let ret: string = hrp + '1';
    for (const value of combined) {
        ret += CHARSET.charAt(value);
    }
    return ret;
};

export const decode = (bechString: string): { hrp: string; data: Uint8Array } | null => {
    let hasLower: boolean = false;
    let hasUpper: boolean = false;
    for (let i: number = 0; i < bechString.length; ++i) {
        const charCode: number = bechString.charCodeAt(i);
        if (charCode < 33 || charCode > 126) {
            return null;
        }
        if (charCode >= 97 && charCode <= 122) {
            hasLower = true;
        }
        if (charCode >= 65 && charCode <= 90) {
            hasUpper = true;
        }
    }

    if (hasLower && hasUpper) {
        return null;
    }

    const lowerBechString: string = bechString.toLowerCase();
    const pos: number = lowerBechString.lastIndexOf('1');

    if (pos < 1 || pos + 7 > lowerBechString.length || lowerBechString.length > 90) {
        return null;
    }

    const hrp: string = lowerBechString.substring(0, pos);
    const data: number[] = [];
    for (let i: number = pos + 1; i < lowerBechString.length; ++i) {
        const d: number = CHARSET.indexOf(lowerBechString.charAt(i));
        if (d === -1) {
            return null;
        }
        data.push(d);
    }

    const dataBytes: Uint8Array = new Uint8Array(data);
    if (!verifyChecksum(hrp, dataBytes)) {
        return null;
    }

    return { hrp, data: dataBytes.slice(0, dataBytes.length - 6) };
};

export const toBech32Address = async (address: string): Promise<string> => {
    const addressBytes = hexToUint8Array(address);
    const addrBz = convertBits(addressBytes, 8, 5);
    assert(addrBz !== null, 'Cannot convert bytes to Bech32 bits.');

    return encode(HRP, addrBz as Uint8Array);
};

export const fromBech32Address = (address: string): string => {
    const res = decode(address);
    assert(res !== null, 'Invalid Bech32 address.');

    const { hrp, data } = res as { hrp: string; data: Uint8Array };
    assert(hrp === HRP, `Expected HRP '${HRP}', but got '${hrp}'.`);

    const buf = convertBits(data, 5, 8, false);
    assert(buf !== null, 'Cannot convert Bech32 bits to bytes.');

    const hexAddress = uint8ArrayToHex(buf as Uint8Array, true);

    return hexAddress;
};


```

`zil-pay/lib/zilliqa/checksum.ts`:

```ts
import { sha256 } from 'crypto/sha256';
import { 
    HEX_PREFIX, 
    stripHexPrefix, 
    uint8ArrayToHex, 
    hexToUint8Array, 
    hexToBigInt 
} from 'lib/utils/hex';

export async function toChecksumBytesAddress(addressBytes: Uint8Array): Promise<string> {
  const addressHex = uint8ArrayToHex(addressBytes);
  const hashBytes = await sha256(addressBytes);
  const hashBigInt = hexToBigInt(uint8ArrayToHex(hashBytes));

  let checksummedHex = '';

  for (let i = 0; i < addressHex.length; i++) {
    const char = addressHex[i];
    if (/[0-9]/.test(char)) {
        checksummedHex += char;
    } else {
      const bitPosition = BigInt(255 - 6 * i);
      const mask = BigInt(2) ** bitPosition;
      const shouldBeUpper = (hashBigInt & mask) >= BigInt(1);

      if (shouldBeUpper) {
        checksummedHex += char.toUpperCase();
      } else {
        checksummedHex += char.toLowerCase();
      }
    }
  }

  return HEX_PREFIX + checksummedHex;
}

export async function toChecksumHexAddress(address: string): Promise<string> {
  const unprefixedAddress = stripHexPrefix(address);
  const addressBytes = hexToUint8Array(unprefixedAddress);
  return toChecksumBytesAddress(addressBytes);
}


```

`zil-pay/lib/zilliqa/config.ts`:

```ts
export const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
export const HRP = 'zil';
export const GENERATOR = [
  0x3b6a57b2,
  0x26508e6d,
  0x1ea119fa,
  0x3d4233dd,
  0x2a1462b3
];

```

`zil-pay/lib/zilliqa/index.ts`:

```ts
export * from './bech32';
export * from './checksum';
export * from './config';
export * from './pubkey';

```

`zil-pay/lib/zilliqa/pubkey.ts`:

```ts
import { sha256 } from 'crypto/sha256';

export async function fromZilPubKey(pubKey: Uint8Array): Promise<Uint8Array> {
  const hashBytes = await sha256(pubKey);
  const addressBytes = hashBytes.slice(12);

  if (addressBytes.length !== 20) {
    throw new Error('Invalid public key length or unexpected hash output length.');
  }

  return addressBytes;
}

```

`zil-pay/popup/App.svelte`:

```svelte
<script lang="ts">
	import { get } from 'svelte/store';
	import { setupI18n } from 'popup/i18n';
	import globlSettingsStore from 'popup/store/global';
	import { Locales } from 'config/locale';
	import Router from './Router.svelte';

	let loading = $state(true);

	$effect(() => {
		const initialize = async () => {
			const { locale } = get<any>(globlSettingsStore);
			try {
				if (locale === Locales.Auto) {
					await setupI18n();
				} else {
					await setupI18n({
						withLocale: locale,
					});
				}
			} catch (err) {
				console.error(err);
				await setupI18n({
					withLocale: Locales.EN,
				});
			} finally {
				loading = false;
			}
		};

		initialize();
	});
</script>

{#if !loading}
	<Router />
{/if}


```

`zil-pay/popup/Router.svelte`:

```svelte
<script lang="ts">
	import { matchRoute, notFoundRoute, parseUrlParams, routes } from './router';
	import { RouteGuard } from './router/guard';
	import { currentParams, currentRoute } from './store/route';

	export function findRouteByHash(hash: string) {
		const path = hash.replace('#', '').replace(/^\//, '/');
		const found = matchRoute(path, routes);

		if (found) {
			return found;
		}

		return notFoundRoute;
	}

	function handleRouteChange() {
		const path = window.location.hash.slice(1) || '/';
		const route = findRouteByHash(path);
		const params = parseUrlParams(route.path, path);

		currentParams.set(params);

		if (route) {
			const guardedRoute = RouteGuard.checkRoute(route);
			currentRoute.set(guardedRoute);
		} else {
			currentRoute.set(notFoundRoute);
		}
	}

	$effect(() => {
		handleRouteChange();
		window.addEventListener('hashchange', handleRouteChange);
		return () => {
			window.removeEventListener('hashchange', handleRouteChange);
		};
	});

	const Component = $derived($currentRoute?.component);
</script>

{#if Component}
	<Component {...$currentParams} />
{/if}

```

`zil-pay/popup/background/wallet.ts`:

```ts
import type { BackgroundState } from "background/storage";

import { get } from "svelte/store";
import { MTypePopup } from "config/stream";
import { Themes } from "config/theme";
import { warpMessage, type SendResponseParams } from "lib/popup/warp-message";
import { Message } from "lib/streem/message";
import { themeDetect } from "popup/mixins/theme";
import globalStore from "popup/store/global";
import type { IKeyPair } from "types/wallet";
 
export async function getGlobalState() {
  const data = await Message.signal(MTypePopup.GET_GLOBAL_STATE).send();
  let resolve = warpMessage(data) as BackgroundState;

  if (resolve.appearances == Themes.System) {
    resolve.appearances = themeDetect();
  }

  document.body.setAttribute("theme", resolve.appearances);
  globalStore.set(resolve);

  return resolve;
}

export async function generateKeyPair(slip44: number) {
  const data =    await new Message<SendResponseParams>({
    type: MTypePopup.GEN_KEYPAIR,
    payload: {
      slip44,
    },
  }).send();
  let resolve = warpMessage(data) as IKeyPair;
  return resolve;
}

export async function fromRpivKey(slip44: number, key: string) {
  const data =    await new Message<SendResponseParams>({
    type: MTypePopup.FROM_PRIV_KEY,
    payload: {
      slip44,
      key,
    },
  }).send();
  let resolve = warpMessage(data) as IKeyPair;
  return resolve;
}

export async function validateBip39Checksum(phrase: string, wordList: string[]) {
  const data =    await new Message<SendResponseParams>({
    type: MTypePopup.VALIDATE_BIP39_CHECK_SUM,
    payload: {
      phrase,
      wordList,
    },
  }).send();
  let resolve = warpMessage(data) as boolean;
  return resolve;
}



export async function generateBip39Words(count: number, wordList: string[]) {
  const data =    await new Message<SendResponseParams>({
    type: MTypePopup.GEN_BIP39,
    payload: {
      count,
      wordList
    },
  }).send();
  let resolve = warpMessage(data) as string;

  return resolve;
}


export async function setGlobalState() {
  const globalState = get(globalStore);

   await new Message({
    type: MTypePopup.SET_GLOBAL_STATE,
    payload: globalState,
  }).send();
}



```

`zil-pay/popup/components/Button.svelte`:

```svelte
<script lang="ts">
  export let width: string = '100%';
  export let height: number = 56;
</script>

<button
  {...$$restProps}
  style:width={width}
  style:height={`${height}px`}
>
  <span class="text">
    <slot />
  </span>
</button>

<style lang="scss">
  button {
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    border: none;
    border-radius: 30px;
    padding: 0 16px;
    background-color: var(--button-background);
    transform-origin: center;
    transition: transform 0.2s cubic-bezier(0.22, 1, 0.36, 1);
    transform: scale(1);
  }

  button:active:not(:disabled) {
    transform: scale(0.9);
  }

  button:disabled {
    cursor: not-allowed;
    background-color: color-mix(in srgb, var(--button-background) 50%, transparent);
  }

  .text {
    font-weight: bold;
    font-size: var(--font-size-large);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: var(--button-text);
  }

  button:disabled .text {
    color: color-mix(in srgb, var(--button-text) 50%, transparent);
  }

  .secondary {
      background-color: var(--secondary-purple);
  }
</style>

```

`zil-pay/popup/components/CopyButton.svelte`:

```svelte
<script lang="ts">
  let {
    text = '',
    ariaLabel = '',
    size = 44,
    disabled = false
  }: {
    text: string;
    ariaLabel?: string;
    size?: number;
    disabled?: boolean;
  } = $props();

  let isCopied = $state(false);

  async function handleCopy() {
    if (!text || disabled) return;
    
    try {
      await navigator.clipboard.writeText(text);
      isCopied = true;
      setTimeout(() => {
        isCopied = false;
      }, 2000);
    } catch (error) {
      console.error('Error copying to clipboard:', error);
    }
  }
</script>

<button
  class="copy-button"
  onclick={handleCopy}
  disabled={disabled || !text}
  aria-label={ariaLabel}
  style="width: {size}px; height: {size}px;"
>
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
  >
    {#if isCopied}
      <path
        d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"
        fill="currentColor"
      />
    {:else}
      <path
        d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"
        fill="currentColor"
      />
    {/if}
  </svg>
</button>

<style lang="scss">
  .copy-button {
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--card-background);
    border: 2px solid transparent;
    border-radius: 10px;
    cursor: pointer;
    color: var(--primary-purple);
    transition: all 0.2s ease;
    flex-shrink: 0;

    &:hover:not(:disabled) {
      border-color: color-mix(in srgb, var(--primary-purple) 30%, transparent);
      background: color-mix(in srgb, var(--card-background) 95%, var(--primary-purple));
    }

    &:focus {
      outline: none;
      border-color: var(--primary-purple);
    }

    &:disabled {
      cursor: not-allowed;
      opacity: 0.5;
      color: var(--text-secondary);
    }

    &:active:not(:disabled) {
      transform: scale(0.95);
    }
  }

  @media (max-width: 480px) {
    .copy-button {
      svg {
        width: 18px;
        height: 18px;
      }
    }
  }

  @media (max-width: 360px) {
    .copy-button {
      svg {
        width: 16px;
        height: 16px;
      }
    }
  }
</style>

```

`zil-pay/popup/components/Dropdown.svelte`:

```svelte
<script lang="ts">
  type DropdownOption = {
    code: string;
    label: string;
  };

  let {
    options = [],
    selected = $bindable(''),
    placeholder = 'Select option',
    onSelect = () => {},
    disabled = false,
    width = '100%'
  }: {
    options: DropdownOption[];
    selected: string;
    placeholder?: string;
    onSelect?: (code: string) => void;
    disabled?: boolean;
    width?: string;
  } = $props();

  let isOpen = $state(false);

  const selectedOption = $derived(
    options.find(option => option.code === selected) || null
  );

  function toggleDropdown() {
    if (disabled) return;
    isOpen = !isOpen;
  }

  function selectOption(code: string) {
    selected = code;
    isOpen = false;
    onSelect(code);
  }

  function handleOutsideClick(event: MouseEvent) {
    const target = event.target as HTMLElement;
    if (!target.closest('.dropdown-container')) {
      isOpen = false;
    }
  }

  function handleKeydown(event: KeyboardEvent) {
    if (disabled) return;
    
    switch (event.key) {
      case 'Enter':
      case ' ':
        event.preventDefault();
        toggleDropdown();
        break;
      case 'Escape':
        isOpen = false;
        break;
      case 'ArrowDown':
        if (!isOpen) {
          event.preventDefault();
          isOpen = true;
        } else {
          event.preventDefault();
        }
        break;
      case 'ArrowUp':
        if (isOpen) {
          event.preventDefault();
        }
        break;
    }
  }

  $effect(() => {
    if (isOpen) {
      document.addEventListener('click', handleOutsideClick);
      return () => {
        document.removeEventListener('click', handleOutsideClick);
      };
    }
  });
</script>

<div class="dropdown-container" style="width: {width}">
  <button 
    class="dropdown-trigger"
    class:open={isOpen}
    class:disabled={disabled}
    onclick={toggleDropdown}
    onkeydown={handleKeydown}
    type="button"
    aria-expanded={isOpen}
    aria-haspopup="listbox"
    {disabled}
  >
    <span class="selected-content">
      {#if selectedOption}
        <span class="option-label">{selectedOption.label}</span>
        <span class="option-code">({selectedOption.code})</span>
      {:else}
        <span class="placeholder">{placeholder}</span>
      {/if}
    </span>
    <span class="dropdown-arrow" class:rotated={isOpen}>▼</span>
  </button>

  {#if isOpen && !disabled}
    <div class="dropdown-menu" role="listbox">
      {#each options as option}
        <button
          class="dropdown-item"
          class:selected={option.code === selected}
          onclick={() => selectOption(option.code)}
          type="button"
          role="option"
          aria-selected={option.code === selected}
        >
          <span class="item-content">
            <span class="option-label">{option.label}</span>
            <span class="option-code">({option.code})</span>
          </span>
          {#if option.code === selected}
            <span class="check-mark">✓</span>
          {/if}
        </button>
      {/each}
    </div>
  {/if}
</div>

<style lang="scss">
  .dropdown-container {
    position: relative;
  }

  .dropdown-trigger {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    padding: 12px 16px;
    background-color: var(--card-background);
    border: 2px solid color-mix(in srgb, var(--text-secondary) 20%, transparent);
    border-radius: 12px;
    cursor: pointer;
    font-size: var(--font-size-medium);
    color: var(--text-primary);
    transition: all 0.2s ease;

    &:hover:not(:disabled) {
      border-color: color-mix(in srgb, var(--primary-purple) 30%, transparent);
    }

    &:focus {
      outline: none;
      border-color: var(--primary-purple);
    }

    &.open {
      border-color: var(--primary-purple);
      border-bottom-left-radius: 4px;
      border-bottom-right-radius: 4px;
    }

    &.disabled {
      cursor: not-allowed;
      opacity: 0.6;
      background-color: color-mix(in srgb, var(--card-background) 50%, transparent);
    }
  }

  .selected-content {
    display: flex;
    align-items: center;
    gap: 6px;
    overflow: hidden;
    flex: 1;
  }

  .option-label {
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .option-code {
    font-size: var(--font-size-small);
    color: var(--text-secondary);
    opacity: 0.8;
    flex-shrink: 0;
  }

  .placeholder {
    color: var(--text-secondary);
    opacity: 0.7;
    font-style: italic;
  }

  .dropdown-arrow {
    font-size: var(--font-size-small);
    color: var(--text-secondary);
    transition: transform 0.2s ease;
    flex-shrink: 0;

    &.rotated {
      transform: rotate(180deg);
    }
  }

  .dropdown-menu {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background-color: var(--card-background);
    border: 2px solid var(--primary-purple);
    border-top: none;
    border-radius: 0 0 12px 12px;
    box-shadow: 0 8px 24px color-mix(in srgb, var(--primary-purple) 15%, transparent);
    z-index: 1000;
    max-height: 280px;
    overflow-y: auto;
  }

  .dropdown-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    padding: 12px 16px;
    background: none;
    border: none;
    cursor: pointer;
    font-size: var(--font-size-medium);
    color: var(--text-primary);
    transition: background-color 0.2s ease;
    text-align: left;

    &:hover {
      background-color: color-mix(in srgb, var(--primary-purple) 10%, transparent);
    }

    &:focus {
      outline: none;
      background-color: color-mix(in srgb, var(--primary-purple) 15%, transparent);
    }

    &.selected {
      background-color: color-mix(in srgb, var(--primary-purple) 20%, transparent);
      
      .option-label {
        color: var(--primary-purple);
        font-weight: 600;
      }
    }

    &:last-child {
      border-radius: 0 0 10px 10px;
    }
  }

  .item-content {
    display: flex;
    align-items: center;
    gap: 6px;
    overflow: hidden;
    flex: 1;
  }

  .check-mark {
    color: var(--primary-purple);
    font-weight: bold;
    font-size: var(--font-size-large);
    flex-shrink: 0;
  }

  /* Scrollbar styling */
  .dropdown-menu::-webkit-scrollbar {
    width: 6px;
  }

  .dropdown-menu::-webkit-scrollbar-track {
    background: transparent;
  }

  .dropdown-menu::-webkit-scrollbar-thumb {
    background: color-mix(in srgb, var(--text-secondary) 30%, transparent);
    border-radius: 3px;

    &:hover {
      background: color-mix(in srgb, var(--text-secondary) 50%, transparent);
    }
  }

  @media (max-width: 480px) {
    .dropdown-trigger,
    .dropdown-item {
      padding: 10px 12px;
      font-size: var(--font-size-small);
    }

    .option-code {
      font-size: calc(var(--font-size-small) * 0.9);
    }
  }
</style>


```

`zil-pay/popup/components/HexKey.svelte`:

```svelte
<script lang="ts">
  import { onMount } from 'svelte';

  let { hexKey = '', title = '' }: { hexKey: string; title: string } = $props();

  let currentPairs = $state<string[]>([]);
  let animationStates = $state<boolean[]>([]);
  let chunkSize = $state(12);
  let isMounted = false;

  function getPairs(key: string): string[] {
    if (!key) return [];
    const cleanKey = key.replace(/[^0-9A-Fa-f]/g, '').toUpperCase();
    const pairs: string[] = [];
    for (let i = 0; i < cleanKey.length; i += 2) {
      if (i + 2 <= cleanKey.length) {
        pairs.push(cleanKey.substring(i, i + 2));
      }
    }
    return pairs;
  }

  function updateChunkSize() {
    if (typeof window === 'undefined') return;
    const width = window.innerWidth;
    if (width < 600) chunkSize = 6;
    else if (width < 905) chunkSize = 8;
    else if (width < 1240) chunkSize = 10;
    else chunkSize = 12;
  }

  const chunks = $derived(() => {
    const result: string[][] = [];
    if (currentPairs.length === 0) return [];
    for (let i = 0; i < currentPairs.length; i += chunkSize) {
      result.push(currentPairs.slice(i, i + chunkSize));
    }
    return result;
  });

  function startAnimation(target: string[]) {
    const delayMs = 30;
    const acceleration = 1.0;

    for (let i = 0; i < target.length; i++) {
      let totalDelay = 0;
      for (let j = 0; j <= i; j++) {
        totalDelay += delayMs * Math.pow(acceleration, j);
      }

      setTimeout(() => {
        if (!animationStates) return;
        animationStates[i] = true;
        currentPairs[i] = target[i];

        setTimeout(() => {
          if (!animationStates) return;
          animationStates[i] = false;
        }, 80);
      }, totalDelay);
    }
  }

  onMount(() => {
    isMounted = true;
    updateChunkSize();
    window.addEventListener('resize', updateChunkSize);
    return () => {
      window.removeEventListener('resize', updateChunkSize);
    };
  });

  $effect(() => {
    if (!isMounted || !hexKey) {
      return;
    }
    
    const newTargetPairs = getPairs(hexKey);
    
    currentPairs = new Array(newTargetPairs.length).fill('  ');
    animationStates = new Array(newTargetPairs.length).fill(false);

    setTimeout(() => {
      startAnimation(newTargetPairs);
    });
  });

</script>

<div class="hex-key-display">
  {#if title}
    <h3 class="title">{title}</h3>
  {/if}
  
  <div class="hex-container">
    {#each chunks() as chunk, chunkIndex}
      <div class="hex-row">
        {#each chunk as pair, pairIndex}
          {@const globalIndex = chunkIndex * chunkSize + pairIndex}
          {@const isAnimating = animationStates[globalIndex] ?? false}
          
          <div 
            class="hex-pair"
            class:animating={isAnimating}
          >
            {pair}
          </div>
        {/each}
      </div>
    {/each}
  </div>
</div>

<style lang="scss">
  .hex-key-display {
    width: 100%;
    padding: var(--padding-side);
    box-sizing: border-box;
  }

  .title {
    font-size: var(--font-size-xl);
    font-weight: 600;
    color: var(--text-secondary);
    margin: 0 0 var(--padding-side) 0;
    line-height: 1.3;
  }

  .hex-container {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .hex-row {
    display: flex;
    gap: 0;
    min-height: 32px;
    align-items: center;
  }

  .hex-pair {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 45px;
    height: 32px;
    font-family: 'Courier New', Courier, monospace;
    font-size: var(--font-size-medium);
    font-weight: 500;
    color: var(--text-primary);
    border-radius: 4px;
    transition: color 100ms ease-in-out;
    
    &.animating {
      color: var(--secondary-purple);
    }
  }
</style>

```

`zil-pay/popup/components/LanguageSelectorButton.svelte`:

```svelte
<script lang="ts">
	import { push } from '../router/navigation';
	import LanguageIcon from '../components/icons/Language.svelte';

	function openLocalePage() {
		push('/locale');
	}
</script>

<button class="language-selector" on:click={openLocalePage}>
	<LanguageIcon width={28} height={28} />
</button>

<style lang="scss">
	.language-selector {
		display: flex;
		align-items: center;
		justify-content: center;
		width: 36px;
		height: 36px;
		border-radius: 50%;
		border: 2px solid var(--modal-border);
		background: rgba(255, 255, 255, 0.05);
		backdrop-filter: blur(10px);
		cursor: pointer;

		&:hover {
			background: rgba(255, 255, 255, 0.2);
			box-shadow: 0 4px 12px rgba(255, 255, 255, 0.1);
		}
	}
</style>

```

`zil-pay/popup/components/LittleButton.svelte`:

```svelte
<script lang="ts">
  let {
    onclick = () => {},
    disabled = false,
    children
  } = $props();
</script>

<button
  class="little-button"
  class:disabled
  onclick={() => onclick()}
  {disabled}
  type="button"
>
  {@render children()}
</button>

<style lang="scss">
  .little-button {
    background: none;
    border: none;
    color: var(--primary-purple);
    font-size: var(--font-size-medium);
    font-weight: 500;
    cursor: pointer;
    text-decoration: underline;
    text-underline-offset: 4px;
    transition: all 0.2s ease;
    padding: 8px 16px;
    border-radius: 8px;

    &:hover:not(:disabled) {
      background: color-mix(in srgb, var(--primary-purple) 8%, transparent);
      text-decoration: none;
    }

    &:focus:not(:disabled) {
      outline: none;
      background: color-mix(in srgb, var(--primary-purple) 12%, transparent);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-purple) 20%, transparent);
    }

    &:active:not(:disabled) {
      transform: scale(0.98);
    }

    &:disabled {
      cursor: not-allowed;
      opacity: 0.5;
      color: var(--text-secondary);
    }
  }

  @media (max-width: 480px) {
    .little-button {
      font-size: var(--font-size-small);
      padding: 6px 12px;
    }
  }
</style>

```

`zil-pay/popup/components/MnemonicWord.svelte`:

```svelte
<script lang="ts">
  let {
    index = 0,
    word = "",
    ...restProps
  } = $props();
</script>

<div class="mnemonic-word" {...restProps}>
  <span class="word-index">{index}</span>
  <span class="word-text">{word}</span>
</div>

<style lang="scss">
  .mnemonic-word {
    display: flex;
    align-items: center;
    gap: 10px;
    background: var(--background-color);
    border-radius: 8px;
    padding: 14px 16px;
    border: 1px solid color-mix(in srgb, var(--text-secondary) 20%, transparent);
    min-width: 0;
  }

  .word-index {
    font-size: var(--font-size-small);
    font-weight: 600;
    color: var(--text-secondary);
    min-width: 20px;
    flex-shrink: 0;
  }

  .word-text {
    font-size: var(--font-size-medium);
    font-weight: 500;
    color: var(--text-primary);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
</style>

```

`zil-pay/popup/components/MnemonicWordInput.svelte`:

```svelte
<script lang="ts">
  let {
    index = 1,
    word = '',
    isEditable = false,
    borderColor = undefined,
    errorBorderColor = undefined,
    hasError = false,
    opacity = 1,
    onChanged = undefined
  }: {
    index: number;
    word: string;
    isEditable?: boolean;
    borderColor?: string;
    errorBorderColor?: string;
    hasError?: boolean;
    opacity?: number;
    onChanged?: (index: number, value: string) => void;
  } = $props();

  let inputValue = $state(word);
  let shouldUpdateFromProps = $state(true);

  $effect(() => {
    if (shouldUpdateFromProps && word !== inputValue) {
      inputValue = word;
    }
    shouldUpdateFromProps = true;
  });

  function handleInput(event: Event) {
    const target = event.target as HTMLInputElement;
    shouldUpdateFromProps = false;
    inputValue = target.value;
    
    if (onChanged) {
      onChanged(index, target.value);
    }
  }
</script>

<div 
  class="mnemonic-word-input"
  class:has-error={hasError}
  class:has-custom-border={borderColor && !hasError}
  style="
    opacity: {opacity};
    --custom-border-color: {borderColor || 'transparent'};
    --custom-error-color: {errorBorderColor || 'var(--danger-color)'};
  "
>
  <span class="word-index">
    {index}
  </span>
  <input
    type="text"
    value={inputValue}
    disabled={!isEditable}
    class="word-input"
    oninput={handleInput}
    autocomplete="off"
    autocapitalize="off"
    spellcheck="false"
  />
</div>

<style lang="scss">
  .mnemonic-word-input {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    background-color: var(--card-background);
    border-radius: 12px;
    border: 1px solid transparent;
    transition: border-color 0.2s ease;
    min-width: 0;
    width: 100%;
    box-sizing: border-box;
    
    &.has-custom-border {
      border-color: var(--custom-border-color);
    }
    
    &.has-error {
      border-color: var(--custom-error-color);
      
      .word-index {
        color: var(--custom-error-color);
      }
      
      .word-input {
        color: var(--custom-error-color);
      }
    }
  }

  .word-index {
    font-size: var(--font-size-small);
    font-weight: 600;
    color: var(--text-secondary);
    min-width: 16px;
    flex-shrink: 0;
    line-height: 1;
    text-align: center;
  }

  .word-input {
    flex: 1;
    border: none;
    background: transparent;
    font-size: var(--font-size-small);
    font-weight: 500;
    color: var(--text-primary);
    outline: none;
    padding: 0;
    min-width: 0;
    width: 100%;
    
    &:disabled {
      cursor: default;
      user-select: none;
    }
    
    &::placeholder {
      color: var(--text-secondary);
      opacity: 0.5;
      font-style: italic;
    }
    
    &:focus {
      outline: none;
    }
  }

  @media (max-width: 480px) {
    .mnemonic-word-input {
      padding: 8px 10px;
      gap: 6px;
    }
    
    .word-index {
      min-width: 14px;
      font-size: calc(var(--font-size-small) * 0.9);
    }
    
    .word-input {
      font-size: calc(var(--font-size-small) * 0.9);
    }
  }
</style>

```

`zil-pay/popup/components/Modal.svelte`:

```svelte
<script lang="ts">
  import type { Snippet } from 'svelte';
  import { scale, fade, fly } from 'svelte/transition';
  import Close from './icons/Close.svelte';

  let {
    title = '',
    show = $bindable(false),
    onClose = () => {},
    width = '500px',
    closeOnOverlay = true,
    children
  }: {
    title?: string;
    show?: boolean;
    onClose?: () => void;
    width?: string;
    closeOnOverlay?: boolean;
    children?: Snippet;
  } = $props();

  let modalRef: HTMLElement | null = $state(null);
  let isSmallScreen = $state(false);

  function handleClose() {
    show = false;
    onClose();
  }

  function handleOverlayClick(event: MouseEvent) {
    if (closeOnOverlay && event.target === modalRef) {
      handleClose();
    }
  }

  function handleOverlayKeydown(event: KeyboardEvent) {
    if (event.key === 'Enter' || event.key === ' ') {
      if (closeOnOverlay && event.target === modalRef) {
        event.preventDefault();
        handleClose();
      }
    }
  }

  function handleKeydown(event: KeyboardEvent) {
    if (event.key === 'Escape' && show) {
      handleClose();
    }
  }

  function checkScreenSize() {
    if (typeof window !== 'undefined') {
      isSmallScreen = window.innerWidth <= 480 || window.innerHeight <= 600;
    }
  }

  $effect(() => {
    checkScreenSize();
    
    if (typeof window !== 'undefined') {
      window.addEventListener('resize', checkScreenSize);
      return () => {
        window.removeEventListener('resize', checkScreenSize);
      };
    }
  });

  $effect(() => {
    if (show) {
      document.addEventListener('keydown', handleKeydown);
      document.body.style.overflow = 'hidden';
      
      const focusableElements = modalRef?.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      const firstElement = focusableElements?.[0] as HTMLElement;
      const lastElement = focusableElements?.[focusableElements.length - 1] as HTMLElement;

      if (firstElement) {
        firstElement.focus();
      }

      function handleTabKey(e: KeyboardEvent) {
        if (e.key === 'Tab') {
          if (e.shiftKey) {
            if (document.activeElement === firstElement) {
              e.preventDefault();
              lastElement?.focus();
            }
          } else {
            if (document.activeElement === lastElement) {
              e.preventDefault();
              firstElement?.focus();
            }
          }
        }
      }

      document.addEventListener('keydown', handleTabKey);
      
      return () => {
        document.removeEventListener('keydown', handleKeydown);
        document.removeEventListener('keydown', handleTabKey);
        document.body.style.overflow = '';
      };
    }
  });
</script>

{#if show}
  <div
    bind:this={modalRef}
    class="modal-overlay"
    class:small-screen={isSmallScreen}
    transition:fade={{ delay: 0, duration: 250 }}
    onclick={handleOverlayClick}
    onkeydown={handleOverlayKeydown}
    role="dialog"
    aria-modal="true"
    aria-labelledby={title ? 'modal-title' : undefined}
    tabindex="-1"
  >
    {#if isSmallScreen}
      {#key show}
        <div
          class="modal-content small-screen"
          in:fly={{ y: 300, duration: 300, opacity: 1 }}
          out:fly={{ y: 300, duration: 250, opacity: 1 }}
          role="document"
        >
          <div class="modal-header">
            {#if title}
              <h2 id="modal-title" class="modal-title">
                {title}
              </h2>
            {/if}
            <button
              class="modal-close-button"
              onclick={handleClose}
              aria-label="Close modal"
              type="button"
            >
              <Close width={24} height={24} />
            </button>
          </div>
          
          <div class="modal-body">
            {#if children}
              {@render children()}
            {/if}
          </div>
        </div>
      {/key}
    {:else}
      {#key show}
        <div
          class="modal-content"
          style="max-width: {width}"
          in:scale={{ delay: 0, duration: 250 }}
          out:scale={{ delay: 0, duration: 200 }}
          role="document"
        >
          <div class="modal-header">
            {#if title}
              <h2 id="modal-title" class="modal-title">
                {title}
              </h2>
            {/if}
            <button
              class="modal-close-button"
              onclick={handleClose}
              aria-label="Close modal"
              type="button"
            >
              <Close width={24} height={24} />
            </button>
          </div>
          
          <div class="modal-body">
            {#if children}
              {@render children()}
            {/if}
          </div>
        </div>
      {/key}
    {/if}
  </div>
{/if}

<style lang="scss">
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(4px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    padding: 20px;
    box-sizing: border-box;

    &.small-screen {
      align-items: flex-end;
      padding: 0;
    }

    &:focus {
      outline: none;
    }
  }

  .modal-content {
    width: 100%;
    background: var(--card-background);
    border-radius: 16px;
    box-shadow: 0 20px 40px color-mix(in srgb, var(--text-primary) 20%, transparent);
    overflow: hidden;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
    border: 1px solid color-mix(in srgb, var(--text-secondary) 15%, transparent);

    &.small-screen {
      max-height: 85vh;
      border-radius: 16px 16px 0 0;
      margin: 0;
      box-shadow: 0 -10px 40px color-mix(in srgb, var(--text-primary) 30%, transparent);
      max-width: none !important;
    }

    &:focus {
      outline: none;
    }
  }

  .modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 20px 24px;
    border-bottom: 1px solid color-mix(in srgb, var(--text-secondary) 15%, transparent);
    background: var(--background-color);
    flex-shrink: 0;
    position: relative;

    .small-screen & {
      padding: 16px 20px;
      
      &::before {
        content: '';
        position: absolute;
        top: 8px;
        left: 50%;
        transform: translateX(-50%);
        width: 36px;
        height: 4px;
        background: color-mix(in srgb, var(--text-secondary) 40%, transparent);
        border-radius: 2px;
      }
    }
  }

  .modal-title {
    font-size: var(--font-size-xl);
    font-weight: 600;
    color: var(--text-primary);
    margin: 0;
    line-height: 1.3;

    .small-screen & {
      font-size: var(--font-size-large);
    }
  }

  .modal-close-button {
    display: flex;
    align-items: center;
    justify-content: center;
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px;
    border-radius: 8px;
    transition: all 0.2s ease;
    color: var(--text-secondary);

    &:focus {
      outline: none;
      background: color-mix(in srgb, var(--primary-purple) 15%, transparent);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-purple) 20%, transparent);
    }

    &:active {
      transform: scale(0.95);
    }
  }

  .modal-body {
    padding: 24px;
    overflow-y: auto;
    flex: 1;
    min-height: 0;

    .small-screen & {
      padding: 20px;
      padding-bottom: max(20px, env(safe-area-inset-bottom));
    }
  }

  .modal-body::-webkit-scrollbar {
    width: 6px;
  }

  .modal-body::-webkit-scrollbar-track {
    background: transparent;
  }

  .modal-body::-webkit-scrollbar-thumb {
    background: color-mix(in srgb, var(--text-secondary) 30%, transparent);
    border-radius: 3px;

    &:hover {
      background: color-mix(in srgb, var(--text-secondary) 50%, transparent);
    }
  }

  @media (max-width: 400px), (max-height: 600px) {
    .modal-overlay {
      align-items: flex-end;
      padding: 0;
    }

    .modal-content {
      max-height: 90vh;
      border-radius: 12px 12px 0 0;
    }

    .modal-header {
      padding: 12px 16px;

      &::before {
        top: 6px;
        width: 32px;
        height: 3px;
      }
    }

    .modal-title {
      font-size: var(--font-size-medium);
    }

    .modal-body {
      padding: 16px;
    }
  }

  @media (max-width: 360px) {
    .modal-header {
      padding: 10px 14px;
    }

    .modal-body {
      padding: 14px;
    }
  }
</style>

```

`zil-pay/popup/components/NavBar.svelte`:

```svelte
<script lang="ts">
	let {
		title = '',
		onBack = () => window.history.back(),
		onRight = null,
		rightIcon = null,
		left = null
	} = $props();
</script>

<nav class="nav-bar">
	<button
		class="nav-left-button"
		type="button"
		onclick={() => onBack()}
		aria-label="Back"
	>
		{#if left}
			{@render left()}
		{:else}
			<span class="arrow">←</span>
		{/if}
	</button>
	<h1 class="nav-title">{title}</h1>
	{#if rightIcon}
		<button
			class="nav-right-button"
			type="button"
			onclick={() => onRight()}
			aria-label="Action"
		>
			{#if typeof rightIcon === 'string'}
				<img src={rightIcon} alt="" />
			{:else}
				{@const Icon = rightIcon}
				<Icon />
			{/if}
		</button>
	{:else}
		<div class="nav-right-placeholder"></div>
	{/if}
</nav>

<style lang="scss">
  .nav-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    padding: 20px 0;
    box-sizing: border-box;
  }

  .nav-title {
    font-size: var(--font-size-xl);
    font-weight: bold;
    flex: 1;
    text-align: center;
    color: var(--text-primary);
    margin: 0;
  }

  .nav-left-button {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-primary);
    font-weight: bold;
    font-size: calc(var(--font-size-xl) * 1.33);
    padding: 0;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .arrow {
    font-size: calc(var(--font-size-xl) * 1.33);
  }

  .nav-right-button {
    background: none;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 36px;
    padding: 0;
    color: var(--text-primary);
  }

  .nav-right-placeholder {
    width: 36px;
    height: 36px;
  }
</style>

```

`zil-pay/popup/components/PrintButton.svelte`:

```svelte
<script lang="ts">
  import type { IKeyPair } from 'types/wallet';
  import { _ } from 'popup/i18n';

  let {
    phrase = [],
    keyPair = null,
    disabled = false,
    ariaLabel = '',
    size = 44
  }: {
    phrase?: string[];
    keyPair?: IKeyPair | null;
    disabled?: boolean;
    ariaLabel?: string;
    size?: number;
  } = $props();

  const isPhraseMode = $derived(phrase && phrase.length > 0);
  const isKeyPairMode = $derived(keyPair && keyPair.privateKey);

  function escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function createBip39PrintDocument(words: string[]): string {
    const currentDate = escapeHtml(new Date().toLocaleDateString());
    const phraseString = escapeHtml(words.join(' '));
    const title = escapeHtml($_('print.bip39.title'));
    const headerTitle = escapeHtml($_('print.bip39.header.title'));
    const headerSubtitle = escapeHtml($_('print.bip39.header.subtitle'));
    const generated = escapeHtml($_('print.bip39.header.generated'));
    
    return `
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="utf-8">
          <title>${title}</title>
          <style>
            * {
              margin: 0;
              padding: 0;
              box-sizing: border-box;
            }
            
            body {
              font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
              background: #ffffff;
              color: #000000;
              padding: 40px;
              line-height: 1.6;
            }
            
            .header {
              text-align: center;
              margin-bottom: 40px;
              border-bottom: 2px solid #e0e0e0;
              padding-bottom: 20px;
            }
            
            .header h1 {
              font-size: 28px;
              font-weight: 700;
              color: #000000;
              margin-bottom: 8px;
            }
            
            .header p {
              font-size: 14px;
              color: #666666;
              margin-bottom: 4px;
            }
            
            .date {
              font-size: 12px;
              color: #999999;
            }
            
            .warning {
              background: #fff3cd;
              border: 2px solid #ffeaa7;
              border-radius: 8px;
              padding: 20px;
              margin-bottom: 30px;
              color: #856404;
            }
            
            .warning h2 {
              font-size: 18px;
              margin-bottom: 10px;
              color: #d63031;
            }
            
            .warning ul {
              margin-left: 20px;
            }
            
            .warning li {
              margin-bottom: 6px;
              font-size: 14px;
            }
            
            .phrase-container {
              margin: 30px 0;
            }
            
            .phrase-title {
              font-size: 20px;
              font-weight: 600;
              text-align: center;
              margin-bottom: 25px;
              color: #000000;
            }
            
            .copy-section {
              background: #e8f4fd;
              border: 2px solid #2196f3;
              border-radius: 8px;
              padding: 16px;
              margin-bottom: 20px;
            }
            
            .copy-section h3 {
              font-size: 16px;
              margin-bottom: 8px;
              color: #1976d2;
            }
            
            .copy-text {
              font-family: 'Courier New', monospace;
              background: #ffffff;
              padding: 12px;
              border-radius: 4px;
              border: 1px solid #2196f3;
              word-break: break-all;
              line-height: 1.5;
              font-size: 14px;
            }
            
            .phrase-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
              gap: 12px;
              max-width: 800px;
              margin: 0 auto;
            }
            
            .word-item {
              display: flex;
              align-items: center;
              background: #f8f9fa;
              border: 1px solid #e9ecef;
              border-radius: 6px;
              padding: 12px 16px;
              font-size: 16px;
            }
            
            .word-number {
              background: #000000;
              color: #ffffff;
              border-radius: 4px;
              padding: 4px 8px;
              font-size: 12px;
              font-weight: 600;
              margin-right: 12px;
              min-width: 24px;
              text-align: center;
            }
            
            .word-text {
              font-weight: 500;
              font-family: 'Courier New', monospace;
              color: #000000;
            }
            
            .instructions {
              margin-top: 40px;
              background: #f8f9fa;
              border-radius: 8px;
              padding: 20px;
            }
            
            .instructions h3 {
              font-size: 16px;
              margin-bottom: 12px;
              color: #000000;
            }
            
            .instructions ol {
              margin-left: 20px;
            }
            
            .instructions li {
              margin-bottom: 8px;
              font-size: 14px;
              color: #333333;
            }
            
            .footer {
              margin-top: 40px;
              text-align: center;
              font-size: 12px;
              color: #999999;
              border-top: 1px solid #e0e0e0;
              padding-top: 20px;
            }
            
            @media print {
              body {
                padding: 20px;
              }
              
              .warning {
                break-inside: avoid;
              }
              
              .phrase-container {
                break-inside: avoid;
              }
              
              .word-item {
                break-inside: avoid;
              }
            }
          </style>
        </head>
        <body>
          <div class="header">
            <h1>${headerTitle}</h1>
            <p>${headerSubtitle}</p>
            <p class="date">${generated}: ${currentDate}</p>
          </div>
          
          <div class="warning">
            <h2>⚠️ ${escapeHtml($_('print.bip39.warning.title'))}</h2>
            <ul>
              <li>${escapeHtml($_('print.bip39.warning.secure'))}</li>
              <li>${escapeHtml($_('print.bip39.warning.access'))}</li>
              <li>${escapeHtml($_('print.bip39.warning.noOnline'))}</li>
              <li>${escapeHtml($_('print.bip39.warning.multipleBackups'))}</li>
              <li>${escapeHtml($_('print.bip39.warning.testRestore'))}</li>
            </ul>
          </div>
          
          <div class="phrase-container">
            <h2 class="phrase-title">${escapeHtml($_('print.bip39.phrase.title'))} (${words.length} ${escapeHtml($_('print.bip39.phrase.words'))})</h2>
            
            <div class="copy-section">
              <h3>${escapeHtml($_('print.bip39.phrase.copyTitle'))}</h3>
              <div class="copy-text">${phraseString}</div>
            </div>
            
            <div class="phrase-grid">
              ${words.map((word, index) => `
                <div class="word-item">
                  <span class="word-number">${index + 1}</span>
                  <span class="word-text">${escapeHtml(word)}</span>
                </div>
              `).join('')}
            </div>
          </div>
          
          <div class="instructions">
            <h3>${escapeHtml($_('print.bip39.instructions.title'))}</h3>
            <ol>
              <li>${escapeHtml($_('print.bip39.instructions.writeDown'))}</li>
              <li>${escapeHtml($_('print.bip39.instructions.doubleCheck'))}</li>
              <li>${escapeHtml($_('print.bip39.instructions.store'))}</li>
              <li>${escapeHtml($_('print.bip39.instructions.test'))}</li>
              <li>${escapeHtml($_('print.bip39.instructions.noPhotos'))}</li>
            </ol>
          </div>
          
          <div class="footer">
            <p>${escapeHtml($_('print.bip39.footer.warning'))}</p>
          </div>
        </body>
      </html>
    `;
  }

  function createKeyPairPrintDocument(keys: IKeyPair): string {
    const currentDate = escapeHtml(new Date().toLocaleDateString());
    const title = escapeHtml($_('print.keypair.title'));
    const headerTitle = escapeHtml($_('print.keypair.header.title'));
    const headerSubtitle = escapeHtml($_('print.keypair.header.subtitle'));
    const generated = escapeHtml($_('print.keypair.header.generated'));
    
    return `
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="utf-8">
          <title>${title}</title>
          <style>
            * {
              margin: 0;
              padding: 0;
              box-sizing: border-box;
            }
            
            body {
              font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
              background: #ffffff;
              color: #000000;
              padding: 40px;
              line-height: 1.6;
            }
            
            .header {
              text-align: center;
              margin-bottom: 40px;
              border-bottom: 2px solid #e0e0e0;
              padding-bottom: 20px;
            }
            
            .header h1 {
              font-size: 28px;
              font-weight: 700;
              color: #000000;
              margin-bottom: 8px;
            }
            
            .header p {
              font-size: 14px;
              color: #666666;
              margin-bottom: 4px;
            }
            
            .date {
              font-size: 12px;
              color: #999999;
            }
            
            .warning {
              background: #fff3cd;
              border: 2px solid #ffeaa7;
              border-radius: 8px;
              padding: 20px;
              margin-bottom: 30px;
              color: #856404;
            }
            
            .warning h2 {
              font-size: 18px;
              margin-bottom: 10px;
              color: #d63031;
            }
            
            .warning ul {
              margin-left: 20px;
            }
            
            .warning li {
              margin-bottom: 6px;
              font-size: 14px;
            }
            
            .phrase-container {
              margin: 30px 0;
            }
            
            .phrase-title {
              font-size: 20px;
              font-weight: 600;
              text-align: center;
              margin-bottom: 25px;
              color: #000000;
            }
            
            .key-section {
              margin: 20px 0;
              padding: 16px;
              background: #f8f9fa;
              border-radius: 8px;
              border: 1px solid #e9ecef;
            }
            
            .key-label {
              font-weight: 600;
              color: #000000;
              margin-bottom: 8px;
              font-size: 14px;
            }
            
            .key-value {
              font-family: 'Courier New', monospace;
              word-break: break-all;
              background: #ffffff;
              padding: 8px;
              border-radius: 4px;
              border: 1px solid #e0e0e0;
              font-size: 12px;
              line-height: 1.4;
            }
            
            .instructions {
              margin-top: 40px;
              background: #f8f9fa;
              border-radius: 8px;
              padding: 20px;
            }
            
            .instructions h3 {
              font-size: 16px;
              margin-bottom: 12px;
              color: #000000;
            }
            
            .instructions ol {
              margin-left: 20px;
            }
            
            .instructions li {
              margin-bottom: 8px;
              font-size: 14px;
              color: #333333;
            }
            
            .footer {
              margin-top: 40px;
              text-align: center;
              font-size: 12px;
              color: #999999;
              border-top: 1px solid #e0e0e0;
              padding-top: 20px;
            }
            
            @media print {
              body {
                padding: 20px;
              }
              
              .warning {
                break-inside: avoid;
              }
              
              .phrase-container {
                break-inside: avoid;
              }
              
              .key-section {
                break-inside: avoid;
              }
            }
          </style>
        </head>
        <body>
          <div class="header">
            <h1>${headerTitle}</h1>
            <p>${headerSubtitle}</p>
            <p class="date">${generated}: ${currentDate}</p>
          </div>
          
          <div class="warning">
            <h2>⚠️ ${escapeHtml($_('print.keypair.warning.title'))}</h2>
            <ul>
              <li>${escapeHtml($_('print.keypair.warning.secure'))}</li>
              <li>${escapeHtml($_('print.keypair.warning.access'))}</li>
              <li>${escapeHtml($_('print.keypair.warning.noOnline'))}</li>
              <li>${escapeHtml($_('print.keypair.warning.multipleBackups'))}</li>
              <li>${escapeHtml($_('print.keypair.warning.testImport'))}</li>
            </ul>
          </div>
          
          <div class="phrase-container">
            <h2 class="phrase-title">${escapeHtml($_('print.keypair.keys.title'))}</h2>
            
            <div class="key-section">
              <div class="key-label">${escapeHtml($_('print.keypair.keys.privateKey'))}</div>
              <div class="key-value">${escapeHtml(keys.privateKey)}</div>
            </div>
            
            <div class="key-section">
              <div class="key-label">${escapeHtml($_('print.keypair.keys.publicKey'))}</div>
              <div class="key-value">${escapeHtml(keys.publicKey)}</div>
            </div>
            
            <div class="key-section">
              <div class="key-label">${escapeHtml($_('print.keypair.keys.address'))}</div>
              <div class="key-value">${escapeHtml(keys.address)}</div>
            </div>
          </div>
          
          <div class="instructions">
            <h3>${escapeHtml($_('print.keypair.instructions.title'))}</h3>
            <ol>
              <li>${escapeHtml($_('print.keypair.instructions.writeDown'))}</li>
              <li>${escapeHtml($_('print.keypair.instructions.doubleCheck'))}</li>
              <li>${escapeHtml($_('print.keypair.instructions.store'))}</li>
              <li>${escapeHtml($_('print.keypair.instructions.test'))}</li>
              <li>${escapeHtml($_('print.keypair.instructions.noPhotos'))}</li>
            </ol>
          </div>
          
          <div class="footer">
            <p>${escapeHtml($_('print.keypair.footer.warning'))}</p>
          </div>
        </body>
      </html>
    `;
  }

  function handlePrint() {
    if (disabled) return;
    
    if (!isPhraseMode && !isKeyPairMode) {
      console.error('No phrase or keypair provided');
      return;
    }

    try {
      let printContent: string;
      
      if (isPhraseMode) {
        printContent = createBip39PrintDocument(phrase);
      } else if (isKeyPairMode) {
        printContent = createKeyPairPrintDocument(keyPair!);
      } else {
        return;
      }

      const printWindow = window.open('', '_blank', 'width=800,height=600');
      
      if (!printWindow) {
        console.error('Failed to open print window');
        return;
      }

      printWindow.document.write(printContent);
      printWindow.document.close();
      
      printWindow.onload = () => {
        printWindow.focus();
        printWindow.print();
        printWindow.onafterprint = () => {
          printWindow.close();
        };
      };
    } catch (error) {
      console.error('Error creating print document:', error);
    }
  }
</script>

<button
  class="print-button"
  onclick={handlePrint}
  disabled={disabled || (!isPhraseMode && !isKeyPairMode)}
  aria-label={ariaLabel}
  style="width: {size}px; height: {size}px;"
>
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
  >
    <path
      d="M6 9V2h12v7M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2M6 14h12v8H6v-8Z"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    />
    <circle cx="17" cy="11" r="1" fill="currentColor"/>
  </svg>
</button>

<style lang="scss">
  .print-button {
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--card-background);
    border: 2px solid transparent;
    border-radius: 10px;
    cursor: pointer;
    color: var(--primary-purple);
    transition: all 0.2s ease;
    flex-shrink: 0;

    &:hover:not(:disabled) {
      border-color: color-mix(in srgb, var(--primary-purple) 30%, transparent);
      background: color-mix(in srgb, var(--card-background) 95%, var(--primary-purple));
    }

    &:focus {
      outline: none;
      border-color: var(--primary-purple);
    }

    &:disabled {
      cursor: not-allowed;
      opacity: 0.5;
      color: var(--text-secondary);
    }

    &:active:not(:disabled) {
      transform: scale(0.95);
    }
  }

  @media (max-width: 480px) {
    .print-button {
      svg {
        width: 18px;
        height: 18px;
      }
    }
  }

  @media (max-width: 360px) {
    .print-button {
      svg {
        width: 16px;
        height: 16px;
      }
    }
  }
</style>

```

`zil-pay/popup/components/RadioOption.svelte`:

```svelte
<script lang="ts" generics="T extends string | number">
  type OptionData = {
    value: T;
    title: string;
    subtitle: string;
    description: string;
  };

  let {
    options = [],
    selected = $bindable(),
    name = '',
    onSelect = () => {}
  }: {
    options: OptionData[];
    selected: T;
    name: string;
    onSelect?: (value: T) => void;
  } = $props();

  function handleSelect(value: T) {
    selected = value;
    onSelect(value);
  }
</script>

<div class="radio-options">
  {#each options as option}
    <label class="radio-option" class:selected={selected === option.value}>
      <input 
        type="radio" 
        {name}
        value={option.value}
        checked={selected === option.value}
        onchange={() => handleSelect(option.value)}
        class="radio-input"
      />
      <div class="option-content">
        <div class="option-header">
          <span class="option-title">{option.title}</span>
        </div>
        <div class="option-subtitle">{option.subtitle}</div>
        <div class="option-description">{option.description}</div>
      </div>
      <div class="option-indicator"></div>
    </label>
  {/each}
</div>

<style lang="scss">
  .radio-options {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .radio-option {
    display: flex;
    align-items: center;
    padding: 16px;
    background: var(--card-background);
    border: 2px solid transparent;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;

    &.selected {
      border-color: var(--primary-purple);
      background: color-mix(in srgb, var(--primary-purple) 8%, var(--card-background));

      .option-title {
        color: var(--primary-purple);
      }

      .option-indicator {
        opacity: 1;
      }
    }

    &:hover:not(.selected) {
      border-color: color-mix(in srgb, var(--primary-purple) 30%, transparent);
    }
  }

  .radio-input {
    display: none;
  }

  .option-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .option-header {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .option-title {
    font-size: var(--font-size-medium);
    font-weight: 600;
    color: var(--text-primary);
  }

  .option-subtitle {
    font-size: var(--font-size-small);
    font-weight: 500;
    color: var(--primary-purple);
  }

  .option-description {
    font-size: var(--font-size-small);
    color: var(--text-secondary);
    line-height: 1.3;
  }

  .option-indicator {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 2px solid var(--text-secondary);
    opacity: 0.3;
    position: relative;
    flex-shrink: 0;
    margin-left: 12px;
    transition: all 0.2s ease;

    &::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--primary-purple);
      transform: translate(-50%, -50%);
      opacity: 0;
      transition: opacity 0.2s ease;
    }
  }

  .radio-option.selected .option-indicator {
    border-color: var(--primary-purple);
    opacity: 1;

    &::after {
      opacity: 1;
    }
  }

  @media (max-width: 480px) {
    .radio-option {
      padding: 12px;
    }

    .option-title {
      font-size: var(--font-size-small);
    }

    .option-subtitle,
    .option-description {
      font-size: calc(var(--font-size-small) * 0.9);
    }
  }

  @media (max-width: 360px) {
    .radio-option {
      padding: 10px;
    }
  }
</style>

```

`zil-pay/popup/components/ReloadButton.svelte`:

```svelte
<script lang="ts">
  import RefreshIcon from './icons/ReloadIcon.svelte';

  export let onClick: () => void = () => {};
  export let ariaLabel = 'Reload';
  export let size: number = 24;
</script>

<button class="reload-button" on:click={onClick} aria-label={ariaLabel}>
  <RefreshIcon class="hover-icon" width={size} height={size} />
</button>

<style lang="scss">
  .reload-button {
    background: none;
    border: none;
    cursor: pointer;
    padding: 6px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .reload-button:hover :global(.hover-icon path) {
    fill: var(--secondary-purple);
  }
</style>

```

`zil-pay/popup/components/SmartInput.svelte`:

```svelte
<script lang="ts">
  import type { Snippet } from 'svelte';

  let {
    id = '',
    label = '',
    placeholder = '',
    value = $bindable(''),
    hide = $bindable(true),
    disabled = false,
    required = false,
    showToggle = true,
    width = '100%',
    hasError = false,
    errorMessage = '',
    onInput = undefined,
    onFocus = undefined,
    onBlur = undefined,
    onToggle = undefined,
    ariaDescribedBy = '',
    toggleIcon = undefined
  }: {
    id?: string;
    label?: string;
    placeholder?: string;
    value?: string;
    hide?: boolean;
    disabled?: boolean;
    required?: boolean;
    showToggle?: boolean;
    width?: string;
    hasError?: boolean;
    errorMessage?: string;
    onInput?: (event: Event) => void;
    onFocus?: (event: FocusEvent) => void;
    onBlur?: (event: FocusEvent) => void;
    onToggle?: () => void;
    ariaDescribedBy?: string;
    toggleIcon?: Snippet;
  } = $props();

  let inputElement: HTMLInputElement;

  function handleToggle() {
    if (disabled) return;
    
    if (onToggle) {
      onToggle();
    } else {
      hide = !hide;
    }
    
    if (inputElement) {
      inputElement.focus();
    }
  }

  function handleInput(event: Event) {
    const target = event.target as HTMLInputElement;
    value = target.value;
    
    if (onInput) {
      onInput(event);
    }
  }

  function handleFocus(event: FocusEvent) {
    if (onFocus) {
      onFocus(event);
    }
  }

  function handleBlur(event: FocusEvent) {
    if (onBlur) {
      onBlur(event);
    }
  }

  function handleKeydown(event: KeyboardEvent) {
    if (event.key === 'Enter' && showToggle) {
      event.preventDefault();
      handleToggle();
    }
  }
</script>

<div class="password-input-container" style="width: {width}">
  {#if label}
    <label for={id} class="input-label">
      {label}
      {#if required}
        <span class="required-indicator" aria-label="required">*</span>
      {/if}
    </label>
  {/if}
  
  <div class="input-wrapper" class:has-error={hasError} class:disabled={disabled}>
    <input
      bind:this={inputElement}
      {id}
      type={hide ? 'password' : 'text'}
      class="password-input"
      {placeholder}
      {disabled}
      {required}
      bind:value={value}
      oninput={handleInput}
      onfocus={handleFocus}
      onblur={handleBlur}
      onkeydown={handleKeydown}
      aria-invalid={hasError}
      aria-describedby={ariaDescribedBy || (errorMessage ? `${id}-error` : undefined)}
    />
    
    {#if showToggle}
      <button 
        type="button"
        class="visibility-toggle"
        onclick={handleToggle}
        {disabled}
        aria-label={hide ? 'Show password' : 'Hide password'}
        tabindex={disabled ? -1 : 0}
      >
        {#if toggleIcon}
          {@render toggleIcon()}
        {:else}
          {#if hide}
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <circle cx="12" cy="12" r="3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          {:else}
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M14.12 14.12a3 3 0 0 1-4.24 0M9.88 9.88a3 3 0 0 1 4.24 4.24M6.18 6.18a10.94 10.94 0 0 0-3.36 5.82 10.94 10.94 0 0 0 3.36 5.82C7.71 19.36 9.81 20 12 20s4.29-.64 5.82-2.18a10.94 10.94 0 0 0 3.36-5.82 10.94 10.94 0 0 0-3.36-5.82C16.29 4.64 14.19 4 12 4s-4.29.64-5.82 2.18Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="m1 1 22 22" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          {/if}
        {/if}
      </button>
    {/if}
  </div>
  
  {#if errorMessage}
    <div id="{id}-error" class="error-message" role="alert">
      {errorMessage}
    </div>
  {/if}
</div>

<style lang="scss">
  .password-input-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .input-label {
    font-size: var(--font-size-medium);
    font-weight: 500;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .required-indicator {
    color: var(--danger-color);
    font-weight: 600;
  }

  .input-wrapper {
    position: relative;
    display: flex;
    align-items: center;
    
    &.has-error {
      .password-input {
        border-color: var(--danger-color);
        
        &:focus {
          border-color: var(--danger-color);
          box-shadow: 0 0 0 3px color-mix(in srgb, var(--danger-color) 15%, transparent);
        }
      }
      
      .visibility-toggle {
        color: var(--danger-color);
      }
    }
    
    &.disabled {
      opacity: 0.6;
      
      .password-input {
        cursor: not-allowed;
        background-color: color-mix(in srgb, var(--card-background) 50%, transparent);
      }
      
      .visibility-toggle {
        cursor: not-allowed;
        opacity: 0.5;
      }
    }
  }

  .password-input {
    width: 100%;
    padding: 14px 50px 14px 16px;
    font-size: var(--font-size-medium);
    font-weight: 500;
    color: var(--text-primary);
    border: 2px solid color-mix(in srgb, var(--text-secondary) 20%, transparent);
    background-color: var(--card-background);
    border-radius: 12px;
    transition: all 0.2s ease;
    outline: none;

    &:focus {
      border-color: var(--primary-purple);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-purple) 15%, transparent);
    }

    &:hover:not(:disabled):not(:focus) {
      border-color: color-mix(in srgb, var(--primary-purple) 30%, transparent);
    }

    &::placeholder {
      color: var(--text-secondary);
      opacity: 0.6;
    }

    &:disabled {
      cursor: not-allowed;
    }
  }

  .visibility-toggle {
    position: absolute;
    right: 12px;
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-secondary);
    padding: 6px;
    border-radius: 6px;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;

    &:hover:not(:disabled) {
      color: var(--primary-purple);
      background-color: color-mix(in srgb, var(--primary-purple) 10%, transparent);
    }

    &:focus:not(:disabled) {
      outline: none;
      color: var(--primary-purple);
      background-color: color-mix(in srgb, var(--primary-purple) 15%, transparent);
    }

    &:active:not(:disabled) {
      transform: scale(0.95);
    }

    &:disabled {
      cursor: not-allowed;
    }
  }

  .error-message {
    font-size: var(--font-size-small);
    color: var(--danger-color);
    font-weight: 500;
    line-height: 1.3;
  }

  @media (max-width: 480px) {
    .password-input {
      padding: 12px 46px 12px 14px;
      font-size: var(--font-size-small);
    }

    .visibility-toggle {
      right: 10px;
      padding: 4px;

      :global(svg) {
        width: 18px;
        height: 18px;
      }
    }

    .input-label {
      font-size: var(--font-size-small);
    }

    .error-message {
      font-size: calc(var(--font-size-small) * 0.9);
    }
  }

  @media (max-width: 360px) {
    .password-input {
      padding: 10px 42px 10px 12px;
    }

    .visibility-toggle {
      right: 8px;

      :global(svg) {
        width: 16px;
        height: 16px;
      }
    }
  }
</style>

```

`zil-pay/popup/components/SvgLoad.svelte`:

```svelte
<script>
  import { onMount } from 'svelte';

  let { src, ...rest } = $props();
  let content = $state('');

  onMount(async () => {
    try {
      const response = await fetch(src);
      if (!response.ok) throw new Error('Failed to fetch svg');
      content = await response.text();
    } catch (error) {
      console.error(error);
    }
  });
</script>

{@html content ? `<svg ${Object.entries(rest).map(([k, v]) => `${k}="${v}"`).join(' ')}>${content.replace(/^<svg[^>]*>/, '').replace(/<\/svg>$/, '')}</svg>` : ''}

```

`zil-pay/popup/components/Switch.svelte`:

```svelte
<script lang="ts">
  type Size = 'small' | 'medium' | 'large';

  let {
    checked = $bindable(false),
    disabled = false,
    size = 'medium' as Size,
    id = '',
    name = '',
    ariaLabel = '',
    onChange = (_newChecked: boolean) => {}
  }: {
    checked?: boolean;
    disabled?: boolean;
    size?: Size;
    id?: string;
    name?: string;
    ariaLabel?: string;
    onChange?: (newChecked: boolean) => void;
  } = $props();

  function handleToggle() {
    if (disabled) return;
    checked = !checked;
    onChange(checked);
  }

  const sizeClassMap: Record<Size, string> = {
    small: 'switch--small',
    medium: 'switch--medium',
    large: 'switch--large'
  };

  const sizeClass = $derived(sizeClassMap[size] ?? sizeClassMap.medium);
</script>

<div class={`switch ${sizeClass} ${disabled ? 'disabled' : ''}`} role="switch" aria-checked={checked ? 'true' : 'false'} aria-label={ariaLabel}>
  <button
    {id}
    {name}
    type="button"
    class="switch-button"
    onclick={handleToggle}
    {disabled}
    aria-pressed={checked}
    aria-labelledby="box"
  >
    <span class="switch-track"></span>
    <span class="switch-thumb" class:checked={checked}></span>
  </button>
</div>

<style lang="scss">
  .switch {
    display: inline-flex;
    align-items: center;
    justify-content: center;

    &.disabled .switch-button {
      cursor: not-allowed;
      opacity: 0.6;
    }

    .switch-button {
      position: relative;
      appearance: none;
      background: none;
      outline: none;
      cursor: pointer;
      border: none;
      padding: 0;
      margin: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;

      .switch-track {
        width: 44px;
        height: 24px;
        background-color: var(--card-background);
        border-radius: 9999px;
        box-shadow: inset 0 0 1px rgba(0,0,0,0.2);
        transition: background-color 0.3s ease;
      }

      .switch-thumb {
        position: absolute;
        left: 3px;
        top: 3px;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background-color: var(--primary-purple);
        transition: transform 0.25s ease-in-out;

        &.checked {
          transform: translateX(20px);
        }
      }
    }

    &.switch--small .switch-button {
      .switch-track {
        width: 36px;
        height: 20px;
      }

      .switch-thumb {
        width: 14px;
        height: 14px;
        top: 3px;
        left: 3px;

        &.checked {
          transform: translateX(16px);
        }
      }
    }

    &.switch--large .switch-button {
      .switch-track {
        width: 52px;
        height: 28px;
      }

      .switch-thumb {
        width: 22px;
        height: 22px;
        top: 3px;
        left: 3px;

        &.checked {
          transform: translateX(24px);
        }
      }
    }
  }
</style>

```

`zil-pay/popup/components/WalletOption.svelte`:

```svelte
<script lang="ts">
  type TagType = 'mainnet' | 'testnet' | 'warning' | 'success' | 'info' | 'default';

  interface TagConfig {
    text: string;
    type?: TagType;
  }

  let {
    title,
    description,
    icon,
    onclick = () => {},
    disabled = false,
    selected = false,
    tags = []
  }: {
    title: string;
    description: string;
    icon: string;
    onclick?: () => void;
    disabled?: boolean;
    selected?: boolean;
    tags?: (string | TagConfig)[];
  } = $props();

  function handleClick() {
    if (!disabled) {
      onclick();
    }
  }

  function getTagType(tag: string | TagConfig): TagType {
    if (typeof tag === 'object' && tag.type) {
      return tag.type;
    }
    
    const text = typeof tag === 'string' ? tag.toLowerCase() : tag.text.toLowerCase();
    
    if (text.includes('mainnet')) return 'mainnet';
    if (text.includes('testnet')) return 'testnet';
    if (text.includes('chain') || text.includes('id')) return 'info';
    if (text.includes('beta') || text.includes('experimental')) return 'warning';
    
    return 'default';
  }

  function getTagText(tag: string | TagConfig): string {
    return typeof tag === 'string' ? tag : tag.text;
  }

  const isIconUrl = typeof icon === 'string' && (icon.startsWith('http') || icon.startsWith('data:') || icon.startsWith('/'));
</script>

<button
  class="wallet-option"
  class:selected
  onclick={handleClick}
  {disabled}
  aria-pressed={selected}
>
  <div class="option-icon" class:url={isIconUrl}>
    {#if isIconUrl}
      <img src={icon} alt="{title} icon" class="icon-image" />
    {:else if typeof icon === 'string'}
      <span class="icon-symbol">{icon}</span>
    {:else}
      {@const Component = icon}
      <Component />
    {/if}
  </div>

  <div class="option-content">
    <div class="option-header">
      <h3 class="option-title">{title}</h3>
      {#if tags.length > 0}
        <div class="tags-container">
          {#each tags as tag}
            {@const tagType = getTagType(tag)}
            {@const tagText = getTagText(tag)}
            <span class="tag tag--{tagType}">{tagText}</span>
          {/each}
        </div>
      {/if}
    </div>
    <p class="option-description">{description}</p>
  </div>

  <div class="option-selector">
    {#if selected}
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="12" cy="12" r="10" stroke="var(--primary-purple)" stroke-width="2"/>
        <circle cx="12" cy="12" r="6" fill="var(--primary-purple)"/>
      </svg>
    {:else}
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="12" cy="12" r="10" stroke="var(--border-color)" stroke-width="2"/>
      </svg>
    {/if}
  </div>
</button>

<style lang="scss">
  .wallet-option {
    display: flex;
    align-items: center;
    width: 100%;
    padding: 20px;
    background-color: var(--card-background);
    border: 2px solid transparent;
    border-radius: 16px;
    cursor: pointer;
    text-align: left;
    min-height: 80px;
    transition: all 0.2s ease;

    &.selected {
      border-color: var(--primary-purple);
      background-color: color-mix(in srgb, var(--primary-purple) 8%, var(--card-background));
    }

    &:hover:not(:disabled) {
      border-color: color-mix(in srgb, var(--primary-purple) 30%, transparent);
      background-color: color-mix(in srgb, var(--card-background) 95%, var(--primary-purple));
    }

    &:focus:not(:disabled) {
      outline: none;
      border-color: var(--primary-purple);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-purple) 15%, transparent);
    }

    &:active:not(:disabled) {
      transform: scale(0.98);
    }

    &:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      background-color: color-mix(in srgb, var(--card-background) 80%, transparent);
      
      .option-title {
        color: color-mix(in srgb, var(--text-primary) 60%, transparent);
      }
      
      .option-description {
        color: color-mix(in srgb, var(--text-secondary) 50%, transparent);
      }
      
      .option-icon {
        opacity: 0.5;
        background: color-mix(in srgb, var(--primary-purple) 50%, transparent);
        box-shadow: none;
      }

      .tag {
        opacity: 0.5;
      }
    }
  }

  .option-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 48px;
    height: 48px;
    margin-right: 16px;
    flex-shrink: 0;
    background: linear-gradient(135deg, var(--primary-purple), color-mix(in srgb, var(--primary-purple) 80%, #000));
    border-radius: 12px;
    box-shadow: 0 4px 12px color-mix(in srgb, var(--primary-purple) 25%, transparent);
    overflow: hidden;
    transition: all 0.2s ease;

    &.url {
      background: transparent;
      box-shadow: none;
    }
  }

  .icon-symbol {
    font-size: calc(var(--font-size-xl) * 1.6);
    font-weight: bold;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .icon-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .option-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
    margin-right: 12px;
    overflow: hidden;
  }

  .option-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 12px;
    min-height: 24px;
  }

  .option-title {
    font-size: var(--font-size-xl);
    font-weight: 600;
    color: var(--text-primary);
    margin: 0;
    line-height: 1.3;
    flex: 1;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .option-description {
    font-size: var(--font-size-medium);
    color: var(--text-secondary);
    margin: 0;
    opacity: 0.8;
    line-height: 1.4;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .tags-container {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    flex-shrink: 0;
    align-items: flex-start;
    max-width: 50%;
  }

  .tag {
    padding: 2px 6px;
    border-radius: 6px;
    font-size: var(--font-size-small);
    font-weight: 500;
    white-space: nowrap;
    line-height: 1.2;
    transition: all 0.2s ease;

    &--mainnet {
      background-color: color-mix(in srgb, var(--success-color) 15%, transparent);
      color: var(--success-color);
      border: 1px solid color-mix(in srgb, var(--success-color) 30%, transparent);
    }

    &--testnet {
      background-color: color-mix(in srgb, var(--warning-color) 15%, transparent);
      color: var(--warning-color);
      border: 1px solid color-mix(in srgb, var(--warning-color) 30%, transparent);
    }

    &--warning {
      background-color: color-mix(in srgb, var(--danger-color) 15%, transparent);
      color: var(--danger-color);
      border: 1px solid color-mix(in srgb, var(--danger-color) 30%, transparent);
    }

    &--info {
      background-color: color-mix(in srgb, var(--primary-purple) 15%, transparent);
      color: var(--primary-purple);
      border: 1px solid color-mix(in srgb, var(--primary-purple) 30%, transparent);
    }

    &--success {
      background-color: color-mix(in srgb, var(--success-color) 15%, transparent);
      color: var(--success-color);
      border: 1px solid color-mix(in srgb, var(--success-color) 30%, transparent);
    }

    &--default {
      background-color: color-mix(in srgb, var(--text-secondary) 15%, transparent);
      color: var(--text-secondary);
      border: 1px solid color-mix(in srgb, var(--text-secondary) 30%, transparent);
    }
  }

  .option-selector {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    flex-shrink: 0;
    transition: transform 0.2s ease;
  }

  .wallet-option:hover:not(:disabled) .option-selector {
    transform: scale(1.1);
  }

  @media (max-width: 480px) {
    .wallet-option {
      padding: 16px;
      min-height: 72px;
    }

    .option-icon {
      width: 44px;
      height: 44px;
      margin-right: 14px;
    }

    .option-header {
      gap: 8px;
      flex-direction: column;
      align-items: flex-start;
    }

    .option-title {
      font-size: var(--font-size-large);
      white-space: normal;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      display: -webkit-box;
    }

    .tags-container {
      max-width: 100%;
      gap: 3px;
    }

    .tag {
      font-size: calc(var(--font-size-small) * 0.9);
      padding: 1px 4px;
    }
  }

  @media (max-width: 360px) {
    .wallet-option {
      padding: 14px;
    }

    .option-icon {
      width: 40px;
      height: 40px;
      margin-right: 12px;
    }

    .option-header {
      gap: 6px;
    }

    .tag {
      font-size: calc(var(--font-size-small) * 0.85);
    }
  }
</style>

```

`zil-pay/popup/components/WordCountSelector.svelte`:

```svelte
<script lang="ts">
  import { ALLOWED_COUNTS } from "config/bip39";

  let {
    wordCounts = ALLOWED_COUNTS,
    selected = $bindable(),
    onSelect = () => {}
  } = $props();

  if (selected === undefined) {
    selected = wordCounts[0];
  }

  const countIndex = $derived(wordCounts.indexOf(selected));

  function handleSelect(count: number) {
    selected = count;
    onSelect(count);
  }
</script>

<div class="selector-wrapper">
  <div
    class="background-highlight"
    style="--index: {countIndex}; --count: {wordCounts.length};"
  ></div>

  <div class="options">
    {#each wordCounts as count}
      <button
        class:selected={count === selected}
        onclick={() => handleSelect(count)}
      >
        {count}
      </button>
    {/each}
  </div>
</div>

<style lang="scss">
  .selector-wrapper {
    position: relative;
    width: 100%;
    height: 48px;
    padding: 4px;
    background-color: var(--card-background);
    border-radius: 12px;
    overflow: hidden;
  }

  .background-highlight {
    position: absolute;
    top: 4px;
    bottom: 4px;
    width: calc((100% - 8px) / var(--count));
    left: calc(4px + ((100% - 8px) / var(--count)) * var(--index));
    background-color: var(--primary-purple);
    border-radius: 8px;
    transition: left 0.3s ease-in-out;
    z-index: 0;
  }

  .options {
    position: relative;
    display: flex;
    height: 100%;
    z-index: 1;

    button {
      flex: 1;
      background: none;
      border: none;
      font-size: var(--font-size-large);
      font-weight: 500;
      cursor: pointer;
      color: var(--text-secondary);
      transition: color 0.2s ease;
      border-radius: 8px;

      &.selected {
        color: white;
        font-weight: 600;
      }

      &:hover:not(.selected) {
        color: var(--text-primary);
      }

      &:focus {
        outline: none;
      }
    }
  }
</style>

```

`zil-pay/popup/components/icons/Appearance.svelte`:

```svelte
<svg {...$$restProps} viewBox="0 0 800 800" fill="none">
  <g clip-path="url(#clip0_75_500)">
    <path
      d="M400 0C620.915 0 800 179.086 800 400C800 407.979 799.765 415.904 799.305 423.767C796.64 469.298 755.475 500.195 709.87 500.195H550.53C461.438 500.195 416.821 607.91 479.817 670.905C524.115 715.2 509.9 789.795 447.694 797.185C432.055 799.045 416.139 800 400 800C179.086 800 0 620.915 0 400C0 179.086 179.086 0 400 0ZM400 100C234.315 100 100 234.315 100 400C100 557.69 221.665 686.965 376.246 699.075C302.95 572.53 391.161 400.196 550.53 400.196H700C700 234.315 565.685 100 400 100ZM250 400C277.614 400 300 422.385 300 450C300 477.614 277.614 500 250 500C222.386 500 200 477.614 200 450C200 422.385 222.386 400 250 400ZM300 250C327.614 250 350 272.386 350 300C350 327.614 327.614 350 300 350C272.386 350 250 327.614 250 300C250 272.386 272.386 250 300 250ZM450 200C477.614 200 500 222.386 500 250C500 277.614 477.614 300 450 300C422.385 300 400 277.614 400 250C400 222.386 422.385 200 450 200Z"
      fill="var(--text-primary)"
    />
  </g>
  <defs>
    <clipPath id="clip0_75_500">
    <rect width="800" height="800" fill="var(--background-color)"/>
    </clipPath>
  </defs>
</svg>

```

`zil-pay/popup/components/icons/BincodeIcon.svelte`:

```svelte
<svg
  width="36"
  height="36"
  {...$$restProps}
  viewBox="0 0 1024 1024"
>
  <path fill="#fff" d="M688 312v-48c0-4.4-3.6-8-8-8H296c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h384c4.4 0 8-3.6 8-8m-392 88c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zm376 116c-119.3 0-216 96.7-216 216s96.7 216 216 216s216-96.7 216-216s-96.7-216-216-216m107.5 323.5C750.8 868.2 712.6 884 672 884s-78.8-15.8-107.5-44.5C535.8 810.8 520 772.6 520 732s15.8-78.8 44.5-107.5C593.2 595.8 631.4 580 672 580s78.8 15.8 107.5 44.5C808.2 653.2 824 691.4 824 732s-15.8 78.8-44.5 107.5M761 656h-44.3c-2.6 0-5 1.2-6.5 3.3l-63.5 87.8l-23.1-31.9a7.92 7.92 0 0 0-6.5-3.3H573c-6.5 0-10.3 7.4-6.5 12.7l73.8 102.1c3.2 4.4 9.7 4.4 12.9 0l114.2-158c3.9-5.3.1-12.7-6.4-12.7M440 852H208V148h560v344c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V108c0-17.7-14.3-32-32-32H168c-17.7 0-32 14.3-32 32v784c0 17.7 14.3 32 32 32h272c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8"/>
</svg>


```

`zil-pay/popup/components/icons/Bip39Icon.svelte`:

```svelte
<svg
  {...$$restProps}
  width="36"
  height="36"
  viewBox="0 0 800 800"
  fill="none"
>
  <path d="M606 267.978L621.45 252.53C647.043 226.935 688.543 226.935 714.137 252.53C739.733 278.125 739.733 319.623 714.137 345.217L698.69 360.667M606 267.978C606 267.978 607.933 300.805 636.897 329.77C665.863 358.733 698.69 360.667 698.69 360.667M606 267.978L463.98 409.997C454.36 419.617 449.55 424.427 445.413 429.73C440.537 435.987 436.353 442.757 432.94 449.917C430.047 455.99 427.893 462.44 423.593 475.347L409.82 516.667L405.363 530.033M698.69 360.667L556.67 502.687C547.05 512.307 542.24 517.117 536.937 521.253C530.68 526.13 523.91 530.313 516.75 533.727C510.677 536.62 504.227 538.773 491.32 543.073L450 556.847L436.633 561.303M405.363 530.033L400.907 543.403C398.79 549.753 400.443 556.757 405.177 561.49C409.91 566.223 416.913 567.877 423.263 565.76L436.633 561.303M405.363 530.033L436.633 561.303" stroke="#fff" stroke-width="50"/>
  <path d="M266.667 433.333H350" stroke="#fff" stroke-width="50" stroke-linecap="round"/>
  <path d="M266.667 300H483.333" stroke="#fff" stroke-width="50" stroke-linecap="round"/>
  <path d="M266.667 566.667H316.667" stroke="#fff" stroke-width="50" stroke-linecap="round"/>
  <path d="M100 466.667V333.333C100 207.625 100 144.772 139.052 105.719C178.105 66.6667 240.959 66.6667 366.667 66.6667H433.333C559.04 66.6667 621.897 66.6667 660.947 105.719M700 466.667C700 592.373 700 655.23 660.947 694.28M660.947 694.28C621.897 733.333 559.04 733.333 433.333 733.333H366.667C240.959 733.333 178.105 733.333 139.052 694.28M660.947 694.28C692.383 662.843 698.513 615.987 699.71 533.333" stroke="#fff" stroke-width="50" stroke-linecap="round"/>
</svg>


```

`zil-pay/popup/components/icons/Close.svelte`:

```svelte
<svg
  {...$$restProps}
  viewBox="0 0 36 36"
  fill="none"
>
  <line
    x1="11.8195"
    y1="11.6689"
    x2="24.5096"
    y2="24.3591"
    stroke-width="2"
    stroke-linecap="round"
  />
  <line
    x1="1"
    y1="-1"
    x2="18.9466"
    y2="-1"
    transform="matrix(-0.707107 0.707107 0.707107 0.707107 25.5274 11.5508)"
    stroke-width="2"
    stroke-linecap="round"
  />
</svg>

<style lang="scss">
  svg {
    cursor: pointer;
    line {
      stroke: var(--primary-purple);
    }
  }
</style>

```

`zil-pay/popup/components/icons/GridIcon.svelte`:

```svelte
<svg {...$$restProps} viewBox="0 0 24 24" fill="none">
  <path
    d="M4 4h4v4H4V4zm6 0h4v4h-4V4zm6 0h4v4h-4V4zM4 10h4v4H4v-4zm6 0h4v4h-4v-4zm6 0h4v4h-4v-4zM4 16h4v4H4v-4zm6 0h4v4h-4v-4zm6 0h4v4h-4v-4z"
    fill="white"
  />
</svg>

```

`zil-pay/popup/components/icons/Language.svelte`:

```svelte
<svg {...$$restProps} viewBox="0 0 800 800" fill="none">
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M489.737 166.667H310.269C271.972 166.878 235.327 182.295 208.397 209.525C181.466 236.756 166.456 273.569 166.669 311.866V488.133C166.456 526.43 181.466 563.243 208.397 590.473C235.327 617.703 271.972 633.123 310.269 633.333H489.737C528.034 633.123 564.677 617.703 591.607 590.473C618.54 563.243 633.547 526.43 633.337 488.133V311.866C633.547 273.569 618.54 236.756 591.607 209.525C564.677 182.295 528.034 166.878 489.737 166.667Z"
    stroke="var(--text-primary)"
    stroke-width="50"
    stroke-linecap="round"
    stroke-linejoin="round"
  />
  <path
    d="M266.671 300C252.864 300 241.671 311.193 241.671 325C241.671 338.807 252.864 350 266.671 350V300ZM400.004 350C413.81 350 425.004 338.807 425.004 325C425.004 311.193 413.81 300 400.004 300V350ZM375.004 325C375.004 338.807 386.197 350 400.004 350C413.81 350 425.004 338.807 425.004 325H375.004ZM425.004 266.667C425.004 252.86 413.81 241.667 400.004 241.667C386.197 241.667 375.004 252.86 375.004 266.667H425.004ZM400.004 300C386.197 300 375.004 311.193 375.004 325C375.004 338.807 386.197 350 400.004 350V300ZM516.67 350C530.477 350 541.67 338.807 541.67 325C541.67 311.193 530.477 300 516.67 300V350ZM516.67 300C502.864 300 491.67 311.193 491.67 325C491.67 338.807 502.864 350 516.67 350V300ZM533.337 350C547.144 350 558.337 338.807 558.337 325C558.337 311.193 547.144 300 533.337 300V350ZM537.127 339.37C545.064 328.074 542.34 312.481 531.044 304.543C519.744 296.606 504.154 299.33 496.214 310.628L537.127 339.37ZM375.79 442.61C365.264 451.547 363.977 467.323 372.914 477.846C381.85 488.373 397.627 489.66 408.15 480.723L375.79 442.61ZM309.991 496.676C298.951 504.966 296.723 520.64 305.014 531.68C313.306 542.72 328.977 544.95 340.017 536.657L309.991 496.676ZM408.564 480.233C418.89 471.07 419.834 455.27 410.67 444.943C401.51 434.613 385.707 433.67 375.38 442.833L408.564 480.233ZM372.304 476.97C380.83 487.83 396.544 489.723 407.407 481.2C418.267 472.673 420.16 456.96 411.637 446.097L372.304 476.97ZM372.867 381.557C367.284 368.927 352.52 363.22 339.894 368.803C327.266 374.387 321.556 389.15 327.14 401.776L372.867 381.557ZM412.03 446.746C403.79 435.666 388.13 433.367 377.05 441.607C365.974 449.847 363.67 465.506 371.91 476.586L412.03 446.746ZM463.177 555.36C475.34 561.89 490.497 557.326 497.03 545.16C503.56 532.996 498.997 517.84 486.834 511.306L463.177 555.36ZM266.671 350H400.004V300H266.671V350ZM425.004 325V266.667H375.004V325H425.004ZM400.004 350H516.67V300H400.004V350ZM516.67 350H533.337V300H516.67V350ZM496.214 310.628C461.84 359.556 421.374 403.907 375.79 442.61L408.15 480.723C456.97 439.273 500.31 391.773 537.127 339.37L496.214 310.628ZM340.017 536.657C357.044 523.87 381.77 504.003 408.564 480.233L375.38 442.833C349.57 465.73 325.898 484.73 309.991 496.676L340.017 536.657ZM411.637 446.097C396.08 426.28 383.057 404.597 372.867 381.557L327.14 401.776C339.01 428.62 354.184 453.88 372.304 476.97L411.637 446.097ZM371.91 476.586C396.184 509.223 427.344 536.117 463.177 555.36L486.834 511.306C457.464 495.536 431.927 473.493 412.03 446.746L371.91 476.586Z"
    fill="var(--text-primary)"
  />
</svg>

```

`zil-pay/popup/components/icons/LockIcon.svelte`:

```svelte
<svg
  {...$$restProps}
  width="35"
  height="35"
  viewBox="0 0 800 800"
  fill="none"
>
  <path d="M389.733 334.6C383.533 331.967 376.333 333.433 371.566 338.2L338.233 371.533C331.733 378.033 331.733 388.6 338.233 395.1C344.733 401.6 355.3 401.6 361.8 395.1L366.667 390.233V450C366.667 459.2 374.134 466.667 383.334 466.667C392.534 466.667 400 459.2 400.033 450V350C400.033 343.267 395.967 337.167 389.733 334.6Z" fill="#fff"/>
  <path d="M489.733 334.6C483.566 331.967 476.333 333.433 471.566 338.2L438.233 371.533C431.733 378.033 431.733 388.6 438.233 395.1C444.733 401.6 455.3 401.6 461.8 395.1L466.667 390.233V450C466.667 459.2 474.134 466.667 483.334 466.667C492.534 466.667 500 459.2 500.033 450V350C500.033 343.267 495.967 337.167 489.733 334.6Z" fill="#fff"/>
  <path d="M589.733 334.6C583.533 331.967 576.366 333.433 571.566 338.2L538.233 371.533C531.733 378.033 531.733 388.6 538.233 395.1C544.733 401.6 555.3 401.6 561.8 395.1L566.667 390.233V450C566.667 459.2 574.134 466.667 583.334 466.667C592.534 466.667 600.002 459.2 600.034 450V350C600.033 343.267 595.967 337.167 589.733 334.6Z" fill="#fff"/>
  <path d="M283.333 333.333H216.666C207.466 333.333 199.998 340.8 199.998 350V450C199.998 459.2 207.466 466.667 216.666 466.667H283.333C292.533 466.667 300 459.2 300 450V350C300 340.8 292.533 333.333 283.333 333.333ZM266.667 433.333H233.334V366.666H266.667V433.333Z" fill="#fff"/>
  <path d="M489.733 534.6C483.566 532 476.333 533.433 471.566 538.2L438.233 571.533C431.733 578.033 431.733 588.6 438.233 595.1C444.733 601.6 455.3 601.6 461.8 595.1L466.667 590.233V650C466.667 659.2 474.134 666.667 483.334 666.667C492.534 666.667 500 659.2 500.033 650V550C500.033 543.267 495.967 537.167 489.733 534.6Z" fill="#fff"/>
  <path d="M589.733 534.6C583.533 532 576.366 533.433 571.566 538.2L538.233 571.533C531.733 578.033 531.733 588.6 538.233 595.1C544.733 601.6 555.3 601.6 561.8 595.1L566.667 590.233V650C566.667 659.2 574.134 666.667 583.334 666.667C592.534 666.667 600.002 659.2 600.034 650V550C600.033 543.267 595.967 537.167 589.733 534.6Z" fill="#fff"/>
  <path d="M256.4 534.6C250.2 532 243 533.433 238.233 538.2L204.9 571.533C198.4 578.033 198.4 588.6 204.9 595.1C211.4 601.6 221.967 601.6 228.467 595.1L233.334 590.233V650C233.334 659.2 240.802 666.667 250.002 666.667C259.202 666.667 266.669 659.2 266.702 650V550C266.7 543.267 262.633 537.167 256.4 534.6Z" fill="#fff"/>
  <path d="M383.333 533.333H316.666C307.466 533.333 299.998 540.8 299.998 550V650C299.998 659.2 307.466 666.667 316.666 666.667H383.333C392.533 666.667 400 659.2 400 650V550C400 540.8 392.533 533.333 383.333 533.333ZM366.667 633.333H333.334V566.666H366.667V633.333Z" fill="#fff"/>
  <path d="M683.333 0H316.667C314.434 0 312.234 0.467188 310.2 1.3C309.567 1.56719 309.1 2.06719 308.533 2.43281C307.266 3.16563 305.933 3.83281 304.866 4.86563L104.866 204.866C104.098 205.633 103.666 206.666 103.066 207.566C102.466 208.466 101.698 209.233 101.298 210.233C100.466 212.266 99.9984 214.433 99.9984 216.666V783.333C100 792.533 107.467 800 116.667 800H683.334C692.534 800 700.002 792.533 700.002 783.333V16.6672C700 7.46719 692.533 0 683.333 0ZM300 56.9V200H156.9L300 56.9ZM666.667 766.667H133.333V233.333H316.666C325.866 233.333 333.333 225.866 333.333 216.666V33.3328H666.666V766.667H666.667Z" fill="#fff"/>
</svg>


```

`zil-pay/popup/components/icons/PuzzleIcon.svelte`:

```svelte
<svg
  width="35"
  height="35"
  {...$$restProps}
  viewBox="0 0 800 800"
  fill="none"
>
  <g clip-path="url(#clip0_5_61)">
    <path d="M800 30.078C800 14.2968 787.195 1.51709 771.427 1.51709H482.603V116.598C489.769 112.601 498.017 110.336 506.792 110.336C534.328 110.336 556.666 132.659 556.666 160.216C556.666 187.745 534.341 210.081 506.792 210.081C498.017 210.081 489.769 207.803 482.603 203.833V318.901H597.684C593.702 326.067 591.422 334.314 591.422 343.083C591.422 370.637 613.747 392.962 641.302 392.962C668.844 392.962 691.167 370.637 691.167 343.083C691.167 334.314 688.889 326.067 684.919 318.901H800V30.078Z" fill="#fff"/>
    <path d="M671.275 430.265H526.284C521.206 430.265 516.509 432.95 513.939 437.303L514.08 437.062L513.914 437.33C512.603 439.558 511.941 442.076 511.941 444.584C511.941 446.976 512.552 449.394 513.748 451.559L522.888 468.015C524.936 471.719 525.941 475.614 525.955 479.864C525.942 486.431 523.422 492.489 518.789 497.148C514.131 501.781 508.061 504.301 501.505 504.326C494.938 504.3 488.867 501.781 484.195 497.148L484.214 497.175C479.567 492.49 477.055 486.42 477.042 479.866C477.055 475.626 478.059 471.72 480.102 468.005L489.247 451.561C490.45 449.395 491.055 446.992 491.055 444.586C491.055 442.078 490.392 439.559 489.061 437.305C486.484 432.94 481.787 430.267 476.717 430.267H368.23V372.167C387.836 371.861 406.355 364.136 420.227 350.237C434.43 336.072 442.297 317.07 442.283 297C442.295 276.903 434.423 257.901 420.227 243.748C406.366 229.848 387.842 222.136 368.23 221.831V127.212C368.223 119.297 361.808 112.881 353.892 112.881H53.9813C39.6 112.87 25.95 118.508 15.8063 128.676C5.73283 138.758 0.0125207 152.592 2.06969e-05 166.872V744.506C-0.0124793 758.875 5.63752 772.519 15.8063 782.675C25.8875 792.742 39.7016 798.469 53.9813 798.483H631.678C645.92 798.47 659.742 792.742 669.809 782.675C679.98 772.519 685.617 758.887 685.605 744.506V444.597C685.606 436.681 679.191 430.265 671.275 430.265ZM44.3281 166.872C44.3281 163.562 45.8688 161.311 47.1281 160.05C48.4328 158.751 50.6781 157.198 53.9813 157.198H323.898V272.203C323.898 274.978 325.369 277.536 327.755 278.948C328.977 279.661 330.344 280.019 331.719 280.019C333.03 280.019 334.334 279.7 335.519 279.039L351.969 269.9C356.608 267.328 361.661 266.017 366.981 266.017C375.247 266.017 383.03 269.237 388.878 275.08C394.733 280.947 397.953 288.736 397.953 296.997C397.953 305.256 394.733 313.034 388.891 318.887C383.03 324.742 375.247 327.962 366.981 327.962C361.655 327.962 356.608 326.651 351.975 324.08L335.513 314.94C334.336 314.28 333.025 313.961 331.72 313.961C330.345 313.961 328.977 314.317 327.756 315.044C325.37 316.444 323.9 319.001 323.9 321.776V436.781H252.689C252.83 435.011 252.898 433.244 252.898 431.5C252.898 413.109 245.739 395.837 232.752 382.869C219.777 369.873 202.505 362.722 184.114 362.722C165.73 362.722 148.459 369.875 135.489 382.856C122.489 395.825 115.33 413.109 115.336 431.487C115.336 433.244 115.405 435.001 115.545 436.783H44.3281V166.872ZM323.9 754.165H53.9813C50.6781 754.165 48.4328 752.612 47.1594 751.353C45.8688 750.055 44.3281 747.801 44.3281 744.506V474.57H159.327C162.095 474.57 164.659 473.106 166.066 470.726C167.472 468.333 167.511 465.38 166.163 462.962L157.031 446.506C154.453 441.859 153.148 436.808 153.142 431.5C153.148 423.239 156.377 415.451 162.205 409.595C168.077 403.755 175.861 400.52 184.114 400.52C192.367 400.52 200.152 403.755 206.005 409.583C211.853 415.45 215.08 423.239 215.086 431.486C215.08 436.819 213.767 441.872 211.216 446.492L202.064 462.948C200.714 465.38 200.755 468.333 202.161 470.712C203.567 473.105 206.133 474.569 208.9 474.569H323.898V545.803C322.128 545.664 320.367 545.6 318.623 545.6C300.227 545.6 282.955 552.753 269.998 565.734C256.992 578.716 249.839 595.987 249.852 614.365C249.839 632.744 256.992 650.028 269.988 662.997C282.956 675.992 300.228 683.144 318.625 683.144C320.381 683.144 322.144 683.08 323.9 682.94V754.165ZM641.288 744.506C641.288 747.801 639.736 750.042 638.462 751.328C637.164 752.614 634.923 754.167 631.628 754.167H361.713V639.162C361.713 636.387 360.25 633.83 357.856 632.43C356.634 631.703 355.266 631.348 353.892 631.348C352.588 631.348 351.277 631.667 350.098 632.328L333.623 641.467C328.997 644.037 323.95 645.348 318.623 645.348C310.37 645.348 302.586 642.117 296.733 636.286C290.884 630.431 287.658 622.642 287.652 614.381C287.658 606.109 290.886 598.333 296.727 592.478C302.577 586.636 310.358 583.403 318.625 583.39C323.914 583.39 328.966 584.701 333.625 587.272L350.094 596.423C351.278 597.086 352.581 597.405 353.894 597.405C355.267 597.405 356.636 597.047 357.858 596.336C360.244 594.923 361.714 592.364 361.714 589.589V474.572H432.93C432.791 476.341 432.72 478.111 432.72 479.866C432.714 498.231 439.867 515.503 452.855 528.484C465.836 541.492 483.114 548.645 501.498 548.645C519.883 548.645 537.155 541.492 550.138 528.498C563.131 515.53 570.272 498.258 570.272 479.867C570.272 478.111 570.208 476.355 570.069 474.573H641.291V744.506H641.288Z" fill="#fff"/>
  </g>
  <defs>
    <clipPath id="clip0_5_61">
      <rect width="800" height="800" fill="#fff"/>
    </clipPath>
  </defs>
</svg>


```

`zil-pay/popup/components/icons/QRCodeIcon.svelte`:

```svelte
<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  {...$$restProps}
>
  <g fill="none">
    <path d="M24 0v24H0V0zM12.593 23.258l-.011.002l-.071.035l-.02.004l-.014-.004l-.071-.035c-.01-.004-.019-.001-.024.005l-.004.01l-.017.428l.005.02l.01.013l.104.074l.015.004l.012-.004l.104-.074l.012-.016l.004-.017l-.017-.427c-.002-.01-.009-.017-.017-.018m.265-.113l-.013.002l-.185.093l-.01.01l-.003.011l.018.43l.005.012l.008.007l.201.093c.012.004.023 0 .029-.008l.004-.014l-.034-.614c-.003-.012-.01-.02-.02-.022m-.715.002a.023.023 0 0 0-.027.006l-.006.014l-.034.614c0 .012.007.02.017.024l.015-.002l.201-.093l.01-.008l.004-.011l.017-.43l-.003-.012l-.01-.01z"/>
    <path fill="#fff" d="M11 3a2 2 0 0 1 1.995 1.85L13 5v6a2 2 0 0 1-1.85 1.995L11 13H5a2 2 0 0 1-1.995-1.85L3 11V5a2 2 0 0 1 1.85-1.995L5 3zm0 2H5v6h6zM8.5 7a.5.5 0 0 1 .492.41L9 7.5v1a.5.5 0 0 1-.41.492L8.5 9h-1a.5.5 0 0 1-.492-.41L7 8.5v-1a.5.5 0 0 1 .41-.492L7.5 7zM21 5a2 2 0 0 0-2-2h-2a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2zm-4 0h2v2h-2zM7 15a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2a2 2 0 0 1 2-2zm0 2H5v2h2zm14 0a2 2 0 0 0-2-2h-2a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2zm-4 0h2v2h-2zm-2-5a1 1 0 0 1 1-1h4a1 1 0 1 1 0 2h-4a1 1 0 0 1-1-1m-2 4a1 1 0 1 0-2 0v4a1 1 0 1 0 2 0z"/>
  </g>
</svg>

```

`zil-pay/popup/components/icons/ReloadIcon.svelte`:

```svelte
<svg
  {...$$restProps}
  viewBox="0 0 800 800"
  fill="none"
>
  <path
    d="M150.729 233.333H233.333C251.743 233.333 266.667 248.257 266.667 266.667C266.667 285.076 251.743 300 233.333 300H100C63.181 300 33.3334 270.152 33.3334 233.333V100C33.3334 81.5903 48.2574 66.6667 66.6667 66.6667C85.076 66.6667 100 81.5903 100 100V189.18C138.07 135.006 190.286 91.903 251.327 64.827C326.248 31.5947 410.143 24.4218 489.617 44.4533C569.09 64.4847 639.56 110.566 689.78 175.339C733.163 231.3 759.27 298.425 765.313 368.507C766.893 386.847 751.59 401.727 733.18 401.637C714.773 401.547 699.967 386.503 698.013 368.197C692.133 313.112 671.067 260.494 636.857 216.368C595.81 163.424 538.21 125.759 473.25 109.385C408.29 93.012 339.717 98.875 278.479 126.038C227.441 148.677 183.951 185.024 152.665 230.743C152.052 231.638 151.406 232.502 150.729 233.333Z"
    fill="var(--text-primary)"
  />
  <path
    d="M700 610.82C661.93 664.993 609.713 708.097 548.673 735.173C473.753 768.407 389.857 775.577 310.384 755.547C230.91 735.513 160.439 689.433 110.221 624.66C66.8354 568.7 40.7287 501.573 34.6881 431.493C33.107 413.153 48.4097 398.273 66.8187 398.363C85.2281 398.453 100.034 413.497 101.988 431.8C107.866 486.887 128.932 539.507 163.142 583.633C204.189 636.577 261.79 674.24 326.75 690.613C391.71 706.987 460.283 701.123 521.52 673.96C572.56 651.323 616.05 614.977 647.337 569.257C647.947 568.363 648.593 567.497 649.27 566.667H566.667C548.257 566.667 533.333 551.743 533.333 533.333C533.333 514.923 548.257 500 566.667 500H700C736.82 500 766.667 529.847 766.667 566.667V700C766.667 718.41 751.743 733.333 733.333 733.333C714.923 733.333 700 718.41 700 700V610.82Z"
    fill="var(--text-primary)"
  />
</svg>


```

`zil-pay/popup/i18n.ts`:

```ts
import { derived } from "svelte/store";
import { dictionary, locale, _, date, time, number } from "svelte-i18n";

const MESSAGE_FILE_URL_TEMPLATE = "/lang/{locale}.json";

let cachedLocale: string | string[];

async function setupI18n({ withLocale: _locale } = { withLocale: "en" }) {
  const messsagesFileUrl = MESSAGE_FILE_URL_TEMPLATE.replace(
    "{locale}",
    _locale,
  );
  const response = await fetch(messsagesFileUrl);
  const messages = await response.json();
  dictionary.set({ [_locale]: messages });
  cachedLocale = _locale;
  locale.set(_locale);
}

function formatDate(
  date: string | number | Date,
  options: Intl.DateTimeFormatOptions,
): string {
  return new Intl.DateTimeFormat(cachedLocale, options).format(new Date(date));
}

const isLocaleLoaded = derived(
  locale,
  ($locale) => typeof $locale === "string",
);
const dir = derived(locale, ($locale) => ($locale === "en" ? "rtl" : "ltr"));

export {
  _,
  locale,
  dir,
  setupI18n,
  formatDate,
  isLocaleLoaded,
  date,
  time,
  number,
};

```

`zil-pay/popup/main.ts`:

```ts
import { mount } from "svelte";
import App from "./App.svelte";
import { getGlobalState } from "./background/wallet";

let app = {};

getGlobalState().finally(() => {
  app = mount(App, {
    target: document.body,
  });
});

export default app;

```

`zil-pay/popup/mixins/chains.ts`:

```ts
import type { IChainConfigState } from "background/storage";

export interface Explorer {
  name: string;
  url: string;
  icon: string;
  standard: string;
}

export interface FToken {
  native: boolean;
  logo: string;
  addr: string;
  name: string;
  symbol: string;
  decimals: number;
}

export interface ChainData {
  mainnet: IChainConfigState[];
  testnet: IChainConfigState[];
}

export async function getChains(): Promise<ChainData> {
  try {
    const baseUrl = "/chains";
    const [mainnetResponse, testnetResponse] = await Promise.all([
      fetch(`${baseUrl}/mainnet.json`),
      fetch(`${baseUrl}/testnet.json`) 
    ]);
  
    const mainnet = await mainnetResponse.json() as IChainConfigState[];
    const testnet = testnetResponse.ok ? await testnetResponse.json() as IChainConfigState[] : [];

    return {
      mainnet,
      testnet
    };
  } catch (error) {
    return {
      mainnet: [],
      testnet: []
    };
  }
}

```

`zil-pay/popup/mixins/theme.ts`:

```ts
import { Themes } from "config/theme";

export function themeDetect() {
  const darkThemeMq = window.matchMedia("(prefers-color-scheme: dark)");
  const isDark = Boolean(darkThemeMq.matches);

  return isDark ? Themes.Dark : Themes.Light;
}

```

`zil-pay/popup/modals/CipherOptions.svelte`:

```svelte
<script lang="ts">
  import { _ } from '../i18n';
  import type { IWalletSettingsState } from 'background/storage';
  import { CipherOrders } from 'crypto/keychain';
  import SmartInput from '../components/SmartInput.svelte';
  import RadioOption from '../components/RadioOption.svelte';

  enum CipherMode {
    Basic,
    Enhanced,
    QuantumResistant
  }

  enum MemoryProfile {
    Weak,
    Medium,
    Strong
  }

  let {
    settings = $bindable(),
    onChange = () => {}
  }: {
    settings: IWalletSettingsState;
    onChange?: (updatedSettings: IWalletSettingsState) => void;
  } = $props();

  const cipherOptions = $derived(() => [
    {
      value: CipherMode.Basic,
      title: $_('modals.cipher.modes.basic.title'),
      subtitle: $_('modals.cipher.modes.basic.subtitle'),
      description: $_('modals.cipher.modes.basic.description'),
    },
    {
      value: CipherMode.Enhanced,
      title: $_('modals.cipher.modes.enhanced.title'),
      subtitle: $_('modals.cipher.modes.enhanced.subtitle'),
      description: $_('modals.cipher.modes.enhanced.description'),
    },
    {
      value: CipherMode.QuantumResistant,
      title: $_('modals.cipher.modes.quantum-resistant.title'),
      subtitle: $_('modals.cipher.modes.quantum-resistant.subtitle'),
      description: $_('modals.cipher.modes.quantum-resistant.description'),
    }
  ]);

  const memoryProfiles = $derived(() => [
    {
      value: MemoryProfile.Weak,
      title: $_('modals.cipher.memory.weak.title'),
      subtitle: $_('modals.cipher.memory.weak.subtitle'),
      description: $_('modals.cipher.memory.weak.description'),
    },
    {
      value: MemoryProfile.Medium,
      title: $_('modals.cipher.memory.medium.title'),
      subtitle: $_('modals.cipher.memory.medium.subtitle'),
      description: $_('modals.cipher.memory.medium.description'),
    },
    {
      value: MemoryProfile.Strong,
      title: $_('modals.cipher.memory.strong.title'),
      subtitle: $_('modals.cipher.memory.strong.subtitle'),
      description: $_('modals.cipher.memory.strong.description'),
    }
  ]);

  let selectedCipherMode = $state<CipherMode>(CipherMode.QuantumResistant);
  let selectedMemoryProfile = $state<MemoryProfile>(MemoryProfile.Medium);

  const profileToParams: Record<MemoryProfile, { memory: number; iterations: number; threads: number }> = {
    [MemoryProfile.Weak]: { memory: 64, iterations: 1, threads: 1 },
    [MemoryProfile.Medium]: { memory: 8192, iterations: 2, threads: 1 },
    [MemoryProfile.Strong]: { memory: 262144, iterations: 4, threads: 2 }
  };

  const cipherToCipherOrders: Record<CipherMode, CipherOrders[]> = {
    [CipherMode.Basic]: [CipherOrders.AESGCM256],
    [CipherMode.Enhanced]: [CipherOrders.AESGCM256, CipherOrders.KUZNECHIK],
    [CipherMode.QuantumResistant]: [CipherOrders.AESGCM256, CipherOrders.KUZNECHIK, CipherOrders.NTRUP761]
  };

  function updateSettings() {
    const profile = profileToParams[selectedMemoryProfile];
    const cipherOrders = cipherToCipherOrders[selectedCipherMode];
    
    const updatedSettings: IWalletSettingsState = {
      ...settings,
      cipherOrders,
      hashFnParams: {
        ...settings.hashFnParams,
        memory: profile.memory,
        iterations: profile.iterations,
        threads: profile.threads
      }
    };

    settings = updatedSettings;
    onChange(updatedSettings);
  }

  function handleCipherChange(value: CipherMode) {
    selectedCipherMode = value;
    updateSettings();
  }

  function handleMemoryChange(value: MemoryProfile) {
    selectedMemoryProfile = value;
    updateSettings();
  }

  function handleSecretChange() {
    updateSettings();
  }

  $effect(() => {
    const currentMemory = settings.hashFnParams.memory;
    if (currentMemory <= 64) {
      selectedMemoryProfile = MemoryProfile.Weak;
    } else if (currentMemory <= 8192) {
      selectedMemoryProfile = MemoryProfile.Medium;
    } else {
      selectedMemoryProfile = MemoryProfile.Strong;
    }

    const orderCount = settings.cipherOrders.length;
    if (orderCount <= 1) {
      selectedCipherMode = CipherMode.Basic;
    } else if (orderCount <= 2) {
      selectedCipherMode = CipherMode.Enhanced;
    } else {
      selectedCipherMode = CipherMode.QuantumResistant;
    }
  });
</script>

<div class="cipher-options-content">
  <div class="options-section">
    <h3 class="section-title">{$_('modals.cipher.encryptionTitle')}</h3>
    <RadioOption
      options={cipherOptions}
      bind:selected={selectedCipherMode}
      name="cipher"
      onSelect={handleCipherChange}
    />
  </div>

  <div class="options-section">
    <h3 class="section-title">{$_('modals.cipher.memoryTitle')}</h3>
    <RadioOption
      options={memoryProfiles}
      bind:selected={selectedMemoryProfile}
      name="memory"
      onSelect={handleMemoryChange}
    />
  </div>

  <div class="options-section">
    <SmartInput
      label={$_('modals.cipher.secretLabel')}
      placeholder={$_('modals.cipher.secretPlaceholder')}
      bind:value={settings.hashFnParams.secret}
      onInput={handleSecretChange}
      showToggle={false}
    />
  </div>
</div>

<style lang="scss">
  .cipher-options-content {
    display: flex;
    flex-direction: column;
    gap: 24px;
  }

  .options-section {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .section-title {
    font-size: var(--font-size-large);
    font-weight: 600;
    color: var(--text-primary);
    margin: 0;
  }

  @media (max-width: 480px) {
    .cipher-options-content {
      gap: 20px;
    }

    .options-section {
      gap: 12px;
    }
  }

  @media (max-width: 360px) {
    .cipher-options-content {
      gap: 16px;
    }
  }
</style>

```

`zil-pay/popup/pages/Bip39Generate.svelte`:

```svelte
<script lang="ts">
  import NavBar from '../components/NavBar.svelte';
  import WordCountSelector from '../components/WordCountSelector.svelte';
  import Dropdown from '../components/Dropdown.svelte';
  import Button from '../components/Button.svelte';
  import ReloadButton from '../components/ReloadButton.svelte';
  import MnemonicWord from '../components/MnemonicWord.svelte';
  import CopyButton from '../components/CopyButton.svelte';
  import PrintButton from '../components/PrintButton.svelte';
  import { _ } from 'popup/i18n';
  import { locale } from 'popup/i18n';
  import { pop, push } from '../router/navigation';
  import { generateBip39Words } from 'popup/background/wallet';
  import { cacheStore }  from 'popup/store/cache';
  import { LANGUAGE_OPTIONS } from 'config/bip39';


  let wordCount = $state(24);
  let selectedLang = $state('en');
  let wordList = $state([]);
  let phrase: string[] = $state([]);
  let hasBackup = $state(false);

  async function loadWordlist(lang: string = selectedLang) {
    try {
      let url = `/bip39/${lang}.json`;
      let res = await fetch(url);
      
      if (!res.ok) {
        url = `/bip39/en.json`;
        res = await fetch(url);
      }
      
      if (!res.ok) {
        throw new Error('Failed to load wordlist');
      }
      
      wordList = await res.json();
    } catch (error) {
      console.error('Error loading wordlist:', error);
      wordList = [];
    }
  }

  async function generateWords() {
    if (!wordList.length) return;
    
    try {
      const raw = await generateBip39Words(wordCount, wordList);
      phrase = raw.split(' ');
      hasBackup = false;
    } catch (error) {
      console.error('Error generating words:', error);
    }
  }

  function handleCountChange(count: number) {
    wordCount = count;
    generateWords();
  }

  function handleLanguageChange(langCode: string) {
    selectedLang = langCode;
    loadWordlist(langCode).then(() => {
      if (wordList.length > 0) {
        generateWords();
      }
    });
  }

  function handleNext() {
    if (hasBackup && phrase.length > 0) {
      cacheStore.set({
        verifyPhrase: phrase,
      });
      push(`/verify-bip39`);
    }
  }

  function handleReload() {
    generateWords();
  }

  $effect(() => {
    let lang = ($locale ?? 'en').toLowerCase().split('-')[0];
    
    const supportedLangs = LANGUAGE_OPTIONS.map(opt => opt.code);
    if (!supportedLangs.includes(lang)) {
      lang = 'en';
    }
    
    selectedLang = lang;
    
    loadWordlist(lang).then(() => {
      if (wordList.length > 0) {
        generateWords();
      }
    });
  });
</script>

<div class="bip39-page">
  <div class="page-container">
    <NavBar
      title={$_('bip39.create.title')}
      onBack={pop}
      rightIcon={ReloadButton}
      onRight={handleReload}
    />

    <div class="content">
      <div class="controls-section">
        <div class="control-group">
          <WordCountSelector bind:selected={wordCount} onSelect={handleCountChange} />
        </div>
        
        <div class="control-group centered">
          <Dropdown 
            options={LANGUAGE_OPTIONS}
            bind:selected={selectedLang} 
            onSelect={handleLanguageChange}
            placeholder="Select language"
            width="200px"
          />
          <CopyButton text={phrase.join(" ")}/>
          <PrintButton phrase={phrase}/>
        </div>
      </div>

      <div class="phrase-section">
        <h3 class="section-title">{$_('bip39.create.phrase')}</h3>
        <div class="phrase-container">
          {#if phrase.length > 0}
            <div class="phrase-grid">
              {#each phrase as word, i}
                <MnemonicWord index={i + 1} {word} />
              {/each}
            </div>
          {:else}
            <div class="empty-state">
              <span>{$_('bip39.create.noWords')}</span>
            </div>
          {/if}
        </div>
      </div>

      <div class="backup-section">
        <label class="checkbox-label">
          <input 
            type="checkbox" 
            bind:checked={hasBackup}
            class="checkbox-input"
          />
          <span class="checkbox-text">
            {$_('bip39.create.backupConfirm')}
          </span>
        </label>
      </div>

      <Button 
        onclick={handleNext} 
        disabled={!hasBackup || phrase.length === 0}
        width="100%"
      >
        {$_('bip39.create.next')}
      </Button>
   </div>
  </div>
</div>

<style lang="scss">
  .bip39-page {
    display: flex;
    justify-content: center;
    min-height: 100vh;
    background: var(--background-color);
    color: var(--text-primary);
  }

  .content {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 24px;
    overflow-y: auto;
    padding-bottom: 20px;
  }

  .controls-section {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 8px;

    &.centered {
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 16px;
    }
  }

  .phrase-section,
  .backup-section {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .section-title {
    font-size: var(--font-size-large);
    font-weight: 600;
    color: var(--text-primary);
    margin: 0;
  }

  .phrase-container {
    background: var(--card-background);
    border-radius: 16px;
    padding: 20px;
    min-height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .phrase-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 12px;
    width: 100%;
    max-width: 100%;
  }

  .empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    color: var(--text-secondary);
    font-size: var(--font-size-medium);
  }

  .checkbox-label {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    cursor: pointer;
    user-select: none;
  }

  .checkbox-input {
    width: 18px;
    height: 18px;
    margin: 0;
    accent-color: var(--primary-purple);
    cursor: pointer;
    flex-shrink: 0;
  }

  .checkbox-text {
    font-size: var(--font-size-medium);
    color: var(--text-secondary);
    line-height: 1.4;
  }

  @media (max-width: 480px) {
    .page-container {
      padding: 0 16px;
    }

    .controls-section {
      gap: 16px;
    }

    .phrase-grid {
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 10px;
    }
  }

  @media (max-width: 360px) {
    .phrase-grid {
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 8px;
    }
  }
</style>

```

`zil-pay/popup/pages/Bip39Restore.svelte`:

```svelte
<script lang="ts">
  import { _ } from '../i18n';
  import { pop, push } from '../router/navigation';
  import NavBar from '../components/NavBar.svelte';
  import WordCountSelector from '../components/WordCountSelector.svelte';
  import MnemonicWordInput from '../components/MnemonicWordInput.svelte';
  import Button from '../components/Button.svelte';
  import { detectLanguage } from 'lib/utils/locale';
  import { ALLOWED_COUNTS, LANGUAGE_OPTIONS } from 'config/bip39';
  import { validateBip39Checksum } from 'popup/background/wallet';
  import { cacheStore }  from 'popup/store/cache';

  let words = $state<string[]>(Array(12).fill(''));
  let wordErrors = $state<number[]>([]);
  let count = $state(12);
  let isChecksumValid = $state(true);
  let bypassChecksum = $state(false);
  let showChecksumWarning = $state(false);
  let allWordsEntered = $state(false);
  let currentLanguage = $state('en');
  let wordlist = $state<string[]>([]);

  const isButtonEnabled = $derived(() => {
    if (!allWordsEntered) return false;
    if (isChecksumValid) return true;
    return bypassChecksum;
  });

  async function loadWordlist(language: string) {
    try {
      const response = await fetch(`/bip39/${language}.json`);
      if (!response.ok) throw new Error(`Failed to load ${language} wordlist`);
      wordlist = await response.json();
      currentLanguage = language;
    } catch (error) {
      console.error('Error loading wordlist:', error);
      if (language !== 'en') {
        await loadWordlist('en');
      }
    }
  }

  async function detectAndLoadLanguage(word: string) {
    try {
      const detectedLang = detectLanguage(word);
      const langExists = LANGUAGE_OPTIONS.some(lang => lang.code === detectedLang);
      
      if (langExists && detectedLang !== currentLanguage) {
        await loadWordlist(detectedLang);
      }
    } catch (error) {
      if (currentLanguage !== 'en') {
        await loadWordlist('en');
      }
    }
  }

  async function checkWords() {
    try {
      const nonEmptyWords = words.filter(word => word.length > 0);
      if (nonEmptyWords.length === 0) return;

      await detectAndLoadLanguage(nonEmptyWords[0]);

      const errorIndexes: number[] = [];

      for (let i = 0; i < words.length; i++) {
        if (words[i].length > 0) {
          if (!wordlist.includes(words[i])) {
            errorIndexes.push(i);
          }
        }
      }

      wordErrors = errorIndexes;
      validateForm();
    } catch (error) {
      console.error('Error checking words:', error);
    }
  }

  async function validateForm() {
    const areAllWordsValid = words.every(word => word.length > 0) && wordErrors.length === 0;
    allWordsEntered = areAllWordsValid;

    if (areAllWordsValid && !showChecksumWarning) {
      const phrase = words.join(' ');
      const checksumValid = await validateBip39Checksum(phrase, wordlist);
      
      isChecksumValid = checksumValid;
      showChecksumWarning = !checksumValid;
    } else if (!areAllWordsValid) {
      showChecksumWarning = false;
      bypassChecksum = false;
    }
  }

  function handleWordChange(index: number, word: string) {
    if (word.trim().includes(' ')) {
      handlePhraseInput(word);
      return;
    }

    const trimmedWord = word.trim().toLowerCase().replace(/[^a-z]/g, '');
    const currentIndex = index - 1;

    words[currentIndex] = trimmedWord;
    
    if (wordErrors.includes(currentIndex)) {
      wordErrors = wordErrors.filter(i => i !== currentIndex);
    }

    if (showChecksumWarning) {
      showChecksumWarning = false;
      bypassChecksum = false;
    }

    validateForm();

    if (trimmedWord.length > 0) {
      queueMicrotask(() => checkWords());
    }
  }

  function handlePhraseInput(phrase: string) {
    const wordsArray = phrase
      .trim()
      .split(/\s+/)
      .filter(word => word.length > 0);

    const targetCount = ALLOWED_COUNTS.find(c => c >= wordsArray.length) || ALLOWED_COUNTS[ALLOWED_COUNTS.length - 1];

    if (targetCount !== count) {
      handleCountChange(targetCount);
    }

    for (let i = 0; i < wordsArray.length && i < targetCount; i++) {
      words[i] = wordsArray[i].toLowerCase();
    }

    showChecksumWarning = false;
    bypassChecksum = false;

    validateForm();

    if (wordsArray.length > 0) {
      queueMicrotask(() => checkWords());
    }
  }

  function handleCountChange(newCount: number) {
    count = newCount;
    const newWords = Array(newCount).fill('');
    
    for (let i = 0; i < Math.min(words.length, newCount); i++) {
      newWords[i] = words[i];
    }
    
    words = newWords;
    wordErrors = [];
    showChecksumWarning = false;
    bypassChecksum = false;
    allWordsEntered = false;

    validateForm();
  }

  function handleRestore() {
    cacheStore.set({
      verifyPhrase: words,
    });
    push("/network-setup");
  }

  $effect(() => {
    loadWordlist('en');
  });
</script>

<div class="page-container restore-page">
  <NavBar title={$_('bip39.restore.title')} onBack={pop} />

  <div class="content">
    <WordCountSelector
      bind:selected={count}
      onSelect={handleCountChange}
    />

    <div class="words-grid">
      {#each words as word, index (index)}
        <MnemonicWordInput
          index={index + 1}
          {word}
          isEditable={true}
          hasError={wordErrors.includes(index)}
          onChanged={handleWordChange}
        />
      {/each}
    </div>

    {#if showChecksumWarning}
      <div class="checksum-warning">
        <p class="warning-text">{$_('bip39.restore.checksumWarning')}</p>
        <label class="bypass-checkbox">
          <input
            type="checkbox"
            bind:checked={bypassChecksum}
          />
          <span class="checkbox-text">{$_('bip39.restore.bypassCheckbox')}</span>
        </label>
      </div>
    {/if}

    <Button
      disabled={!isButtonEnabled}
      onclick={handleRestore}
      width="100%"
    >
      {$_('bip39.restore.restoreButton')}
    </Button>
  </div>
</div>

<style lang="scss">
  .restore-page {
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: var(--background-color);
    color: var(--text-primary);
    padding: 0 20px;
    box-sizing: border-box;
  }

  .content {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 20px;
    overflow-y: auto;
    padding-bottom: 20px;
  }

  .words-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 12px;
    overflow-y: auto;
    padding: 8px 0;
    min-height: 200px;
  }

  .checksum-warning {
    padding: 16px;
    background-color: color-mix(in srgb, var(--danger-color) 10%, var(--card-background));
    border: 1px solid var(--danger-color);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .warning-text {
    color: var(--danger-color);
    font-weight: 600;
    font-size: var(--font-size-medium);
    margin: 0;
  }

  .bypass-checkbox {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    color: var(--text-primary);
    user-select: none;
  }

  .checkbox-text {
    font-size: var(--font-size-medium);
    color: var(--text-secondary);
    line-height: 1.4;
  }

  .bypass-checkbox input {
    width: 16px;
    height: 16px;
    accent-color: var(--primary-purple);
    cursor: pointer;
  }

  @media (max-width: 480px) {
    .restore-page {
      padding: 0 16px;
    }

    .content {
      gap: 16px;
    }

    .words-grid {
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
    }

    .checksum-warning {
      padding: 12px;
      gap: 10px;
    }

    .warning-text,
    .checkbox-text {
      font-size: var(--font-size-small);
    }
  }

  @media (max-width: 360px) {
    .words-grid {
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
    }
  }
</style>

```

`zil-pay/popup/pages/Bip39Verify.svelte`:

```svelte
<script lang="ts">
  import { _ } from '../i18n';
  import { push } from '../router/navigation';
  import NavBar from '../components/NavBar.svelte';
  import Button from '../components/Button.svelte';
  import { cacheStore } from '../store/cache';

  const VERIFICATION_COUNT = 4;

  let phrase = $state<string[]>([]);
  let selectedIndices = $state<number[]>([]);
  let userInputs = $state<string[]>(Array(VERIFICATION_COUNT).fill(''));
  let isValid = $state(false);

  function shuffle(array: number[]): number[] {
    const result = [...array];
    for (let i = result.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
  }

  function validate() {
    isValid = userInputs.every((input, idx) => {
      const original = phrase[selectedIndices[idx]];
      const userInput = input.trim().toLowerCase();
      const expectedWord = original?.toLowerCase();
      return userInput === expectedWord && userInput.length > 0;
    });
  }

  $effect(() => {
    validate();
  });

  function handleVerify() {
    push('/network-setup');
  }

  $effect(() => {
    if (!$cacheStore.verifyPhrase || $cacheStore.verifyPhrase.length === 0) {
      return push('/generate-bip39');
    }

    phrase = $cacheStore.verifyPhrase;
        
    if (phrase.length < VERIFICATION_COUNT) {
      push('/generate-bip39');
      return;
    }

    const indices = Array.from({ length: phrase.length }, (_, i) => i);
    selectedIndices = shuffle(indices).slice(0, VERIFICATION_COUNT).sort((a, b) => a - b);
    userInputs = Array(VERIFICATION_COUNT).fill('');
    isValid = false;
  });
</script>

<div class="page-container verify-page">
  <div class="page-container">
    <NavBar title={$_('bip39.verify.title')} />

    <div class="content">
      <div class="instructions">
        <h2 class="title">{$_('bip39.verify.subtitle')}</h2>
        <p class="description">{$_('bip39.verify.instructions')}</p>
      </div>

      <div class="verification-section">
        {#each selectedIndices as idx, i}
          <div class="input-group">
            <div class="word-indicator">
              <span class="word-number">{idx + 1}</span>
            </div>
            <input
              type="text"
              bind:value={userInputs[i]}
              placeholder={$_('bip39.verify.placeholder')}
              autocapitalize="off"
              autocomplete="off"
              spellcheck="false"
              class="word-input"
            />
          </div>
        {/each}
      </div>

      <div class="actions">
        <Button 
          disabled={!isValid} 
          onclick={handleVerify}
          width="100%"
        >
          {$_('bip39.verify.button')}
        </Button>
      </div>
    </div>
  </div>
</div>

<style lang="scss">
  .verify-page {
    display: flex;
    justify-content: center;
    min-height: 100vh;
    background: var(--background-color);
    color: var(--text-primary);
    padding: 0 var(--padding-side);
    box-sizing: border-box;
  }

  .page-container {
    display: flex;
    flex-direction: column;
    width: 100%;
    max-width: var(--max-content-width);
    min-height: 100vh;
    box-sizing: border-box;
  }

  .content {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    gap: 20px;
    padding-bottom: 20px;
  }

  .instructions {
    text-align: center;
    padding: 16px 0;
  }

  .title {
    font-size: var(--font-size-xl);
    font-weight: 700;
    color: var(--text-primary);
    margin: 0 0 8px 0;
    line-height: 1.3;
  }

  .description {
    font-size: var(--font-size-medium);
    color: var(--text-secondary);
    margin: 0;
    line-height: 1.4;
    opacity: 0.9;
    max-width: 320px;
    margin: 0 auto;
  }

  .verification-section {
    display: flex;
    flex-direction: column;
    gap: 16px;
    flex: 1;
    justify-content: center;
    max-width: 400px;
    margin: 0 auto;
    width: 100%;
  }

  .input-group {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .word-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    background: linear-gradient(135deg, var(--primary-purple), color-mix(in srgb, var(--primary-purple) 80%, #000));
    border-radius: 10px;
    box-shadow: 0 2px 8px color-mix(in srgb, var(--primary-purple) 25%, transparent);
    flex-shrink: 0;
  }

  .word-number {
    font-size: var(--font-size-medium);
    font-weight: 700;
    color: white;
  }

  .word-input {
    flex: 1;
    padding: 12px 16px;
    border-radius: 10px;
    border: 2px solid color-mix(in srgb, var(--text-secondary) 20%, transparent);
    background: var(--card-background);
    color: var(--text-primary);
    font-size: var(--font-size-medium);
    font-weight: 500;
    transition: all 0.2s ease;

    &:focus {
      outline: none;
      border-color: var(--primary-purple);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-purple) 15%, transparent);
    }

    &::placeholder {
      color: var(--text-secondary);
      opacity: 0.6;
    }
  }

  .actions {
    padding: 16px 0;
    max-width: 400px;
    margin: 0 auto;
    width: 100%;
  }

  @media (max-width: 480px) {
    .content {
      gap: 16px;
    }

    .instructions {
      padding: 12px 0;
    }

    .title {
      font-size: calc(var(--font-size-xl) * 0.9);
    }

    .description {
      font-size: var(--font-size-small);
      max-width: 280px;
    }

    .verification-section {
      gap: 14px;
    }

    .input-group {
      gap: 10px;
    }

    .word-indicator {
      width: 36px;
      height: 36px;
    }

    .word-number {
      font-size: var(--font-size-small);
    }

    .word-input {
      padding: 10px 14px;
      font-size: var(--font-size-small);
    }

    .actions {
      padding: 12px 0;
    }
  }

  @media (max-width: 360px) {
    .verification-section {
      gap: 12px;
    }

    .input-group {
      gap: 8px;
    }

    .word-indicator {
      width: 32px;
      height: 32px;
    }

    .word-input {
      padding: 8px 12px;
    }
  }

  @media (min-width: 768px) {
    .content {
      max-width: 500px;
      margin: 0 auto;
    }

    .verification-section {
      max-width: 450px;
    }

    .actions {
      max-width: 450px;
    }
  }
</style>

```

`zil-pay/popup/pages/GenerateWallet.svelte`:

```svelte
<script lang="ts">
  import { _ } from '../i18n';
  import { pop, push } from '../router/navigation';
  import NavBar from '../components/NavBar.svelte';
  import WalletOption from '../components/WalletOption.svelte';
  import Bip39Icon from '../components/icons/Bip39Icon.svelte';
  import GridIcon from '../components/icons/GridIcon.svelte';
  import LockIcon from '../components/icons/LockIcon.svelte';

  type GenerateOption = {
    id: string;
    titleKey: string;
    descriptionKey: string;
    icon: any;
    disabled: boolean;
    action: () => void;
  };

  const generateOptions: GenerateOption[] = [
    {
      id: 'bip39',
      titleKey: 'generateWallet.bip39.title',
      descriptionKey: 'generateWallet.bip39.description',
      icon: Bip39Icon,
      disabled: false,
      action: () => handleBip39()
    },
    {
      id: 'private-key',
      titleKey: 'generateWallet.privateKey.title',
      descriptionKey: 'generateWallet.privateKey.description',
      icon: LockIcon,
      disabled: false,
      action: () => handlePrivateKey()
    },
    {
      id: 'slip0039',
      titleKey: 'generateWallet.slip0039.title',
      descriptionKey: 'generateWallet.slip0039.description',
      icon: GridIcon,
      disabled: true,
      action: () => handleSlip0039()
    },
  ];

  function handleBip39() {
    push('/generate-bip39');
  }

  function handleSlip0039() {
    push('/generate-wallet/slip0039');
  }

  function handlePrivateKey() {
    push('/keypair-generate');
  }
</script>

<div class="page-container generate-wallet">
  <NavBar title={$_('generateWallet.title')} onBack={() => pop()} />
  
  <div class="options-container">
    <div class="generate-options">
      {#each generateOptions as option}
        <WalletOption
          title={$_(option.titleKey)}
          description={$_(option.descriptionKey)}
          icon={option.icon}
          disabled={option.disabled}
          onclick={() => option.action()}
        />
      {/each}
    </div>
  </div>
</div>

<style lang="scss">
  .generate-wallet {
    display: flex;
    flex-direction: column;
    height: 100vh;
    background-color: var(--background-color);
    padding: 0 20px 20px;
    box-sizing: border-box;
  }

  .options-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    padding: 8px 0;
  }

  .generate-options {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
</style>

```

`zil-pay/popup/pages/Home.svelte`:

```svelte
<script lang="ts">
</script>

<div class="home-container">
  <h1>Welcome to the Wallet</h1>
</div>

<style lang="scss">
</style>

```

`zil-pay/popup/pages/KeyPairGen.svelte`:

```svelte
<script lang="ts">
  import type { IKeyPair } from 'types/wallet';
  import NavBar from '../components/NavBar.svelte';
  import HexKey from '../components/HexKey.svelte';
  import Button from '../components/Button.svelte';
  import CopyButton from '../components/CopyButton.svelte';
  import PrintButton from '../components/PrintButton.svelte';
  import ReloadButton from '../components/ReloadButton.svelte';
  import { _ } from '../i18n';
  import { pop, push } from '../router/navigation';
  import { generateKeyPair } from 'popup/background/wallet';
  import { ETHEREUM } from 'config/slip44';
  import { cacheStore }  from 'popup/store/cache';

  let keyPair = $state<IKeyPair>({
    address: "",
    privateKey: "",
    publicKey: "",
    slip44: ETHEREUM,
  });
  let hasBackup = $state(false);

  async function generateKeys() {
    try {
      keyPair = await generateKeyPair(ETHEREUM);
      hasBackup = false;
    } catch (error) {
      console.error('Error generating keys:', error);
    }
  }

  function handleNext() {
    cacheStore.set({
      keyPair: keyPair,
    });
    push("/network-setup");
  }

  function handleReload() {
    generateKeys();
  }

  $effect(() => {
    generateKeys();
  });
</script>

<div class="secret-key-page">
  <div class="page-container">
    <NavBar
      title={$_('secretKeyGenerator.title')}
      onBack={pop}
      rightIcon={ReloadButton}
      onRight={handleReload}
    />

    <div class="content">
      <div class="keys-section">
        <HexKey
          hexKey={keyPair.privateKey}
          title={$_('secretKeyGenerator.privateKey')}
        />
        
        <div class="key-actions">
          <CopyButton
            text={keyPair.privateKey}
            ariaLabel="Copy private key"
            size={44}
          />
          <PrintButton
            keyPair={keyPair}
            ariaLabel="Print private key"
            size={44}
          />
        </div>
      </div>

      <div class="actions-section">
        <div class="backup-confirmation">
          <label class="checkbox-container">
            <input
              type="checkbox"
              bind:checked={hasBackup}
              class="checkbox-input"
            />
            <span class="checkbox-text">
              {$_('secretKeyGenerator.backupCheckbox')}
            </span>
          </label>
        </div>

        <Button
          onclick={handleNext}
          disabled={!hasBackup || !keyPair.privateKey}
          width="100%"
        >
          {$_('secretKeyGenerator.nextButton')}
        </Button>
      </div>
    </div>
  </div>
</div>

<style lang="scss">
  .secret-key-page {
    display: flex;
    justify-content: center;
    min-height: 100vh;
    background: var(--background-color);
    color: var(--text-primary);
  }

  .page-container {
    display: flex;
    flex-direction: column;
    width: 100%;
    max-width: 480px;
    min-height: 100vh;
    padding: 0 20px;
    box-sizing: border-box;
  }

  .content {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    gap: 24px;
    overflow-y: auto;
    padding-bottom: 20px;
  }

  .keys-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 16px;
    min-height: 0;
    overflow-y: auto;
  }

  .key-actions {
    display: flex;
    justify-content: center;
    gap: 12px;
    padding: 8px 0;
  }

  .actions-section {
    display: flex;
    flex-direction: column;
    gap: 16px;
    padding: 16px 0;
    max-width: 480px;
    margin: 0 auto;
    width: 100%;
  }

  .backup-confirmation {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .checkbox-container {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    cursor: pointer;
    user-select: none;
  }

  .checkbox-input {
    width: 18px;
    height: 18px;
    margin: 0;
    accent-color: var(--primary-purple);
    cursor: pointer;
    flex-shrink: 0;
  }

  .checkbox-text {
    font-size: var(--font-size-medium);
    color: var(--text-secondary);
    line-height: 1.4;
  }

  @media (max-width: 480px) {
    .page-container {
      padding: 0 16px;
    }

    .content {
      gap: 20px;
    }

    .key-actions {
      gap: 10px;
    }

    .actions-section {
      padding: 12px 0;
      gap: 14px;
    }

    .checkbox-text {
      font-size: var(--font-size-small);
    }
  }

  @media (max-width: 360px) {
    .content {
      gap: 16px;
    }

    .key-actions {
      gap: 8px;
    }
  }

  @media (min-width: 768px) {
    .content {
      max-width: 500px;
      margin: 0 auto;
    }

    .actions-section {
      max-width: 450px;
    }
  }
</style>

```

`zil-pay/popup/pages/KeyPairRestore.svelte`:

```svelte
<script lang="ts">
  import type { IKeyPair } from 'types/wallet';
  import { _ } from '../i18n';
  import { pop, push } from '../router/navigation';
  import NavBar from '../components/NavBar.svelte';
  import Button from '../components/Button.svelte';
  import HexKey from '../components/HexKey.svelte';
  import { cacheStore }  from 'popup/store/cache';
  import { fromRpivKey } from 'popup/background/wallet';
  import { ETHEREUM } from 'config/slip44';


  let input = $state('');
  let isValid = $state(false);
  let keyPair = $state<IKeyPair>({
    address: "",
    privateKey: "",
    publicKey: "",
    slip44: ETHEREUM,
  });

  async function handleInput(event: Event) {
    const value = (event.target as HTMLInputElement).value.trim();
    input = value;
    validateKey(value);

    try {
      keyPair = await fromRpivKey(ETHEREUM, value); // TODO: change it depends of network
    } catch {
      isValid = false;
    }
  }

  function validateKey(value: string) {
    const clean = value.replace(/^0x/, '').toLowerCase();
    if (/^[0-9a-f]{64}$/i.test(clean)) {
      isValid = true;
    } else {
      isValid = false;
    }
  }

  function handleRestore() {
    cacheStore.set({
      keyPair: keyPair,
    });
    push("/network-setup");
  }
</script>

<div class="page-container keypair-restore">
  <NavBar title={$_('restoreKeyPair.title')} onBack={pop} />

  <div class="content">
    <div class="input-section">
      <label for="private-key" class="input-label">
        {$_('restoreKeyPair.inputLabel')}
      </label>
      <input
        id="private-key"
        type="text"
        class="text-input"
        placeholder={$_('restoreKeyPair.placeholder')}
        autocapitalize="off"
        autocomplete="off"
        spellcheck="false"
        bind:value={input}
        oninput={handleInput}
      />
    </div>

    {#if isValid && keyPair.privateKey}
      <HexKey hexKey={keyPair.privateKey} title={$_('restoreKeyPair.previewTitle')} />
    {/if}

    <Button width="100%" disabled={!isValid} onclick={handleRestore}>
      {$_('restoreKeyPair.restoreButton')}
    </Button>
  </div>
</div>

<style lang="scss">
  .keypair-restore {
    display: flex;
    flex-direction: column;
    background-color: var(--background-color);
    color: var(--text-primary);
    height: 100vh;
    padding: 0 20px;
    box-sizing: border-box;
  }

  .content {
    padding: 16px 0 20px;
    display: flex;
    flex-direction: column;
    gap: 20px;
    flex: 1;
  }

  .input-section {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .input-label {
    font-size: var(--font-size-medium);
    font-weight: 500;
    color: var(--text-secondary);
  }

  .text-input {
    width: 100%;
    padding: 14px 16px;
    font-size: var(--font-size-medium);
    font-weight: 500;
    color: var(--text-primary);
    border: 2px solid color-mix(in srgb, var(--text-secondary) 20%, transparent);
    background-color: var(--card-background);
    border-radius: 12px;
    transition: border-color 0.2s ease;

    &:focus {
      outline: none;
      border-color: var(--primary-purple);
    }

    &::placeholder {
      color: var(--text-secondary);
      opacity: 0.6;
    }
  }

  @media (max-width: 480px) {
    .keypair-restore {
      padding: 0 16px;
    }
  }
</style>

```

`zil-pay/popup/pages/Locale.svelte`:

```svelte
<script lang="ts">
    import { _ } from 'popup/i18n';
    import { pop } from 'popup/router/navigation';
    import globalStore from 'popup/store/global';
    import { setGlobalState } from 'popup/background/wallet';
    import { setupI18n } from 'popup/i18n';
    import { Locales } from 'config/locale';
    
    import NavBar from '../components/NavBar.svelte';

    type Language = {
        code: Locales;
        primaryName: string;
        secondaryName: string;
    };

    const languages: Language[] = [
        { code: Locales.Auto, primaryName: 'System', secondaryName: 'Auto-detect' },
        { code: Locales.RU, primaryName: 'Russian', secondaryName: 'Русский' },
        { code: Locales.EN, primaryName: 'English', secondaryName: 'English' },
        { code: Locales.JA, primaryName: 'Japanese', secondaryName: '日本語' },
        { code: Locales.ZH, primaryName: 'Chinese', secondaryName: '中文' }
    ];

    async function handleLanguageSelect(localeCode: Locales) {
        if ($globalStore.locale === localeCode) return;
        
        globalStore.update(store => ({ ...store, locale: localeCode }));
        await setGlobalState();

        if (localeCode === Locales.Auto) {
            await setupI18n();
        } else {
            await setupI18n({ withLocale: localeCode });
        }
        
        globalStore.set({
            ...$globalStore,
            locale: localeCode,
        });

        await setGlobalState();
    }
</script>

<div class="page-container locale-page">
    <NavBar title={$_('locale.title')} onBack={pop} />
    <div class="language-container">
        <div class="language-grid">
            {#each languages as lang}
                <button 
                    class="language-card" 
                    class:selected={$globalStore.locale === lang.code}
                    onclick={() => handleLanguageSelect(lang.code)}
                    aria-pressed={$globalStore.locale === lang.code}
                >
                    <div class="language-content">
                        <div class="primary-name">{lang.primaryName}</div>
                        <div class="secondary-name">{lang.secondaryName}</div>
                    </div>
                    <div class="selection-indicator"></div>
                </button>
            {/each}
        </div>
    </div>
</div>

<style lang="scss">
  .locale-page {
    display: flex;
    flex-direction: column;
    height: 100%;
    background-color: var(--background-color);
    padding: 0 20px 20px;
    box-sizing: border-box;
  }

  .language-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
  }

  .language-grid {
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 8px 0;
  }

  .language-card {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    padding: 20px 24px;
    background-color: var(--card-background);
    border: 2px solid transparent;
    border-radius: 16px;
    cursor: pointer;
    text-align: left;
    min-height: 72px;
    
    &:hover {
      border-color: color-mix(in srgb, var(--primary-purple) 30%, transparent);
    }

    &:focus {
      outline: none;
      border-color: var(--primary-purple);
    }

    &.selected {
      background: linear-gradient(135deg, 
          color-mix(in srgb, var(--primary-purple) 15%, transparent),
          color-mix(in srgb, var(--primary-purple) 8%, transparent)
      );
      border-color: var(--primary-purple);

      .selection-indicator {
        opacity: 1;
      }

      .primary-name {
        color: var(--primary-purple);
      }
    }
  }

  .language-content {
    display: flex;
    flex-direction: column;
    gap: 4px;
    flex: 1;
  }

  .primary-name {
    font-size: var(--font-size-large);
    font-weight: 500;
    color: var(--text-primary);
  }

  .secondary-name {
    font-size: var(--font-size-medium);
    color: var(--text-secondary);
    opacity: 0.8;
  }

  .selection-indicator {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--primary-purple), color-mix(in srgb, var(--primary-purple) 80%, #000));
    opacity: 0;
    position: relative;
    flex-shrink: 0;
    
    &::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 6px;
      height: 10px;
      border: 2px solid white;
      border-top: none;
      border-left: none;
      transform: translate(-50%, -60%) rotate(45deg);
    }
  }
</style>

```

`zil-pay/popup/pages/Lock.svelte`:

```svelte
<script lang="ts">
</script>

<div class="home-container">
  <h1>Welcome to the Wallet</h1>
</div>

<style lang="scss">
</style>

```

`zil-pay/popup/pages/NetworkSetup.svelte`:

```svelte
<script lang="ts">
  import type { IChainConfigState } from 'background/storage/chain';

  import { getChains } from '../mixins/chains';
  import NavBar from '../components/NavBar.svelte';
  import WalletOption from '../components/WalletOption.svelte';
  import Switch from '../components/Switch.svelte';
  import { _ } from '../i18n';
  import { pop, push } from '../router/navigation';
  import globalStore from 'popup/store/global';
  import { viewChain } from 'lib/popup/url';
  import { themeDetect } from 'popup/mixins/theme';
  import { Themes } from 'config/theme';
  import { cacheStore }  from 'popup/store/cache';

  let isTestnet = $state(false);
  let mainnetChains = $state<IChainConfigState[]>([]);
  let testnetChains = $state<IChainConfigState[]>([]);

  let currentTheme = $state(
    $globalStore.appearances === Themes.System
      ? themeDetect()
      : $globalStore.appearances,
  );

  function generateTags(chain: IChainConfigState, isTestnetMode: boolean): string[] {
    const tags: string[] = [];

    if (chain.chainIds) {
      tags.push(`ID: ${chain.chainIds[0]}`);
    }

    if (isTestnetMode) {
      tags.push('testnet');
    } else {
      tags.push('mainnet');
    }

    return tags;
  }

  async function loadChains() {
    const chains = await getChains();
    mainnetChains = chains.mainnet || [];
    testnetChains = chains.testnet || [];
  }

  function next(chain: IChainConfigState) {
    cacheStore.set({
      ...$cacheStore,
      chain,
    });
    push("/password-setup");
  }

  $effect(() => {
    if (!$cacheStore.keyPair && !$cacheStore.verifyPhrase) {
      return push("/start");
    }

    loadChains();
  });

  $effect(() => {
    const newTheme = $globalStore.appearances;
    currentTheme = newTheme === Themes.System ? themeDetect() : newTheme;
  });
</script>

<div class="page-container network-setup">
  <NavBar
    title={$_('networkSetup.title')}
    onBack={pop}
  />

  <div class="controls">
    <Switch
      bind:checked={isTestnet}
      ariaLabel="Mainnet"
      name="testnet"
    />
  </div>

  <div class="network-list">
    {#each (isTestnet ? testnetChains : mainnetChains) as chain}
      <WalletOption
        title={chain.name}
        description={chain.chain}
        icon={viewChain({ network: chain, theme: currentTheme })}
        tags={generateTags(chain, isTestnet)}
        disabled={false}
        onclick={() => next(chain)}
      />
    {/each}
  </div>
</div>

<style lang="scss">
  .network-setup {
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: var(--background-color);
    padding: 0 20px 20px;
  }

  .controls {
    margin: 0 0 16px;
    display: flex;
    justify-content: flex-end;
  }

  .network-list {
    flex: 1;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  @media (max-width: 480px) {
    .network-setup {
      padding: 0 16px 20px;
    }
  }
</style>

```

`zil-pay/popup/pages/NewWalletOptions.svelte`:

```svelte
<script lang="ts">
  import { _ } from 'popup/i18n';
  import { pop, push } from 'popup/router/navigation';
  import NavBar from '../components/NavBar.svelte';
  import WalletOption from '../components/WalletOption.svelte';

  type WalletOptionType = {
    id: string;
    titleKey: string;
    descriptionKey: string;
    icon: string;
    disabled: boolean;
    action: () => void;
  };

  const mainOptions: WalletOptionType[] = [
    {
      id: 'new-wallet',
      titleKey: 'newWalletOptions.newWallet.title',
      descriptionKey: 'newWalletOptions.newWallet.description',
      icon: '+',
      disabled: false,
      action: () => handleNewWallet()
    },
    {
      id: 'existing-wallet',
      titleKey: 'newWalletOptions.existingWallet.title',
      descriptionKey: 'newWalletOptions.existingWallet.description',
      icon: '↑',
      disabled: false,
      action: () => handleExistingWallet()
    },
    {
      id: 'pair-ledger',
      titleKey: 'newWalletOptions.pairWithLedger.title',
      descriptionKey: 'newWalletOptions.pairWithLedger.description',
      icon: '⊞',
      disabled: true,
      action: () => handlePairLedger()
    }
  ];

  const otherOptions: WalletOptionType[] = [
    {
      id: 'watch-account',
      titleKey: 'newWalletOptions.watchAccount.title',
      descriptionKey: 'newWalletOptions.watchAccount.description',
      icon: '👁',
      disabled: true,
      action: () => handleWatchAccount()
    }
  ];

  function handleNewWallet() {
    push('/generate-wallet');
  }

  function handleExistingWallet() {
    push('/restore-wallet');
  }

  function handlePairLedger() {
    push('/new-wallet/ledger');
  }

  function handleWatchAccount() {
    push('/new-wallet/watch');
  }
</script>

<div class="page-container new-wallet-options">
  <NavBar title={$_('newWalletOptions.title')} onBack={pop} />

  <div class="options-container">
    <div class="main-options">
      {#each mainOptions as option}
        <WalletOption
          title={$_(option.titleKey)}
          description={$_(option.descriptionKey)}
          icon={option.icon}
            disabled={option.disabled}
          onclick={option.action}
        />
      {/each}
    </div>

    <div class="other-section">
      <h4 class="section-title">{$_('newWalletOptions.otherOptions')}</h4>
      <div class="other-options">
        {#each otherOptions as option}
          <WalletOption
            title={$_(option.titleKey)}
            description={$_(option.descriptionKey)}
            icon={option.icon}
            disabled={option.disabled}
            onclick={option.action}
          />
        {/each}
      </div>
    </div>
  </div>
</div>

<style lang="scss">
  .new-wallet-options {
    display: flex;
    flex-direction: column;
    height: 100vh;
    background-color: var(--background-color);
    padding: 0 20px 20px;
    box-sizing: border-box;
  }

  .options-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 32px;
    overflow-y: auto;
    padding: 8px 0;
  }

  .main-options {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .other-section {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .section-title {
    font-size: 14px;
    color: var(--text-secondary);
    font-weight: 500;
    margin: 0;
    opacity: 0.8;
  }

  .other-options {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
</style>

```

`zil-pay/popup/pages/NotFoundPage.svelte`:

```svelte
<script lang="ts">
</script>

<style>
    .not-found-container {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100vh;
        text-align: center;
        background-color: #f8f9fa;
        color: #343a40;
        font-family: Arial, sans-serif;
    }

    .not-found-container h1 {
        font-size: 6rem;
        margin: 0;
    }

    .not-found-container p {
        font-size: 1.25rem;
    }
</style>

<div class="not-found-container">
    <h1>404</h1>
    <p>Oops! The page you are looking for doesn't exist.</p>
</div>

```

`zil-pay/popup/pages/PasswordSetup.svelte`:

```svelte
<script lang="ts">
  import NavBar from '../components/NavBar.svelte';
  import Button from '../components/Button.svelte';
  import SmartInput from '../components/SmartInput.svelte';
  import LittleButton from '../components/LittleButton.svelte';
  import Modal from '../components/Modal.svelte';
  import { _ } from '../i18n';
  import { pop, push } from '../router/navigation';
  import { cacheStore } from '../store/cache';

  let password = $state('');
  let confirmPassword = $state('');
  let passwordStrength = $state(0);
  let isValid = $state(false);
  let errors = $state<string[]>([]);
  let showAdvancedModal = $state(false);

  const strengthLabels = [
    'passwordSetup.strength.veryWeak',
    'passwordSetup.strength.weak', 
    'passwordSetup.strength.fair',
    'passwordSetup.strength.good',
    'passwordSetup.strength.strong'
  ];

  const strengthColors = [
    'var(--danger-color)',
    'var(--warning-color)', 
    'var(--warning-color)',
    'var(--success-color)',
    'var(--success-color)'
  ];

  function calculatePasswordStrength(pwd: string): number {
    if (!pwd) return 0;
    
    let score = 0;
    
    if (pwd.length >= 8) score++;
    if (pwd.length >= 12) score++;
    if (/[a-z]/.test(pwd)) score++;
    if (/[A-Z]/.test(pwd)) score++;
    if (/[0-9]/.test(pwd)) score++;
    if (/[^A-Za-z0-9]/.test(pwd)) score++;
    
    return Math.min(Math.floor(score / 1.2), 4);
  }

  function validatePassword(): string[] {
    const validationErrors: string[] = [];
    
    if (password.length < 8) {
      validationErrors.push($_('passwordSetup.errors.minLength'));
    }
    
    if (!/[a-z]/.test(password)) {
      validationErrors.push($_('passwordSetup.errors.lowercase'));
    }
    
    if (!/[A-Z]/.test(password)) {
      validationErrors.push($_('passwordSetup.errors.uppercase'));
    }
    
    if (!/[0-9]/.test(password)) {
      validationErrors.push($_('passwordSetup.errors.number'));
    }
    
    if (password !== confirmPassword && confirmPassword.length > 0) {
      validationErrors.push($_('passwordSetup.errors.mismatch'));
    }
    
    return validationErrors;
  }

  function handlePasswordInput() {
    passwordStrength = calculatePasswordStrength(password);
    updateValidation();
  }

  function handleConfirmPasswordInput() {
    updateValidation();
  }

  function updateValidation() {
    errors = validatePassword();
    isValid = errors.length === 0 && password.length > 0 && confirmPassword.length > 0;
  }

  async function handleCreateWallet() {
    if (!isValid) return;
    
    try {
      push('/');
    } catch (error) {
      console.error('Error creating wallet:', error);
    }
  }

  function handleAdvancedSettings() {
    showAdvancedModal = true;
  }

  function handleModalClose() {
    showAdvancedModal = false;
    console.log('Advanced settings modal closed');
  }

  function handleSaveAdvanced() {
    console.log('Advanced settings saved');
    showAdvancedModal = false;
  }

  $effect(() => {
    if (!$cacheStore.chain || (!$cacheStore.keyPair && !$cacheStore.verifyPhrase)) {
      
    }
  });
</script>

<div class="page-container password-setup">
  <NavBar title={$_('passwordSetup.title')} onBack={pop} />

  <div class="content">
    <div class="intro-section">
      <h2 class="subtitle">{$_('passwordSetup.subtitle')}</h2>
      <p class="description">{$_('passwordSetup.description')}</p>
    </div>

    <div class="form-section">
      <SmartInput
        id="password"
        label={$_('passwordSetup.passwordLabel')}
        placeholder={$_('passwordSetup.passwordPlaceholder')}
        bind:value={password}
        onInput={handlePasswordInput}
        required
        hasError={password.length > 0 && passwordStrength < 2}
        ariaDescribedBy="password-strength"
      />

      {#if password.length > 0}
        <div id="password-strength" class="strength-indicator">
          <div class="strength-label">
            {$_('passwordSetup.strength.label')}: 
            <span 
              class="strength-text"
              style="color: {strengthColors[passwordStrength]}"
            >
              {$_(strengthLabels[passwordStrength])}
            </span>
          </div>
          <div class="strength-bar">
            {#each Array(5) as _, index}
              <div 
                class="strength-segment"
                class:active={index <= passwordStrength}
                style="background-color: {index <= passwordStrength ? strengthColors[passwordStrength] : 'var(--card-background)'}"
              ></div>
            {/each}
          </div>
        </div>
      {/if}

      <SmartInput
        id="confirm-password"
        label={$_('passwordSetup.confirmLabel')}
        placeholder={$_('passwordSetup.confirmPlaceholder')}
        bind:value={confirmPassword}
        onInput={handleConfirmPasswordInput}
        required
        hasError={confirmPassword.length > 0 && password !== confirmPassword}
        errorMessage={confirmPassword.length > 0 && password !== confirmPassword ? $_('passwordSetup.errors.mismatch') : ''}
      />

      {#if errors.length > 0}
        <div class="error-section">
          <div class="error-title">{$_('passwordSetup.requirements')}</div>
          <ul class="error-list">
            {#each errors as error}
              <li class="error-item">{error}</li>
            {/each}
          </ul>
        </div>
      {/if}
    </div>

    <div class="actions-section">
      <div class="advanced-section">
        <LittleButton onclick={handleAdvancedSettings}>
          {$_('passwordSetup.advanced')}
        </LittleButton>
      </div>

      <div class="security-note">
        <div class="note-icon">🔒</div>
        <p class="note-text">{$_('passwordSetup.securityNote')}</p>
      </div>

      <Button 
        disabled={!isValid} 
        onclick={handleCreateWallet}
        width="100%"
      >
        {$_('passwordSetup.createButton')}
      </Button>
    </div>
  </div>
</div>

<!-- Advanced Settings Modal -->
<Modal 
  bind:show={showAdvancedModal}
  title="Advanced Settings"
  onClose={handleModalClose}
  width="600px"
  closeOnOverlay={true}
>
  {#snippet children()}
    <div class="advanced-modal-content">
      <div class="setting-group">
        <h3 class="setting-title">Security Options</h3>
        <p class="setting-description">
          Configure additional security features for your wallet.
        </p>
        
        <div class="setting-item">
          <label class="setting-label">
            <input type="checkbox" class="setting-checkbox" />
            <span>Enable biometric authentication</span>
          </label>
          <p class="setting-help">Use fingerprint or face recognition to unlock your wallet</p>
        </div>

        <div class="setting-item">
          <label class="setting-label">
            <input type="checkbox" class="setting-checkbox" checked />
            <span>Auto-lock after inactivity</span>
          </label>
          <p class="setting-help">Automatically lock wallet after 5 minutes of inactivity</p>
        </div>
      </div>

      <div class="setting-group">
        <h3 class="setting-title">Backup Options</h3>
        <p class="setting-description">
          Choose how you want to backup your wallet data.
        </p>
        
        <div class="setting-item">
          <label class="setting-label">
            <input type="radio" name="backup" class="setting-radio" checked />
            <span>Cloud backup (encrypted)</span>
          </label>
          <p class="setting-help">Store encrypted backup in your cloud storage</p>
        </div>

        <div class="setting-item">
          <label class="setting-label">
            <input type="radio" name="backup" class="setting-radio" />
            <span>Local backup only</span>
          </label>
          <p class="setting-help">Keep backup files only on this device</p>
        </div>
      </div>

      <div class="modal-actions">
        <Button onclick={() => showAdvancedModal = false} width="auto">
          Cancel
        </Button>
        <Button onclick={handleSaveAdvanced} width="auto">
          Save Settings
        </Button>
      </div>
    </div>
  {/snippet}
</Modal>

<style lang="scss">
  .password-setup {
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: var(--background-color);
    color: var(--text-primary);
  }

  .content {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
    overflow-y: auto;
    padding-bottom: 16px;
  }

  .intro-section {
    text-align: center;
    padding: 4px 0 12px;
    flex-shrink: 0;
  }

  .subtitle {
    font-size: var(--font-size-large);
    font-weight: 600;
    color: var(--text-primary);
    margin: 0 0 6px 0;
    line-height: 1.2;
  }

  .description {
    font-size: var(--font-size-small);
    color: var(--text-secondary);
    margin: 0;
    line-height: 1.3;
    opacity: 0.9;
  }

  .form-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 14px;
    min-height: 0;
    margin-bottom: 16px;
  }

  .strength-indicator {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .strength-label {
    font-size: var(--font-size-small);
    color: var(--text-secondary);
  }

  .strength-text {
    font-weight: 600;
  }

  .strength-bar {
    display: flex;
    gap: 3px;
    height: 3px;
  }

  .strength-segment {
    flex: 1;
    border-radius: 2px;
    transition: background-color 0.3s ease;
  }

  .error-section {
    padding: 12px;
    background-color: color-mix(in srgb, var(--danger-color) 10%, var(--card-background));
    border: 1px solid var(--danger-color);
    border-radius: 10px;
  }

  .error-title {
    font-size: var(--font-size-small);
    font-weight: 600;
    color: var(--danger-color);
    margin-bottom: 6px;
  }

  .error-list {
    list-style: none;
    margin: 0;
    padding: 0;
  }

  .error-item {
    font-size: calc(var(--font-size-small) * 0.9);
    color: var(--danger-color);
    margin-bottom: 3px;
    position: relative;
    padding-left: 12px;

    &::before {
      content: '•';
      position: absolute;
      left: 0;
      color: var(--danger-color);
    }

    &:last-child {
      margin-bottom: 0;
    }
  }

  .actions-section {
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .advanced-section {
    display: flex;
    justify-content: center;
    padding: 4px 0;
  }

  .security-note {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    padding: 12px;
    background: color-mix(in srgb, var(--primary-purple) 8%, var(--card-background));
    border-radius: 10px;
    border: 1px solid color-mix(in srgb, var(--primary-purple) 20%, transparent);
  }

  .note-icon {
    font-size: var(--font-size-medium);
    flex-shrink: 0;
    line-height: 1;
  }

  .note-text {
    font-size: calc(var(--font-size-small) * 0.9);
    color: var(--text-secondary);
    line-height: 1.3;
    margin: 0;
  }

  /* Modal Content Styles */
  .advanced-modal-content {
    display: flex;
    flex-direction: column;
    gap: 24px;
  }

  .setting-group {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .setting-title {
    font-size: var(--font-size-large);
    font-weight: 600;
    color: var(--text-primary);
    margin: 0;
  }

  .setting-description {
    font-size: var(--font-size-medium);
    color: var(--text-secondary);
    margin: 0;
    line-height: 1.4;
  }

  .setting-item {
    display: flex;
    flex-direction: column;
    gap: 6px;
    padding: 12px;
    background: var(--background-color);
    border-radius: 10px;
    border: 1px solid color-mix(in srgb, var(--text-secondary) 15%, transparent);
  }

  .setting-label {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    font-size: var(--font-size-medium);
    font-weight: 500;
    color: var(--text-primary);
  }

  .setting-checkbox,
  .setting-radio {
    width: 16px;
    height: 16px;
    accent-color: var(--primary-purple);
    cursor: pointer;
  }

  .setting-help {
    font-size: var(--font-size-small);
    color: var(--text-secondary);
    margin: 0;
    line-height: 1.3;
    padding-left: 26px;
  }

  .modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 12px;
    padding-top: 16px;
    border-top: 1px solid color-mix(in srgb, var(--text-secondary) 15%, transparent);
  }

  @media (max-width: 480px) {
    .content {
      padding-bottom: 12px;
    }

    .intro-section {
      padding: 2px 0 8px;
    }

    .subtitle {
      font-size: var(--font-size-medium);
      margin-bottom: 4px;
    }

    .description {
      font-size: calc(var(--font-size-small) * 0.9);
    }

    .form-section {
      gap: 12px;
      margin-bottom: 12px;
    }

    .actions-section {
      gap: 10px;
    }

    .security-note {
      padding: 10px;
      gap: 8px;
    }

    .note-text {
      font-size: calc(var(--font-size-small) * 0.85);
    }

    .advanced-modal-content {
      gap: 20px;
    }

    .setting-group {
      gap: 12px;
    }

    .modal-actions {
      flex-direction: column;
      gap: 8px;
    }
  }

  @media (max-width: 360px) {
    .form-section {
      gap: 10px;
    }

    .actions-section {
      gap: 8px;
    }

    .advanced-modal-content {
      gap: 16px;
    }
  }
</style>

```

`zil-pay/popup/pages/RestoreWallet.svelte`:

```svelte
<script lang="ts">
  import { _ } from 'popup/i18n';
  import { pop, push } from 'popup/router/navigation';
  import NavBar from '../components/NavBar.svelte';
  import WalletOption from '../components/WalletOption.svelte';
  import PuzzleIcon from '../components/icons/PuzzleIcon.svelte';
  import BincodeIcon from '../components/icons/BincodeIcon.svelte';
  import QRCodeIcon from '../components/icons/QRCodeIcon.svelte';
  import Bip39Icon from '../components/icons/Bip39Icon.svelte';
  import LockIcon from '../components/icons/LockIcon.svelte';


  type RestoreOption = {
    id: string;
    titleKey: string;
    descriptionKey: string;
    icon: any;
    disabled: boolean;
    action: () => void;
  };

  const restoreOptions: RestoreOption[] = [
    {
      id: 'bip39',
      titleKey: 'restoreWallet.bip39.title',
      descriptionKey: 'restoreWallet.bip39.description',
      icon: Bip39Icon,
      disabled: false,
      action: () => handleBip39()
    },
    {
      id: 'private-key',
      titleKey: 'restoreWallet.privateKey.title',
      descriptionKey: 'restoreWallet.privateKey.description',
      icon: LockIcon,
      disabled: false,
      action: () => handlePrivateKey()
    },
    {
      id: 'slip0039',
      titleKey: 'restoreWallet.slip0039.title',
      descriptionKey: 'restoreWallet.slip0039.description',
      icon: PuzzleIcon,
      disabled: true,
      action: () => handleSlip0039()
    },
    {
      id: 'keystore-file',
      titleKey: 'restoreWallet.keystoreFile.title',
      descriptionKey: 'restoreWallet.keystoreFile.description',
      icon: BincodeIcon,
      disabled: true,
      action: () => handleKeystoreFile()
    },
    {
      id: 'qrcode',
      titleKey: 'restoreWallet.qrcode.title',
      descriptionKey: 'restoreWallet.qrcode.description',
      icon: QRCodeIcon,
      disabled: true,
      action: () => handleQRCode()
    }
  ];

  function handleBip39() {
    push('/restore-bip39');
  }

  function handleSlip0039() {
    push('/restore-wallet/slip0039');
  }

  function handlePrivateKey() {
    push('/restore-private-key');
  }

  function handleKeystoreFile() {
    push('/restore-wallet/keystore');
  }

  function handleQRCode() {
    push('/restore-wallet/qrcode');
  }
</script>

<div class="page-container restore-wallet">
  <NavBar title={$_('restoreWallet.title')} onBack={pop} />
  
  <div class="options-container">
    <div class="restore-options">
      {#each restoreOptions as option}
        <WalletOption
          title={$_(option.titleKey)}
          description={$_(option.descriptionKey)}
          icon={option.icon}
          disabled={option.disabled}
          onclick={() => option.action()}
        />
      {/each}
    </div>
  </div>
</div>

<style lang="scss">
  .restore-wallet {
    display: flex;
    flex-direction: column;
    height: 100vh;
    background-color: var(--background-color);
    padding: 0 20px 20px;
    box-sizing: border-box;
  }

  .options-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    padding: 8px 0;
  }

  .restore-options {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
</style>

```

`zil-pay/popup/pages/Start.svelte`:

```svelte
<script lang="ts">
    import { _ }	 from 'popup/i18n';
    import { push } from 'popup/router/navigation';

    import globalStore from "popup/store/global";

    import SvgLoad from '../components/SvgLoad.svelte';
    import LanguageIcon from '../components/icons/Language.svelte';
    import AppearanceIcon from '../components/icons/Appearance.svelte';
    import Button from '../components/Button.svelte';

    import { Themes } from 'config/theme';
    import { themeDetect } from 'popup/mixins/theme';
    import { setGlobalState } from 'popup/background/wallet';


    function handleGetStarted() {
        return push('/new-wallet-options');
    }

    async function handleThemeToggle() {
        if ($globalStore.appearances == Themes.System) {
            const theme = themeDetect();

            if (theme == Themes.Light) {
                globalStore.set({
                    ...$globalStore,
                    appearances: Themes.Dark,
                });
            } else if (theme == Themes.Dark) {
                globalStore.set({
                    ...$globalStore,
                    appearances: Themes.Light,
                });
            }
        } else if ($globalStore.appearances == Themes.Light) {
            globalStore.set({
                ...$globalStore,
                appearances: Themes.Dark,
            });
        } else if ($globalStore.appearances == Themes.Dark) {
            globalStore.set({
                ...$globalStore,
                appearances: Themes.Light,
            });
        }

        document.body.setAttribute("theme", $globalStore.appearances);

        await setGlobalState();
    }

    function handleLanguageSelect() {
        return push('/locale');
    }
</script>

<div class="start-page">
    <div class="header">
        <button class="theme-toggle" on:click={handleThemeToggle}>
            <AppearanceIcon width={28} height={28} />
        </button>
        <button class="language-selector" on:click={handleLanguageSelect}>
            <LanguageIcon width={36} height={36} />
        </button>
    </div>
    <div class="content">
        <SvgLoad
            src="/icons/little_dragons.svg"
            class="dragon-image"
            width="90%"
            height="90%"
            viewBox="0 0 460 460"
        />
    </div>
    <Button onclick={handleGetStarted}>
        {$_('start.btn')}
    </Button>
</div>

<style lang="scss">
    .start-page {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
        height: 100vh;
        max-width: 400px;
        margin: 0 auto;
        background-color: var(--background-color);
        color: var(--text-primary);
        padding: 0 20px;
        box-sizing: border-box;
        padding-bottom: 16px;
    }

    .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        padding: 20px 0;
    }

    .theme-toggle {
        padding: 4px;
    }

    .theme-toggle,
    .language-selector {
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid var(--modal-border);
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
    }

    .theme-toggle:hover,
    .language-selector:hover {
        background: rgba(255, 255, 255, 0.2);
        box-shadow: 0 4px 12px rgba(255, 255, 255, 0.1);
    }

    .content {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
    }
</style>

```

`zil-pay/popup/router/guard.ts`:

```ts
import { get } from "svelte/store";
import globalStore from "popup/store/global";
import { type Route } from "./index";
import StartPage from "../pages/Start.svelte";
import LockPage from "../pages/Lock.svelte";
import ConnectPage from "../pages/Connect.svelte";
import ConfirmPopupPage from "../pages/ConfirmPopup.svelte";
import SignMessagePopupPage from "../pages/SignMessagePopup.svelte";

export class RouteGuard {
  private static navigate(path: string) {
    window.location.hash = path;
  }

  static checkRoute(route: Route): Route {
    if (!route.isProtected) {
      return route;
    }

    const globalState = get(globalStore);

    if (globalState.wallets.length == 0) {
      this.navigate("/start");

      return { path: "/start", component: StartPage };
    }

    const wallet = globalState.wallets[globalState.selected_wallet]; 

    if (globalState.selected_wallet == -1 || !wallet) {
      this.navigate("lock");
      return {
        path: "/lock",
        component: LockPage,
      };
    }


    if (wallet.confirm.length != 0) {
      // detect if really conect
      this.navigate("connect");
      return {
        path: "/connect",
        component: ConnectPage,
      };
    }

    if (wallet.confirm.length != 0) {
      // detect if really confirm
      this.navigate("confirm");
      return {
        path: "/confirm",
        component: ConfirmPopupPage,
      };
    }

    if (wallet.confirm.length != 0) {
      // detect if really sign-message
      this.navigate("sign-message");
      return {
        path: "/sign-message",
        component: SignMessagePopupPage,
      };
    }

    return route;
  }
}

```

`zil-pay/popup/router/index.ts`:

```ts
import type { Component } from "svelte";
import NotFoundPage from "../pages/NotFoundPage.svelte";
import HomePage from "../pages/Home.svelte";
import LockPage from "../pages/Lock.svelte";
import StartPage from "../pages/Start.svelte";
import ConnectPage from "../pages/Connect.svelte";
import ConfirmPopupPage from "../pages/ConfirmPopup.svelte";
import SignMessagePopupPage from "../pages/SignMessagePopup.svelte";
import LocalePage from "../pages/Locale.svelte";
import NewWalletOptionsPage from "../pages/NewWalletOptions.svelte";
import GenerateWalletPage from "../pages/GenerateWallet.svelte";
import RestoreWalletPage from "../pages/RestoreWallet.svelte";
import Bip39GeneratePage from "../pages/Bip39Generate.svelte";
import Bip39VerifyPage from "../pages/Bip39Verify.svelte";
import KeyPairGenPage from "../pages/KeyPairGen.svelte";
import Bip39RestorePage from "../pages/Bip39Restore.svelte"; 
import KeyPairRestorePage from "../pages/KeyPairRestore.svelte";
import NetworkSetupPage from '../pages/NetworkSetup.svelte';
import PasswordSetupPage from '../pages/PasswordSetup.svelte';


export type ParamsRecord = Record<string, string | null>;
export interface Route {
  path: string;
  component: Component;
  isProtected?: boolean;
}

export const notFoundRoute: Route = {
  path: "*",
  component: NotFoundPage,
};

export const protectedRoutes: Route[] = [
  { path: "/", component: HomePage, isProtected: true },
  { path: "/connect", component: ConnectPage, isProtected: true },
  { path: "/confirm", component: ConfirmPopupPage, isProtected: true },
  { path: "/sign-message", component: SignMessagePopupPage, isProtected: true },
];

export const publicRoutes: Route[] = [
  { path: "/lock", component: LockPage },
  { path: "/start", component: StartPage },
  { path: "/locale", component: LocalePage },
  { path: "/new-wallet-options", component: NewWalletOptionsPage },
  { path: "/generate-wallet", component: GenerateWalletPage },
  { path: "/restore-wallet", component: RestoreWalletPage },
  { path: "/restore-bip39", component: Bip39RestorePage },
  { path: "/generate-bip39", component: Bip39GeneratePage },
  { path: "/verify-bip39", component: Bip39VerifyPage },
  { path: "/keypair-generate", component: KeyPairGenPage },
  { path: "/restore-private-key", component: KeyPairRestorePage },
  { path: "/network-setup", component: NetworkSetupPage },
  { path: "/password-setup", component: PasswordSetupPage },
];

export const routes = [...protectedRoutes, ...publicRoutes];

export function matchRoute(url: string, routes: Route[]): Route | null {
  const urlParts = url.split("/").filter(Boolean);

  for (const route of routes) {
    const routeParts = route.path.split("/").filter(Boolean);

    if (!isMatchingLength(routeParts, urlParts)) {
      continue;
    }

    let isMatch = true;

    for (let i = 0; i < routeParts.length; i++) {
      const routePart = routeParts[i];
      const urlPart = urlParts[i];

      if (routePart.startsWith(":")) {
        const isOptional = routePart.endsWith("?");
        if (!urlPart && !isOptional) {
          isMatch = false;
          break;
        }
        continue;
      }

      if (routePart !== urlPart) {
        isMatch = false;
        break;
      }
    }

    if (isMatch) {
      return route;
    }
  }

  return null;
}

export function parseUrlParams(pattern: string, url: string): ParamsRecord {
  const params: ParamsRecord = {};
  const patternParts: string[] = pattern.split("/").filter(Boolean);
  const urlParts: string[] = url.split("/").filter(Boolean);

  for (let i = 0; i < patternParts.length; i++) {
    const patternPart = patternParts[i];

    if (!patternPart.startsWith(":")) {
      continue;
    }

    let paramName = patternPart.slice(1);
    const isOptional = paramName.endsWith("?");

    if (isOptional) {
      paramName = paramName.slice(0, -1);
    }

    const value = urlParts[i];
    params[paramName] = value || null;
  }

  return params;
}

function isMatchingLength(routeParts: string[], urlParts: string[]): boolean {
  const optionalParams = routeParts.filter((part) => part.endsWith("?")).length;
  return (
    urlParts.length >= routeParts.length - optionalParams &&
    urlParts.length <= routeParts.length
  );
}

```

`zil-pay/popup/router/navigation.ts`:

```ts
import { get } from "svelte/store";
import { currentRoute } from "popup/store/route";

export function getCurrentRoute(): string {
  let rote = get(currentRoute);

  return rote?.path || "";
}

export function push(path: string) {
  window.location.hash = path;
}

export function replace(path: string) {
  const normalizedPath = path.startsWith("/") ? path : `/${path}`;
  const targetHash = `#${normalizedPath}`;

  if (window.location.hash !== targetHash) {
    window.location.replace(targetHash);
  }
}

export function pop() {
  window.history.back();
}

export function route(node: HTMLAnchorElement) {
  const handleClick = (event: Event) => {
    event.preventDefault();
    const path = new URL(node.href).pathname;
    push(path);

    const navigationEvent = new CustomEvent("navigation", {
      detail: { href: path },
    });
    window.dispatchEvent(navigationEvent);
  };

  node.addEventListener("click", handleClick);

  return {
    destroy() {
      node.removeEventListener("click", handleClick);
    },
  };
}

```

`zil-pay/popup/store/cache.ts`:

```ts
import type { IChainConfigState } from 'background/storage';
import type { IKeyPair } from 'types/wallet';
import { writable } from 'svelte/store';

export interface ICache {
  verifyPhrase?: string[];
  keyPair?: IKeyPair;
  chain?: IChainConfigState;
}

export const cacheStore = writable<ICache>({});

```

`zil-pay/popup/store/global.ts`:

```ts
import type { IBackgroundState } from "background/storage";
import { Locales } from "config/locale";
import { Themes } from "config/theme";
import { writable } from "svelte/store";


export default writable<IBackgroundState>({
  storageVersion: 4,
  wallets: [],
  selected_wallet: -1,
  notificationsGlobalEnabled: true,
  locale: Locales.Auto,
  appearances: Themes.System,
  abbreviatedNumber: true,
  hideBalance: false,
  chains: [] 
});


```

`zil-pay/popup/store/route.ts`:

```ts
import type { ParamsRecord, Route } from "popup/router";
import { writable } from "svelte/store";

export const currentRoute = writable<Route | null>(null);
export const currentParams = writable<ParamsRecord>({});

```

`zil-pay/popup/styles/global.scss`:

```scss
@use "./mixins";
@use "./theme.scss";

:global(*),
:global(*::after),
:global(*::before) {
  @include mixins.box-sizing(border-box);
  margin: 0;
  padding: 0;
}

:global(:root) {
  font-family: var(--font-family, system-ui, sans-serif);
  font-size: 16px;
  line-height: 1.5;
  color: var(--text-primary);
  
  /* Smooth scrolling for supported browsers */
  scroll-behavior: smooth;
}

:global(*) {
  user-select: none;
  scrollbar-width: none;
  -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
}

/* Specifically handle focus outlines for accessibility */
:global(*:focus) {
  outline-offset: 2px;
}

:global(*:focus:not(:focus-visible)) {
  outline: none; /* Remove outline for mouse users but keep for keyboard */
}

/* Document body */
:global(body),
:global(html) {
  margin: 0;
  padding: 0;
  text-rendering: optimizeLegibility;
  font-kerning: normal;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  
  min-width: 320px;
  min-height: 600px;
  
  background-color: var(--background-color);
  
  /* Prevent overscrolling on iOS */
  overscroll-behavior: none;
}


/* Images */
:global(img) {
  max-width: 100%;
  height: auto;
  display: block;
}

/* Hide scrollbars but allow scrolling */
:global(::-webkit-scrollbar) {
  display: none;
}

:global(.page-container) {
  width: 100%;
  max-width: var(--max-content-width);
  margin: 0 auto;
  padding: 0 var(--padding-side, 20px);
  box-sizing: border-box;
}

```

`zil-pay/popup/styles/mixins.scss`:

```scss
@mixin box-sizing($box-model) {
  box-sizing: $box-model;
}

```

`zil-pay/popup/styles/theme.scss`:

```scss
:global(:root) {
  --font-size-base: 12px;
  --font-size-small: calc(var(--font-size-base) * 0.85);  // ~10px
  --font-size-medium: var(--font-size-base);              // 12px
  --font-size-large: calc(var(--font-size-base) * 1.15);  // ~14px
  --font-size-xl: calc(var(--font-size-base) * 1.4);      // ~17px

  --max-content-width: 360px;
  --padding-side: 16px;

  @media (min-width: 480px) {
    --max-content-width: 480px;
    --padding-side: 20px;
    --font-size-base: 13px;  // ~11px, 13px, ~15px, ~18px
  }

  @media (min-width: 768px) {
    --max-content-width: 600px;
    --padding-side: 24px;
    --font-size-base: 14px;  // ~12px, 14px, ~16px, ~20px
  }
}

:global(:root) {
  --primary-purple: #fc72ff;
  --secondary-purple: #b0b0b0;
  --background-color: #ffffff;
  --card-background: #f7f7f7;
  --text-primary: #000000;
  --text-secondary: #6c6c6c;
  --button-background: #ff007a;
  --button-text: #ffffff;
  --danger-color: #ff4d4d;
  --success-color: #00d395;
  --warning-color: #ffa500;
  --gradient-start: #ff007a;
  --gradient-middle: #d500f9;
  --gradient-end: #ff007a;
  --modal-border: #e0e0e0;
  --background-gradient: linear-gradient(180deg, #ff007a 0%, #d500f9 50%, #ff007a 100%);
}

:global(body[theme="dark"]) {
  --primary-purple: #8a2be2;
  --secondary-purple: #b23aee;
  --background-color: #000000;
  --card-background: #0d1117;
  --text-primary: #ffffff;
  --text-secondary: #b3b3b3;
  --button-background: #ff37c7;
  --button-text: #fff;
  --danger-color: #e94560;
  --success-color: #4caf50;
  --warning-color: #ff9800;
  --gradient-start: #4a0e4e;
  --gradient-middle: #220a23;
  --gradient-end: #000000;
  --modal-border: rgba(158, 158, 158, 0.2);
  --background-gradient: linear-gradient(180deg, #4a0e4e 0%, #220a23 50%, #000000 100%);
}

```

`zil-pay/types/micro-eth-signer.d.ts`:

```ts
declare module "micro-eth-signer/abi.js" {
  export * from "micro-eth-signer/abi";
}

```

`zil-pay/types/tx.d.ts`:

```ts
export interface MinScillaParams {
  chainId?: number;
  nonce?: string | number;
  gasPrice?: string | number;
  gasLimit?: string | number;
  priority?: boolean;
  code?: string;
  data?: string;
  toAddr: string;
  amount: string;
}

export interface TokenTransferMetadata {
  decimals: number;
  symbol: string;
  name: string;
  to: string;
}

export interface TransactionRequestEVM {
  nonce?: number;
  from?: string;
  to?: string;
  value?: string;
  gasLimit?: number;
  data?: string;
  maxFeePerGas?: string;
  maxPriorityFeePerGas?: string;
  gasPrice?: string;
  chainId?: number;
  accessList?: AccessListItem[];
  blobVersionedHashes?: string[];
  maxFeePerBlobGas?: string;
}

export interface AccessListItem {
  address: string;
  storageKeys: string[];
}

```

`zil-pay/types/wallet.d.ts`:

```ts
export interface SetPasswordPayload {
  cipherOrders: CipherOrders[];
  walletIndex: number;
  hashSettings: RequiredHashSettings;
  currentPassword: string;
  newPassword: string;
}

export interface WalletFromPrivateKeyParams {
  key: string;
  walletName: string;
  accountName: string;
  hashSettings: RequiredHashSettings;
  chainHash: number;
  password: string;
  settings: IWalletSettingsState;
}

export interface IKeyPair {
  address: string;
  privateKey: string;
  publicKey: string;
  slip44: number;
};

```

`zil-pay/vitest.config.ts`:

```ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    setupFiles: '__tests__/setupTests.ts',
    include: ['__tests__/**/*.test.{ts,tsx}'],
  },
});

```