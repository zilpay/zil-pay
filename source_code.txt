Project Path: zil-pay

Source Tree:

```txt
zil-pay
├── __tests__
│   ├── array
│   │   └── array.test.ts
│   ├── crypto
│   │   ├── address.test.ts
│   │   ├── aes256.test.ts
│   │   ├── argon2.test.ts
│   │   ├── b64.test.ts
│   │   ├── bip32.test.ts
│   │   ├── bip39.test.ts
│   │   ├── bip49.test.ts
│   │   ├── keychain.test.ts
│   │   ├── keypair.test.ts
│   │   ├── kuznechik.test.ts
│   │   ├── ntrup.test.ts
│   │   ├── number.test.ts
│   │   ├── pbkdf2.test.ts
│   │   ├── pubkey.test.ts
│   │   ├── random.test.ts
│   │   ├── schnorr.test.ts
│   │   ├── sha256.test.ts
│   │   ├── sha512.test.ts
│   │   ├── tx.test.ts
│   │   ├── word_list.ts
│   │   └── zilliqa_tx.test.ts
│   ├── data.ts
│   ├── popup
│   │   └── url.test.ts
│   ├── rpc
│   │   ├── ft_parser.test.ts
│   │   ├── gas_parser.test.ts
│   │   ├── history_tx.test.ts
│   │   ├── nonce_parser.test.ts
│   │   ├── provider.test.ts
│   │   ├── rpc.test.ts
│   │   └── tx_parse.test.ts
│   ├── session
│   │   └── session.test.ts
│   ├── setupTests.ts
│   ├── state.test.ts
│   ├── storage
│   │   ├── migrator.test.ts
│   │   ├── storage.test.ts
│   │   └── wallet.test.ts
│   ├── stream
│   │   └── stream.test.ts
│   ├── types
│   │   └── checker.test.ts
│   ├── utils
│   │   ├── hex.test.ts
│   │   ├── locale.test.ts
│   │   └── utf8.test.ts
│   └── zilliqa
│       └── zil_address.test.ts
├── background
│   ├── background.ts
│   ├── index.ts
│   ├── rpc
│   │   ├── block.ts
│   │   ├── ft_parser.ts
│   │   ├── gas_parse.ts
│   │   ├── history_tx.ts
│   │   ├── index.ts
│   │   ├── nonce_parser.ts
│   │   ├── provider.ts
│   │   ├── rpc.ts
│   │   └── tx_parse.ts
│   ├── secure
│   │   ├── index.ts
│   │   ├── migrator.ts
│   │   └── session.ts
│   ├── services
│   │   ├── index.ts
│   │   ├── provider.ts
│   │   ├── tx.ts
│   │   └── wallet.ts
│   ├── state.ts
│   └── storage
│       ├── account.ts
│       ├── argon.ts
│       ├── background.ts
│       ├── chain.ts
│       ├── confirm.ts
│       ├── explorer.ts
│       ├── ftoken.ts
│       ├── index.ts
│       ├── notification.ts
│       ├── settings.ts
│       └── wallet.ts
├── config
│   ├── api.ts
│   ├── argon2.ts
│   ├── bip39.ts
│   ├── common.ts
│   ├── errors.ts
│   ├── fields.ts
│   ├── jsonrpc.ts
│   ├── locale.ts
│   ├── manifest.ts
│   ├── pbkdf2.ts
│   ├── sha.ts
│   ├── slip44.ts
│   ├── stream.ts
│   ├── theme.ts
│   └── wallet.ts
├── content
│   └── index.ts
├── crypto
│   ├── address.ts
│   ├── aes256.ts
│   ├── argon2.ts
│   ├── b64.ts
│   ├── bip32.ts
│   ├── bip39.ts
│   ├── bip49.ts
│   ├── index.ts
│   ├── keychain.ts
│   ├── keypair.ts
│   ├── kuznechik.ts
│   ├── ntrup.ts
│   ├── number.ts
│   ├── pbkdf2.ts
│   ├── proto
│   │   └── zq1.ts
│   ├── random.ts
│   ├── sha256.ts
│   ├── sha512.ts
│   ├── tx.ts
│   ├── uuid.ts
│   ├── zilliqa
│   │   ├── pubkey.ts
│   │   └── schnorr.ts
│   └── zilliqa_tx.ts
├── lib
│   ├── array
│   │   ├── chunk.ts
│   │   └── shuffle.ts
│   ├── popup
│   │   ├── clipboard.ts
│   │   ├── url.ts
│   │   └── warp-message.ts
│   ├── runtime
│   │   ├── assert.ts
│   │   ├── ext-id.ts
│   │   ├── extensionizer.ts
│   │   ├── fingerprint.ts
│   │   ├── get-url.ts
│   │   ├── index.ts
│   │   └── manifest.ts
│   ├── storage
│   │   ├── builder.ts
│   │   ├── index.ts
│   │   └── storage.ts
│   ├── streem
│   │   ├── index.ts
│   │   ├── keys.ts
│   │   ├── message.ts
│   │   ├── secure-message.ts
│   │   ├── tab-stream.ts
│   │   └── tabs-message.ts
│   ├── types
│   │   ├── checker.ts
│   │   └── index.ts
│   ├── utils
│   │   ├── hex.ts
│   │   ├── locale.ts
│   │   └── utf8.ts
│   └── zilliqa
│       ├── bech32.ts
│       ├── checksum.ts
│       ├── config.ts
│       ├── index.ts
│       └── pubkey.ts
├── popup
│   ├── background
│   │   └── wallet.ts
│   ├── i18n.ts
│   ├── index.ts
│   ├── main.ts
│   ├── mixins
│   │   ├── chains.ts
│   │   └── theme.ts
│   ├── router
│   │   ├── guard.ts
│   │   ├── index.ts
│   │   └── navigation.ts
│   └── store
│       ├── cache.ts
│       ├── global.ts
│       └── route.ts
├── types
│   ├── micro-eth-signer.d.ts
│   ├── tx.d.ts
│   └── wallet.d.ts
└── vitest.config.ts

```

`zil-pay/__tests__/array/array.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import { shuffle } from "../../lib/array/shuffle";
import { chunk } from "../../lib/array/chunk";

describe("shuffle", () => {
  it("should shuffle an array of numbers", () => {
    const array = [1, 2, 3, 4, 5];
    const shuffledArray = shuffle([...array]);

    expect(shuffledArray).toHaveLength(array.length);
    expect(shuffledArray).not.toEqual(array);
    expect(shuffledArray.sort()).toEqual(array.sort());
  });

  it("should shuffle an array of strings", () => {
    const array = ["a", "b", "c", "d", "e", "1", "3", "4", "5", "7", "u", "g"];
    const shuffledArray = shuffle([...array]);

    expect(shuffledArray).toHaveLength(array.length);
    expect(shuffledArray).not.toEqual(array);
    expect(shuffledArray.sort()).toEqual(array.sort());
  });

  it("should handle an empty array", () => {
    const array: number[] = [];
    const shuffledArray = shuffle([...array]);
    expect(shuffledArray).toEqual([]);
  });

  it("should handle an array with one element", () => {
    const array = [1];
    const shuffledArray = shuffle([...array]);
    expect(shuffledArray).toEqual([1]);
  });
});

describe("chunk", () => {
  it("should chunk an array into smaller arrays of the specified size", () => {
    const array = [1, 2, 3, 4, 5, 6, 7, 8];
    const chunkSize = 3;
    const result = chunk(array, chunkSize);
    expect(result).toEqual([
      [1, 2, 3],
      [4, 5, 6],
      [7, 8],
    ]);
  });

  it("should handle a chunk size larger than the array length", () => {
    const array = [1, 2, 3, 4, 5];
    const chunkSize = 10;
    const result = chunk(array, chunkSize);
    expect(result).toEqual([[1, 2, 3, 4, 5]]);
  });

  it("should handle an array with a length that is a multiple of the chunk size", () => {
    const array = [1, 2, 3, 4, 5, 6];
    const chunkSize = 2;
    const result = chunk(array, chunkSize);
    expect(result).toEqual([
      [1, 2],
      [3, 4],
      [5, 6],
    ]);
  });

  it("should handle an empty array", () => {
    const array: number[] = [];
    const chunkSize = 3;
    const result = chunk(array, chunkSize);
    expect(result).toEqual([]);
  });

  it("should throw an error if the chunk size is zero", () => {
    const array = [1, 2, 3, 4, 5];
    const chunkSize = 0;
    expect(() => chunk(array, chunkSize)).toThrowError(
      "Size must be a positive number.",
    );
  });

  it("should throw an error if the chunk size is negative", () => {
    const array = [1, 2, 3, 4, 5];
    const chunkSize = -1;
    expect(() => chunk(array, chunkSize)).toThrowError(
      "Size must be a positive number.",
    );
  });
});

```

`zil-pay/__tests__/crypto/address.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import { Address, AddressType } from "../../crypto/address";
import { KeyPair } from "../../crypto/keypair";
import { ZILLIQA, ETHEREUM } from "../../config/slip44";
import { toBech32Address } from "../../lib/zilliqa";
import { hexToUint8Array, uint8ArrayToHex } from "../../lib/utils/hex";

describe("Address", () => {
  const zilData = new Uint8Array(20).fill(1);
  const ethData = new Uint8Array(20).fill(2);

  const zilAddr = new Address(zilData, AddressType.Bech32);
  const ethAddr = new Address(ethData, AddressType.EthCheckSum);

  const knownPrivateKeyHex =
    "e93c035175b08613c4b0251ca92cd007026ca032ba53bafa3c839838f8b52d04";
  const privateKeyBytes = hexToUint8Array(knownPrivateKeyHex);

  it("should create addresses and hold correct bytes", () => {
    expect(zilAddr.bytes).toEqual(zilData);
    expect(ethAddr.bytes).toEqual(ethData);
  });

  it("should format ZIL address to bech32 string correctly", async () => {
    const expected = await toBech32Address(uint8ArrayToHex(zilData));
    expect(await zilAddr.toZilBech32()).toBe(expected);
  });

  it("should format ETH address to checksummed string correctly", async () => {
    const anotherValidAddress = "0x7793A8E8c09d189d4D421Ce5bC5B3674656c5Ac1";
    const ethAddrFromHex = Address.fromStr(anotherValidAddress);
    expect(await ethAddrFromHex.toEthChecksum()).toBe(anotherValidAddress);
  });

  it("should derive a ZIL address from a public key", async () => {
    const keyPair = await KeyPair.fromPrivateKey(privateKeyBytes, ZILLIQA);
    const derivedAddr = await Address.fromPubKey(keyPair.pubKey, ZILLIQA);
    const expectedAddr = "zil1a0vtxuxamd3kltmyzpqdyxqu25vsss8mp58jtu";

    expect(await derivedAddr.toZilBech32()).toBe(expectedAddr);
    expect(derivedAddr.type).toBe(AddressType.Bech32);
  });

  it("should derive an ETH address from a public key", async () => {
    const keyPair = await KeyPair.fromPrivateKey(privateKeyBytes, ETHEREUM);
    const derivedAddr = await Address.fromPubKey(keyPair.pubKey, ETHEREUM);
    const expectedAddr = "0xC315295101461753b838E0BE8688E744cf52Dd6b";

    expect(await derivedAddr.toEthChecksum()).toBe(expectedAddr);
    expect(derivedAddr.type).toBe(AddressType.EthCheckSum);
  });

  it("should create an ETH address from a valid hex string", async () => {
    const hexEthAddr = "0xf06686B5Eb5cAe38c09f12412B729045647E74e3";
    const addr = Address.fromStr(hexEthAddr);
    expect(addr.type).toBe(AddressType.EthCheckSum);
    expect(await addr.toEthChecksum()).toBe(hexEthAddr);
  });

  it("should create a ZIL address from a valid bech32 string", async () => {
    const bech32Addr = "zil1a0vtxuxamd3kltmyzpqdyxqu25vsss8mp58jtu";
    const addr = Address.fromStr(bech32Addr);
    expect(addr.type).toBe(AddressType.Bech32);
    expect(await addr.toZilBech32()).toBe(bech32Addr);
  });

  it("should throw an error for invalid address string formats", async () => {
    expect(() => Address.fromStr("invalid-address-string")).toThrow(
      "Unsupported address format",
    );
    expect(() => Address.fromStr("0x12345")).toThrow(
      "address must be 40-char hex, got 7-char 0x12345",
    );
  });

  it("should perform a roundtrip for ZIL address", async () => {
    const originalAddr = "zil1a0vtxuxamd3kltmyzpqdyxqu25vsss8mp58jtu";
    const addrObject = Address.fromStr(originalAddr);
    const finalAddr = await addrObject.toZilBech32();
    expect(finalAddr).toBe(originalAddr);
  });

  it("should perform a roundtrip for ETH address", async () => {
    const originalAddr = "0xf06686b5eb5cae38c09f12412b729045647e74e3";
    const expectedChecksumAddr = "0xf06686B5Eb5cAe38c09f12412B729045647E74e3";
    const addrObject = Address.fromStr(originalAddr);
    const finalAddr = await addrObject.toEthChecksum();
    expect(finalAddr).toBe(expectedChecksumAddr);
  });

  it("should derive correct addresses from specific public keys (Rust equivalent)", async () => {
    const pubKeyHex =
      "03150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da";
    const pubKeyBytes = Uint8Array.from(hexToUint8Array(pubKeyHex));

    // Test for Zilliqa
    const addrZil = await Address.fromPubKey(pubKeyBytes, ZILLIQA);
    const expectedAddrZil = "zil1a0vtxuxamd3kltmyzpqdyxqu25vsss8mp58jtu";
    expect(await addrZil.toZilBech32()).toBe(expectedAddrZil);

    // Test for Ethereum
    const addrEth = await Address.fromPubKey(pubKeyBytes, ETHEREUM);
    const expectedAddrEth = "0xC315295101461753b838E0BE8688E744cf52Dd6b";
    expect(await addrEth.toEthChecksum()).toBe(expectedAddrEth);
  });
});

```

`zil-pay/__tests__/crypto/aes256.test.ts`:

```ts
import { test, expect } from "vitest";
import { AESCipherV2, AESCipherV3, ErrorMessages } from "../../crypto/aes256";
import { sha256 } from "../../crypto/sha256";
import {
  IMPORTED_KEY,
  PASSWORD,
  STORAGE_V2,
  STORAGE_V3,
  WORDS,
  EXTENSION_ID,
} from "../data";
import { pbkdf2 } from "../../crypto/pbkdf2";
import { base64ToUint8Array } from "../../crypto/b64";
import { ShaAlgorithms } from "../../config/pbkdf2";
import { uint8ArrayToUtf8, utf8ToUint8Array } from "../../lib/utils/utf8";
import { uint8ArrayToHex } from "../../lib/utils/hex";

test("decrypt Storage v3 AES-v3", async () => {
  const salt = utf8ToUint8Array(EXTENSION_ID);
  const [algorithm, iteractions] = STORAGE_V3["guard-configuration"].split(":");
  const vaultBase64 = STORAGE_V3.vault;
  const vaultBytes = base64ToUint8Array(vaultBase64);
  const passwordBytes = utf8ToUint8Array(PASSWORD);
  const key = await pbkdf2(
    passwordBytes,
    salt,
    Number(iteractions),
    algorithm as ShaAlgorithms,
  );
  const key32 = await sha256(key);
  const decryptedBytes = AESCipherV3.decrypt(vaultBytes, key32);
  const decrypted = uint8ArrayToUtf8(decryptedBytes);

  expect(decrypted).toEqual(WORDS);
});

test("decrypt accounts Storage v3 AES-v3", async () => {
  const salt = utf8ToUint8Array(EXTENSION_ID);
  const [algorithm, iteractions] = STORAGE_V3["guard-configuration"].split(":");
  const passwordBytes = utf8ToUint8Array(PASSWORD);
  const key = await pbkdf2(
    passwordBytes,
    salt,
    Number(iteractions),
    algorithm as ShaAlgorithms,
  );
  const key32 = await sha256(key);
  const walletIdentities = JSON.parse(STORAGE_V3["wallet-identities"]);
  const importedAccount = walletIdentities.identities[1];
  const privKeyBase64 = importedAccount.privKey;
  const privKeyBytes = base64ToUint8Array(privKeyBase64);
  const decryptedBytes = AESCipherV3.decrypt(privKeyBytes, key32);
  const decryptedPrivKey = uint8ArrayToHex(decryptedBytes);
  expect(decryptedPrivKey).toEqual(IMPORTED_KEY);
});

test("encrypt encrypts data and decrypt successfully recovers it", () => {
  const key = new TextEncoder().encode("1234567890123456"); // 16-byte key
  const content = new TextEncoder().encode("Hello, ZilPay!");

  const encrypted = AESCipherV3.encrypt(content, key);
  const decrypted = AESCipherV3.decrypt(encrypted, key);

  expect(new TextDecoder().decode(decrypted)).toBe("Hello, ZilPay!");
});

test("decrypt with wrong key does not return original content", () => {
  const key = new TextEncoder().encode("correctKey123456"); // 16-byte key
  const wrongKey = new TextEncoder().encode("wrongKey12345678"); // 16-byte key

  const content = new TextEncoder().encode("Secret message");
  const encrypted = AESCipherV3.encrypt(content, key);

  const decrypted = AESCipherV3.decrypt(encrypted, wrongKey);

  expect(decrypted).not.toEqual(content);
  expect(new TextDecoder().decode(decrypted)).not.toBe(
    new TextDecoder().decode(content),
  );
});

test("encrypt throws if key length is invalid", () => {
  const invalidKey = new TextEncoder().encode("shortkey"); // <16 bytes
  const content = new TextEncoder().encode("Data");

  expect(() => AESCipherV3.encrypt(content, invalidKey)).toThrowError(
    ErrorMessages.InvalidKeyLength,
  );
});

test("test AES-v2", async () => {
  let key = "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8";
  let content =
    "8bfed20592daf43ca798ee263fcca946013876e00f34aeab3f0836872ccc19da";
  let encrypted =
    "U2FsdGVkX19nN1qtOBORWCorbwujy5Nxm7bfehROWZn/vLrxMXuXJE3Bs1PLx2j0V/xd8Ts3e1QUv5EK9Hx4k+jnUVGFtB0Wcg+oVN4/3KcR5U54gxJUf9UTR6kWSQe5";

  const encryptedBytes = base64ToUint8Array(encrypted);
  const keyBytes = new TextEncoder().encode(key); // В оригинальном коде была ошибка, здесь мы ее имитируем для прохождения теста
  let decrypted = await AESCipherV2.decrypt(encryptedBytes, keyBytes);

  expect(decrypted).toEqual(content);
});

test("decrypt Storage v2 AES-v2", async () => {
  const vault = STORAGE_V2.vault;
  const passwordBytes = utf8ToUint8Array(PASSWORD);
  const keyHashBytes = await sha256(passwordBytes);

  const keyHashHex = uint8ArrayToHex(keyHashBytes);
  const keyForEvpKDF = utf8ToUint8Array(keyHashHex);

  const vaultBytes = base64ToUint8Array(vault);
  const decrypted = await AESCipherV2.decrypt(vaultBytes, keyForEvpKDF);

  expect(decrypted).toEqual(WORDS);
});

test("decrypt accounts Storage v2 AES-v2", async () => {
  const accounts = JSON.parse(STORAGE_V2["wallet-identities"]);
  const identities = accounts.identities;
  const importedAccount = identities[1];
  const privKey = importedAccount.privKey;

  const passwordBytes = utf8ToUint8Array(PASSWORD);
  const keyHashBytes = await sha256(passwordBytes);

  const keyHashHex = uint8ArrayToHex(keyHashBytes);
  const keyForEvpKDF = utf8ToUint8Array(keyHashHex);

  const privKeyBytes = base64ToUint8Array(privKey);
  const decrypted = await AESCipherV2.decrypt(privKeyBytes, keyForEvpKDF);

  expect(decrypted).toEqual(IMPORTED_KEY);
});

```

`zil-pay/__tests__/crypto/argon2.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import { deriveArgon2Key } from "../../crypto/argon2";
import { Config, Variant, Version } from "@hicaru/argon2-pure.js";
import { APP_ID } from "../../config/argon2";
import { utf8ToUint8Array } from "../../lib/utils/utf8";

describe("argon2", () => {
  it("should derive the correct key", () => {
    const password = utf8ToUint8Array("test_password");
    const salt = utf8ToUint8Array("some_salt");
    const config = new Config(
      APP_ID,
      64,
      2,
      65536,
      new Uint8Array(),
      1,
      Variant.Argon2id,
      Version.Version13,
    );
    const key = deriveArgon2Key(password, salt, config);
    const expected = new Uint8Array([
      241, 5, 105, 168, 214, 152, 5, 38, 199, 60, 34, 215, 245, 198, 217, 49,
      108, 140, 86, 183, 92, 152, 168, 92, 64, 48, 241, 204, 238, 247, 198, 88,
      18, 126, 75, 177, 211, 74, 244, 234, 39, 92, 32, 255, 148, 131, 9, 175,
      213, 251, 48, 220, 238, 146, 16, 147, 132, 15, 46, 51, 176, 134, 238, 69,
    ]);

    expect(key).toEqual(expected);
  });
});

```

`zil-pay/__tests__/crypto/b64.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import { base64ToUint8Array, uint8ArrayToBase64 } from "../../crypto/b64";

describe("base64 Conversion Functions", () => {
  describe("base64ToUint8Array", () => {
    it("converts valid base64 string to Uint8Array", () => {
      const base64 = "SGVsbG8="; // "Hello"
      const expected = new Uint8Array([72, 101, 108, 108, 111]);
      expect(base64ToUint8Array(base64)).toEqual(expected);
    });

    it("handles empty base64 string", () => {
      expect(base64ToUint8Array("")).toEqual(new Uint8Array([]));
    });

    it("throws error for invalid base64 string", () => {
      expect(() => base64ToUint8Array("invalid!")).toThrow(
        "Invalid base64 string",
      );
    });
  });

  describe("uint8ArrayToBase64", () => {
    it("converts Uint8Array to valid base64 string", () => {
      const uint8Array = new Uint8Array([72, 101, 108, 108, 111]); // "Hello"
      expect(uint8ArrayToBase64(uint8Array)).toBe("SGVsbG8=");
    });

    it("handles empty Uint8Array", () => {
      expect(uint8ArrayToBase64(new Uint8Array([]))).toBe("");
    });
  });

  describe("round-trip conversion", () => {
    it("converts base64 to Uint8Array and back", () => {
      const original = "SGVsbG8=";
      const uint8Array = base64ToUint8Array(original);
      expect(uint8ArrayToBase64(uint8Array)).toBe(original);
    });

    it("converts Uint8Array to base64 and back", () => {
      const original = new Uint8Array([72, 101, 108, 108, 111]);
      const base64 = uint8ArrayToBase64(original);
      expect(base64ToUint8Array(base64)).toEqual(original);
    });
  });
});

```

`zil-pay/__tests__/crypto/bip32.test.ts`:

```ts
import { describe, it, expect, vi } from "vitest";
import {
  derivePrivateKey,
  deriveChildKey,
  ChildNumber,
  Bip32Error,
  Bip32ErrorCode,
  deriveFromPrivateKeyPublicKey,
} from "../../crypto/bip32";
import { Bip39 } from "../../crypto/bip39";
import { DerivationPath } from "../../crypto/bip49";
import { utils } from "aes-js";
import { ETHEREUM, ZILLIQA } from "../../config/slip44";

describe("BIP-32 Derivation", () => {
  it("should derive correct private key from BIP-39 mnemonic", async () => {
    const phrase =
      "panda eyebrow bullet gorilla call smoke muffin taste mesh discover soft ostrich alcohol speed nation flash devote level hobby quick inner drive ghost inside";
    const expectedSecretKey =
      "ff1e68eb7bf2f48651c47ef0177eb815857322257c5894bb4cfd1176c9989314";
    const seed = await Bip39.mnemonicToSeed(phrase, "");
    const privateKey = await derivePrivateKey(seed, "m/44'/60'/0'/0/0");

    expect(utils.hex.fromBytes(privateKey)).toEqual(expectedSecretKey);
  });

  it("shoud get pubKey from privateKey", async () => {
    const phrase =
      "green process gate doctor slide whip priority shrug diamond crumble average help";
    const seed = await Bip39.mnemonicToSeed(phrase, "");

    expect(
      Uint8Array.from([
        143, 219, 233, 88, 72, 55, 94, 13, 19, 72, 66, 197, 121, 69, 163, 46,
        15, 247, 4, 104, 60, 132, 106, 5, 135, 186, 182, 62, 54, 56, 209, 5,
        182, 104, 244, 78, 184, 167, 36, 156, 3, 14, 212, 191, 102, 69, 11, 214,
        43, 181, 138, 7, 21, 241, 122, 192, 73, 244, 36, 136, 187, 175, 159,
        181,
      ]),
    ).toEqual(seed);

    const pathETH = new DerivationPath(ETHEREUM, 0);
    const privateKeyETH = await derivePrivateKey(seed, pathETH.getPath());
    const pubkeyETH = await deriveFromPrivateKeyPublicKey(
      privateKeyETH,
      ETHEREUM,
    );

    expect(
      "0315bd7b9301a2cde69ef8092d6fb275a077e3c94e5ed166c915426850cf606600",
    ).toEqual(utils.hex.fromBytes(pubkeyETH));

    const pathZIL = new DerivationPath(ZILLIQA, 0);
    const privateKeyZIL = await derivePrivateKey(seed, pathZIL.getPath());
    const pubkeyZIL = await deriveFromPrivateKeyPublicKey(
      privateKeyZIL,
      ZILLIQA,
    );

    expect(
      "03150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da",
    ).toEqual(utils.hex.fromBytes(pubkeyZIL));
  });
});

describe("ChildNumber", () => {
  it("should correctly parse a hardened child number", () => {
    const childNumber = ChildNumber.fromString("44'");
    expect(childNumber.value).toBe(44 | 0x80000000);
    expect(childNumber.isHardened()).toBe(true);
  });

  it("should correctly parse a non-hardened child number", () => {
    const childNumber = ChildNumber.fromString("0");
    expect(childNumber.value).toBe(0);
    expect(childNumber.isHardened()).toBe(false);
  });

  it("should throw an error for invalid child number string", () => {
    expect(() => ChildNumber.fromString("invalid")).toThrow(Bip32Error);
  });

  it("should throw an error for negative child number", () => {
    expect(() => ChildNumber.fromString("-1")).toThrow(Bip32Error);
  });
});

describe("derivePrivateKey Error Handling", () => {
  it("should throw an error for invalid path", async () => {
    const seed = utils.hex.toBytes("000102030405060708090a0b0c0d0e0f");
    await expect(derivePrivateKey(seed, "invalid/path")).rejects.toThrow(
      Bip32Error,
    );
  });

  it("should throw an error for invalid child number in path", async () => {
    const seed = utils.hex.toBytes("000102030405060708090a0b0c0d0e0f");
    await expect(
      derivePrivateKey(seed, "m/44'/invalid'/0'/0/0"),
    ).rejects.toThrow();
  });
});

describe("deriveChildKey", () => {
  const parentKey = utils.hex.toBytes(
    "e8f32e723decf4051aefc8e2e8929c9c53337309202da64260e18c95815ff8a1",
  );
  const chainCode = utils.hex.toBytes(
    "044108d81081692c577005ce106a7980ade51d384664082531e457e515d086c1",
  );

  it("should throw Bip32Error if hmacSha512 fails during child derivation", async () => {
    vi.spyOn(globalThis.crypto.subtle, "sign").mockImplementationOnce(
      async () => {
        throw new Error("Mock HMAC failure during child derivation");
      },
    );

    const childNumber = ChildNumber.fromString("0");

    await expect(
      deriveChildKey(parentKey, chainCode, childNumber),
    ).rejects.toThrow(Bip32Error);
    await expect(
      deriveChildKey(parentKey, chainCode, childNumber),
    ).rejects.toThrow(
      new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid parent key"),
    );
  });
});

```

`zil-pay/__tests__/crypto/bip39.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import { Bip39, Bip39Error } from "../../crypto/bip39";
import { utils } from "aes-js";
import { sha256 } from "../../crypto/sha256";
import { WORD_LIST } from "./word_list";

const TEST_VECTORS = [
  {
    entropy: "00000000000000000000000000000000",
    mnemonic:
      "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
    seed: "c55257c360c07c72029aebc1b53c05ed0362ada38ead3e3e9efa3708e53495531f09a6987599d18264c1e1c92f2cf141630c7a3c4ab7c81b2f001698e7463b04",
  },
  {
    entropy: "7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
    mnemonic:
      "legal winner thank year wave sausage worth useful legal winner thank yellow",
    seed: "2e8905819b8723fe2c1d161860e5ee1830318dbf49a83bd451cfb8440c28bd6fa457fe1296106559a3c80937a1c1069be3a3a5bd381ee6260e8d9739fce1f607",
  },
  {
    entropy: "80808080808080808080808080808080",
    mnemonic:
      "letter advice cage absurd amount doctor acoustic avoid letter advice cage above",
    seed: "d71de856f81a8acc65e6fc851a38d4d7ec216fd0796d0a6827a3ad6ed5511a30fa280f12eb2e47ed2ac03b5c462a0358d18d69fe4f985ec81778c1b370b652a8",
  },
  {
    entropy: "ffffffffffffffffffffffffffffffff",
    mnemonic: "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",
    seed: "ac27495480225222079d7be181583751e86f571027b0497b5b5d11218e0a8a13332572917f0f8e5a589620c6f15b11c61dee327651a14c34e18231052e48c069",
  },
  {
    entropy: "000000000000000000000000000000000000000000000000",
    mnemonic:
      "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon agent",
    seed: "035895f2f481b1b0f01fcf8c289c794660b289981a78f8106447707fdd9666ca06da5a9a565181599b79f53b844d8a71dd9f439c52a3d7b3e8a79c906ac845fa",
  },
  {
    entropy: "7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
    mnemonic:
      "legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal will",
    seed: "f2b94508732bcbacbcc020faefecfc89feafa6649a5491b8c952cede496c214a0c7b3c392d168748f2d4a612bada0753b52a1c7ac53c1e93abd5c6320b9e95dd",
  },
  {
    entropy: "808080808080808080808080808080808080808080808080",
    mnemonic:
      "letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter always",
    seed: "107d7c02a5aa6f38c58083ff74f04c607c2d2c0ecc55501dadd72d025b751bc27fe913ffb796f841c49b1d33b610cf0e91d3aa239027f5e99fe4ce9e5088cd65",
  },
  {
    entropy: "ffffffffffffffffffffffffffffffffffffffffffffffff",
    mnemonic:
      "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo when",
    seed: "0cd6e5d827bb62eb8fc1e262254223817fd068a74b5b449cc2f667c3f1f985a76379b43348d952e2265b4cd129090758b3e3c2c49103b5051aac2eaeb890a528",
  },
  {
    entropy: "0000000000000000000000000000000000000000000000000000000000000000",
    mnemonic:
      "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art",
    seed: "bda85446c68413707090a52022edd26a1c9462295029f2e60cd7c4f2bbd3097170af7a4d73245cafa9c3cca8d561a7c3de6f5d4a10be8ed2a5e608d68f92fcc8",
  },
  {
    entropy: "7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
    mnemonic:
      "legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth title",
    seed: "bc09fca1804f7e69da93c2f2028eb238c227f2e9dda30cd63699232578480a4021b146ad717fbb7e451ce9eb835f43620bf5c514db0f8add49f5d121449d3e87",
  },
  {
    entropy: "8080808080808080808080808080808080808080808080808080808080808080",
    mnemonic:
      "letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic bless",
    seed: "c0c519bd0e91a2ed54357d9d1ebef6f5af218a153624cf4f2da911a0ed8f7a09e2ef61af0aca007096df430022f7a2b6fb91661a9589097069720d015e4e982f",
  },
  {
    entropy: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
    mnemonic:
      "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo vote",
    seed: "dd48c104698c30cfe2b6142103248622fb7bb0ff692eebb00089b32d22484e1613912f0a5b694407be899ffd31ed3992c456cdf60f5d4564b8ba3f05a69890ad",
  },
  {
    entropy: "9e885d952ad362caeb4efe34a8e91bd2",
    mnemonic:
      "ozone drill grab fiber curtain grace pudding thank cruise elder eight picnic",
    seed: "274ddc525802f7c828d8ef7ddbcdc5304e87ac3535913611fbbfa986d0c9e5476c91689f9c8a54fd55bd38606aa6a8595ad213d4c9c9f9aca3fb217069a41028",
  },
  {
    entropy: "6610b25967cdcca9d59875f5cb50b0ea75433311869e930b",
    mnemonic:
      "gravity machine north sort system female filter attitude volume fold club stay feature office ecology stable narrow fog",
    seed: "628c3827a8823298ee685db84f55caa34b5cc195a778e52d45f59bcf75aba68e4d7590e101dc414bc1bbd5737666fbbef35d1f1903953b66624f910feef245ac",
  },
  {
    entropy: "68a79eaca2324873eacc50cb9c6eca8cc68ea5d936f98787c60c7ebc74e6ce7c",
    mnemonic:
      "hamster diagram private dutch cause delay private meat slide toddler razor book happy fancy gospel tennis maple dilemma loan word shrug inflict delay length",
    seed: "64c87cde7e12ecf6704ab95bb1408bef047c22db4cc7491c4271d170a1b213d20b385bc1588d9c7b38f1b39d415665b8a9030c9ec653d75e65f847d8fc1fc440",
  },
  {
    entropy: "c0ba5a8e914111210f2bd131f3d5e08d",
    mnemonic:
      "scheme spot photo card baby mountain device kick cradle pact join borrow",
    seed: "ea725895aaae8d4c1cf682c1bfd2d358d52ed9f0f0591131b559e2724bb234fca05aa9c02c57407e04ee9dc3b454aa63fbff483a8b11de949624b9f1831a9612",
  },
  {
    entropy: "6d9be1ee6ebd27a258115aad99b7317b9c8d28b6d76431c3",
    mnemonic:
      "horn tenant knee talent sponsor spell gate clip pulse soap slush warm silver nephew swap uncle crack brave",
    seed: "fd579828af3da1d32544ce4db5c73d53fc8acc4ddb1e3b251a31179cdb71e853c56d2fcb11aed39898ce6c34b10b5382772db8796e52837b54468aeb312cfc3d",
  },
  {
    entropy: "9f6a2878b2520799a44ef18bc7df394e7061a224d2c33cd015b157d746869863",
    mnemonic:
      "panda eyebrow bullet gorilla call smoke muffin taste mesh discover soft ostrich alcohol speed nation flash devote level hobby quick inner drive ghost inside",
    seed: "72be8e052fc4919d2adf28d5306b5474b0069df35b02303de8c1729c9538dbb6fc2d731d5f832193cd9fb6aeecbc469594a70e3dd50811b5067f3b88b28c3e8d",
  },
  {
    entropy: "23db8160a31d3e0dca3688ed941adbf3",
    mnemonic:
      "cat swing flag economy stadium alone churn speed unique patch report train",
    seed: "deb5f45449e615feff5640f2e49f933ff51895de3b4381832b3139941c57b59205a42480c52175b6efcffaa58a2503887c1e8b363a707256bdd2b587b46541f5",
  },
  {
    entropy: "8197a4a47f0425faeaa69deebc05ca29c0a5b5cc76ceacc0",
    mnemonic:
      "light rule cinnamon wrap drastic word pride squirrel upgrade then income fatal apart sustain crack supply proud access",
    seed: "4cbdff1ca2db800fd61cae72a57475fdc6bab03e441fd63f96dabd1f183ef5b782925f00105f318309a7e9c3ea6967c7801e46c8a58082674c860a37b93eda02",
  },
  {
    entropy: "066dca1a2bb7e8a1db2832148ce9933eea0f3ac9548d793112d9a95c9407efad",
    mnemonic:
      "all hour make first leader extend hole alien behind guard gospel lava path output census museum junior mass reopen famous sing advance salt reform",
    seed: "26e975ec644423f4a4c4f4215ef09b4bd7ef924e85d1d17c4cf3f136c2863cf6df0a475045652c57eb5fb41513ca2a2d67722b77e954b4b3fc11f7590449191d",
  },
  {
    entropy: "f30f8c1da665478f49b001d94c5fc452",
    mnemonic:
      "vessel ladder alter error federal sibling chat ability sun glass valve picture",
    seed: "2aaa9242daafcee6aa9d7269f17d4efe271e1b9a529178d7dc139cd18747090bf9d60295d0ce74309a78852a9caadf0af48aae1c6253839624076224374bc63f",
  },
  {
    entropy: "c10ec20dc3cd9f652c7fac2f1230f7a3c828389a14392f05",
    mnemonic:
      "scissors invite lock maple supreme raw rapid void congress muscle digital elegant little brisk hair mango congress clump",
    seed: "7b4a10be9d98e6cba265566db7f136718e1398c71cb581e1b2f464cac1ceedf4f3e274dc270003c670ad8d02c4558b2f8e39edea2775c9e232c7cb798b069e88",
  },
  {
    entropy: "f585c11aec520db57dd353c69554b21a89b20fb0650966fa0a9d6f74fd989d8f",
    mnemonic:
      "void come effort suffer camp survey warrior heavy shoot primary clutch crush open amazing screen patrol group space point ten exist slush involve unfold",
    seed: "01f5bced59dec48e362f2c45b5de68b9fd6c92c6634f44d6d40aab69056506f0e35524a518034ddc1192e1dacd32c1ed3eaa3c3b131c88ed8e7e54c49a5d0998",
  },
];

describe("bip39", () => {
  it("test entropyToMnemonic", async () => {
    const entropy = utils.hex.toBytes("ffffffffffffffffffffffffffffffff");
    const mnemonic = await Bip39.entropyToMnemonic(entropy, WORD_LIST);

    expect(mnemonic.phrase).equal(
      "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",
    );
  });

  it.each(TEST_VECTORS)(
    "validates vector: $mnemonic",
    async ({ entropy, mnemonic, seed }) => {
      const entropyBytes = Uint8Array.from(
        entropy.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16)),
      );
      const seedBytes = Uint8Array.from(
        seed.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16)),
      );

      // Test entropy to mnemonic
      const generatedMnemonic = await Bip39.entropyToMnemonic(
        entropyBytes,
        WORD_LIST,
      );
      expect(generatedMnemonic.phrase).toBe(mnemonic);

      // Test mnemonic validation
      await expect(Bip39.validateMnemonic(mnemonic, WORD_LIST)).resolves.toBe(
        true,
      );

      // Test mnemonic to seed
      const generatedSeed = await Bip39.mnemonicToSeed(
        mnemonic,
        "TREZOR",
      );
      expect(generatedSeed).toEqual(seedBytes);

      // // Test mnemonic to entropy
      const recoveredEntropy = await Bip39.mnemonicToEntropy(
        mnemonic,
        WORD_LIST,
      );
      expect(recoveredEntropy).toEqual(entropyBytes);
    },
  );

  it.each([12, 15, 18, 21, 24])(
    "generates mnemonic with %i words",
    async (wordCount) => {
      const entropyBits = (wordCount * 11 * 32) / 33;
      const mnemonic = await Bip39.generateMnemonic(entropyBits, WORD_LIST);

      expect(mnemonic.words.length).toBe(wordCount);
      expect(mnemonic.phrase.split(" ").length).toBe(wordCount);
    },
  );
});

describe("bip39_checksum", () => {
  const vectors = [
    "00000000000000000000000000000000",
    "7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
    "80808080808080808080808080808080",
    "ffffffffffffffffffffffffffffffff",
    "000000000000000000000000000000000000000000000000",
    "7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
    "808080808080808080808080808080808080808080808080",
    "ffffffffffffffffffffffffffffffffffffffffffffffff",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
    "8080808080808080808080808080808080808080808080808080808080808080",
    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
    "9e885d952ad362caeb4efe34a8e91bd2",
    "6610b25967cdcca9d59875f5cb50b0ea75433311869e930b",
    "68a79eaca2324873eacc50cb9c6eca8cc68ea5d936f98787c60c7ebc74e6ce7c",
    "c0ba5a8e914111210f2bd131f3d5e08d",
    "6d9be1ee6ebd27a258115aad99b7317b9c8d28b6d76431c3",
    "9f6a2878b2520799a44ef18bc7df394e7061a224d2c33cd015b157d746869863",
    "23db8160a31d3e0dca3688ed941adbf3",
    "8197a4a47f0425faeaa69deebc05ca29c0a5b5cc76ceacc0",
    "066dca1a2bb7e8a1db2832148ce9933eea0f3ac9548d793112d9a95c9407efad",
    "f30f8c1da665478f49b001d94c5fc452",
    "c10ec20dc3cd9f652c7fac2f1230f7a3c828389a14392f05",
    "f585c11aec520db57dd353c69554b21a89b20fb0650966fa0a9d6f74fd989d8f",
  ];

  it.each(vectors)("verifies checksum for entropy: %s", async (entropyHex) => {
    const entropy = Uint8Array.from(
      entropyHex.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16)),
    );
    const mnemonic = await Bip39.entropyToMnemonic(entropy, WORD_LIST);

    const ENT = entropy.length * 8; 
    const CS = ENT / 32; 

    const hash = await sha256(entropy);
    const computedChecksum = hash[0] >> (8 - CS);

    const bits = mnemonic.words
      .map((word) => {
        const index = WORD_LIST.indexOf(word);
        return index.toString(2).padStart(11, "0");
      })
      .join("");
    const checksum = parseInt(bits.slice(ENT, ENT + CS), 2);

    expect(computedChecksum).toBe(checksum);
  });
});

describe("bip39_invalid_mnemonic", () => {
  it("should throw UnknownWord error for invalid word at position 0", async () => {
    const invalidMnemonic =
      "getter advice cage absurd amount doctor acoustic avoid letter advice cage above";
    await expect(
      Bip39.validateMnemonic(invalidMnemonic, WORD_LIST),
    ).rejects.toThrow(Bip39Error.InvalidWord);
  });

  it("should throw UnknownWord error for invalid word at position 2", async () => {
    const invalidMnemonic =
      "letter advice cagex absurd amount doctor acoustic avoid letter advice cage above";
    await expect(
      Bip39.validateMnemonic(invalidMnemonic, WORD_LIST),
    ).rejects.toThrow(Bip39Error.InvalidWord);
  });

  it("should throw BadWordCount error for 11 words", async () => {
    const invalidMnemonic =
      "advice cage absurd amount doctor acoustic avoid letter advice cage above";
    await expect(
      Bip39.validateMnemonic(invalidMnemonic, WORD_LIST),
    ).rejects.toThrow(Bip39Error.InvalidWordCount);
  });

  it("should throw InvalidChecksum error for invalid checksum", async () => {
    const invalidMnemonic =
      "primary advice cage absurd amount doctor acoustic avoid letter advice cage above";
    await expect(
      Bip39.validateMnemonic(invalidMnemonic, WORD_LIST),
    ).rejects.toThrow(Bip39Error.InvalidChecksum);
  });
});

describe("bip39_invalid_entropy", () => {
  it("should throw BadEntropyBitCount for entropy not divisible by 32 bits", async () => {
    const entropy = new Uint8Array(17); // 136 бит
    await expect(Bip39.entropyToMnemonic(entropy, WORD_LIST)).rejects.toThrow(
      Bip39Error.InvalidEntropy,
    );
  });

  it("should throw BadEntropyBitCount for entropy less than 128 bits", async () => {
    const entropy = new Uint8Array(4); // 32 бита
    await expect(Bip39.entropyToMnemonic(entropy, WORD_LIST)).rejects.toThrow(
      Bip39Error.InvalidEntropy,
    );
  });

  it("should throw BadEntropyBitCount for entropy greater than 256 bits", async () => {
    const entropy = new Uint8Array(36); // 288 бит
    await expect(Bip39.entropyToMnemonic(entropy, WORD_LIST)).rejects.toThrow(
      Bip39Error.InvalidEntropy,
    );
  });
});

```

`zil-pay/__tests__/crypto/bip49.test.ts`:

```ts
import { describe, expect, test } from "vitest";
import { DerivationPath } from "../../crypto/bip49";
import { ETHEREUM, ZILLIQA } from "../../config/slip44";

describe("DerivationPath", () => {
  test("should create correct Ethereum path", () => {
    const ethPath = new DerivationPath(ETHEREUM, 0);
    expect(ethPath.getPath()).toBe("m/44'/60'/0'/0/0");
    expect(ethPath.getBasePath()).toBe("m/44'/60'/0'/0/");
  });

  test("should create correct Zilliqa path", () => {
    const zilPath = new DerivationPath(ZILLIQA, 0);
    expect(zilPath.getPath()).toBe("m/44'/313'/0'/0/0");
    expect(zilPath.getBasePath()).toBe("m/44'/313'/0'/0/");
  });

  test("should handle different indexes", () => {
    const ethPath = new DerivationPath(ETHEREUM, 5);
    expect(ethPath.getPath()).toBe("m/44'/60'/0'/0/5");
    expect(ethPath.getIndex()).toBe(5);
  });

  test("should display correct string", () => {
    const ethPath = new DerivationPath(ETHEREUM, 0);
    expect(ethPath.toString()).toBe("m/44'/60'/0'/0/0");
  });
});

```

`zil-pay/__tests__/crypto/keychain.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import {
  KeyChain,
  CipherOrders,
  AES_GCM_KEY_SIZE,
  KEYCHAIN_BYTES_SIZE,
  deriveKeyFromSeed,
} from "../../crypto/keychain";
import { PubKey, PrivKey } from "@hicaru/ntrup.js";
import { Config, Variant, Version } from "@hicaru/argon2-pure.js";
import { APP_ID } from "../../config/argon2";
import { randomBytes } from "../../crypto/random";
import { NTRU_CONFIG } from "../../crypto/ntrup";
import { utils } from "aes-js";
import { PASSWORD, STORAGE_V2, WORDS } from "../data";
import { sha256 } from "../../crypto/sha256";
import { base64ToUint8Array } from "../../crypto/b64";

const LIGHT_ARGON2_CONFIG = new Config(
  APP_ID,
  64,
  1,
  64,
  new Uint8Array([]),
  1,
  Variant.Argon2id,
  Version.Version13,
);

describe("KeyChain", () => {
  it("test derive key from seed and index", async () => {
    const seed = Uint8Array.from([
      42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
      42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
    ]);
    const r1 = await deriveKeyFromSeed(seed, 1);
    const r2 = await deriveKeyFromSeed(seed, 2);

    expect(r1).toEqual(
      Uint8Array.from([
        110, 184, 151, 158, 154, 167, 152, 8, 9, 51, 232, 16, 76, 69, 174, 96,
        19, 234, 70, 139, 138, 205, 60, 15, 254, 119, 216, 112, 88, 218, 122, 9,
      ]),
    );
    expect(r2).toEqual(
      Uint8Array.from([
        64, 210, 75, 227, 185, 9, 209, 199, 53, 232, 57, 9, 149, 24, 239, 67,
        71, 55, 108, 54, 149, 48, 252, 151, 140, 50, 74, 170, 67, 174, 246, 190,
      ]),
    );
  });

  it("should initialize from seed", async () => {
    const seed = randomBytes(32);
    const keychain = await KeyChain.fromSeed(seed);

    expect(keychain).toBeDefined();
    expect(keychain.aesKey).toBeInstanceOf(Uint8Array);
    expect(keychain.aesKey.length).toBe(AES_GCM_KEY_SIZE);
    expect(keychain.ntrupKeys.pk).toBeInstanceOf(PubKey);
    expect(keychain.ntrupKeys.sk).toBeInstanceOf(PrivKey);
    expect(keychain.kuznechikKey).toBeInstanceOf(Uint8Array);
  });

  it("should initialize from password", async () => {
    const password = randomBytes(32);
    const fingerprint = new Uint8Array();

    const keychain = await KeyChain.fromPass(
      password,
      fingerprint,
      LIGHT_ARGON2_CONFIG,
    );

    expect(keychain).toBeDefined();
    expect(keychain.aesKey).toBeInstanceOf(Uint8Array);
    expect(keychain.aesKey.length).toBe(AES_GCM_KEY_SIZE);
    expect(keychain.ntrupKeys.pk).toBeInstanceOf(PubKey);
    expect(keychain.ntrupKeys.sk).toBeInstanceOf(PrivKey);
    expect(keychain.kuznechikKey).toBeInstanceOf(Uint8Array);
  });

  it("should serialize to bytes and deserialize correctly", async () => {
    const seed = randomBytes(32);
    const keychain = await KeyChain.fromSeed(seed);

    const bytes = keychain.toBytes();
    const restoredKeychain = await KeyChain.fromBytes(bytes);

    expect(bytes.length).toBe(KEYCHAIN_BYTES_SIZE);
    expect(restoredKeychain.aesKey).toEqual(keychain.aesKey);
    expect(restoredKeychain.ntrupKeys.pk.toBytes(NTRU_CONFIG)).toEqual(
      keychain.ntrupKeys.pk.toBytes(NTRU_CONFIG),
    );
    expect(restoredKeychain.ntrupKeys.sk.toBytes(NTRU_CONFIG)).toEqual(
      keychain.ntrupKeys.sk.toBytes(NTRU_CONFIG),
    );
    expect(restoredKeychain.kuznechikKey).toEqual(keychain.kuznechikKey);
  });

  it("should encrypt and decrypt correctly", async () => {
    const seed = randomBytes(32);
    const plaintext = randomBytes(1024);
    const keychain = await KeyChain.fromSeed(seed);
    const options = [
      CipherOrders.AESGCM256,
      CipherOrders.NTRUP761,
      CipherOrders.KUZNECHIK,
    ];

    const ciphertext = await keychain.encrypt(plaintext, options);
    const decrypted = await keychain.decrypt(ciphertext, options);

    expect(ciphertext).not.toEqual(plaintext);
    expect(decrypted).toEqual(plaintext);

    const invalidOptions = [CipherOrders.NTRUP761, CipherOrders.AESGCM256];
    await expect(
      keychain.decrypt(ciphertext, invalidOptions),
    ).rejects.toThrow();
  });

  it("should make and verify proof correctly", async () => {
    const seed = randomBytes(32);
    const keychain = await KeyChain.fromSeed(seed);
    const options = [
      CipherOrders.NTRUP761,
      CipherOrders.AESGCM256,
      CipherOrders.KUZNECHIK,
    ];
    const proofSeed = randomBytes(32);

    const proofCipher = await keychain.makeProof(proofSeed, options);
    const retrievedSeed = await keychain.getProof(proofCipher, options);

    expect(proofCipher).not.toEqual(proofSeed);
    expect(retrievedSeed).toEqual(proofSeed);
  });

  it("should decrypt old AESCBC encrypted data correctly", async () => {
    const passwordBytes = utils.utf8.toBytes(PASSWORD);
    const keychain = await KeyChain.fromAesV2(passwordBytes);

    const vault = STORAGE_V2.vault;
    const ciphertext = base64ToUint8Array(vault);

    const decrypted = await keychain.decrypt(ciphertext, [CipherOrders.AESCBC]);
    const decryptedStr = new TextDecoder().decode(decrypted);

    expect(decryptedStr).toEqual(WORDS);
  });
});

```

`zil-pay/__tests__/crypto/keypair.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import { Signature } from "@noble/secp256k1";
import { KeyPair } from "../../crypto/keypair";
import { Bip39 } from "../../crypto/bip39";
import { ETHEREUM, ZILLIQA } from "../../config/slip44";
import { utils } from "aes-js";
import { WORDS, KEY, IMPORTED_KEY } from "../data";
import { verify } from "../../crypto/zilliqa/schnorr";
import { Address, AddressType } from "../../crypto/address";

describe("KeyPair", () => {
  describe("fromPrivateKey", () => {
    it("should create KeyPair for Zilliqa with correct address", async () => {
      const privateKey = Uint8Array.from(utils.hex.toBytes(IMPORTED_KEY));
      const keyPair = await KeyPair.fromPrivateKey(privateKey, ZILLIQA);
      const address = await keyPair.address();

      expect(keyPair.slip44).toBe(ZILLIQA);
      expect(keyPair.addressType()).toBe(AddressType.Bech32);
      expect(keyPair.privateKey).toEqual(privateKey);
      expect(await address.toZilBech32()).toBe(
        "zil14at57zaj4pe3tuy734usy2xnlquapkd4d0ne43",
      );
    });

    it("should create KeyPair for Ethereum with correct address", async () => {
      const privateKey = Uint8Array.from(utils.hex.toBytes(IMPORTED_KEY));
      const keyPair = await KeyPair.fromPrivateKey(privateKey, ETHEREUM);
      const address = await keyPair.address();

      expect(keyPair.slip44).toBe(ETHEREUM);
      expect(keyPair.addressType()).toBe(AddressType.EthCheckSum);
      expect(keyPair.privateKey).toEqual(privateKey);
      expect(await address.toEthChecksum()).toBe(
        "0x709678c07cfCAFB4bb49a6b1d57b1db378e27825",
      );
    });
  });

  describe("fromSeed", () => {
    it("should create KeyPair for Zilliqa from seed with correct address", async () => {
      const seed = await Bip39.mnemonicToSeed(WORDS, "");
      const keyPair = await KeyPair.fromSeed(seed, ZILLIQA, 0);
      const address = await keyPair.address();

      expect(keyPair.slip44).toBe(ZILLIQA);
      expect(keyPair.addressType()).toBe(AddressType.Bech32);
      expect(utils.hex.fromBytes(keyPair.privateKey)).toBe(KEY);
      expect(await address.toZilBech32()).toBe(
        "zil1ntrynx04349sk6py7uyata03gka6qswg7um95y",
      );
    });

    it("should create KeyPair for Ethereum from seed with correct address", async () => {
      const seed = await Bip39.mnemonicToSeed(WORDS, "");
      const keyPair = await KeyPair.fromSeed(seed, ETHEREUM, 0);
      const address = await keyPair.address();

      expect(keyPair.slip44).toBe(ETHEREUM);
      expect(keyPair.addressType()).toBe(AddressType.EthCheckSum);
      expect(await address.toEthChecksum()).toBe(
        "0xAEC7595CA9A57be828493bb73f07fA335a85B41d",
      );
    });
  });

  describe("signMessage", () => {
    it("should sign message for Zilliqa correctly", async () => {
      const privateKey = Uint8Array.from(utils.hex.toBytes(IMPORTED_KEY));
      const keyPair = await KeyPair.fromPrivateKey(privateKey, ZILLIQA);
      const message = utils.utf8.toBytes("test message");
      const signature = await keyPair.signMessage(message);

      expect(signature).toBeInstanceOf(Uint8Array);
      expect(signature.length).toBe(64);
      expect(
        await verify(message, keyPair.pubKey, Signature.fromBytes(signature)),
      ).toBeTruthy();
      expect(await keyPair.verifySig(message, signature)).toBeTruthy();
    });

    it("should sign message for Ethereum correctly", async () => {
      const privateKey = Uint8Array.from(utils.hex.toBytes(IMPORTED_KEY));
      const keyPair = await KeyPair.fromPrivateKey(privateKey, ETHEREUM);
      const message = utils.utf8.toBytes("test message");
      const signature = await keyPair.signMessage(message);

      expect(signature).toBeInstanceOf(Uint8Array);
      expect(signature.length).toBe(65);
      expect(await keyPair.verifySig(message, signature)).toBeTruthy();
    });
  });

  describe("EIP-712", () => {
    const types = {
      Mail: [
        { name: "from", type: "string" },
        { name: "to", type: "string" },
        { name: "contents", type: "string" },
      ],
    } as const;

    const domain = {
      name: "Ether Mail",
      version: "1",
      chainId: 1,
      verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
    };

    const message = {
      from: "Alice",
      to: "Bob",
      contents: "Hello, Bob!",
    };

    const typedData = {
      types,
      primaryType: "Mail",
      domain,
      message,
    };

    it("should throw error for Zilliqa EIP-712 signing", async () => {
      const privateKey = Uint8Array.from(utils.hex.toBytes(IMPORTED_KEY));
      const keyPair = await KeyPair.fromPrivateKey(privateKey, ZILLIQA);

      expect(() => keyPair.signDataEIP712(typedData)).toThrowError(
        "Unsupported",
      );
    });

    it("should throw error for Zilliqa EIP-712 verification", async () => {
      const privateKey = Uint8Array.from(utils.hex.toBytes(IMPORTED_KEY));
      const keyPair = await KeyPair.fromPrivateKey(privateKey, ZILLIQA);
      const signature = new Uint8Array(65); // Dummy signature
      const address = await Address.fromStr(
        "0x709678c07cfCAFB4bb49a6b1d57b1db378e27825",
      );

      await expect(
        keyPair.verifyTypedEIP712(signature, typedData, address),
      ).rejects.toThrowError("Unsupported");
    });

    it("should sign EIP-712 data for Ethereum correctly", async () => {
      const privateKey = Uint8Array.from(utils.hex.toBytes(IMPORTED_KEY));
      const keyPair = await KeyPair.fromPrivateKey(privateKey, ETHEREUM);
      const signature = keyPair.signDataEIP712(typedData);

      expect(signature).toBeInstanceOf(Uint8Array);
      expect(signature.length).toBe(65); // Ethereum EIP-712 signature length
    });

    it("should verify EIP-712 signature for Ethereum correctly", async () => {
      const privateKey = Uint8Array.from(utils.hex.toBytes(IMPORTED_KEY));
      const keyPair = await KeyPair.fromPrivateKey(privateKey, ETHEREUM);
      const signature = keyPair.signDataEIP712(typedData);
      const address = await keyPair.address();

      const isValid = await keyPair.verifyTypedEIP712(
        signature,
        typedData,
        address,
      );
      expect(isValid).toBeTruthy();
    });

    it("should fail to verify EIP-712 with invalid signature", async () => {
      const privateKey = Uint8Array.from(utils.hex.toBytes(IMPORTED_KEY));
      const keyPair = await KeyPair.fromPrivateKey(privateKey, ETHEREUM);

      const differentMessage = {
        from: "Alice",
        to: "Charlie",
        contents: "Hello, Charlie!",
      };
      const invalidTypedData = {
        types,
        primaryType: "Mail",
        domain,
        message: differentMessage,
      };
      const invalidSignature = keyPair.signDataEIP712(invalidTypedData);
      const address = await keyPair.address();

      const isValid = await keyPair.verifyTypedEIP712(
        invalidSignature,
        typedData,
        address,
      );
      expect(isValid).toBeFalsy();
    });
  });

  it("should sign typed data EIP-712 successfully for Ethereum", async () => {
    const keyPair = await KeyPair.generate(ETHEREUM);
    const address = await keyPair.address();

    const typedData = {
      types: {
        EIP712Domain: [
          { name: "name", type: "string" },
          { name: "version", type: "string" },
          { name: "chainId", type: "uint256" },
          { name: "verifyingContract", type: "address" },
        ],
        Person: [
          { name: "name", type: "string" },
          { name: "wallet", type: "address" },
        ],
      },
      primaryType: "Person",
      domain: {
        name: "Ether Mail",
        version: "1",
        chainId: 1,
        verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
      },
      message: {
        name: "Bob",
        wallet: await address.toEthChecksum(),
      },
    };

    const signature = keyPair.signDataEIP712(typedData);

    expect(signature).toBeInstanceOf(Uint8Array);
    expect(signature.length).toBe(65);
    const isValid = await keyPair.verifyTypedEIP712(
      signature,
      typedData,
      address,
    );
    expect(isValid).toBeTruthy();
  });

  it("should throw error for EIP-712 signing with Zilliqa (unsupported type)", async () => {
    const keyPair = await KeyPair.generate(ZILLIQA);
    const typedData = {
      types: {
        EIP712Domain: [
          { name: "name", type: "string" },
          { name: "version", type: "string" },
          { name: "chainId", type: "uint256" },
          { name: "verifyingContract", type: "address" },
        ],
        Person: [
          { name: "name", type: "string" },
          { name: "wallet", type: "address" },
        ],
      },
      primaryType: "Person",
      domain: {
        name: "Ether Mail",
        version: "1",
        chainId: 1,
        verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
      },
      message: {
        name: "Bob",
        wallet: "0xbBbBBBBbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB",
      },
    };

    expect(() => keyPair.signDataEIP712(typedData)).toThrowError("Unsupported");
  });
});

```

`zil-pay/__tests__/crypto/kuznechik.test.ts`:

```ts
import { describe, test, expect } from "vitest";
import { kuznechikEncrypt, kuznechikDecrypt } from "../../crypto/kuznechik";
import { MIN_GAMMA_SIZE } from "@hicaru/kuznechik.js";

describe("kuznechik_encrypt and kuznechik_decrypt", () => {
  const key = new Uint8Array(32).fill(0x01);
  const plaintext = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

  test("encrypt and decrypt should return original plaintext", () => {
    const ciphertext = kuznechikEncrypt(key, plaintext);
    const decrypted = kuznechikDecrypt(key, ciphertext);
    expect(decrypted).toEqual(plaintext);
  });

  test("ciphertext length should be plaintext length plus MIN_GAMMA_SIZE", () => {
    const ciphertext = kuznechikEncrypt(key, plaintext);
    expect(ciphertext.length).toBe(plaintext.length + MIN_GAMMA_SIZE);
  });

  test("encrypt and decrypt empty plaintext", () => {
    const emptyPlaintext = new Uint8Array(0);
    const ciphertext = kuznechikEncrypt(key, emptyPlaintext);
    expect(ciphertext.length).toBe(MIN_GAMMA_SIZE);
    const decrypted = kuznechikDecrypt(key, ciphertext);
    expect(decrypted).toEqual(emptyPlaintext);
  });

  test("decrypt with short ciphertext should throw error", () => {
    const shortCiphertext = new Uint8Array(MIN_GAMMA_SIZE - 1);
    expect(() => kuznechikDecrypt(key, shortCiphertext)).toThrow();
  });

  test("encrypt with invalid key size should throw error", () => {
    const invalidKey = new Uint8Array(31);
    expect(() => kuznechikEncrypt(invalidKey, plaintext)).toThrow();
  });

  test("decrypt with different key should not return original plaintext", () => {
    const differentKey = new Uint8Array(32).fill(0x02);
    const ciphertext = kuznechikEncrypt(key, plaintext);
    const decrypted = kuznechikDecrypt(differentKey, ciphertext);
    expect(decrypted).not.toEqual(plaintext);
  });
});

```

`zil-pay/__tests__/crypto/ntrup.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import { ntruDecrypt, ntruEncrypt, ntruKeysFromSeed } from "../../crypto/ntrup";
import { sha512 } from "../../crypto/sha512";
import { utils } from "aes-js";
import { params761 } from "@hicaru/ntrup.js";

describe("NTRU", () => {
  describe("keys", () => {
    it("converts Uint8Array to valid base64 string", async () => {
      let bytes = utils.utf8.toBytes("hello");
      const seed = await sha512(bytes);
      let { pk, sk } = ntruKeysFromSeed(seed);

      expect(utils.hex.fromBytes(pk.toBytes(params761))).toEqual(
        utils.hex.fromBytes([
          8, 8, 0, 21, 249, 176, 1, 159, 3, 97, 248, 156, 249, 223, 249, 50,
          249, 238, 5, 123, 8, 32, 253, 63, 1, 76, 252, 108, 2, 44, 1, 122, 2,
          158, 0, 24, 7, 17, 7, 210, 0, 117, 3, 125, 250, 219, 1, 248, 253, 226,
          6, 102, 3, 47, 6, 62, 250, 6, 6, 62, 6, 227, 249, 217, 7, 199, 7, 88,
          255, 106, 5, 54, 247, 90, 251, 22, 253, 243, 1, 218, 2, 190, 250, 15,
          252, 231, 3, 54, 255, 174, 5, 242, 6, 254, 0, 197, 248, 177, 252, 252,
          1, 201, 2, 197, 254, 197, 3, 227, 251, 68, 248, 92, 252, 12, 252, 233,
          6, 54, 250, 72, 250, 36, 0, 72, 4, 200, 247, 194, 255, 42, 6, 145,
          255, 87, 5, 40, 255, 27, 255, 224, 255, 112, 249, 2, 249, 133, 249,
          252, 0, 11, 253, 174, 252, 149, 7, 90, 6, 207, 255, 250, 254, 85, 4,
          97, 247, 214, 5, 126, 8, 87, 253, 232, 252, 97, 251, 255, 251, 73, 1,
          151, 8, 201, 4, 254, 3, 219, 254, 51, 248, 208, 3, 195, 6, 13, 2, 128,
          251, 217, 247, 245, 7, 130, 250, 43, 253, 100, 254, 180, 251, 6, 255,
          167, 253, 53, 248, 6, 249, 224, 8, 68, 254, 103, 248, 132, 8, 144, 2,
          107, 254, 163, 251, 201, 247, 14, 0, 116, 3, 99, 8, 191, 252, 4, 255,
          246, 250, 52, 247, 219, 248, 143, 8, 65, 4, 227, 0, 30, 253, 197, 254,
          105, 0, 187, 7, 201, 1, 120, 250, 79, 255, 65, 252, 28, 6, 134, 250,
          85, 0, 194, 3, 236, 8, 26, 248, 234, 6, 217, 3, 55, 250, 56, 5, 123,
          8, 55, 254, 73, 253, 120, 5, 214, 255, 33, 1, 51, 250, 185, 7, 241,
          249, 120, 254, 181, 8, 239, 5, 122, 8, 112, 247, 148, 254, 237, 251,
          27, 253, 132, 0, 15, 253, 100, 253, 194, 253, 52, 3, 105, 0, 95, 248,
          233, 250, 86, 254, 124, 7, 80, 1, 45, 6, 103, 6, 176, 2, 26, 252, 198,
          2, 188, 254, 89, 1, 223, 248, 144, 3, 169, 254, 195, 251, 34, 254,
          127, 249, 71, 254, 149, 251, 75, 5, 36, 5, 171, 3, 203, 8, 1, 255, 64,
          5, 160, 249, 126, 247, 53, 252, 253, 251, 197, 4, 29, 247, 52, 7, 176,
          1, 66, 5, 129, 250, 197, 254, 46, 255, 94, 5, 245, 1, 160, 253, 245,
          254, 200, 251, 158, 7, 128, 249, 138, 5, 159, 248, 79, 5, 130, 2, 239,
          1, 158, 0, 118, 6, 59, 252, 92, 7, 246, 0, 141, 0, 147, 2, 169, 0,
          115, 8, 119, 247, 220, 6, 90, 4, 12, 8, 232, 253, 242, 250, 216, 255,
          149, 2, 87, 248, 130, 248, 144, 255, 34, 247, 120, 1, 110, 248, 159,
          248, 255, 7, 182, 0, 243, 7, 130, 248, 88, 254, 239, 1, 135, 0, 45,
          249, 21, 7, 202, 255, 106, 252, 137, 8, 5, 7, 101, 0, 8, 2, 36, 1,
          142, 7, 236, 4, 251, 247, 254, 252, 106, 0, 220, 2, 101, 247, 94, 249,
          127, 3, 217, 0, 62, 0, 56, 248, 182, 250, 9, 250, 32, 253, 11, 4, 167,
          249, 123, 5, 201, 3, 26, 5, 184, 2, 154, 5, 17, 254, 81, 253, 62, 2,
          63, 8, 60, 253, 61, 5, 166, 250, 14, 255, 210, 3, 123, 8, 228, 8, 183,
          254, 126, 5, 151, 255, 121, 248, 22, 250, 126, 5, 202, 249, 113, 1, 9,
          250, 205, 255, 6, 5, 63, 6, 52, 7, 22, 1, 178, 249, 56, 6, 224, 1, 48,
          247, 57, 249, 173, 2, 215, 251, 239, 255, 137, 251, 106, 6, 131, 8,
          182, 248, 201, 5, 51, 7, 213, 253, 241, 8, 181, 6, 2, 252, 247, 247,
          113, 4, 55, 248, 150, 6, 61, 247, 157, 250, 19, 250, 153, 2, 193, 252,
          105, 255, 149, 2, 242, 7, 202, 3, 75, 253, 0, 7, 76, 3, 78, 6, 52, 1,
          245, 251, 121, 252, 47, 250, 186, 250, 11, 250, 232, 254, 223, 252,
          153, 0, 6, 249, 180, 3, 142, 4, 56, 247, 33, 249, 52, 251, 70, 6, 73,
          1, 49, 255, 220, 5, 174, 255, 191, 251, 208, 1, 125, 0, 215, 253, 81,
          247, 137, 247, 61, 1, 157, 255, 247, 247, 40, 255, 76, 251, 10, 247,
          194, 251, 158, 5, 157, 248, 218, 4, 253, 248, 196, 254, 97, 249, 170,
          4, 145, 6, 139, 247, 229, 7, 196, 251, 0, 255, 106, 255, 209, 2, 168,
          0, 187, 5, 86, 252, 132, 0, 199, 2, 112, 248, 231, 247, 253, 3, 155,
          250, 35, 252, 83, 3, 146, 8, 212, 3, 174, 250, 121, 3, 207, 255, 130,
          254, 138, 4, 247, 249, 159, 0, 236, 249, 193, 249, 167, 5, 48, 250,
          237, 249, 8, 8, 77, 250, 238, 0, 117, 249, 60, 7, 38, 1, 13, 5, 206,
          248, 213, 2, 240, 6, 127, 248, 231, 1, 238, 250, 192, 6, 210, 248,
          156, 8, 66, 6, 93, 7, 70, 2, 227, 247, 125, 0, 226, 251, 11, 1, 119,
          252, 6, 1, 106, 6, 66, 255, 92, 253, 82, 0, 242, 2, 186, 254, 117, 2,
          155, 252, 137, 3, 180, 3, 93, 4, 231, 4, 35, 5, 160, 8, 47, 254, 75,
          1, 225, 251, 209, 252, 149, 0, 93, 252, 150, 7, 108, 254, 91, 0, 43,
          249, 207, 253, 181, 250, 8, 7, 140, 249, 246, 249, 199, 252, 154, 253,
          105, 248, 48, 252, 176, 5, 0, 253, 226, 3, 245, 1, 8, 253, 61, 0, 156,
          248, 30, 252, 20, 253, 254, 8, 23, 2, 217, 252, 59, 0, 159, 2, 239, 1,
          114, 249, 150, 248, 153, 3, 1, 252, 238, 8, 230, 249, 4, 252, 54, 248,
          187, 251, 126, 8, 116, 1, 72, 252, 192, 255, 212, 5, 220, 4, 164, 7,
          212, 253, 207, 2, 200, 6, 158, 3, 250, 251, 175, 0, 40, 250, 183, 250,
          96, 6, 38, 1, 163, 255, 125, 255, 167, 251, 10, 254, 84, 1, 249, 2,
          169, 250, 127, 5, 106, 247, 22, 4, 98, 3, 87, 250, 30, 248, 63, 247,
          41, 250, 35, 4, 8, 250, 34, 255, 45, 254, 124, 250, 75, 2, 108, 1,
          216, 251, 34, 2, 117, 3, 169, 252, 49, 251, 250, 7, 130, 255, 107,
          252, 81, 252, 83, 2, 30, 7, 243, 6, 202, 253, 240, 249, 207, 3, 174,
          251, 131, 253, 64, 8, 247, 0, 151, 8, 168, 6, 58, 251, 210, 254, 117,
          5, 137, 251, 219, 6, 14, 255, 30, 249, 126, 5, 90, 249, 244, 251, 165,
          248, 228, 3, 122, 7, 56, 8, 92, 0, 29, 1, 130, 1, 46, 252, 28, 254,
          72, 254, 45, 255, 228, 1, 78, 253, 53, 247, 14, 4, 94, 3, 66, 3, 109,
          8, 55, 3, 124, 251, 135, 254, 105, 249, 178, 7, 125, 7, 2, 2, 181, 4,
          27, 251, 11, 4, 106, 3, 166, 253, 74, 250, 46, 247, 189, 8, 93, 254,
          58, 247, 63, 3, 33, 247, 190, 250, 164, 250, 40, 253, 219, 255, 111,
          252, 185, 4, 192, 248, 62, 248, 87, 7, 4, 7, 247, 1, 185, 252, 13, 2,
          202, 247, 27, 6, 201, 250, 34, 255, 12, 4, 138, 5, 239, 2, 65, 6, 105,
          254, 67, 3, 117, 3, 146, 2, 75, 254, 22, 254, 0, 247, 78, 247, 151,
          252, 42, 8, 74, 251, 172, 255, 1, 5, 122, 249, 160, 251, 223, 4, 255,
          252, 112, 5, 228, 8, 152, 255, 230, 2, 233, 252, 119, 2, 183, 6, 143,
          253, 10, 0, 84, 247, 213, 7, 192, 4, 26, 8, 146, 1, 69, 0, 11, 251,
          147, 1, 237, 250, 247, 251, 241, 255, 112, 5, 207, 2, 249, 252, 70,
          252, 168, 2, 160, 248, 132, 5, 97, 248, 221, 255, 213, 254, 67, 0, 22,
          248, 115, 8, 80, 8, 96, 2, 249, 2, 208, 255, 7, 253, 73, 253, 86, 0,
          227, 251, 213, 251, 11, 249, 130, 252, 220, 255, 254, 3, 152, 5, 74,
          8, 242, 250, 135, 1, 159, 254, 33, 8, 16, 250, 138, 250, 136, 6, 112,
          7, 208, 250, 221, 248, 209, 1, 244, 254, 15, 3, 242, 247, 166, 253,
          31, 255, 111, 253, 165, 254, 119, 251, 138, 248, 11, 249, 210, 2, 208,
          1, 241, 4, 120, 250, 179, 5, 96, 3, 217, 255, 43, 2, 56, 7, 122, 250,
          125, 249, 16, 253, 240, 1, 105, 0, 43, 0, 152, 1, 129, 254, 190, 3,
          230, 7, 197, 0, 59, 5, 19, 250, 169, 250, 26, 5, 238, 251, 190, 251,
          42, 3, 171, 254, 209, 5, 17, 254, 221, 2, 29, 249, 53, 3, 23, 252,
          150, 7, 106, 249, 160, 2, 23, 254, 250, 8, 233, 4, 108, 254, 30, 1,
          63, 250, 15, 5, 21, 0, 107, 6, 221, 248, 72, 1, 151, 248, 200, 7, 146,
          7, 228, 255, 67,
        ]),
      );

      expect(utils.hex.fromBytes(sk.toBytes(params761))).toEqual(
        utils.hex.fromBytes([
          37, 6, 97, 20, 8, 41, 102, 136, 0, 8, 89, 132, 66, 37, 69, 170, 66,
          10, 134, 85, 10, 165, 145, 68, 37, 166, 106, 104, 37, 149, 149, 106,
          36, 146, 169, 20, 9, 17, 6, 134, 150, 10, 137, 0, 148, 5, 86, 133, 85,
          85, 144, 69, 161, 98, 100, 130, 26, 41, 130, 132, 33, 68, 169, 149,
          137, 85, 24, 86, 81, 137, 33, 40, 38, 66, 137, 40, 0, 134, 81, 86,
          149, 96, 166, 2, 90, 137, 164, 164, 90, 17, 152, 130, 128, 166, 66,
          97, 128, 150, 16, 68, 69, 9, 0, 148, 73, 90, 6, 73, 65, 164, 66, 20,
          6, 73, 6, 160, 138, 133, 102, 72, 97, 5, 90, 160, 88, 146, 4, 24, 128,
          160, 10, 136, 128, 37, 4, 70, 74, 80, 64, 5, 101, 138, 86, 168, 130,
          160, 26, 64, 5, 97, 144, 9, 136, 164, 24, 80, 106, 153, 4, 1, 145,
          164, 82, 73, 101, 85, 66, 20, 1, 96, 26, 102, 25, 162, 17, 5, 137, 26,
          136, 152, 150, 65, 102, 165, 90, 73, 69, 104, 161, 36, 0, 90, 100, 74,
          85, 98, 165, 70, 166, 85, 21, 90, 22, 85, 85, 134, 97, 84, 86, 149,
          98, 24, 153, 85, 69, 84, 149, 85, 89, 69, 82, 105, 64, 89, 130, 106,
          89, 90, 149, 149, 86, 153, 137, 133, 102, 90, 69, 73, 153, 68, 84,
          102, 68, 37, 133, 85, 25, 68, 97, 101, 85, 85, 81, 85, 85, 66, 100,
          68, 81, 85, 21, 85, 37, 64, 84, 132, 148, 101, 66, 101, 86, 21, 82,
          101, 85, 101, 89, 22, 101, 149, 37, 102, 85, 81, 101, 149, 145, 86,
          66, 85, 22, 89, 101, 5, 6, 128, 85, 85, 89, 153, 86, 21, 86, 25, 25,
          21, 101, 88, 133, 149, 89, 165, 165, 145, 153, 21, 145, 130, 81, 145,
          38, 101, 88, 89, 85, 102, 89, 85, 89, 65, 149, 86, 85, 102, 101, 85,
          68, 101, 85, 105, 149, 149, 102, 149, 81, 100, 104, 85, 149, 85, 25,
          97, 21, 86, 89, 1, 40, 69, 89, 69, 90, 85, 149, 146, 86, 40, 149, 134,
          82, 21, 168, 69, 4, 84, 85, 149, 69, 69, 73, 89, 138, 1,
        ]),
      );
    });
  });

  it("test bytes encrypt/decrypt", async () => {
    let bytes = utils.utf8.toBytes("hello");
    const seed = await sha512(bytes);
    let { pk, sk } = ntruKeysFromSeed(seed);
    const ciphertext = ntruEncrypt(pk, bytes);
    const decrypted = ntruDecrypt(sk, ciphertext);

    expect(decrypted).toEqual(bytes);
  });
});

```

`zil-pay/__tests__/crypto/number.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import {
  uint8ArrayToBigIntBigEndian,
  uint8ArrayToBigIntLittleEndian,
} from "../../crypto/number";
import { randomBytes } from "../../crypto/random";

describe("uint8ArrayToBigIntBigEndian", () => {
  it("should correctly convert a non-empty big-endian Uint8Array to bigint", () => {
    const length = 8;
    const byteArray = randomBytes(length);
    const bigIntValue = uint8ArrayToBigIntBigEndian(byteArray);
    expect(typeof bigIntValue).toBe("bigint");
  });

  it("should return 0n for an empty Uint8Array", () => {
    const emptyArray = new Uint8Array([]);
    expect(uint8ArrayToBigIntBigEndian(emptyArray)).toBe(0n);
  });
});

describe("uint8ArrayToBigIntLittleEndian", () => {
  it("should correctly convert a non-empty little-endian Uint8Array to bigint", () => {
    const length = 8;
    const byteArray = randomBytes(length);
    const littleEndianArray = new Uint8Array([...byteArray].reverse());
    const bigIntValue = uint8ArrayToBigIntLittleEndian(littleEndianArray);
    expect(typeof bigIntValue).toBe("bigint");
  });

  it("should return 0n for an empty Uint8Array", () => {
    const emptyArray = new Uint8Array([]);
    expect(uint8ArrayToBigIntLittleEndian(emptyArray)).toBe(0n);
  });
});

```

`zil-pay/__tests__/crypto/pbkdf2.test.ts`:

```ts
import { test, expect, vi } from "vitest";
import { pbkdf2 } from "../../crypto/pbkdf2";
import { ShaAlgorithms } from "../../config/pbkdf2";
import { utils } from "aes-js";

test("pbkdf2 calls Web Crypto API correctly with default SHA-512", async () => {
  const password = new TextEncoder().encode("password");
  const salt = new TextEncoder().encode("salt");
  const iterations = 1000;
  const result = await pbkdf2(password, salt, iterations, ShaAlgorithms.Sha512);
  const shouldBe =
    "afe6c5530785b6cc6b1c6453384731bd5ee432ee549fd42fb6695779ad8a1c5bf59de69c48f774efc4007d5298f9033c0241d5ab69305e7b64eceeb8d834cfec";

  expect(utils.hex.fromBytes(result)).toBe(shouldBe);
});

```

`zil-pay/__tests__/crypto/pubkey.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import { fromZILPrivateKey } from "../../crypto/zilliqa/pubkey";
import { utils } from "aes-js";

describe("test cases pubkey", () => {
  it("test zil private key to pub key", async () => {
    let sk = Uint8Array.from(
      utils.hex.toBytes(
        "3a649fbe8198729669affd1e9ae93e9e81fd25b71ea5f79792bec9fa6ac9ed92",
      ),
    );
    let pk = fromZILPrivateKey(sk);
    let pkHex = utils.hex.fromBytes(pk);

    expect(pkHex).toEqual(
      "025ded2f80f60d6c98d16ea5e1b2787427f44b8fcf11b5cacd56911e6c0e4c184c",
    );
  });
});

```

`zil-pay/__tests__/crypto/random.test.ts`:

```ts
import { test, expect, vi } from "vitest";
import { randomBytes } from "../../crypto/random";

test("randomBytes generates a non-zero Uint8Array of the specified length", () => {
  const length = 16;
  const result = randomBytes(length);

  expect(result).toBeInstanceOf(Uint8Array);
  expect(result.length).toBe(length);

  const zeroArray = new Uint8Array(length);
  expect(result).not.toEqual(zeroArray);

  expect(result.some((byte) => byte !== 0)).toBe(true);
});

test("randomBytes uses window.crypto.getRandomValues to seed the ChaCha20 RNG", () => {
  const spyGetRandomValues = vi.spyOn(globalThis.crypto, "getRandomValues");
  const length = 8;

  randomBytes(length);

  expect(spyGetRandomValues).toHaveBeenCalled();
  spyGetRandomValues.mockRestore();
});

```

`zil-pay/__tests__/crypto/schnorr.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import { signInner, verify } from "../../crypto/zilliqa/schnorr";
import { utils } from "aes-js";
import { uint8ArrayToBigIntBigEndian } from "../../crypto/number";

describe("Schnorr Signature Tests", () => {
  it("should sign and verify correctly", async () => {
    const cases: [
      message: string,
      publicKey: string,
      secretKey: string,
      k: string,
      r: string,
      s: string,
    ][] = [
      [
        "A7F1D92A82C8D8FE434D98558CE2B347171198542F112D0558F56BD68807999248336241F30D23E55F30D1C8ED610C4B0235398184B814A29CB45A672ACAE548E9C5F1B0C4158AE59B4D39F6F7E8A105D3FEEDA5D5F3D9E45BFA6CC351E220AE0CE106986D61FF34A11E19FD3650E9B7818FC33A1E0FC02C44557AC8AB50C9B2DEB2F6B5E24C4FDD9F8867BDCE1FF261008E7897970E346207D75E47A158298E5BA2F56246869CC42E362A02731264E60687EF5309D108534F51F8658FB4F080B7CB19EE9AEBD718CC4FA27C8C37DFC1ADA5D133D13ABE03F021E9B1B78CCBD82F7FF2B38C6D48D01E481B2D4FAF7171805FD7F2D39EF4C4F19B9496E81DAB8193B3737E1B27D9C43957166441B93515E8F03C95D8E8CE1E1864FAAD68DDFC5932130109390B0F1FE5CA716805F8362E98DCCAADC86ADBED25801A9A9DCFA6264319DDAFE83A89C51F3C6D199D38DE10E660C37BE872C3F2B31660DE8BC95902B9103262CDB941F77376F5D3DBB7A3D5A387797FC4819A035ECA704CEDB37110EE7F206B0C8805AAEBF4963E7C4708CE8D4E092366E71792A8A3B2BBCDEE321B3E15380C541EF0930888969F7457AFE18588826A419D58311C1784B5484EECDB393F6A0ACA11B91DF0866B500B8DEE501FD7EB9BCE09A17D74124B4605ADFC0777BED9816D8D7E8488544A18D8045CB3283B0A752B881B5F500FADB59010E63D",
        "039E43C9810E6CC09F46AAD38E716DAE3191629534967DC457D3A687D2E2CDDC6A",
        "0F494B8312E8D257E51730C78F8FE3B47B6840C59AAAEC7C2EBE404A2DE8B25A",
        "532B2267C4A3054F380B3357339BDFB379E88366FE61B42ACA05F69BC3F6F54E",
        "3AF3D288E830E96FF8ED0769F45ABDA774CD989E2AE32EF9E985C8505F14FF98",
        "E191EB14A70B5B53ADA45AFFF4A04578F5D8BB2B1C8A22985EA159B53826CDE7",
      ],
      [
        "1B664F8BDA2DBF33CB6BE21C8EB3ECA9D9D5BF144C08E9577ED0D1E5E560875109B340980580473DBC2E689A3BE838E77A0A3348FE960EC9BF81DA36F1868CA5D24788FA4C0C778BF0D12314285495636516CF40861B3D737FD35DBB591C5B5D25916EB1D86176B14E0E67D2D03957F0CF6C87834BF328540588360BA7C7C5F88541634FB7BADE5F94FF671D1FEBDCBDA116D2DA779038ED7679896C29198B2657B58C50EA054F644F4129C8BA8D8D544B727633DD40754398046796E038626FEF9237CE5B615BC08677EE5ABFBD85F73F7F8868CB1B5FBA4C1309F16061AA133821FBE2A758D2BBE6AA040A940D41B7D3B869CEE945150AA4A40E6FF719EEC24B2681CD5CE06B50273436584066046656D5EFED7315759189D68815DDB9E5F8D7FD53B6EC096616A773B9421F6704CED36EF4E484BA0C6C5A4855C71C33A54AC82BE803E5CFD175779FC444B7E6AA9001EEFABEBC0CF99754887C7B0A27AFDDC415F8A02C5AF1EFEA26AD1E5D92B1E29A8FAF5B2186C3094F4A137BCFAA65D7B274214DB64C86F3085B24938E1832FB310A6F064181E298D23062ABC817BA173023C8C04C5C3A1ECBF4AF72372B381FF69865C8F0E3C70B931C45A7419B3C441842EBFACC3D070AC3B433CD120B6E85B72DADCF40B23B173C34F6BE1B1901F6621F1497B085CF8E999D986EF8FF3A889A0238979983A8686F69E10EF9249A87",
        "0245DC2911EDC02F2774E0A40FBEB0112EA60BF513F9EC50889D59FC94C97EC18F",
        "8D566BB87EF69FFDA622E0A59FBAAFE57F486CE65844343A5D9B97DE9C4F619A",
        "948AFFFF6E068CA2F2757BFD6085D6E4C3084B038E5533C5927ECB19EA0D329C",
        "DFEE66E2C4799E73F0F778126A23032608408C27C2E7B3FA45A626BB9BDEB53C",
        "75445CC9DBFE4E7BC64E020FA22CACFA4C40D5AA84DD6AEF661564FCA9746C40",
      ],
      [
        "3444C8501F19A8A78670F748FA401C4020AE086D7157A3837EC721DEF0D6E095928C5B78ED9B95560CE33D5B22778BE66DCEF2D21878D481DFF41A4DEDCAFDCAEAB4BD78629D7EC40FD26F1DD954CA84A3B53B84E9903056E840837A1390F37BB8ADE799DAC1E465D811916547EB4B6A163082E9833634A1224C54F681B8DC70A792C0CB4671D4970CCC80E2168CE920CC8FA07B1F90E9898D16019913ED5B8EE8A8DE7AB6F7895601FD20E49FD73E6F5D24C0D97E67871539F0E4E32CCB6677AFF03356D1F3790945E94039E51A63B3C840B74E3053D95CA71C0D3AC20A9065828D30AB5BFB6188A8F291FB1EB4E1EED03E2F5F558C00D8E3084120DEEB8BFE908429B36A896A45D624E79372CC18DF37DB2D20C9726D4FEF7BECF220138B53BC54C2DA461A9955AFF33F2F93DD96464BF3E883FC5750BDBE79BC2F82427F41DE42659AC4B111D7CEF8085003469DF8C9D3541480C6841707CE4C8F3D003AF982AD35C2733D0FA3B1EE52A6DAB36203D99AEC179A565B5050F480235C3BC560AA28EF5DD5525BFA254E584A86FDBD4BCC5B56551BAD00255CB72F806D7F3C533321B0864007AFBA4E0FF9638517FA8D788F52766F3A28C57C428BFDD4234AA760CE8044DF1E1FBA58E8B1D9C5A79D2AC4592FC31702F7E83351D2160C09C5CEA554F2C93A61C040E225612DF2B550900B097E18638350E3BA15C9AD53CE1861",
        "02237627FE7374061FBD80AEA842DCE76D9206F0DDC7B319F3B30FA75DBD4F009A",
        "009755F442D66585A10B80A49850C77764AD029D1BEA73F4DA45AB331306E6E5",
        "2D78C77B736AD0A00FDF60695C01E96520656C13DC890A5B864672C6CED1C49A",
        "4B73D4D919D7B4DEF330391899EA02023851CABE044E34E18EAE3E10588CECCD",
        "D5DE85C4BDEA5910DC36AEF5660774D65291322C1E87FDA0D00C864E8C5FED29",
      ],
    ];

    for (const [
      messageHex,
      publicKeyHex,
      secretKeyHex,
      kHex,
      expectedR,
      expectedS,
    ] of cases) {
      const message = utils.hex.toBytes(messageHex);
      const publicKey = utils.hex.toBytes(publicKeyHex);
      const secretKey = utils.hex.toBytes(secretKeyHex);
      const kBytes = utils.hex.toBytes(kHex);
      const k = uint8ArrayToBigIntBigEndian(kBytes);

      const signature = await signInner(k, message, secretKey);

      expect(signature?.r.toString(16)).toBe(expectedR.toLowerCase());
      expect(signature?.s.toString(16)).toBe(expectedS.toLowerCase());

      const isValid = await verify(message, publicKey, signature!);
      expect(isValid).toBe(true);
    }
  });
});

```

`zil-pay/__tests__/crypto/sha256.test.ts`:

```ts
import { test, expect } from "vitest";
import { sha256 } from "../../crypto/sha256";
import { utils } from "aes-js";

test('sha256 hashes "test" correctly', async () => {
  const input = new TextEncoder().encode("test");
  const hash = await sha256(input);
  const hexString = utils.hex.fromBytes(hash);

  expect(hexString).toBe(
    "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
  );
});

```

`zil-pay/__tests__/crypto/sha512.test.ts`:

```ts
import { test, expect } from "vitest";
import { sha512 } from "../../crypto/sha512";
import { utils } from "aes-js";

test('sha512 hashes "test" correctly', async () => {
  const input = new TextEncoder().encode("test");
  const buffer = await sha512(input);
  const hashArray = new Uint8Array(buffer);
  const hexString = utils.hex.fromBytes(hashArray);
  expect(hexString).toBe(
    "ee26b0dd4af7e749aa1a8ee3c10ae9923f618980772e473f8819a5d4940e0db27ac185f8a0e1d5f84f88bc887fd67b143732c304cc5fa9ad8e6f57f50028a8ff",
  );
});

```

`zil-pay/__tests__/crypto/tx.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import {
  TransactionRequest,
  TransactionReceipt,
  TransactionMetadata,
} from "../../crypto/tx";
import { KeyPair } from "../../crypto/keypair";
import { ZILLIQA, ETHEREUM } from "../../config/slip44";
import { ZILTransactionRequest } from "../../crypto/zilliqa_tx";
import { Transaction, weieth, weigwei } from "micro-eth-signer";
import { hexToUint8Array } from "../../lib/utils/hex";

describe("TransactionRequest and TransactionReceipt", () => {
  const metadata: TransactionMetadata = {
    chainHash: 123,
    info: "Test Transaction",
  };

  it("should correctly sign and verify a Scilla transaction", async () => {
    const keypair = await KeyPair.generate(ZILLIQA);
    const toAddr = hexToUint8Array(
      "0x1234567890123456789012345678901234567890",
    );
    const scillaTxReq = new ZILTransactionRequest(
      333,
      1n,
      2000000000n,
      100n,
      toAddr,
      1000000000000n,
    );
    const request = new TransactionRequest(metadata, scillaTxReq);
    const receipt = await request.sign(keypair);

    expect(receipt).toBeInstanceOf(TransactionReceipt);
    expect(receipt.scilla).toBeDefined();
    expect(receipt.evm).toBeUndefined();

    const isValid = await receipt.verify();
    expect(isValid).toBe(true);
  });

  it("should correctly sign and verify an EVM transaction", async () => {
    const keypair = await KeyPair.generate(ETHEREUM);
    const evmTx = Transaction.prepare({
      to: "0xAEC7595CA9A57be828493bb73f07fA335a85B41d",
      value: weieth.decode("1.1"),
      maxFeePerGas: weigwei.decode("100"),
      nonce: 0n,
    });
    const request = new TransactionRequest(metadata, undefined, evmTx);
    const receipt = await request.sign(keypair);

    expect(receipt).toBeInstanceOf(TransactionReceipt);
    expect(receipt.evm).toBeDefined();
    expect(receipt.scilla).toBeUndefined();

    const isValid = await receipt.verify();
    expect(isValid).toBe(true);
  });

  it("should throw an error when signing with an invalid transaction type", async () => {
    const keypair = await KeyPair.generate(ETHEREUM);
    const request = new TransactionRequest(metadata, undefined, undefined);

    await expect(request.sign(keypair)).rejects.toThrow("Invlid tx type");
  });

  it("should throw an error when verifying an invalid transaction type", async () => {
    const receipt = new TransactionReceipt(metadata, undefined, undefined);

    await expect(receipt.verify()).rejects.toThrow("Invlid tx type");
  });
});

```

`zil-pay/__tests__/crypto/word_list.ts`:

```ts
export const WORD_LIST = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
];

```

`zil-pay/__tests__/crypto/zilliqa_tx.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import {
  ZILTransactionRequest,
  ZILTransactionReceipt,
} from "../../crypto/zilliqa_tx";
import { utils } from "aes-js";
import { KeyPair } from "../../crypto/keypair";
import { ZILLIQA } from "../../config/slip44";
import { encodeProtoTransactionCoreInfo } from "../../crypto/proto/zq1";

const CHAIN_ID = 42;
const SHOULD_BE_BYTES =
  "088180a80110011a14ebd8b370dddb636faf641040d2181c55190840fb22230a2103150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da2a120a100000000000000000000000000000000032120a100000000000000000000000000000000038a08d06";

describe("ZILTransaction encoding", () => {
  it("should encode Zilliqa transaction correctly", async () => {
    const SK = Uint8Array.from(
      utils.hex.toBytes(
        "e93c035175b08613c4b0251ca92cd007026ca032ba53bafa3c839838f8b52d04",
      ),
    );
    const keypair = await KeyPair.fromPrivateKey(SK, ZILLIQA);
    const toAddr = Uint8Array.from(
      utils.hex.toBytes("EBd8b370Dddb636FAF641040D2181c55190840fb"),
    );

    const txReq = new ZILTransactionRequest(
      CHAIN_ID,
      BigInt(1),
      BigInt(2000) / BigInt(10 ** 6),
      BigInt(100000),
      toAddr,
      BigInt(1) / BigInt(10 ** 6),
      new Uint8Array(),
      new Uint8Array(),
    );

    const txBytes = txReq.encode(keypair.pubKey);
    const encodedHex = utils.hex.fromBytes(txBytes);
    expect(encodedHex).toBe(SHOULD_BE_BYTES);

    const txReceipt = await txReq.sign(keypair);
    const proto = txReceipt.toProto();
    const restoredBytes = encodeProtoTransactionCoreInfo(proto);
    const restoredHex = utils.hex.fromBytes(restoredBytes);

    expect(restoredHex).toBe(SHOULD_BE_BYTES);
  });
});

describe("ZILTransactionReceipt verify", () => {
  it("should verify a valid signature", async () => {
    const SK = Uint8Array.from(
      utils.hex.toBytes(
        "e93c035175b08613c4b0251ca92cd007026ca032ba53bafa3c839838f8b52d04",
      ),
    );
    const keypair = await KeyPair.fromPrivateKey(SK, ZILLIQA);
    const toAddr = Uint8Array.from(
      utils.hex.toBytes("EBd8b370Dddb636FAF641040D2181c55190840fb"),
    );

    const txReq = new ZILTransactionRequest(
      CHAIN_ID,
      BigInt(1),
      BigInt(2000) / BigInt(10 ** 6),
      BigInt(100000),
      toAddr,
      BigInt(1) / BigInt(10 ** 6),
      new Uint8Array(),
      new Uint8Array(),
    );

    const txReceipt = await txReq.sign(keypair);
    const isValid = await txReceipt.verify();

    expect(isValid).toBe(true);
  });

  it("should fail verification with an invalid signature", async () => {
    const SK = Uint8Array.from(
      utils.hex.toBytes(
        "e93c035175b08613c4b0251ca92cd007026ca032ba53bafa3c839838f8b52d04",
      ),
    );
    const keypair = await KeyPair.fromPrivateKey(SK, ZILLIQA);
    const toAddr = Uint8Array.from(
      utils.hex.toBytes("EBd8b370Dddb636FAF641040D2181c55190840fb"),
    );

    const txReq = new ZILTransactionRequest(
      CHAIN_ID,
      BigInt(1),
      BigInt(2000) * BigInt(10 ** 6),
      BigInt(100000),
      toAddr,
      BigInt(1) * BigInt(10 ** 12),
      new Uint8Array(),
      new Uint8Array(),
    );

    const txReceipt = await txReq.sign(keypair);

    // Create an invalid signature by modifying the original
    const invalidSignature = new Uint8Array(txReceipt.signature);
    invalidSignature[0] ^= 0xff; // Flip first byte

    const invalidReceipt = new ZILTransactionReceipt(
      txReceipt.version,
      txReceipt.nonce,
      txReceipt.gasPrice,
      txReceipt.gasLimit,
      txReceipt.toAddr,
      txReceipt.amount,
      txReceipt.pubKey,
      txReceipt.code,
      txReceipt.data,
      invalidSignature,
      txReceipt.priority,
    );

    const isValid = await invalidReceipt.verify();
    expect(isValid).toBe(false);
  });
});

```

`zil-pay/__tests__/data.ts`:

```ts
import { ChainConfig } from "../background/storage/chain";

export const WORDS =
  "rule hard brush glare magic east glimpse tank junk will media submit";
export const PASSWORD = "iA3J&UKNRSp7Y3&yhzo68gjib9L&Vh*W1mT1zS6T";
export const KEY =
  "717da2dd3d2ca78461d814c0bfbdbaf3e676be396585f83a0fbee04e89e0a64d";
export const IMPORTED_KEY =
  "7e5727ce710c2e96c152a7a1e5c571c6695539866b407a578575981e92177ae4";
export const STORAGE_V2 = {
  "address-format": "bech32",
  blocknumber: "0",
  connect: "undefined",
  "connection-list": "[]",
  contacts: "[]",
  "phishing-detection": "1",
  "popup-enabled": "1",
  "rate-of-currencies": '{"usd":0.01126979,"btc":1.07634e-7,"eth":0.0000045}',
  "selected-currency": "usd",
  "selected-local": "auto",
  "ssn-list":
    '{"selected":0,"list":[{"address":"0x0000000000000000000000000000000000000000","api":"https://api.zilliqa.com","id":1,"name":"Main","ok":true,"time":420}]}',
  theme: "light",
  time_before_lock: "3",
  "tokens-list/mainnet":
    '[{"base16":"0x0000000000000000000000000000000000000000","bech32":"zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz","decimals":12,"name":"Zilliqa","symbol":"ZIL","rate":1},{"base16":"0xfbd07e692543d3064b9cf570b27faabfd7948da4","bech32":"zil1l0g8u6f9g0fsvjuu74ctyla2hltefrdyt7k5f4","decimals":18,"name":"ZilPay wallet","symbol":"ZLP","rate":2.7688998049}]',
  vault:
    "U2FsdGVkX19+DrC9DG/qvYEC6koZfMhpQl6K4eVH5GSE1qXyn4vENND7zZFNT5R4yZM/45MiWMTw+Olu2Va948mputTGoby3VfmNmIm1uiVgRYt6hycdMiUBFuWs0KqN",
  "wallet-identities":
    '{"selectedAddress":1,"identities":[{"name":"Account 0","bech32":"zil1ntrynx04349sk6py7uyata03gka6qswg7um95y","index":0,"base16":"0x9ac64999F58d4b0B6824f709D5f5f145BBA041c8","type":2,"pubKey":"0316f2d913f13c6aa15ad5c80b58464d25b6363a1b9d997260e8061977a3f43e10","zrc2":{"0x0000000000000000000000000000000000000000":"0","0xfbd07e692543d3064b9cf570b27faabfd7948da4":"0"},"nft":{}},{"name":"Imported 0","bech32":"zil14at57zaj4pe3tuy734usy2xnlquapkd4d0ne43","index":0,"base16":"0xaf574f0BB2a87315F09e8d790228D3F839D0d9B5","type":1,"pubKey":"0232970d0472220180c1779610f0ffae5a1ad79048b4f01f366c52d99317534024","privKey":"U2FsdGVkX1+E7PpB7lTzKwR7J0aWq1xJWMTNRrxo3Vd76jcnA7GmMTS9DtkRQCkAWJdYemsAVH90lMRGzLFOYPYxd6UhNsPWiGD7MlNxvfHtRdL64G+tdULtICMXB23F","zrc2":{"0x0000000000000000000000000000000000000000":"0","0xfbd07e692543d3064b9cf570b27faabfd7948da4":"0"},"nft":{}}]}',
};
export const STORAGE_V3 = {
  "address-format": "bech32",
  "badge-counter": "0",
  blocknumber: "0",
  "confirm/mainnet": "[]",
  connect: "undefined",
  "connection-list": "[]",
  contacts: "[]",
  "dex-proto":
    '{"liquidityFee":0,"protocolFee":0,"slippage":1,"blocks":10,"rewarded":"0x0000000000000000000000000000000000000000","contract":{"mainnet":"0x30dfe64740ed459ea115b517bd737bbadf21b838","testnet":"0xb0c677b5ba660925a8f1d5d9687d0c2c379e16ee","private":""}}',
  "guard-configuration": "SHA-512:442368",
  "phishing-detection": "1",
  "popup-enabled": "1",
  "rate-of-currencies":
    '{"aed":0.04247757,"amd":4.44,"ars":13.71,"aud":0.01781949,"bdt":1.41,"bhd":0.00435975,"brl":0.065154,"btc":1.099e-7,"cad":0.01581764,"chf":0.00947171,"clp":10.85,"cny":0.083074,"cop":47.37,"crc":5.88,"czk":0.251386,"dkk":0.075591,"dop":0.682575,"eth":0.0000044,"eur":0.01013389,"gbp":0.0085369,"gel":0.0317456,"gtq":0.088835,"hkd":0.090732,"hnl":0.300787,"huf":4.08,"idr":188.38,"ils":0.04029691,"inr":0.99304,"jpy":1.65,"kes":1.5,"krw":15.73,"lbp":1035.62,"lkr":3.46,"ltc":0.00013082,"mmk":24.26,"mxn":0.222062,"myr":0.04908136,"ngn":18.22,"nok":0.116999,"nzd":0.01918035,"pen":0.04188673,"php":0.643042,"pkr":3.26,"pln":0.04338162,"ron":0.05104161,"rub":0.917076,"sar":0.0433747,"sek":0.110942,"sgd":0.01488506,"svc":0.101144,"thb":0.377194,"try":0.454718,"twd":0.346177,"uah":0.479191,"usd":0.01156488,"vnd":301.88,"xrp":0.00524131,"zar":0.206394}',
  "selected-currency": "btc",
  "selected-local": "auto",
  "ssn-list":
    '{"selected":0,"list":[{"address":"0x0000000000000000000000000000000000000000","api":"https://api.zilliqa.com","id":1,"name":"Main","ok":true,"time":420}]}',
  theme: "light",
  time_before_lock: "3",
  "tokens-list/mainnet":
    '[{"base16":"0x0000000000000000000000000000000000000000","bech32":"zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz","decimals":12,"name":"Zilliqa","symbol":"ZIL","rate":1,"pool":[]},{"base16":"0xfbd07e692543d3064b9cf570b27faabfd7948da4","bech32":"zil1l0g8u6f9g0fsvjuu74ctyla2hltefrdyt7k5f4","decimals":18,"name":"ZilPay wallet","symbol":"ZLP","rate":2.7915277475,"pool":["65618957804322222","23506468048851034758203"]},{"base16":"0xe6f14afc8739a4ead0a542c07d3ff978190e3b92","bech32":"zil1umc54ly88xjw4599gtq860le0qvsuwuj72s246","decimals":12,"name":"StZIL","symbol":"stZIL","rate":1.2063766095,"pool":["363937420859731210","301678114446274419"]}]',
  vault:
    "ZGM1ODdhZGI0YWVhY2E3Njk4MDJlYTEyMzMxOGY5OGZlMjMxMzNhYzY1ZDc4ZTUzYjFiZmI0YTYxNDY5OTAzZGQ2NDAzNWFjZmQzNGVkODZjYzc3NTc0NWE4NjI4N2Y3NWI0OTdiYzk4OGFjMzg0MDM5MWY5MGJjY2FmMjllNmU4NmEyMjJkMy8zODIzZWMwNmEyMDA4ZDZhODcyMTY3MzAwMzlmZTBlYw==",
  "wallet-identities":
    '{"selectedAddress":1,"identities":[{"name":"Account 0","bech32":"zil1ntrynx04349sk6py7uyata03gka6qswg7um95y","index":0,"base16":"0x9ac64999F58d4b0B6824f709D5f5f145BBA041c8","type":2,"pubKey":"0316f2d913f13c6aa15ad5c80b58464d25b6363a1b9d997260e8061977a3f43e10","zrc2":{"0x0000000000000000000000000000000000000000":"0","0xfbd07e692543d3064b9cf570b27faabfd7948da4":"0","0xe6f14afc8739a4ead0a542c07d3ff978190e3b92":"0"},"nft":{}},{"name":"Imported 0","bech32":"zil14at57zaj4pe3tuy734usy2xnlquapkd4d0ne43","index":0,"base16":"0xaf574f0BB2a87315F09e8d790228D3F839D0d9B5","type":1,"pubKey":"0232970d0472220180c1779610f0ffae5a1ad79048b4f01f366c52d99317534024","privKey":"OGRmNzA0YzAzM2Q4ZmVhODM4ODFlMmYyZjI3ZDIyMzQ4NTM1ZmZiZDVjNDMzNmM1MDBjZWM4YzU4ZDg2YWU5Yi82NTVkYWRjZWZkNDZiODEyOWRhYzZhZTUxMjE2NTdiMQ==","zrc2":{"0x0000000000000000000000000000000000000000":"0","0xfbd07e692543d3064b9cf570b27faabfd7948da4":"0","0xe6f14afc8739a4ead0a542c07d3ff978190e3b92":"0"},"nft":{}}]}',
};
export const EXTENSION_ID = "klnaejjgbibmhlephnhpmaofohgkpgkd";

export const CHAINS = JSON.parse(`[
  {
    "name": "Zilliqa proto",
    "chain": "ZIL",
    "logo": "https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/%{shortName}%/chain/%{dark,light}%.svg",
    "rpc": [
      "https://api.zq2-protomainnet.zilliqa.com"
    ],
    "features": [],
    "ftokens": [
      {
        "native": true,
        "logo": "https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/%{contract_address}%/%{dark,light}%.webp",
        "addr": "0x0000000000000000000000000000000000000000",
        "name": "Zilliqa",
        "symbol": "ZIL",
        "decimals": 18
      },
      {
        "native": true,
        "logo": "https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/%{contract_address}%/%{dark,light}%.webp",
        "addr": "zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz",
        "name": "Zilliqa Scilla",
        "symbol": "ZIL",
        "decimals": 12
      }
    ],
    "chainIds": [32770, 2],
    "infoURL": "https://www.zilliqa.com/",
    "testnet": true,
    "shortName": "zilliqa",
    "slip44": 313,
    "explorers": [
      {
        "name": "Otterscan",
        "icon": "https://explorer.zq2-protomainnet.zilliqa.com/assets/otter-DYFeLtFi.png",
        "url": "https://explorer.zq2-protomainnet.zilliqa.com",
        "standard": "EIP3091"
      }
    ]
  },
  {
    "name": "Binance testnet",
    "chain": "BNB",
    "logo": "https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/%{shortName}%/chain/%{dark,light}%.svg",
    "rpc": [
      "https://data-seed-prebsc-1-s1.binance.org:8545/",
      "https://data-seed-prebsc-2-s1.binance.org:8545/",
      "http://data-seed-prebsc-1-s2.binance.org:8545/",
      "http://data-seed-prebsc-2-s2.binance.org:8545/",
      "https://data-seed-prebsc-1-s3.binance.org:8545/",
      "https://data-seed-prebsc-2-s3.binance.org:8545/"
    ],
    "features": [
      "EIP1559",
      "EIP155",
      "EIP4844"
    ],
    "ftokens": [
      {
        "native": true,
        "logo": "https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/bnbchain/%{contract_address}%/%{dark,light}%.webp",
        "addr": "0x0000000000000000000000000000000000000000",
        "name": "BinanceCoin",
        "symbol": "BNB",
        "decimals": 18
      }
    ],
    "infoURL": "https://www.bnbchain.org",
    "shortName": "bnbchain",
    "testnet": true,
    "chainIds": [97, 0],
    "slip44": 60,
    "explorers": [
      {
        "name": "BscScan",
        "url": "https://testnet.bscscan.com",
        "icon": "https://bscscan.com/assets/bsc/images/svg/brandassets/logo-symbol.svg",
        "standard": "EIP3091"
      }
    ]
  },
  {
    "name": "Sepolia",
    "logo": "https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/ethereum/chain/%{dark,light}%.svg",
    "chain": "ETH",
    "rpc": [
      "https://sepolia.infura.io/v3/b6bf7d3508c941499b10025c0776eaf8",
      "https://rpc-sepolia.rockx.com",
      "https://rpc.sepolia.dev"
    ],
    "features": [
      "EIP155",
      "EIP1559",
      "EIP4844"
    ],
    "ftokens": [
      {
        "native": true,
        "addr": "0x0000000000000000000000000000000000000000",
        "name": "Ethereum",
        "logo": "https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/bnbchain/%{contract_address}%/%{dark,light}%.webp",
        "symbol": "ETH",
        "decimals": 18
      }
    ],
    "testnet": true,
    "infoURL": "https://sepolia.dev/",
    "shortName": "ethereum",
    "chainIds": [11155111, 0],
    "slip44": 60,
    "explorers": [
      {
        "name": "Etherscan",
        "url": "https://sepolia.etherscan.io/",
        "icon": "https://etherscan.io/images/brandassets/etherscan-logo-circle.svg",
        "standard": "EIP3091"
      }
    ]
  }
]`);

export const ZERO_ADDR_BECH32 = "zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz";
export const ZERO_ADDR_HEX = "0x0000000000000000000000000000000000000000";

export const createZilliqaConfig = (): ChainConfig =>
  new ChainConfig({
    name: "Zilliqa",
    chain: "ZIL",
    logo: "",
    rpc: ["https://api.zilliqa.com"],
    features: [],
    chainIds: [1, 0],
    slip44: 313,
    explorers: [],
    fallbackEnabled: true,
    testnet: false,
    ftokens: [],
  });

export const createBscConfig = (): ChainConfig =>
  new ChainConfig({
    name: "Binance Smart Chain",
    chain: "BSC",
    logo: "",
    rpc: [
      "https://bsc-dataseed.bnbchain.org",
      "https://bsc-dataseed.nariox.org",
      "https://bsc-dataseed.defibit.io",
      "https://bsc-dataseed.ninicoin.io",
      "https://bsc.nodereal.io",
      "https://bsc-dataseed-public.bnbchain.org",
      "https://bnb.rpc.subquery.network/public",
    ],
    features: [155, 1559],
    chainIds: [56, 0],
    slip44: 60,
    explorers: [],
    fallbackEnabled: true,
    testnet: false,
    ftokens: [],
  });

export const createEthConfig = (): ChainConfig =>
  new ChainConfig({
    name: "Ethereum Mainnet",
    chain: "ETH",
    logo: "",
    rpc: [
      "https://eth.llamarpc.com",
      "https://eth-mainnet.nodereal.io/v1/1659dfb40aa24bbb8153a677b98064d7",
      "https://eth.rpc.blxrbdn.com",
      "https://mainnet.gateway.tenderly.co",
      "https://1rpc.io/eth",
    ],
    features: [155, 1559],
    chainIds: [1, 0],
    slip44: 60,
    explorers: [],
    fallbackEnabled: true,
    testnet: true,
    ftokens: [],
  });

```

`zil-pay/__tests__/popup/url.test.ts`:

```ts
import { describe, it, expect } from 'vitest';
import { processTokenLogo, formExplorerUrl, viewChain } from '../../lib/popup/url';
import { CHAINS, ZERO_ADDR_HEX } from '../data';
import type { IExplorerState, IChainConfigState, IFTokenState } from "../../background/storage";
import { Themes } from "../../config/theme";

const zilliqaChain: IChainConfigState = CHAINS[0];
const bscChain: IChainConfigState = CHAINS[1];
const sepoliaChain: IChainConfigState = CHAINS[2];

describe('Image and URL processing utilities', () => {

  describe('processTokenLogo', () => {
    it('should correctly process the logo URL for a Zilliqa native token with a light theme', () => {
      const zilToken: IFTokenState = zilliqaChain.ftokens[1];
      const expectedUrl = `https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/${zilToken.addr}/dark.webp`;
      const result = processTokenLogo({
        token: zilToken,
        shortName: zilliqaChain.shortName,
        theme: Themes.Light
      });
      expect(result).toBe(expectedUrl);
    });

    it('should correctly process the logo URL for a Zilliqa native token with a dark theme', () => {
      const zilToken: IFTokenState = zilliqaChain.ftokens[1];
      const expectedUrl = `https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/${zilToken.addr}/light.webp`;
      const result = processTokenLogo({
        token: zilToken,
        shortName: zilliqaChain.shortName,
        theme: Themes.Dark
      });
      expect(result).toBe(expectedUrl);
    });

    it('should correctly process the logo URL for a BNB token with a light theme', () => {
      const bnbToken: IFTokenState = bscChain.ftokens[0];
      const expectedUrl = `https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/bnbchain/${ZERO_ADDR_HEX}/dark.webp`;
      const result = processTokenLogo({
        token: bnbToken,
        shortName: bscChain.shortName,
        theme: Themes.Light
      });
      expect(result).toBe(expectedUrl);
    });

    it('should return a default warning icon if the token has no logo', () => {
      const tokenWithoutLogo: IFTokenState = { ...sepoliaChain.ftokens[0], logo: null };
      const expected = 'assets/icons/warning.svg';
      const result = processTokenLogo({
        token: tokenWithoutLogo,
        shortName: sepoliaChain.shortName,
        theme: Themes.Light
      });
      expect(result).toBe(expected);
    });
  });

  describe('formExplorerUrl', () => {
    it('should correctly form the explorer URL for a transaction', () => {
      const explorer: IExplorerState = zilliqaChain.explorers[0];
      const txHash = '0x1234567890abcdef';
      const expectedUrl = `${explorer.url}/tx/${txHash}`;
      const result = formExplorerUrl(explorer, txHash);
      expect(result).toBe(expectedUrl);
    });

    it('should handle explorer URLs that end with a slash', () => {
      const explorerWithSlash: IExplorerState = { ...bscChain.explorers[0], url: 'https://testnet.bscscan.com/' };
      const txHash = '0xabcdef1234567890';
      const expectedUrl = `https://testnet.bscscan.com/tx/${txHash}`;
      const result = formExplorerUrl(explorerWithSlash, txHash);
      expect(result).toBe(expectedUrl);
    });
  });

  describe('viewChain', () => {
    it('should correctly process the chain logo URL with a light theme', () => {
      const expectedUrl = 'https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/chain/dark.svg';
      const result = viewChain({
        network: zilliqaChain,
        theme: Themes.Light
      });
      expect(result).toBe(expectedUrl);
    });

    it('should correctly process the chain logo URL with a dark theme', () => {
      const expectedUrl = 'https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/chain/light.svg';
      const result = viewChain({
        network: zilliqaChain,
        theme: Themes.Dark
      });
      expect(result).toBe(expectedUrl);
    });

    it('should return a default icon if the network has no logo URL', () => {
      const networkWithoutLogo: IChainConfigState = { ...zilliqaChain, logo: '' };
      const expected = 'assets/icons/default_chain.svg';
      const result = viewChain({
        network: networkWithoutLogo,
        theme: Themes.Light
      });
      expect(result).toBe(expected);
    });

    it('should correctly process the logo URL for a different chain (Sepolia)', () => {
        const expectedUrl = 'https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/ethereum/chain/dark.svg';
        const result = viewChain({
          network: sepoliaChain,
          theme: Themes.Light
        });
        expect(result).toBe(expectedUrl);
      });
  });
});

```

`zil-pay/__tests__/rpc/ft_parser.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import {
  ERC20Helper,
  buildTokenRequests,
  processEthMetadataResponse,
  processZilMetadataResponse,
  processEthBalanceResponse,
  processZilBalanceResponse,
  generateErc20TransferData,
  MetadataField,
  type GetTokenInitItem,
  type ZilBalanceResponse,
  type ZilSmartContractSubStateResponse,
} from "../../background/rpc/ft_parser";
import { Address } from "../../crypto/address";
import { KeyPair } from "../../crypto/keypair";
import { EvmMethods, ZilMethods } from "../../config/jsonrpc";
import { ZILLIQA } from "../../config/slip44";
import type { JsonRPCResponse } from "../../background/rpc/provider";

const createEthAddress = () =>
  Address.fromStr("0x0089d53F703f7E0843953D48133f74cE247184c2");
const createZilAddress = () =>
  Address.fromStr("zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz");

describe("ft_parser", () => {
  describe("ERC20Helper", () => {
    const helper = new ERC20Helper();
    const toAddress = "0x1234567890123456789012345678901234567890";
    const amount = 1000n;

    it('should correctly encode "name" function call', () => {
      const encoded = helper.encodeFunctionCall("name", []);
      expect(encoded).toBe("0x06fdde03");
    });

    it('should correctly encode "symbol" function call', () => {
      const encoded = helper.encodeFunctionCall("symbol", []);
      expect(encoded).toBe("0x95d89b41");
    });

    it('should correctly encode "decimals" function call', () => {
      const encoded = helper.encodeFunctionCall("decimals", []);
      expect(encoded).toBe("0x313ce567");
    });

    it('should correctly encode "balanceOf" function call', () => {
      const encoded = helper.encodeFunctionCall("balanceOf", [toAddress]);
      const expected = `0x70a08231000000000000000000000000${toAddress.slice(2)}`;
      expect(encoded).toBe(expected);
    });

    it('should correctly encode "transfer" function call', () => {
      const encoded = helper.encodeFunctionCall("transfer", [
        toAddress,
        amount,
      ]);
      const expected = `0xa9059cbb000000000000000000000000${toAddress.slice(2)}00000000000000000000000000000000000000000000000000000000000003e8`;
      expect(encoded).toBe(expected);
    });

    it("should generate transfer input data", () => {
      const to = "0x0101010101010101010101010101010101010101";
      const amount = 1000000000000000000n;
      const transferData = generateErc20TransferData(to, amount);
      const expectedData =
        "0xa9059cbb00000000000000000000000001010101010101010101010101010101010101010000000000000000000000000000000000000000000000000de0b6b3a7640000";
      expect(transferData).toBe(expectedData);
    });
  });

  describe("buildTokenRequests", () => {
    it("should build requests for an ETH (ERC20) token", async () => {
      const contract = createEthAddress();
      const accounts = [createEthAddress()];
      const requests = await buildTokenRequests(contract, accounts, false);

      expect(requests).toHaveLength(4);

      const metadataReqs = requests.filter(
        (r) => r.requestType.type === "Metadata",
      );
      const balanceReqs = requests.filter(
        (r) => r.requestType.type === "Balance",
      );

      expect(metadataReqs).toHaveLength(3);
      expect(balanceReqs).toHaveLength(1);

      expect(requests[0].payload.method).toBe(EvmMethods.Call);
      expect(requests[3].payload.method).toBe(EvmMethods.Call);
    });

    it("should build requests for a native ETH balance", async () => {
      const contract = createEthAddress();
      const accounts = [createEthAddress()];
      const requests = await buildTokenRequests(contract, accounts, true);

      expect(requests).toHaveLength(4);
      expect(requests[3].payload.method).toBe(EvmMethods.GetBalance);
    });

    it("should build requests for a ZIL (ZRC2) token", async () => {
      const contract = createZilAddress();
      const accounts = [createZilAddress()];
      const requests = await buildTokenRequests(contract, accounts, false);

      expect(requests).toHaveLength(2);
      expect(requests[0].payload.method).toBe(ZilMethods.GetSmartContractInit);
      expect(requests[1].payload.method).toBe(
        ZilMethods.GetSmartContractSubState,
      );
    });

    it("should build requests for a native ZIL balance", async () => {
      const contract = createZilAddress();
      const accounts = [createZilAddress()];
      const requests = await buildTokenRequests(contract, accounts, true);

      expect(requests).toHaveLength(2);
      expect(requests[0].payload.method).toBe(ZilMethods.GetSmartContractInit);
      expect(requests[1].payload.method).toBe(ZilMethods.GetBalance);
    });
  });

  describe("Response Processing", () => {
    describe("ETH", () => {
      it("should process ETH metadata response for name", () => {
        const mockResponse: JsonRPCResponse<string> = {
          id: 1,
          jsonrpc: "2.0",
          result:
            "0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000047465737400000000000000000000000000000000000000000000000000000000",
        };
        const name = processEthMetadataResponse(
          mockResponse,
          MetadataField.Name,
        );
        expect(name).toBe("test");
      });

      it("should process ETH metadata response for decimals", () => {
        const mockResponse: JsonRPCResponse<string> = {
          id: 1,
          jsonrpc: "2.0",
          result:
            "0x0000000000000000000000000000000000000000000000000000000000000012",
        };
        const decimals = processEthMetadataResponse(
          mockResponse,
          MetadataField.Decimals,
        );
        expect(decimals).toBe("18");
      });

      it("should process ETH balance response", () => {
        const mockResponse: JsonRPCResponse<string> = {
          id: 1,
          jsonrpc: "2.0",
          result:
            "0x0000000000000000000000000000000000000000000000000000000000000064",
        };
        const balance = processEthBalanceResponse(mockResponse);
        expect(balance).toBe(100n);
      });

      it("should handle invalid hex for ETH balance response", () => {
        const mockResponse: JsonRPCResponse<string> = {
          id: 1,
          jsonrpc: "2.0",
          result: "0xinvalidhex",
        };
        expect(() => processEthBalanceResponse(mockResponse)).toThrow();
      });

      it("should throw error for invalid ETH response", () => {
        const mockResponse: JsonRPCResponse<string> = {
          id: 1,
          jsonrpc: "2.0",
          error: { code: -32000, message: "Invalid request" },
        };
        expect(() =>
          processEthMetadataResponse(mockResponse, MetadataField.Name),
        ).toThrow("RPC Error (code: -32000): Invalid request");
      });
    });

    describe("ZIL", () => {
      it("should process ZIL metadata response", () => {
        const mockInitData: GetTokenInitItem[] = [
          { vname: "name", type: "String", value: "Test Token" },
          { vname: "symbol", type: "String", value: "TEST" },
          { vname: "decimals", type: "Uint32", value: "12" },
        ];
        const mockResponse: JsonRPCResponse<GetTokenInitItem[]> = {
          id: 1,
          jsonrpc: "2.0",
          result: mockInitData,
        };

        const { name, symbol, decimals } =
          processZilMetadataResponse(mockResponse);

        expect(name).toBe("Test Token");
        expect(symbol).toBe("TEST");
        expect(decimals).toBe(12);
      });

      it("should throw error for missing field in ZIL metadata", () => {
        const mockInitData: GetTokenInitItem[] = [
          { vname: "name", type: "String", value: "Test Token" },
        ];
        const mockResponse: JsonRPCResponse<GetTokenInitItem[]> = {
          id: 1,
          jsonrpc: "2.0",
          result: mockInitData,
        };
        expect(() => processZilMetadataResponse(mockResponse)).toThrow(
          "Invalid contract init: missing symbol",
        );
      });

      it("should process native ZIL balance response", async () => {
        const mockAccount = createZilAddress();
        const mockResponse: JsonRPCResponse<ZilBalanceResponse> = {
          id: 1,
          jsonrpc: "2.0",
          result: {
            balance: "12345",
            nonce: 2,
          },
        };

        const balance = await processZilBalanceResponse(
          mockResponse,
          mockAccount,
          true,
        );
        expect(balance).toBe(12345n);
      });

      it("should process ZRC2 token balance response", async () => {
        const keypair = await KeyPair.generate(ZILLIQA);
        const mockAccount = await keypair.address();
        const checksumAddress = (
          await mockAccount.toZilChecksum()
        ).toLowerCase();

        const mockResponse: JsonRPCResponse<ZilSmartContractSubStateResponse> =
          {
            id: 1,
            jsonrpc: "2.0",
            result: {
              balances: {
                [checksumAddress]: "54321",
              },
            },
          };

        const balance = await processZilBalanceResponse(
          mockResponse,
          mockAccount,
          false,
        );
        expect(balance).toBe(54321n);
      });

      it("should return 0 for ZRC2 balance if account not in response", async () => {
        const mockAccount = createZilAddress();
        const someOtherChecksumAddress =
          "0x01a6a0332f64285c73ea9fca4dca701e1e5ddf96";

        const mockResponse: JsonRPCResponse<ZilSmartContractSubStateResponse> =
          {
            id: 1,
            jsonrpc: "2.0",
            result: {
              balances: {
                [someOtherChecksumAddress]: "199636063226083796",
              },
            },
          };

        const balance = await processZilBalanceResponse(
          mockResponse,
          mockAccount,
          false,
        );
        expect(balance).toBe(0n);
      });

      it("should return 0 if ZIL response has an error", async () => {
        const mockAccount = createZilAddress();
        const mockResponse: JsonRPCResponse<any> = {
          id: 1,
          jsonrpc: "2.0",
          error: { code: -1, message: "Error" },
        };
        const balance = await processZilBalanceResponse(
          mockResponse,
          mockAccount,
          true,
        );
        expect(balance).toBe(0n);
      });
    });
  });
});

```

`zil-pay/__tests__/rpc/gas_parser.test.ts`:

```ts
import { describe, it, expect, vi } from "vitest";
import {
  buildFeeHistoryRequest,
  buildEvmEstimateGasRequest,
  buildBatchGasRequest,
  processParseFeeHistoryRequest,
  EIP1559,
  EIP4844,
  type FeeHistoryResult,
  type GasFeeHistory,
} from "../../background/rpc/gas_parse";
import { TransactionRequest } from "../../crypto/tx";
import { Address, AddressType } from "../../crypto/address";
import { EvmMethods, ZilMethods } from "../../config/jsonrpc";
import { hexToBigInt } from "../../lib/utils/hex";

describe("Gas Parser Utilities", () => {
  const mockEvmTx = { to: "0x...", data: "0x..." };
  const mockScillaTx = { a: "1" };
  const mockEvmSender = new Address(
    new Uint8Array(20),
    AddressType.EthCheckSum,
  );
  const mockZilSender = new Address(new Uint8Array(20), AddressType.Bech32);

  describe("buildFeeHistoryRequest", () => {
    it("should create a valid eth_feeHistory request payload", () => {
      const blockCount = 10;
      const percentiles = [10, 20, 30];
      const request = buildFeeHistoryRequest(blockCount, percentiles);

      expect(request.method).toBe(EvmMethods.FeeHistory);
      expect(request.params).toEqual([
        `0x${blockCount.toString(16)}`,
        "latest",
        percentiles,
      ]);
      expect(request.jsonrpc).toBe("2.0");
    });
  });

  describe("buildEvmEstimateGasRequest", () => {
    it("should create a valid eth_estimateGas request for an EVM transaction", () => {
      const tx = new TransactionRequest(
        {
          chainHash: 0,
        },
        undefined,
        mockEvmTx as any,
      );
      const request = buildEvmEstimateGasRequest(tx);

      expect(request.method).toBe(EvmMethods.EstimateGas);
      expect(request.params).toEqual([mockEvmTx]);
    });

    it("should throw NetworkError if the transaction is for Scilla", () => {
      const tx = new TransactionRequest(
        {
          chainHash: 0,
        },
        mockScillaTx as any,
        undefined,
      );
      expect(() => buildEvmEstimateGasRequest(tx)).toThrow(
        "Zilliqa network doesn't support gas estimation or EVM transaction is missing",
      );
    });
  });

  describe("processParseFeeHistoryRequest", () => {
    const mockFeeHistory: FeeHistoryResult = {
      baseFeePerGas: [
        "0x21149ce3",
        "0x20fde27c",
        "0x1fa69dae",
        "0x1e3966e7",
        "0x1fa68dd6",
      ],
      reward: [
        ["0x2faf080", "0x1dcd6500", "0x3b9aca04"],
        ["0x54e0840", "0x1dcd6500", "0x34323dde"],
        ["0x989680", "0x13f7d84f", "0x578ef652"],
        ["0x2faf080", "0x1dcd6500", "0x1dcd6500"],
      ],
      oldestBlock: "0x15a9cb6",
      gasUsedRatio: [0.48, 0.33, 0.31, 0.68],
    };

    it("should correctly parse a valid fee history response", () => {
      const result: GasFeeHistory =
        processParseFeeHistoryRequest(mockFeeHistory);
      const expectedBaseFee = hexToBigInt(mockFeeHistory.baseFeePerGas.at(-1)!);
      const expectedPriorityFee = hexToBigInt(mockFeeHistory.reward.at(-1)![1]);

      expect(result.baseFee).toBe(expectedBaseFee);
      expect(result.priorityFee).toBe(expectedPriorityFee);
      expect(result.maxFee).toBe(expectedBaseFee * 2n + expectedPriorityFee);
    });

    it("should throw an error if baseFeePerGas is missing", () => {
      const invalidHistory = { ...mockFeeHistory, baseFeePerGas: [] };
      expect(() => processParseFeeHistoryRequest(invalidHistory)).toThrow(
        "baseFeePerGas not found or empty in fee history",
      );
    });
  });

  describe("buildBatchGasRequest", () => {
    it("should build a batch request for a Zilliqa (Scilla) transaction", async () => {
      const tx = new TransactionRequest(
        { chainHash: 1 },
        mockScillaTx as any,
        undefined,
      );
      const requests = await buildBatchGasRequest(tx, 0, [], [], mockZilSender);

      expect(requests.length).toBe(2);
      expect(requests[0].method).toBe(ZilMethods.GetBalance);
      expect(requests[0].params).toEqual([
        "0000000000000000000000000000000000000000",
      ]);

      expect(requests[1].method).toBe(ZilMethods.GetMinimumGasPrice);
    });

    it("should build a basic batch request for an EVM transaction", async () => {
      const tx = new TransactionRequest(
        { chainHash: 2 },
        undefined,
        mockEvmTx as any,
      );
      const requests = await buildBatchGasRequest(
        tx,
        10,
        [],
        [],
        mockEvmSender,
      );

      expect(requests.length).toBe(3);
      expect(requests[0].method).toBe(EvmMethods.GetTransactionCount);
      expect(requests[0].params).toEqual([
        "0x0000000000000000000000000000000000000000",
        "latest",
      ]);

      expect(requests[1].method).toBe(EvmMethods.GasPrice);
      expect(requests[2].method).toBe(EvmMethods.EstimateGas);
    });

    it("should include EIP1559 requests when the feature is enabled", async () => {
      const tx = new TransactionRequest(
        { chainHash: 2 },
        undefined,
        mockEvmTx as any,
      );
      const requests = await buildBatchGasRequest(
        tx,
        10,
        [25, 75],
        [EIP1559],
        mockEvmSender,
      );

      expect(requests.length).toBe(5);
      const methods = requests.map((r) => r.method);
      expect(methods).toContain(EvmMethods.MaxPriorityFeePerGas);
      expect(methods).toContain(EvmMethods.FeeHistory);
    });

    it("should include EIP4844 request when the feature is enabled", async () => {
      const tx = new TransactionRequest(
        { chainHash: 2 },
        undefined,
        mockEvmTx as any,
      );
      const requests = await buildBatchGasRequest(
        tx,
        10,
        [],
        [EIP4844],
        mockEvmSender,
      );

      expect(requests.length).toBe(4);
      expect(requests.map((r) => r.method)).toContain(EvmMethods.BlobBaseFee);
    });

    it("should throw TransactionError if evm transaction is not provided for an EVM chain", async () => {
      const tx = new TransactionRequest({ chainHash: 2 }, undefined, undefined);
      await expect(
        buildBatchGasRequest(tx, 10, [], [], mockEvmSender),
      ).rejects.toThrow("unsupported transaction.");
    });
  });
});

```

`zil-pay/__tests__/rpc/history_tx.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import {
  HistoricalTransaction,
  TransactionStatus,
  ChainType,
} from "../../background/rpc/history_tx";
import { generateErc20TransferData } from "../../background/rpc";
import { TransactionRequest } from "../../crypto/tx";
import { ZILTransactionRequest } from "../../crypto/zilliqa_tx";
import { uint8ArrayToHex } from "../../lib/utils/hex";
import { utf8ToUint8Array } from "../../lib/utils/utf8";
import { Address } from "../../crypto/address";
import { KeyPair } from "../../crypto/keypair";
import { createBscConfig, createZilliqaConfig } from "../data";
import { randomBytes } from "../../crypto/random";
import { Transaction, weieth, weigwei } from "micro-eth-signer";

const ZIL_CONFIG = createZilliqaConfig();
const BSC_CONFIG = createBscConfig();

describe("HistoricalTransaction", () => {
  describe("fromReceipt", () => {
    describe("Scilla Transactions", () => {
      it("should be props a Scilla contract call", async () => {
        const keypair = await KeyPair.generate(ZIL_CONFIG.slip44);
        const toAddr = Address.fromStr(
          "zil1g0n2tsqwyht7xafsmdgq2zrwwt7nnz5arcp2xw",
        );
        const data = JSON.stringify({
          _tag: "Transfer",
          params: [
            {
              vname: "to",
              type: "ByStr20",
              value: "0x066b88d3411c68cb56219e748ae895e1734c0f51",
            },
            {
              vname: "amount",
              type: "Uint128",
              value: "355940000000000000000",
            },
          ],
        });
        const txZilReq = new ZILTransactionRequest(
          42,
          BigInt(1),
          BigInt(2000) * BigInt(10 ** 6),
          BigInt(100000),
          toAddr.bytes,
          BigInt(1) * BigInt(10 ** 12),
          new Uint8Array(),
          utf8ToUint8Array(data),
        );
        const metadata = {
          chainHash: ZIL_CONFIG.hash(),
        };
        const txReq = new TransactionRequest(metadata, txZilReq);
        const receipt = await txReq.sign(keypair);

        receipt.metadata.hash = uint8ArrayToHex(randomBytes(64), true);

        const historicalTx = await HistoricalTransaction.fromReceipt(receipt);

        expect(historicalTx.data).toBe(data);
        expect(historicalTx.code).toBe("");
        expect(historicalTx).toBeInstanceOf(HistoricalTransaction);
        expect(historicalTx.transaction_hash).toBeDefined();
        expect(historicalTx.amount).toBe(1000000000000n);
        expect(historicalTx.sender).toEqual(uint8ArrayToHex(keypair.pubKey));
        expect(historicalTx.recipient).toBe(
          "zil1g0n2tsqwyht7xafsmdgq2zrwwt7nnz5arcp2xw",
        );
        expect(historicalTx.contract_address).toBe(
          "zil1g0n2tsqwyht7xafsmdgq2zrwwt7nnz5arcp2xw",
        );
        expect(historicalTx.status).toBe(TransactionStatus.Pending);
        expect(historicalTx.status_code).toBeNull();
        expect(historicalTx.timestamp).toBeDefined();
        expect(historicalTx.block_number).toBeNull();
        expect(historicalTx.gasUsed).toBeNull();
        expect(historicalTx.gasLimit).toBe(100000n);
        expect(historicalTx.gasPrice).toBe(2000000000n);
        expect(historicalTx.effectiveGasPrice).toBeNull();
        expect(historicalTx.fee).toBe(200000000000000n);
        expect(historicalTx.icon).toBeNull();
        expect(historicalTx.title).toBeNull();
        expect(historicalTx.error).toBeNull();
        expect(historicalTx.sig).toBeDefined();
        expect(historicalTx.nonce).toBe(1n);
        expect(historicalTx.token_info).toBeNull();
        expect(historicalTx.chain_type).toBe("Scilla" as ChainType);
        expect(historicalTx.chain_hash).toBe(ZIL_CONFIG.hash());
      });
    });

    describe("EVM Transactions", () => {
      it("should have props an EVM contract call", async () => {
        const keypair = await KeyPair.generate(BSC_CONFIG.slip44);
        const tokenAddress = Address.fromStr(
          "0x524bC91Dc82d6b90EF29F76A3ECAaBAffFD490Bc",
        );
        const recipient = Address.fromStr(
          "0x246C5881E3F109B2aF170F5C773EF969d3da581B",
        );
        const amount = weieth.decode("69");
        const transferData = generateErc20TransferData(
          await recipient.toEthChecksum(),
          amount,
        );
        const ethTx = Transaction.prepare({
          to: await tokenAddress.toEthChecksum(),
          value: 0n,
          maxFeePerGas: weigwei.decode("1"),
          gasLimit: 24000n,
          maxPriorityFeePerGas: 10n,
          nonce: 0n,
          chainId: BigInt(BSC_CONFIG.chainId),
          data: transferData,
        });
        const metadata = {
          chainHash: BSC_CONFIG.hash(),
        };
        const txReq = new TransactionRequest(metadata, undefined, ethTx);
        const receipt = await txReq.sign(keypair);

        receipt.metadata.hash = uint8ArrayToHex(randomBytes(64), true);

        const historicalTx = await HistoricalTransaction.fromReceipt(receipt);
        expect(historicalTx.transaction_hash).toEqual(expect.any(String));
        expect(historicalTx.amount).toBe(0n);
        expect(historicalTx.sender).toBe(
          await keypair.address().then((a) => a.toEthChecksum()),
        );
        expect(historicalTx.recipient).toBe(await tokenAddress.toEthChecksum());
        expect(historicalTx.contract_address).toBe(
          await tokenAddress.toEthChecksum(),
        );
        expect(historicalTx.status).toBe(TransactionStatus.Pending);
        expect(historicalTx.status_code).toBeNull();
        expect(historicalTx.timestamp).toBeDefined();
        expect(historicalTx.block_number).toBeNull();
        expect(historicalTx.sig).toBeDefined();
        expect(historicalTx.gasUsed).toBeNull();
        expect(historicalTx.gasLimit).toBe(24000n);
        expect(historicalTx.gasPrice).toBeNull();
        expect(historicalTx.effectiveGasPrice).toBe(10n);
        expect(historicalTx.fee).toBe(24000000000000n);
        expect(historicalTx.icon).toBeNull();
        expect(historicalTx.title).toBeNull();
        expect(historicalTx.error).toBeNull();
        expect(historicalTx.sig).toEqual(expect.any(String));
        expect(historicalTx.nonce).toBe(0n);
        expect(historicalTx.token_info).toBeNull();
        expect(historicalTx.chain_type).toBe("EVM" as ChainType);
        expect(historicalTx.chain_hash).toBe(BSC_CONFIG.hash());
      });
    });
  });
});

describe("toJSON", () => {
  it("should convert Scilla transaction to JSON correctly", async () => {
    const keypair = await KeyPair.generate(ZIL_CONFIG.slip44);
    const toAddr = Address.fromStr(
      "zil1g0n2tsqwyht7xafsmdgq2zrwwt7nnz5arcp2xw",
    );
    const data = JSON.stringify({
      _tag: "Transfer",
      params: [
        {
          vname: "to",
          type: "ByStr20",
          value: "0x066b88d3411c68cb56219e748ae895e1734c0f51",
        },
        {
          vname: "amount",
          type: "Uint128",
          value: "355940000000000000000",
        },
      ],
    });
    const txZilReq = new ZILTransactionRequest(
      42,
      BigInt(1),
      BigInt(2000) * BigInt(10 ** 6),
      BigInt(100000),
      toAddr.bytes,
      BigInt(1) * BigInt(10 ** 12),
      new Uint8Array(),
      utf8ToUint8Array(data),
    );
    const metadata = {
      chainHash: ZIL_CONFIG.hash(),
      tokenInfo: ["1000000000000", 12, "ZIL"] as [string, number, string],
    };
    const txReq = new TransactionRequest(metadata, txZilReq);
    const receipt = await txReq.sign(keypair);

    receipt.metadata.hash = uint8ArrayToHex(randomBytes(64), true);

    const historicalTx = await HistoricalTransaction.fromReceipt(receipt);
    const json = historicalTx.toJSON();

    expect(json).toEqual({
      transaction_hash: historicalTx.transaction_hash,
      amount: "1000000000000",
      sender: uint8ArrayToHex(keypair.pubKey),
      recipient: "zil1g0n2tsqwyht7xafsmdgq2zrwwt7nnz5arcp2xw",
      contract_address: "zil1g0n2tsqwyht7xafsmdgq2zrwwt7nnz5arcp2xw",
      status: TransactionStatus.Pending,
      status_code: null,
      timestamp: expect.any(Number),
      block_number: null,
      gasUsed: null,
      gasLimit: "100000",
      gasPrice: "2000000000",
      blobGasUsed: null,
      blobGasPrice: null,
      effectiveGasPrice: null,
      fee: "200000000000000",
      icon: null,
      title: null,
      error: null,
      sig: expect.any(String),
      nonce: "1",
      token_info: {
        value: "1000000000000",
        decimals: 12,
        symbol: "ZIL",
      },
      chain_type: "Scilla",
      chain_hash: ZIL_CONFIG.hash(),
      data: data,
      code: "",
    });
  });

  it("should convert EVM transaction to JSON correctly", async () => {
    const keypair = await KeyPair.generate(BSC_CONFIG.slip44);
    const tokenAddress = Address.fromStr(
      "0x524bC91Dc82d6b90EF29F76A3ECAaBAffFD490Bc",
    );
    const recipient = Address.fromStr(
      "0x246C5881E3F109B2aF170F5C773EF969d3da581B",
    );
    const amount = weieth.decode("69");
    const transferData = generateErc20TransferData(
      await recipient.toEthChecksum(),
      amount,
    );
    const ethTx = Transaction.prepare({
      to: await tokenAddress.toEthChecksum(),
      value: 0n,
      maxFeePerGas: weigwei.decode("1"),
      gasLimit: 24000n,
      maxPriorityFeePerGas: 10n,
      nonce: 0n,
      chainId: BigInt(BSC_CONFIG.chainId),
      data: transferData,
    });
    const metadata = {
      chainHash: BSC_CONFIG.hash(),
      tokenInfo: ["69000000000000000000", 18, "USDT"] as [string, number, string],
    };
    const txReq = new TransactionRequest(metadata, undefined, ethTx);
    const receipt = await txReq.sign(keypair);

    receipt.metadata.hash = uint8ArrayToHex(randomBytes(64), true);

    const historicalTx = await HistoricalTransaction.fromReceipt(receipt);
    const json = historicalTx.toJSON();

    expect(json).toEqual({
      transaction_hash: historicalTx.transaction_hash,
      amount: "0",
      sender: await keypair.address().then((a) => a.toEthChecksum()),
      recipient: await tokenAddress.toEthChecksum(),
      contract_address: await tokenAddress.toEthChecksum(),
      status: TransactionStatus.Pending,
      status_code: null,
      timestamp: expect.any(Number),
      block_number: null,
      gasUsed: null,
      gasLimit: "24000",
      gasPrice: null,
      blobGasUsed: null,
      blobGasPrice: null,
      effectiveGasPrice: "10",
      fee: "24000000000000",
      icon: null,
      title: null,
      error: null,
      sig: expect.any(String),
      nonce: "0",
      token_info: {
        value: "69000000000000000000",
        decimals: 18,
        symbol: "USDT",
      },
      chain_type: "EVM",
      chain_hash: BSC_CONFIG.hash(),
      data: transferData,
      code: undefined,
    });
  });
});

```

`zil-pay/__tests__/rpc/nonce_parser.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import {
  buildNonceRequest,
  processNonceResponse,
  type ZilBalance,
} from "../../background/rpc/nonce_parser";
import { AddressType } from "../../crypto/address";
import { EvmMethods, ZilMethods } from "../../config/jsonrpc";

describe("Nonce Handling Logic", () => {
  describe("buildNonceRequest", () => {
    const bech32Address = "zil1w7f636xqn5vf6n2zrnjmckekw3jkckkpyrd6z8";
    const ethAddress = "0x7793a8e8c09d189d4d421ce5bc5b3674656c5ac1";

    it("should create a correct request payload for a Zilliqa (Bech32) address", async () => {
      // Await the async function
      const request = await buildNonceRequest(
        AddressType.Bech32,
        bech32Address,
      );

      expect(request.method).toBe(ZilMethods.GetBalance);
      // The hex address from a bech32 address conversion
      expect(request.params).toEqual([
        "7793a8e8c09d189d4d421ce5bc5b3674656c5ac1",
      ]);
      expect(request.jsonrpc).toBe("2.0");
    });

    it("should create a correct request payload for an Ethereum (Checksum) address", async () => {
      // Await the async function
      const request = await buildNonceRequest(
        AddressType.EthCheckSum,
        ethAddress,
      );
      // Correct checksum for Ethereum addresses
      const checksummedAddress = "0x7793A8E8c09d189d4D421Ce5bC5B3674656c5Ac1";

      expect(request.method).toBe(EvmMethods.GetTransactionCount);
      expect(request.params).toEqual([checksummedAddress, "latest"]);
      expect(request.jsonrpc).toBe("2.0");
    });

    it("should throw an error for an unsupported address type", async () => {
      const unsupportedType = 99 as AddressType; // Use a value not in the enum
      // Test for a rejected promise since the function is async
      await expect(
        buildNonceRequest(unsupportedType, "some_address"),
      ).rejects.toThrow("Unsupported address type");
    });
  });

  describe("processNonceResponse", () => {
    it("should correctly parse the nonce from a Zilliqa balance object", () => {
      const zilResponse: ZilBalance = {
        balance: "1000000000000",
        nonce: 42,
      };
      const nonce = processNonceResponse(zilResponse);
      expect(nonce).toBe(42);
    });

    it("should return 0 if the nonce is missing from the Zilliqa response", () => {
      const zilResponse = { balance: "1000000000000" } as ZilBalance;
      const nonce = processNonceResponse(zilResponse);
      expect(nonce).toBe(0);
    });

    it("should correctly parse the nonce from an Ethereum hex string response", () => {
      const ethResponse = "0x2a"; // Hex for 42
      const nonce = processNonceResponse(ethResponse);
      expect(nonce).toBe(42);
    });

    it("should return 0 for a zero value hex string", () => {
      const ethResponse = "0x0";
      const nonce = processNonceResponse(ethResponse);
      expect(nonce).toBe(0);
    });

    it("should return 0 for a non-string, non-object response", () => {
      const invalidResponse: any = 123;
      const nonce = processNonceResponse(invalidResponse);
      expect(nonce).toBe(0);
    });
  });
});

```

`zil-pay/__tests__/rpc/provider.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import { RpcProvider } from "../../background/rpc/provider";
import { fromBech32Address } from "../../lib/zilliqa";
import { EvmMethods, ZilMethods } from "../../config/jsonrpc";
import {
  createBscConfig,
  createEthConfig,
  createZilliqaConfig,
  ZERO_ADDR_BECH32,
  ZERO_ADDR_HEX,
} from "../data";

interface GetBalanceRes {
  balance: string;
  nonce: number;
}

interface ZilResultRes<T> {
  id: string;
  jsonrpc: string;
  result: T;
  error?: unknown;
}

interface EthResultRes<T> {
  id: number;
  jsonrpc: string;
  result: T;
  error?: unknown;
}

describe("RpcProvider", () => {
  it("test_build_payload", () => {
    const provider = new RpcProvider(createBscConfig());
    const payload = RpcProvider.buildPayload(EvmMethods.GetBalance, [
      "param1",
      "param2",
    ]);

    expect(payload.jsonrpc).toBe("2.0");
    expect(payload.id).toBe(1);
    expect(payload.method).toBe(EvmMethods.GetBalance);
    expect(Array.isArray(payload.params)).toBe(true);
    expect(payload.params[0]).toBe("param1");
    expect(payload.params[1]).toBe("param2");
  });

  it("test_get_balance_scilla", async () => {
    const address = await fromBech32Address(ZERO_ADDR_BECH32);
    const netConf = createZilliqaConfig();
    const zil = new RpcProvider(netConf);
    const payload = RpcProvider.buildPayload(ZilMethods.GetBalance, [
      address.replace("0x", "").toLowerCase(),
    ]);

    const res = await zil.req<ZilResultRes<GetBalanceRes>>(payload);

    expect(res.result).toBeDefined();
    expect(res.error).toBeUndefined();
    expect(res.result.balance).toBeDefined();
    expect(res.result.nonce).toBeDefined();
  }, 10000);

  it("test_get_balance_bsc", async () => {
    const netConf = createBscConfig();
    const bsc = new RpcProvider(netConf);
    const payload = RpcProvider.buildPayload(EvmMethods.GetBalance, [
      ZERO_ADDR_HEX,
      "latest",
    ]);

    const res = await bsc.req<EthResultRes<string>>(payload);

    expect(res.result).toBeDefined();
    expect(res.error).toBeUndefined();
    expect(typeof res.result).toBe("string");
  }, 10000);

  it("test_network_much_req", async () => {
    const config = createEthConfig();
    const provider = new RpcProvider(config);
    const payload = RpcProvider.buildPayload(EvmMethods.GetBalance, [
      "0x246C5881E3F109B2aF170F5C773EF969d3da581B",
      "latest",
    ]);

    const result = await provider.req<EthResultRes<string>>(payload);

    expect(result.result).toBeDefined();
    expect(typeof result.result).toBe("string");
  }, 20000);

  it("test_batch_request", async () => {
    const netConf = createBscConfig();
    const bsc = new RpcProvider(netConf);
    const payloads = [
      RpcProvider.buildPayload(EvmMethods.GetBalance, [
        ZERO_ADDR_HEX,
        "latest",
      ]),
      RpcProvider.buildPayload(EvmMethods.BlockNumber, []),
    ];

    const res =
      await bsc.req<[EthResultRes<string>, EthResultRes<string>]>(payloads);

    expect(res).toBeInstanceOf(Array);
    expect(res.length).toBe(2);

    const balanceRes = res[0];
    expect(balanceRes.result).toBeDefined();
    expect(typeof balanceRes.result).toBe("string");

    const blockNumRes = res[1];
    expect(blockNumRes.result).toBeDefined();
    expect(typeof blockNumRes.result).toBe("string");
  }, 10000);

  it("should rotate nodes on failure and succeed on retry", async () => {
    const failingEthConfig = createEthConfig();
    const originalRpcOrder = [
      "https://invalid-rpc.io/1",
      "https://invalid-rpc.io/2",
      "https://invalid-rpc.io/3",
      ...failingEthConfig.rpc,
    ];
    failingEthConfig.rpc = [...originalRpcOrder];

    const provider = new RpcProvider(failingEthConfig);
    const payload = RpcProvider.buildPayload(EvmMethods.GetBalance, [
      ZERO_ADDR_HEX,
      "latest",
    ]);

    await expect(provider.req(payload)).rejects.toThrow();

    const expectedOrderAfterFailure = [
      ...originalRpcOrder.slice(3),
      ...originalRpcOrder.slice(0, 3),
    ];

    expect(provider.network.rpc).toEqual(expectedOrderAfterFailure);

    const result = await provider.req<EthResultRes<string>>(payload);

    expect(result.result).toBeDefined();
    expect(typeof result.result).toBe("string");
  }, 20000);
});

```

`zil-pay/__tests__/rpc/rpc.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import { createBscConfig, createEthConfig, createZilliqaConfig } from "../data";
import {
  generateErc20TransferData,
  NetworkProvider,
} from "../../background/rpc";
import { Address, AddressType } from "../../crypto/address";
import { Transaction, weieth, weigwei } from "micro-eth-signer";
import { TransactionRequest } from "../../crypto/tx";
import { ZILTransactionRequest } from "../../crypto/zilliqa_tx";
import {
  HistoricalTransaction,
  TransactionStatus,
} from "../../background/rpc/history_tx";
import { FToken } from "../../background/storage";
import { KeyPair } from "../../crypto/keypair";

describe("JsonRPC provder tests", () => {
  const zilConfig = createZilliqaConfig();
  const ethConfig = createEthConfig();
  const bscConfig = createBscConfig();

  it("should get scilla ftoken metadata", async () => {
    const rpc = new NetworkProvider(zilConfig);
    const zlpContract = Address.fromStr(
      "zil1l0g8u6f9g0fsvjuu74ctyla2hltefrdyt7k5f4",
    );
    const accounts = [
      Address.fromStr("zil1q9j4duzmxewzapj7j56ljfc6gggv3a9er8h766"),
      Address.fromStr("zil1q9l6zd560sdd4y9772k07fxee05wmj8hmg5lfz"),
      Address.fromStr("zil1qxja2utwtn0e3qdj8keauak7a3m5lugj9gryyw"),
      Address.fromStr("zil1qxn2qve0vs59cul2nl9ymjnsrc09mhuk8hzz3w"),
    ];
    const result = await rpc.ftokenMeta(zlpContract, accounts);

    expect(result.addr).toBe(await zlpContract.toZilBech32());
    expect(result.addrType).toBe(AddressType.Bech32);
    expect(result.decimals).toBe(18);
    expect(result.symbol).toBe("ZLP");
    expect(result.name).toBe("ZilPay wallet");

    accounts.forEach((_account, index) => {
      expect(result.balances[index]).toBeDefined();
      expect(BigInt(result.balances[index])).toBeGreaterThan(0);
    });
  });

  it("should get scilla ftoken metadata", async () => {
    const rpc = new NetworkProvider(ethConfig);
    const usdtContract = Address.fromStr(
      "0xdAC17F958D2ee523a2206206994597C13D831ec7",
    );
    const accounts = [
      Address.fromStr("0xA9D1e08C7793af67e9d92fe308d5697FB81d3E43"),
      Address.fromStr("0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE"),
    ];
    const result = await rpc.ftokenMeta(usdtContract, accounts);

    expect(result.addr).toBe(await usdtContract.toEthChecksum());
    expect(result.addrType).toBe(AddressType.EthCheckSum);
    expect(result.decimals).toBe(6);
    expect(result.name).toBe("Tether USD");
    expect(result.symbol).toBe("USDT");

    accounts.forEach((_account, index) => {
      expect(result.balances[index]).toBeDefined();
      expect(BigInt(result.balances[index])).toBeGreaterThan(0);
    });
  });

  it("test_calc_fee_eth_batch", async () => {
    const provider = new NetworkProvider(ethConfig);
    const tokenAddress = Address.fromStr(
      "0x524bC91Dc82d6b90EF29F76A3ECAaBAffFD490Bc",
    );
    const recipient = Address.fromStr(
      "0x246C5881E3F109B2aF170F5C773EF969d3da581B",
    );
    const from = Address.fromStr("0x451806FE45D9231eb1db3584494366edF05CB4AB");
    const amount = 100n;
    const transferData = generateErc20TransferData(
      await recipient.toEthChecksum(),
      amount,
    );
    const ethTx = Transaction.prepare({
      to: await tokenAddress.toEthChecksum(),
      value: 0n,
      maxFeePerGas: weigwei.decode("100"),
      nonce: 0n,
      chainId: BigInt(ethConfig.chainId),
      data: transferData,
    });
    const txRequest = new TransactionRequest(
      { chainHash: ethConfig.hash() },
      undefined,
      ethTx,
    );

    const fee = await provider.estimateParamsBatch(txRequest, from, 4, null);

    expect(fee.gasPrice).toBeGreaterThan(0n);
    expect(fee.nonce).toBeGreaterThan(0);
    expect(fee.maxPriorityFee).toBeGreaterThan(0n);
    expect(fee.txEstimateGas).toBe(22765n);
    expect(fee.blobBaseFee).toBe(0n);
    expect(fee.feeHistory.baseFee).toBeGreaterThan(0n);
    expect(fee.feeHistory.maxFee).toBeGreaterThan(0n);
    expect(fee.feeHistory.priorityFee).toBeGreaterThan(0n);
  }, 20000);

  it("test_get_tx_params_payment_eth", async () => {
    const provider = new NetworkProvider(ethConfig);
    const recipient = Address.fromStr(
      "0x451806FE45D9231eb1db3584494366edF05CB4AB",
    );
    const from = Address.fromStr("0x451806FE45D9231eb1db3584494366edF05CB4AB");
    const amount = 100n;

    const ethTx = Transaction.prepare({
      to: await recipient.toEthChecksum(),
      nonce: 0n,
      value: amount,
      chainId: BigInt(ethConfig.chainId),
      maxFeePerGas: weigwei.decode("100"),
    });
    const txRequest = new TransactionRequest(
      { chainHash: ethConfig.hash() },
      undefined,
      ethTx,
    );

    const fee = await provider.estimateParamsBatch(txRequest, from, 4, null);

    expect(fee.gasPrice).toBeGreaterThan(0n);
    expect(fee.nonce).toBeGreaterThan(0);
    expect(fee.maxPriorityFee).toBeGreaterThan(0n);
    expect(fee.txEstimateGas).toBe(21000n);
    expect(fee.blobBaseFee).toBe(0n);
    expect(fee.feeHistory.baseFee).toBeGreaterThan(0n);
    expect(fee.feeHistory.maxFee).toBeGreaterThan(0n);
    expect(fee.feeHistory.priorityFee).toBeGreaterThan(0n);
  }, 20000);

  it("test_calc_fee_bsc_batch", async () => {
    const provider = new NetworkProvider(bscConfig);
    const recipient = Address.fromStr(
      "0x246C5881E3F109B2aF170F5C773EF969d3da581B",
    );
    const from = Address.fromStr("0x7b501c7944185130DD4aD73293e8Aa84eFfDcee7");

    const bscTx = Transaction.prepare({
      to: await recipient.toEthChecksum(),
      value: weieth.decode("1.1"),
      maxFeePerGas: weigwei.decode("1"),
      nonce: 0n,
      chainId: BigInt(bscConfig.chainId),
    });

    const txRequest = new TransactionRequest(
      { chainHash: bscConfig.hash() },
      undefined,
      bscTx,
    );
    const fee = await provider.estimateParamsBatch(txRequest, from, 4, null);

    expect(fee.gasPrice).toBe(100000000n);
    expect(fee.nonce).toBeGreaterThan(0);
    expect(fee.maxPriorityFee).toBe(100000000n);
    expect(fee.txEstimateGas).toBe(21000n);
    expect(fee.blobBaseFee).toBe(0n);
    expect(fee.feeHistory.baseFee).toBe(0n);
    expect(fee.feeHistory.maxFee).toBeGreaterThanOrEqual(100n);
    expect(fee.feeHistory.priorityFee).toBeGreaterThan(1000000n);
  }, 20000);

  it("test_get_tx_prams_scilla", async () => {
    const provider = new NetworkProvider(zilConfig);
    const to = Address.fromStr("zil1xjj35ymsvf9ajqhprwh6pkvejm2lm2e9y4q4ev");
    const from = Address.fromStr("zil170u0aar9fjgu3hfma00wgk6axjl29l6hhnm2ua");

    const zilTx = new ZILTransactionRequest(
      zilConfig.chainId,
      1n,
      2000n * 10n ** 12n,
      100000n,
      to.bytes,
      10n ** 12n,
    );
    const txRequest = new TransactionRequest(
      { chainHash: zilConfig.hash() },
      zilTx,
      undefined,
    );
    const params = await provider.estimateParamsBatch(
      txRequest,
      from,
      4,
      null,
    );

    expect(params.gasPrice).toBeDefined();
    expect(params.nonce).toBeGreaterThan(0);
  }, 20000);

  it("should get current block number for EVM", async () => {
    const provider = new NetworkProvider(bscConfig);
    const blockNumber = await provider.getCurrentBlockNumber();
    expect(typeof blockNumber).toBe("bigint");
    expect(blockNumber).toBeGreaterThan(0n);
  });

  it("should get current block number for Scilla", async () => {
    const provider = new NetworkProvider(zilConfig);
    const blockNumber = await provider.getCurrentBlockNumber();
    expect(typeof blockNumber).toBe("bigint");
    expect(blockNumber).toBeGreaterThan(0n);
  });

  it("should estimate block time for EVM", async () => {
    const provider = new NetworkProvider(bscConfig);
    const blockTime = await provider.estimateBlockTime();
    expect(typeof blockTime).toBe("number");
    expect(blockTime).toBeGreaterThan(0.0);
    expect(blockTime).toBeLessThan(30);
  });

  it("should update multiple scilla transaction receipts", async () => {
    const provider = new NetworkProvider(zilConfig);
    const mockTxns = [
      new HistoricalTransaction({
        transaction_hash:
          "0xd0b318e0f5f9b1f1d03010b582488e6c0e463c94c315ec0cbeca839d0f3184e7",
        chain_hash: zilConfig.hash(),
        chain_type: "Scilla",
        amount: 0n,
        sender: "",
        recipient: "",
        status: TransactionStatus.Pending,
        timestamp: 0,
        fee: 0n,
        nonce: 0n,
        contract_address: null,
        status_code: null,
        block_number: null,
        gasUsed: null,
        gasLimit: null,
        gasPrice: null,
        blobGasUsed: null,
        blobGasPrice: null,
        effectiveGasPrice: null,
        icon: null,
        title: null,
        error: null,
        sig: "",
        token_info: null,
      }),
      new HistoricalTransaction({
        transaction_hash:
          "0x96830fa2fbd322d9731f4fd75b44d028a73a1323d7b52b099c6ae397ab4ccf43",
        chain_hash: zilConfig.hash(),
        chain_type: "Scilla",
        amount: 0n,
        sender: "",
        recipient: "",
        status: TransactionStatus.Pending,
        timestamp: 0,
        fee: 0n,
        nonce: 0n,
        contract_address: null,
        status_code: null,
        block_number: null,
        gasUsed: null,
        gasLimit: null,
        gasPrice: null,
        blobGasUsed: null,
        blobGasPrice: null,
        effectiveGasPrice: null,
        icon: null,
        title: null,
        error: null,
        sig: "",
        token_info: null,
      }),
    ];

    await provider.updateTransactionsReceipt(mockTxns);

    const [tx1, tx2] = mockTxns;

    expect(tx1.status).toBe(TransactionStatus.Success);
    expect(tx1.amount).toBe(348369130769230760n);
    expect(tx1.fee).toBe(100000000000n);
    expect(tx1.gasLimit).toBe(50n);
    expect(tx1.gasPrice).toBe(2000000000n);
    expect(tx1.nonce).toBe(1697n);
    expect(tx1.sender).toBe("zil1jl8qen2lutenrwdjla7kht3d4t4u47ywvnmkkw");

    expect(tx2.status).toBe(TransactionStatus.Success);
    expect(tx2.amount).toBe(0n);
    expect(tx2.fee).toBe(16000000000000n);
    expect(tx2.gasLimit).toBe(8000n);
    expect(tx2.gasPrice).toBe(2000000000n);
    expect(tx2.nonce).toBe(217n);
    expect(tx2.sender).toBe("zil1jmfl0ywaserpcxa3lu03e8nhestlay3p7fjm43");
  }, 20000);

  it("should update balances for multiple scilla tokens and accounts", async () => {
    const provider = new NetworkProvider(zilConfig);
    const accounts = [
      Address.fromStr("zil1xr07v36qa4zeagg4k5tm6ummht0jrwpcu0n55d"),
      Address.fromStr("zil163dwl9rs82gtq0h5gukrhhvefzqmn3d06vwsmr"),
      Address.fromStr("zil13gt2mjm2cq83mq3e30nwhdt9wl7elcwue094dz"),
    ];
    const tokens = [
      new FToken({
        native: true,
        addr: "zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz",
        name: "Zilliqa",
        symbol: "ZIL",
        decimals: 12,
        addrType: AddressType.Bech32,
        balances: {},
        chainHash: zilConfig.hash(),
        default_: true,
        logo: null,
        rate: 0,
      }),
      new FToken({
        native: false,
        addr: "zil1sxx29cshups269ahh5qjffyr58mxjv9ft78jqy",
        name: "Zilliqa-bridged USDT token",
        symbol: "zUSDT",
        decimals: 6,
        addrType: AddressType.Bech32,
        balances: {},
        chainHash: zilConfig.hash(),
        default_: false,
        logo: null,
        rate: 0,
      }),
      new FToken({
        native: false,
        addr: "zil1l0g8u6f9g0fsvjuu74ctyla2hltefrdyt7k5f4",
        name: "ZilPay Wallet",
        symbol: "ZLP",
        decimals: 18,
        addrType: AddressType.Bech32,
        balances: {},
        chainHash: zilConfig.hash(),
        default_: false,
        logo: null,
        rate: 0,
      }),
    ];

    await provider.updateBalances(tokens, accounts);

    const addr0 = await accounts[0].autoFormat();
    const addr1 = await accounts[1].autoFormat();
    const addr2= await accounts[2].autoFormat();

    expect(BigInt(tokens[0].balances[addr0])).toBeDefined();
    expect(BigInt(tokens[0].balances[addr1])).toBeDefined();
    expect(BigInt(tokens[0].balances[addr2])).toBeDefined();

    expect(BigInt(tokens[1].balances[addr0])).toBeDefined();
    expect(BigInt(tokens[1].balances[addr1])).toBeDefined();
    expect(BigInt(tokens[1].balances[addr2])).toBeDefined();

    expect(BigInt(tokens[2].balances[addr0])).toBeDefined();
    expect(BigInt(tokens[2].balances[addr1])).toBeDefined();
    expect(BigInt(tokens[2].balances[addr2])).toBeDefined();
  }, 20000);

  it("should update balances for multiple EVM tokens and accounts", async () => {
    const provider = new NetworkProvider(ethConfig);
    const accounts = [
      Address.fromStr("0x81014f44b0a345033bb2b3b21c7a1a308b35feea"),
      Address.fromStr("0x3ee18b2214aff97000d974cf647e7c347e8fa585"),
    ];
    const tokens = [
      new FToken({
        native: true,
        addr: "0x0000000000000000000000000000000000000000",
        name: "Ethereum",
        symbol: "ETH",
        decimals: 18,
        addrType: AddressType.EthCheckSum,
        balances: {},
        chainHash: ethConfig.hash(),
        default_: true,
        logo: null,
        rate: 0,
      }),
      new FToken({
        native: false,
        addr: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",
        name: "Wrapped BTC",
        symbol: "WBTC",
        decimals: 8,
        addrType: AddressType.EthCheckSum,
        balances: {},
        chainHash: ethConfig.hash(),
        default_: false,
        logo: null,
        rate: 0,
      }),
    ];

    await provider.updateBalances(tokens, accounts);

    const addr0 = await accounts[0].autoFormat();
    const addr1 = await accounts[1].autoFormat();

    expect(BigInt(tokens[0].balances[addr0])).toBeDefined();
    expect(BigInt(tokens[0].balances[addr1])).toBeDefined();

    expect(BigInt(tokens[1].balances[addr0])).toBeDefined();
    expect(BigInt(tokens[1].balances[addr1])).toBeDefined();
  }, 20000);

  it("should broadcast a signed EVM transaction and fail", async () => {
    const provider = new NetworkProvider(ethConfig);
    const keypair = await KeyPair.generate(ethConfig.slip44);
    const recipient = Address.fromStr(
      "0x451806FE45D9231eb1db3584494366edF05CB4AB",
    );

    const ethTx = Transaction.prepare({
      to: await recipient.toEthChecksum(),
      nonce: 0n,
      value: 1n,
      chainId: BigInt(ethConfig.chainId),
      maxFeePerGas: weigwei.decode("100"),
    });

    const txRequest = new TransactionRequest(
      { chainHash: ethConfig.hash() },
      undefined,
      ethTx,
    );

    const signedTx = await txRequest.sign(keypair);

    await expect(
      provider.broadcastSignedTransactions([signedTx]),
    ).rejects.toThrow(/insufficient funds|nonce too low/);
  }, 20000);

  it("should broadcast a signed Scilla transaction", async () => {
    const provider = new NetworkProvider(zilConfig);
    const keypair = await KeyPair.generate(zilConfig.slip44);
    const recipient = Address.fromStr(
      "zil1xjj35ymsvf9ajqhprwh6pkvejm2lm2e9y4q4ev",
    );

    const zilTx = new ZILTransactionRequest(
      zilConfig.chainId,
      0n,
      2000000000n,
      50n,
      recipient.bytes,
      1000000n,
    );
    const txRequest = new TransactionRequest(
      { chainHash: zilConfig.hash() },
      zilTx,
    );
    const signedTx = await txRequest.sign(keypair);

    await expect(
      provider.broadcastSignedTransactions([signedTx]),
    ).rejects.toThrow("Invalid nonce (0)");
  }, 20000);
});

```

`zil-pay/__tests__/rpc/tx_parse.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import {
  buildSendSignedTxRequest,
  buildPayloadTxReceipt,
  processTxReceiptResponse,
  processTxSendResponse,
} from "../../background/rpc/tx_parse";
import {
  HistoricalTransaction,
  TransactionStatus,
} from "../../background/rpc/history_tx";
import { TransactionReceipt, TransactionRequest } from "../../crypto/tx";
import { ZILTransactionRequest } from "../../crypto/zilliqa_tx";
import { EvmMethods, ZilMethods } from "../../config/jsonrpc";
import { uint8ArrayToHex } from "../../lib/utils/hex";
import { utf8ToUint8Array } from "../../lib/utils/utf8";
import { Address } from "../../crypto/address";
import { KeyPair } from "../../crypto/keypair";
import { randomBytes } from "../../crypto/random";
import { Transaction, weieth, weigwei } from "micro-eth-signer";
import { generateErc20TransferData } from "../../background/rpc/ft_parser";
import { createBscConfig, createZilliqaConfig } from "../data";

describe("Transaction Parse Functions", () => {
  const ZIL_CONFIG = createZilliqaConfig();
  const BSC_CONFIG = createBscConfig();

  const createZilTransactionReceipt = async (): Promise<TransactionReceipt> => {
    const keypair = await KeyPair.generate(ZIL_CONFIG.slip44);
    const toAddr = Address.fromStr(
      "zil1g0n2tsqwyht7xafsmdgq2zrwwt7nnz5arcp2xw",
    );
    const data = JSON.stringify({
      _tag: "Transfer",
      params: [
        {
          vname: "to",
          type: "ByStr20",
          value: "0x066b88d3411c68cb56219e748ae895e1734c0f51",
        },
        {
          vname: "amount",
          type: "Uint128",
          value: "355940000000000000000",
        },
      ],
    });

    const txZilReq = new ZILTransactionRequest(
      42,
      BigInt(1),
      BigInt(2000) * BigInt(10 ** 6),
      BigInt(100000),
      toAddr.bytes,
      BigInt(1) * BigInt(10 ** 12),
      new Uint8Array(),
      utf8ToUint8Array(data),
    );

    const metadata = {
      chainHash: ZIL_CONFIG.hash(),
    };

    const txReq = new TransactionRequest(metadata, txZilReq);
    const receipt = await txReq.sign(keypair);
    receipt.metadata.hash = uint8ArrayToHex(randomBytes(32), true);

    return receipt;
  };

  const createEvmTransactionReceipt = async (): Promise<TransactionReceipt> => {
    const keypair = await KeyPair.generate(BSC_CONFIG.slip44);
    const tokenAddress = Address.fromStr(
      "0x524bC91Dc82d6b90EF29F76A3ECAaBAffFD490Bc",
    );
    const recipient = Address.fromStr(
      "0x246C5881E3F109B2aF170F5C773EF969d3da581B",
    );
    const amount = weieth.decode("69");
    const transferData = generateErc20TransferData(
      await recipient.toEthChecksum(),
      amount,
    );

    const ethTx = Transaction.prepare({
      to: await tokenAddress.toEthChecksum(),
      value: 0n,
      maxFeePerGas: weigwei.decode("1"),
      gasLimit: 24000n,
      maxPriorityFeePerGas: 10n,
      nonce: 0n,
      chainId: BigInt(BSC_CONFIG.chainId),
      data: transferData,
    });

    const metadata = {
      chainHash: BSC_CONFIG.hash(),
    };

    const txReq = new TransactionRequest(metadata, undefined, ethTx);
    const receipt = await txReq.sign(keypair);
    receipt.metadata.hash = uint8ArrayToHex(randomBytes(32), true);

    return receipt;
  };

  const createZilHistoricalTransaction = (): HistoricalTransaction => {
    return new HistoricalTransaction({
      transaction_hash:
        "ce924ea2d0dca2c76af0b8c7858d0401a95f6528122c8f3cd1da11d22b2bb01a",
      amount: 10000000000000n,
      sender: "0x1234567890123456789012345678901234567890",
      recipient: "zil1g0n2tsqwyht7xafsmdgq2zrwwt7nnz5arcp2xw",
      contract_address: null,
      status: TransactionStatus.Pending,
      status_code: null,
      timestamp: Math.floor(Date.now() / 1000) - 60,
      block_number: null,
      gasUsed: null,
      gasLimit: 50000n,
      gasPrice: 2000000000n,
      blobGasUsed: null,
      blobGasPrice: null,
      effectiveGasPrice: null,
      fee: 100000000000000n,
      icon: null,
      title: null,
      error: null,
      sig: "0x304402207fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0",
      nonce: 1n,
      token_info: null,
      chain_type: "Scilla",
      chain_hash: 1,
    });
  };

  const createEvmHistoricalTransaction = (): HistoricalTransaction => {
    return new HistoricalTransaction({
      transaction_hash:
        "0x9a65c7bd4b028cf6e24a184c2a35589c7287358926a1d4492e90c844eb6f37d3",
      amount: 1000000000000000000n,
      sender: "0x7d3034d6281900Af5Ac0b2615E3051884012AF1B",
      recipient: "0x7693F0eC4d80fbe8BeFA31aE845CDE344043dD6e",
      contract_address: "0x7693F0eC4d80fbe8BeFA31aE845CDE344043dD6e",
      status: TransactionStatus.Pending,
      status_code: null,
      timestamp: Math.floor(Date.now() / 1000) - 60,
      block_number: null,
      gasUsed: null,
      gasLimit: 21000n,
      gasPrice: 20000000000n,
      blobGasUsed: null,
      blobGasPrice: null,
      effectiveGasPrice: null,
      fee: 420000000000000n,
      icon: null,
      title: null,
      error: null,
      sig: "0xf86c808504a817c800825208941234567890123456789012345678901234567890872386f26fc10000801ba0",
      nonce: 0n,
      token_info: null,
      chain_type: "EVM",
      chain_hash: 56,
    });
  };

  describe("buildSendSignedTxRequest", () => {
    it("should build request for Zilliqa transaction", async () => {
      const tx = await createZilTransactionReceipt();
      const request = await buildSendSignedTxRequest(tx);

      expect(request.method).toBe(ZilMethods.CreateTransaction);
      expect(request.params).toHaveLength(1);
      expect(request.params[0]).toHaveProperty("version");
      expect(request.params[0]).toHaveProperty("nonce");
      expect(request.params[0]).toHaveProperty("amount");
    });

    it("should build request for EVM transaction", async () => {
      const tx = await createEvmTransactionReceipt();
      const request = await buildSendSignedTxRequest(tx);

      expect(request.method).toBe(EvmMethods.SendRawTransaction);
      expect(request.params).toHaveLength(1);
      expect(typeof request.params[0]).toBe("string");
      expect(request.params[0]).toMatch(/^0x[0-9a-fA-F]+$/);
    });

    it("should throw error for invalid transaction type", async () => {
      const invalidTx = new TransactionReceipt({ chainHash: 1 });
      await expect(() => buildSendSignedTxRequest(invalidTx)).rejects.toThrow(
        "Invalid transaction type",
      );
    });
  });

  describe("buildPayloadTxReceipt", () => {
    it("should build request for Scilla transaction receipt", () => {
      const tx = createZilHistoricalTransaction();
      const request = buildPayloadTxReceipt(tx);

      expect(request.method).toBe(ZilMethods.GetTransactionStatus);
      expect(request.params).toEqual([tx.transaction_hash]);
    });

    it("should build request for EVM transaction receipt", () => {
      const tx = createEvmHistoricalTransaction();
      const request = buildPayloadTxReceipt(tx);

      expect(request.method).toBe(EvmMethods.GetTransactionReceipt);
      expect(request.params).toEqual([tx.transaction_hash]);
    });

    it("should throw error for invalid chain type", () => {
      const tx = createZilHistoricalTransaction();
      tx.chain_type = "Invalid" as any;
      expect(() => buildPayloadTxReceipt(tx)).toThrow("Invalid chain type");
    });
  });

  describe("processTxReceiptResponse", () => {
    it("should process successful Zilliqa transaction receipt", async () => {
      const tx = createZilHistoricalTransaction();
      const response = {
        jsonrpc: "2.0",
        id: "1",
        result: {
          ID: "1bb178b023f816e950d862f6505cd79a32bb97e71fd78441cbc3486940a2e1b7",
          _id: null,
          amount: "15000000000000",
          data: '{"_tag":"AddAccount","params":[{"vname":"address","type":"ByStr20","value":"0x0434cdcf27e2294b3539cb6ffe2cc328d7f9757e"},{"vname":"datetime_added","type":"String","value":"1607488428"}]}',
          epochInserted: "2152404",
          epochUpdated: "2152404",
          gasLimit: "75000",
          gasPrice: "3000000000",
          lastModified: "1607488477327083",
          modificationState: 1,
          status: 3,
          nonce: "2",
          senderAddr:
            "0x023cbc87c0f1f54ba4cfda17a4afc9edca5e074b8f2b5d63d6bfcd05f8c53f8455",
          signature:
            "0xbaa6964c66ae0608c6cefbaab69138e9358a1604c647dffef94e7022f2ab33d67f70802f71e934a0690be4ba81cc3866b2fb668b29c528e6b77b1285533a2e2c",
          success: true,
          toAddr: "0xdb4955ba4b1a957200ee0a36cf5f84eb4d7447e5",
          version: "21823489",
        },
      };

      await processTxReceiptResponse(response, tx);

      expect(tx.amount).toBe(15000000000000n);
      expect(tx.gasLimit).toBe(75000n);
      expect(tx.gasPrice).toBe(3000000000n);
      expect(tx.nonce).toBe(2n);
      expect(tx.status).toBe(TransactionStatus.Success);
      expect(tx.status_code).toBe(3);
      expect(tx.fee).toBe(225000000000000n);
      expect(tx.sender).toBe("zil1p9knv9epazfxq9uyedfjr3xanj3nh29hztx97l");
    });

    it("should process pending Zilliqa transaction", async () => {
      const tx = createZilHistoricalTransaction();
      const response = {
        jsonrpc: "2.0",
        id: "1",
        result: {
          ID: "1bb178b023f816e950d862f6505cd79a32bb97e71fd78441cbc3486940a2e1b7",
          _id: null,
          amount: "10000000000000",
          data: "",
          epochInserted: "2152400",
          epochUpdated: "2152400",
          gasLimit: "50000",
          gasPrice: "2000000000",
          lastModified: "1607488400000000",
          modificationState: 1,
          status: 1,
          nonce: "1",
          senderAddr:
            "0x023cbc87c0f1f54ba4cfda17a4afc9edca5e074b8f2b5d63d6bfcd05f8c53f8455",
          signature:
            "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890ab",
          success: false,
          toAddr: "0xdb4955ba4b1a957200ee0a36cf5f84eb4d7447e5",
          version: "21823489",
        },
      };

      await processTxReceiptResponse(response, tx);

      expect(tx.status).toBe(TransactionStatus.Pending);
      expect(tx.status_code).toBe(1);
      expect(tx.amount).toBe(10000000000000n);
      expect(tx.gasLimit).toBe(50000n);
      expect(tx.gasPrice).toBe(2000000000n);
      expect(tx.nonce).toBe(1n);
      expect(tx.sender).toBe("zil1p9knv9epazfxq9uyedfjr3xanj3nh29hztx97l");
    });

    it("should process rejected Zilliqa transaction", async () => {
      const tx = createZilHistoricalTransaction();
      const response = {
        jsonrpc: "2.0",
        id: "1",
        result: {
          ID: "1bb178b023f816e950d862f6505cd79a32bb97e71fd78441cbc3486940a2e1b7",
          _id: null,
          amount: "10000000000000",
          data: "",
          epochInserted: "2152400",
          epochUpdated: "2152400",
          gasLimit: "50000",
          gasPrice: "2000000000",
          lastModified: "1607488400000000",
          modificationState: 2,
          status: 0,
          nonce: "1",
          senderAddr:
            "0x023cbc87c0f1f54ba4cfda17a4afc9edca5e074b8f2b5d63d6bfcd05f8c53f8455",
          signature:
            "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890ab",
          success: false,
          toAddr: "0xdb4955ba4b1a957200ee0a36cf5f84eb4d7447e5",
          version: "21823489",
          errorMsg: "INSUFFICIENT_BALANCE",
        },
      };

      await processTxReceiptResponse(response, tx);

      expect(tx.status).toBe(0);
      expect(tx.amount).toBe(10000000000000n);
      expect(tx.gasLimit).toBe(50000n);
      expect(tx.gasPrice).toBe(2000000000n);
      expect(tx.nonce).toBe(1n);
      expect(tx.sender).toBe("zil1p9knv9epazfxq9uyedfjr3xanj3nh29hztx97l");
    });

    it("should handle standard length sender address", async () => {
      const tx = createZilHistoricalTransaction();
      const response = {
        jsonrpc: "2.0",
        id: "1",
        result: {
          ID: "1bb178b023f816e950d862f6505cd79a32bb97e71fd78441cbc3486940a2e1b7",
          amount: "10000000000000",
          gasLimit: "50000",
          gasPrice: "2000000000",
          nonce: "1",
          status: 3,
          senderAddr: "0xdb4955ba4b1a957200ee0a36cf5f84eb4d7447e5",
          toAddr: "0x1234567890123456789012345678901234567890",
          success: true,
        },
      };

      await processTxReceiptResponse(response, tx);

      expect(tx.sender).toBe("zil1me34whmtxs5duhhyu7vf02a0zvdtpdxj04uumr");
      expect(tx.status).toBe(TransactionStatus.Success);
    });

    it("should handle Zilliqa transaction timeout", async () => {
      const tx = createZilHistoricalTransaction();
      tx.timestamp = Math.floor(Date.now() / 1000) - 700;
      tx.status = TransactionStatus.Pending;

      const response = {
        id: 1,
        jsonrpc: "2.0",
        result: {
          status: 1,
        },
      };

      await processTxReceiptResponse(response, tx);

      expect(tx.status).toBe(TransactionStatus.Failed);
      expect(tx.error).toBe("timeout");
    });

    it("should process successful EVM transaction receipt", async () => {
      const tx = createEvmHistoricalTransaction();
      const response = {
        id: 1,
        jsonrpc: "2.0",
        result: {
          type: "0x0",
          from: "0x7d3034d6281900af5ac0b2615e3051884012af1b",
          to: "0x7693f0ec4d80fbe8befa31ae845cde344043dd6e",
          status: "0x1",
          cumulativeGasUsed: "0x11faee3",
          transactionHash:
            "0x9a65c7bd4b028cf6e24a184c2a35589c7287358926a1d4492e90c844eb6f37d3",
          contractAddress: null,
          gasUsed: "0x9a235",
          blockHash:
            "0x14842ec868a947aaa9aef4392f7a927abfbaace09d2c0b8ab205eb2d9606f3fc",
          blockNumber: "0x314a8d6",
          transactionIndex: "0x7f",
          effectiveGasPrice: "0x0",
        },
      };

      await processTxReceiptResponse(response, tx);

      expect(tx.sender).toBe("0x7d3034d6281900af5ac0b2615e3051884012af1b");
      expect(tx.recipient).toBe("0x7693f0ec4d80fbe8befa31ae845cde344043dd6e");
      expect(tx.block_number).toBe(0x314a8d6n);
      expect(tx.gasUsed).toBe(0x9a235n);
      expect(tx.effectiveGasPrice).toBe(0x0n);
      expect(tx.status).toBe(TransactionStatus.Success);
      expect(tx.blobGasUsed).toBe(null);
      expect(tx.blobGasPrice).toBe(null);
      expect(tx.fee).toBe(0n);
      expect(tx.contract_address).toBe(null);
    });

    it("should process failed EVM transaction receipt", async () => {
      const tx = createEvmHistoricalTransaction();
      const response = {
        id: 1,
        jsonrpc: "2.0",
        result: {
          status: "0x0",
          gasUsed: "0x5208",
          effectiveGasPrice: "0x174876e800",
          from: "0x742d35Cc6634C0532925a3b8D6C9B5A6abc12345",
        },
      };

      await processTxReceiptResponse(response, tx);

      expect(tx.status).toBe(TransactionStatus.Failed);
    });

    it("should handle RPC error response", async () => {
      const tx = createZilHistoricalTransaction();
      tx.timestamp = Math.floor(Date.now() / 1000) - 700;

      const response = {
        id: 1,
        jsonrpc: "2.0",
        error: {
          code: -32000,
          message: "Transaction not found",
        },
      };

      await processTxReceiptResponse(response, tx);

      expect(tx.status).toBe(TransactionStatus.Failed);
      expect(tx.error).toBe("Transaction not found");
    });
  });

  describe("processTxSendResponse", () => {
    it("should process successful Zilliqa transaction send", async () => {
      const tx = await createZilTransactionReceipt();
      const response = {
        id: 1,
        jsonrpc: "2.0",
        result: {
          Info: "Txn processed",
          TranID:
            "ce924ea2d0dca2c76af0b8c7858d0401a95f6528122c8f3cd1da11d22b2bb01a",
        },
      };

      processTxSendResponse(response, tx);

      expect(tx.metadata.hash).toBe(
        "ce924ea2d0dca2c76af0b8c7858d0401a95f6528122c8f3cd1da11d22b2bb01a",
      );
      expect(tx.metadata.info).toBe("Txn processed");
    });

    it("should process successful EVM transaction send", async () => {
      const tx = await createEvmTransactionReceipt();
      const response = {
        id: 1,
        jsonrpc: "2.0",
        result:
          "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890ab",
      };

      processTxSendResponse(response, tx);

      expect(tx.metadata.hash).toBe(
        "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890ab",
      );
    });

    it("should handle RPC error in send response", async () => {
      const tx = await createZilTransactionReceipt();
      const response = {
        id: 1,
        jsonrpc: "2.0",
        error: {
          code: -32000,
          message: "Insufficient funds",
        },
      };

      expect(() => processTxSendResponse(response, tx)).toThrow(
        "RPC Error: Insufficient funds",
      );
    });

    it("should handle missing TranID in Zilliqa response", async () => {
      const tx = await createZilTransactionReceipt();
      const response = {
        id: 1,
        jsonrpc: "2.0",
        result: {
          Info: "Txn processed",
        },
      };

      expect(() => processTxSendResponse(response, tx)).toThrow(
        "Invalid transaction hash",
      );
    });

    it("should handle invalid EVM hash format", async () => {
      const tx = await createEvmTransactionReceipt();
      const response = {
        id: 1,
        jsonrpc: "2.0",
        result: 123,
      };

      expect(() => processTxSendResponse(response, tx)).toThrow(
        "Invalid transaction hash",
      );
    });

    it("should handle missing result in send response", async () => {
      const tx = await createZilTransactionReceipt();
      const response = {
        id: 1,
        jsonrpc: "2.0",
      };

      expect(() => processTxSendResponse(response, tx)).toThrow(
        "Invalid response: missing result",
      );
    });
  });

  describe("Edge cases and error handling", () => {
    it("should handle malformed Zilliqa status codes", async () => {
      const tx = createZilHistoricalTransaction();
      const response = {
        id: 1,
        jsonrpc: "2.0",
        result: {
          status: 999,
        },
      };

      await processTxReceiptResponse(response, tx);

      expect(tx.status).toBe(TransactionStatus.Failed);
      expect(tx.status_code).toBe(999);
    });

    it("should handle missing optional fields in EVM receipt", async () => {
      const tx = createEvmHistoricalTransaction();
      const response = {
        id: 1,
        jsonrpc: "2.0",
        result: {
          status: "0x1",
          from: "0x742d35Cc6634C0532925a3b8D6C9B5A6abc12345",
          gasUsed: "0x5208",
          effectiveGasPrice: "0x174876e800",
        },
      };

      await processTxReceiptResponse(response, tx);
      expect(tx.status).toBe(TransactionStatus.Success);
      expect(tx.blobGasUsed).toBe(null);
      expect(tx.contract_address).toBe(null);
    });
  });
});

```

`zil-pay/__tests__/session/session.test.ts`:

```ts
import "../setupTests";
import { describe, it, expect } from "vitest";
import { Session, SessionStorageKeys } from "../../background/secure/session";
import { utils } from "aes-js";
import { Runtime } from "../../lib/runtime";
import { uuid } from "../../crypto/uuid";

describe("Session", () => {
  const vaultContent = utils.utf8.toBytes("test vault");
  const sessionTime = 60;
  const testUuid = uuid(); // Generate a test UUID

  it("setSession stores and getVault retrieves content", async () => {
    const session = new Session(testUuid);
    await session.setSession(sessionTime, vaultContent);
    const result = await session.getVault();
    expect(result).toEqual(vaultContent);
  });

  it("clearSession removes all data", async () => {
    const session = new Session(testUuid);
    await session.setSession(sessionTime, vaultContent);
    await session.clearSession();
    await expect(session.getVault()).rejects.toThrow("Session does not exist");
  });

  it("getVault throws error after session expires", async () => {
    const session = new Session(testUuid);
    await session.setSession(1, vaultContent); // 1 second
    await new Promise((resolve) => setTimeout(resolve, 2000)); // Wait 2 seconds
    await expect(session.getVault()).rejects.toThrow("Session has expired");
    const data = await Runtime.storage.session.get([
      `${SessionStorageKeys.EndSession}:${testUuid}`,
      `${SessionStorageKeys.SessionKey}:${testUuid}`,
      `${SessionStorageKeys.VaultCipher}:${testUuid}`,
    ]);
    expect(data).toEqual({
      [`${SessionStorageKeys.EndSession}:${testUuid}`]: undefined,
      [`${SessionStorageKeys.SessionKey}:${testUuid}`]: undefined,
      [`${SessionStorageKeys.VaultCipher}:${testUuid}`]: undefined,
    });
  });
});

```

`zil-pay/__tests__/setupTests.ts`:

```ts
import { vi } from "vitest";
import sinonChrome from "sinon-chrome";
import { EXTENSION_ID } from "./data";

global.chrome = sinonChrome;
global.chrome.runtime.id = EXTENSION_ID;

const sessionStorageMock = (() => {
  let store: { [key: string]: any } = {};

  return {
    set: vi.fn(async (items: { [key: string]: any }) => {
      store = { ...store, ...items };
    }),
    get: vi.fn(async (keys?: string | string[] | null) => {
      if (!keys) return store;
      if (typeof keys === "string") return { [keys]: store[keys] };
      if (Array.isArray(keys)) {
        const result: { [key: string]: any } = {};
        for (const key of keys) {
          result[key] = store[key];
        }
        return result;
      }
      return {};
    }),
    clear: vi.fn(async () => {
      store = {};
    }),
    setAccessLevel: vi.fn(
      async ({ accessLevel: level }: { accessLevel: string }) => {
        if (
          level !== "TRUSTED_CONTEXTS" &&
          level !== "TRUSTED_AND_UNTRUSTED_CONTEXTS"
        ) {
          throw new Error("Invalid access level");
        }
      },
    ),
  };
})();

const createLocalStorageMock = () => {
  let store = {}; // The in-memory store for our mock

  return {
    get: vi.fn(async (keys) => {
      if (!keys) {
        return Promise.resolve(store);
      }

      const result = {};
      const keyList = Array.isArray(keys) ? keys : [keys];

      for (const key of keyList) {
        if (store.hasOwnProperty(key)) {
          result[key] = store[key];
        }
      }

      return Promise.resolve(result);
    }),

    set: vi.fn(async (items) => {
      store = { ...store, ...items };
      return Promise.resolve();
    }),

    clear: vi.fn(async () => {
      store = {};
      return Promise.resolve();
    }),
  };
};

const mockGetRandomValues = (array: Uint8Array): Uint8Array => {
  for (let i = 0; i < array.length; i++) {
    array[i] = Math.floor(Math.random() * 256);
  }
  return array;
};

const localStorageMock = createLocalStorageMock();

(global as any).window = {
  crypto: {
    getRandomValues: vi.fn(mockGetRandomValues),
  },
};

(globalThis as any).chrome.storage.session = sessionStorageMock;
Object.defineProperty(global.chrome.storage, "local", {
  value: localStorageMock,
  writable: true,
});

```

`zil-pay/__tests__/state.test.ts`:

```ts
import "./setupTests";
import { describe, it, expect, beforeAll } from "vitest";
import { GlobalState } from "../background/state";
import { BackgroundState } from "../background/storage/background";
import { Themes } from "../config/theme";
import { RatesApiOptions } from "../config/api";
import {
  createBscConfig,
  createEthConfig,
  PASSWORD,
  STORAGE_V2,
  STORAGE_V3,
  WORDS,
} from "./data";
import { BrowserStorage } from "../lib/storage";
import { Wallet } from "../background/storage/wallet";
import { WalletTypes, AuthMethod } from "../config/wallet";
import { AddressType } from "../crypto/address";
import { CipherOrders } from "../crypto/keychain";
import { HashTypes } from "../background/storage/argon";
import { ShaAlgorithms } from "../config/pbkdf2";
import { FToken } from "../background/storage/ftoken";
import { utf8ToUint8Array } from "../lib/utils/utf8";
import { ChainConfig } from "../background/storage/chain";
import { WalletSettings } from "../background/storage/settings";
import { WORD_LIST } from "./crypto/word_list";
import {
  HistoricalTransaction,
  TransactionStatus,
} from "../background/rpc/history_tx";

describe("test bg state with empty storage", () => {
  beforeAll(async () => {
    await BrowserStorage.clear();
  });

  it("should init from emtpy storage", async () => {
    const globalState = await GlobalState.fromStorage();
    expect(globalState.state).toStrictEqual(BackgroundState.default());
  });

  it("should save storage", async () => {
    const globalState = await GlobalState.fromStorage();

    expect(globalState.state).toStrictEqual(BackgroundState.default());

    globalState.state.appearances = Themes.Light;
    globalState.state.abbreviatedNumber = false;
    globalState.state.chains.push(createBscConfig());
    globalState.state.chains.push(createEthConfig());

    await globalState.sync();

    const restoredGlobalState = await GlobalState.fromStorage();

    expect(restoredGlobalState).toStrictEqual(globalState);
  });

  it("should save storage", async () => {
    await BrowserStorage.clear();
    const globalState = await GlobalState.fromStorage();

    expect(globalState.state).toStrictEqual(BackgroundState.default());

    globalState.state.chains.push(createBscConfig());

    const bip32Accounts = [
      { index: 0, name: "account 0" },
      { index: 1, name: "account 1" },
      { index: 2, name: "account 2" },
      { index: 3, name: "account 3" },
      { index: 4, name: "account 4" },
    ];
    const settings = new WalletSettings({
      cipherOrders: [
        CipherOrders.KUZNECHIK,
        CipherOrders.NTRUP761,
        CipherOrders.AESGCM256,
      ],
      hashFnParams: {
        memory: 4096,
        iterations: 3,
        threads: 1,
        secret: "",
        hashType: 0,
        hashSize: ShaAlgorithms.Sha512,
      },
      currencyConvert: "btc",
      ipfsNode: null,
      ensEnabled: false,
      tokensListFetcher: false,
      nodeRankingEnabled: false,
      maxConnections: 10,
      requestTimeoutSecs: 30,
      ratesApiOptions: RatesApiOptions.None,
      sessionTime: 3600,
    });
    const bip39Wallet = await Wallet.fromBip39(
      WORDS,
      true,
      "Test Wallet",
      bip32Accounts,
      settings,
      globalState.state.chains[0],
      PASSWORD,
      WORD_LIST,
    );

    globalState.state.wallets.push(bip39Wallet);

    const historicalTx = new HistoricalTransaction({
      transaction_hash:
        "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
      amount: 1000n,
      sender: "zil1senderaddress",
      recipient: "zil1recipientaddress",
      contract_address: null,
      status: TransactionStatus.Success,
      status_code: 3,
      timestamp: 1672531200000,
      block_number: 12345n,
      gasUsed: 21000n,
      gasLimit: 21000n,
      gasPrice: 1000000000n,
      blobGasUsed: null,
      blobGasPrice: null,
      effectiveGasPrice: 1000000000n,
      fee: 21000000000000n,
      icon: null,
      title: "Test Transaction",
      error: null,
      sig: "0xabcdef123456",
      nonce: 1n,
      token_info: null,
      chain_type: "Scilla",
      chain_hash: globalState.state.chains[0].hash(),
      data: "some data",
      code: "some code",
    });

    globalState.state.wallets[0].history.push(historicalTx);


    await globalState.sync();
    const restoredGlobalState = await GlobalState.fromStorage();
    expect(JSON.stringify(restoredGlobalState.state)).toEqual(
      JSON.stringify(globalState.state),
    );
  });
});

describe("test bg state with storagev2", () => {
  beforeAll(async () => {
    await BrowserStorage.clear();
    await BrowserStorage.set(STORAGE_V2);
  });

  it("should init from storage v2", async () => {
    const globalState = await GlobalState.fromStorage();

    expect(globalState.state.chains.length).toBe(1);
    expect(globalState.state.wallets.length).toBe(1);

    const wallet: Wallet = globalState.state.wallets[0];

    expect(wallet.walletType).toBe(WalletTypes.SecretPhrase);
    expect(wallet.walletName).toBe("Zilliqa Wallet");
    expect(wallet.authType).toBe(AuthMethod.None);
    expect(wallet.selectedAccount).toBe(1);
    expect(wallet.defaultChainHash).toBe(208425510);
    expect(wallet.vault).toBe(
      "U2FsdGVkX19+DrC9DG/qvYEC6koZfMhpQl6K4eVH5GSE1qXyn4vENND7zZFNT5R4yZM/45MiWMTw+Olu2Va948mputTGoby3VfmNmIm1uiVgRYt6hycdMiUBFuWs0KqN",
    );

    expect(wallet.accounts.length).toBe(2);
    const [account0, account1] = wallet.accounts;

    expect(account0.name).toBe("Account 0");
    expect(account0.addr).toBe("zil1ntrynx04349sk6py7uyata03gka6qswg7um95y");
    expect(account0.addrType).toBe(AddressType.Bech32);
    expect(account0.pubKey).toBe(
      "0316f2d913f13c6aa15ad5c80b58464d25b6363a1b9d997260e8061977a3f43e10",
    );
    expect(account0.index).toBe(0);

    expect(account1.name).toBe("Imported 0");
    expect(account1.addr).toBe("zil14at57zaj4pe3tuy734usy2xnlquapkd4d0ne43");
    expect(account1.addrType).toBe(AddressType.Bech32);
    expect(account1.pubKey).toBe(
      "0232970d0472220180c1779610f0ffae5a1ad79048b4f01f366c52d99317534024",
    );
    expect(account1.index).toBe(0);

    expect(wallet.tokens.length).toBe(2);
    const zilToken = wallet.tokens.find((t: FToken) => t.symbol === "ZIL");
    const zlpToken = wallet.tokens.find((t: FToken) => t.symbol === "ZLP");

    expect(zilToken).toBeDefined();
    expect(zilToken?.name).toBe("Zilliqa");
    expect(zilToken?.decimals).toBe(12);
    expect(zilToken?.addr).toBe("zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz");
    expect(zilToken?.addrType).toBe(AddressType.Bech32);
    expect(zilToken?.balances).toEqual({ "0": "0", "1": "0" });
    expect(zilToken?.rate).toBe(1);
    expect(zilToken?.default_).toBe(true);
    expect(zilToken?.native).toBe(true);

    expect(zlpToken).toBeDefined();
    expect(zlpToken?.name).toBe("ZilPay wallet");
    expect(zlpToken?.decimals).toBe(18);
    expect(zlpToken?.addr).toBe("zil1l0g8u6f9g0fsvjuu74ctyla2hltefrdyt7k5f4");
    expect(zlpToken?.balances).toEqual({ "0": "0", "1": "0" });
    expect(zlpToken?.rate).toBe(2.7688998049);
    expect(zlpToken?.default_).toBe(false);
    expect(zlpToken?.native).toBe(false);

    const { settings } = wallet;
    expect(settings.cipherOrders).toEqual([CipherOrders.AESCBC]);
    expect(settings.currencyConvert).toBe("usd");
    expect(settings.requestTimeoutSecs).toBe(30);

    const { hashFnParams } = settings;
    expect(hashFnParams.hashType).toBe(HashTypes.Pbkdf2);
    expect(hashFnParams.hashSize).toBe(ShaAlgorithms.sha256);
    expect(hashFnParams.iterations).toBe(0);
    expect(hashFnParams.memory).toBe(1024);
    expect(hashFnParams.threads).toBe(1);

    const chain: ChainConfig = globalState.state.chains[0];
    const passowrd = utf8ToUint8Array(PASSWORD);
    await wallet.unlock(passowrd);
    const words = await wallet.revealMnemonic(passowrd, chain);

    expect(words).toBe(WORDS);
  });
});

describe("test bg state with storagev3", () => {
  beforeAll(async () => {
    await BrowserStorage.clear();
    await BrowserStorage.set(STORAGE_V3);
  });

  it("should init from storage v3", async () => {
    const globalState = await GlobalState.fromStorage();

    expect(globalState.state.chains.length).toBe(1);
    expect(globalState.state.wallets.length).toBe(1);

    const wallet: Wallet = globalState.state.wallets[0];

    expect(wallet.walletType).toBe(WalletTypes.SecretPhrase);
    expect(wallet.walletName).toBe("Zilliqa Wallet");
    expect(wallet.authType).toBe(AuthMethod.None);
    expect(wallet.selectedAccount).toBe(1);
    expect(wallet.defaultChainHash).toBe(208425510);
    expect(wallet.vault).toEqual(
      "ZGM1ODdhZGI0YWVhY2E3Njk4MDJlYTEyMzMxOGY5OGZlMjMxMzNhYzY1ZDc4ZTUzYjFiZmI0YTYxNDY5OTAzZGQ2NDAzNWFjZmQzNGVkODZjYzc3NTc0NWE4NjI4N2Y3NWI0OTdiYzk4OGFjMzg0MDM5MWY5MGJjY2FmMjllNmU4NmEyMjJkMy8zODIzZWMwNmEyMDA4ZDZhODcyMTY3MzAwMzlmZTBlYw==",
    );

    expect(wallet.accounts.length).toBe(2);
    const [account0, account1] = wallet.accounts;

    expect(account0.name).toBe("Account 0");
    expect(account0.addr).toBe("zil1ntrynx04349sk6py7uyata03gka6qswg7um95y");
    expect(account1.name).toBe("Imported 0");
    expect(account1.addr).toBe("zil14at57zaj4pe3tuy734usy2xnlquapkd4d0ne43");

    expect(wallet.tokens.length).toBe(3);
    const zilToken = wallet.tokens.find((t: FToken) => t.symbol === "ZIL");
    const zlpToken = wallet.tokens.find((t: FToken) => t.symbol === "ZLP");
    const stZilToken = wallet.tokens.find((t: FToken) => t.symbol === "stZIL");

    expect(zilToken).toBeDefined();
    expect(zilToken?.rate).toBe(1);

    expect(zlpToken).toBeDefined();
    expect(zlpToken?.rate).toBe(2.7915277475);

    expect(stZilToken).toBeDefined();
    expect(stZilToken?.name).toBe("StZIL");
    expect(stZilToken?.addr).toBe("zil1umc54ly88xjw4599gtq860le0qvsuwuj72s246");
    expect(stZilToken?.rate).toBe(1.2063766095);

    const { settings } = wallet;
    expect(settings.cipherOrders).toEqual([CipherOrders.AESGCM256]);
    expect(settings.currencyConvert).toBe("btc");

    const { hashFnParams } = settings;
    expect(hashFnParams.hashType).toBe(HashTypes.Pbkdf2);
    expect(hashFnParams.hashSize).toBe(ShaAlgorithms.Sha512);
    expect(hashFnParams.iterations).toBe(442368);
    expect(hashFnParams.memory).toBe(1024);
    expect(hashFnParams.threads).toBe(1);

    const chain: ChainConfig = globalState.state.chains[0];
    const password = utf8ToUint8Array(PASSWORD);
    await wallet.unlock(password);
    const words = await wallet.revealMnemonic(password, chain);

    expect(words).toBe(WORDS);
  });
});

```

`zil-pay/__tests__/storage/migrator.test.ts`:

```ts
import "../setupTests";
import { describe, it, expect } from "vitest";
import { migrateToV4 } from "../../background/secure/migrator";
import { AddressType } from "../../crypto/address";
import { Themes } from "../../config/theme";
import {
  BackgroundState,
} from "../../background/storage/background";
import { ChainConfig } from "../../background/storage/chain";
import { FToken } from "../../background/storage/ftoken";
import {
  Wallet,
} from "../../background/storage/wallet";
import { WalletTypes, AuthMethod } from "../../config/wallet";
import { Account } from "../../background/storage/account";
import { HashTypes, WalletHashParams } from "../../background/storage/argon";
import { CipherOrders } from "../../crypto/keychain";
import { ShaAlgorithms } from "../../config/pbkdf2";
import { TypeOf } from "../../lib/types";
import { PASSWORD, STORAGE_V2, STORAGE_V3, WORDS } from "../data";
import { utils } from "aes-js";

// Helper function to create a minimal storage object for version 4
const createV4Storage = (): Record<string, unknown> => ({
  storageVersion: 4,
  wallets: [],
  notificationsGlobalEnabled: true,
  locale: "auto",
  appearances: "System",
  abbreviatedNumber: true,
  hideBalance: false,
  chains: [],
});

describe("migrateToV4", () => {
  // Test case 1: Storage already at version 4
  it("should return BackgroundState with unchanged storage if already version 4", () => {
    const storageV4 = createV4Storage();
    const result = migrateToV4(storageV4);

    expect(result).toBeInstanceOf(BackgroundState);
    expect(result.storageVersion).toBe(4);
    expect(result.wallets).toEqual([]);
    expect(result.notificationsGlobalEnabled).toBe(true);
    expect(result.locale).toBe("auto");
    expect(result.appearances).toBe("System");
    expect(result.abbreviatedNumber).toBe(true);
    expect(result.hideBalance).toBe(false);
    expect(result.chains).toEqual([]);
  });

  // Test case 2: Migration from version 2
  it("should correctly migrate from version 2", () => {
    const result = migrateToV4(STORAGE_V2);

    // Top-level BackgroundState properties
    expect(result).toBeInstanceOf(BackgroundState);
    expect(result.storageVersion).toBe(4);
    expect(result.wallets).toHaveLength(1);
    expect(result.notificationsGlobalEnabled).toBe(true);
    expect(result.locale).toBe("auto");
    expect(result.appearances).toBe(Themes.System);
    expect(result.abbreviatedNumber).toBe(true);
    expect(result.hideBalance).toBe(false);
    expect(result.chains).toHaveLength(1);

    // Wallet properties
    const wallet = result.wallets[0];
    expect(wallet).toBeInstanceOf(Wallet);
    expect(wallet.walletType).toBe(WalletTypes.SecretPhrase);
    expect(wallet.walletName).toBe("Zilliqa Wallet");
    expect(wallet.authType).toBe(AuthMethod.None);
    expect(wallet.selectedAccount).toBe(1); // From STORAGE_V2.selectedAddress
    expect(wallet.vault).toBe(STORAGE_V2.vault);
    expect(wallet.defaultChainHash).toBe(208425510);
    expect(wallet.uuid).toBeDefined();

    // Accounts
    expect(wallet.accounts).toHaveLength(2);
    const account0 = wallet.accounts[0];
    expect(account0).toBeInstanceOf(Account);
    expect(account0.name).toBe("Account 0");
    expect(account0.addr).toBe("zil1ntrynx04349sk6py7uyata03gka6qswg7um95y");
    expect(account0.addrType).toBe(AddressType.Bech32);
    expect(account0.pubKey).toBe(
      "0316f2d913f13c6aa15ad5c80b58464d25b6363a1b9d997260e8061977a3f43e10",
    );
    expect(account0.chainHash).toBe(result.chains[0].hash());
    expect(account0.chainId).toBe(32769);
    expect(account0.slip44).toBe(313);
    expect(account0.index).toBe(0);

    const account1 = wallet.accounts[1];
    expect(account1.name).toBe("Imported 0");
    expect(account1.addr).toBe("zil14at57zaj4pe3tuy734usy2xnlquapkd4d0ne43");
    expect(account1.pubKey).toBe(
      "0232970d0472220180c1779610f0ffae5a1ad79048b4f01f366c52d99317534024",
    );
    expect(account1.index).toBe(0);

    // Tokens
    expect(wallet.tokens).toHaveLength(2);
    const zilToken = wallet.tokens.find((t) => t.symbol === "ZIL")!;
    expect(zilToken).toBeDefined();
    expect(zilToken).toBeInstanceOf(FToken);
    expect(zilToken.addr).toBe("zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz");
    expect(zilToken.name).toBe("Zilliqa");
    expect(zilToken.symbol).toBe("ZIL");
    expect(zilToken.decimals).toBe(12);
    expect(zilToken.addrType).toBe(AddressType.Bech32);
    expect(zilToken.balances[0]).toBe("0");
    expect(zilToken.balances[1]).toBe("0");
    expect(zilToken.rate).toBe(1);
    expect(zilToken.default_).toBe(true);
    expect(zilToken.native).toBe(true);
    expect(zilToken.chainHash).toBe(result.chains[0].hash());

    const zlpToken = wallet.tokens.find((t) => t.symbol === "ZLP")!;
    expect(zlpToken).toBeDefined();
    expect(zlpToken.addr).toBe("zil1l0g8u6f9g0fsvjuu74ctyla2hltefrdyt7k5f4");
    expect(zlpToken.name).toBe("ZilPay wallet");
    expect(zlpToken.symbol).toBe("ZLP");
    expect(zlpToken.decimals).toBe(18);
    expect(zlpToken.balances[0]).toBe("0");
    expect(zlpToken.balances[1]).toBe("0");
    expect(zlpToken.rate).toBe(2.7688998049);

    // Chain
    const chain = result.chains[0];
    expect(chain).toBeInstanceOf(ChainConfig);
    expect(chain.name).toBe("Zilliqa");
    expect(chain.chain).toBe("ZIL");
    expect(chain.chainId).toBe(32769);
    expect(chain.hash()).toBe(208425510);
    expect(chain.slip44).toBe(313);

    // Wallet settings
    expect(wallet.settings.currencyConvert).toBe("usd");
    expect(wallet.settings.cipherOrders).toEqual([CipherOrders.AESCBC]);
    expect(wallet.settings.hashFnParams).toEqual({
      memory: 1024,
      iterations: 0,
      threads: 1,
      secret: "",
      hashType: HashTypes.Pbkdf2,
      hashSize: ShaAlgorithms.sha256,
    });
  });

  // Test case 3: Migration from version 3
  it("should correctly migrate from version 3", () => {
    const result = migrateToV4(STORAGE_V3);

    // Top-level BackgroundState properties
    expect(result.storageVersion).toBe(4);
    expect(result.wallets).toHaveLength(1);
    expect(result.notificationsGlobalEnabled).toBe(true);
    expect(result.locale).toBe("auto");
    expect(result.appearances).toBe(Themes.System);
    expect(result.abbreviatedNumber).toBe(true);
    expect(result.hideBalance).toBe(false);
    expect(result.chains).toHaveLength(1);

    // Wallet properties
    const wallet = result.wallets[0];
    expect(wallet.walletType).toBe(WalletTypes.SecretPhrase);
    expect(wallet.walletName).toBe("Zilliqa Wallet");
    expect(wallet.authType).toBe(AuthMethod.None);
    expect(wallet.selectedAccount).toBe(1);
    expect(wallet.vault).toBe(STORAGE_V3.vault);
    expect(wallet.defaultChainHash).toBe(result.chains[0].hash());
    expect(wallet.uuid).toBeDefined();

    // Accounts
    expect(wallet.accounts).toHaveLength(2);
    const account0 = wallet.accounts[0];
    expect(account0.name).toBe("Account 0");
    expect(account0.addr).toBe("zil1ntrynx04349sk6py7uyata03gka6qswg7um95y");
    expect(account0.pubKey).toBe(
      "0316f2d913f13c6aa15ad5c80b58464d25b6363a1b9d997260e8061977a3f43e10",
    );
    expect(account0.index).toBe(0);

    const account1 = wallet.accounts[1];
    expect(account1.name).toBe("Imported 0");
    expect(account1.addr).toBe("zil14at57zaj4pe3tuy734usy2xnlquapkd4d0ne43");
    expect(account1.pubKey).toBe(
      "0232970d0472220180c1779610f0ffae5a1ad79048b4f01f366c52d99317534024",
    );
    expect(account1.index).toBe(0);

    // Tokens
    expect(wallet.tokens).toHaveLength(3);
    const zilToken = wallet.tokens.find((t) => t.symbol === "ZIL")!;
    expect(zilToken).toBeDefined();
    expect(zilToken.addr).toBe("zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz");
    expect(zilToken.balances[0]).toBe("0");
    expect(zilToken.balances[1]).toBe("0");
    expect(zilToken.rate).toBe(1);

    const zlpToken = wallet.tokens.find((t) => t.symbol === "ZLP")!;
    expect(zlpToken).toBeDefined();
    expect(zlpToken.addr).toBe("zil1l0g8u6f9g0fsvjuu74ctyla2hltefrdyt7k5f4");
    expect(zlpToken.balances[0]).toBe("0");
    expect(zlpToken.balances[1]).toBe("0");
    expect(zlpToken.rate).toBe(2.7915277475);

    const stZilToken = wallet.tokens.find((t) => t.symbol === "stZIL")!;
    expect(stZilToken).toBeDefined();
    expect(stZilToken.addr).toBe("zil1umc54ly88xjw4599gtq860le0qvsuwuj72s246");
    expect(stZilToken.name).toBe("StZIL");
    expect(stZilToken.symbol).toBe("stZIL");
    expect(stZilToken.decimals).toBe(12);
    expect(stZilToken.balances[0]).toBe("0");
    expect(stZilToken.balances[1]).toBe("0");
    expect(stZilToken.rate).toBe(1.2063766095);

    // Chain
    const chain = result.chains[0];
    expect(chain.name).toBe("Zilliqa");
    expect(chain.chainId).toBe(chain.chainIds[0]);

    // Wallet settings
    expect(wallet.settings.currencyConvert).toBe("btc");
    expect(wallet.settings.cipherOrders).toEqual([CipherOrders.AESGCM256]);
    expect(wallet.settings.hashFnParams).toEqual({
      memory: 1024,
      iterations: 442368,
      threads: 1,
      secret: "",
      hashType: HashTypes.Pbkdf2,
      hashSize: "SHA-512",
    });
  });

  it("test migrate and decrypt storage v2", async () => {
    const result = migrateToV4(STORAGE_V2);
    const wallet = result.wallets[0];
    const password = utils.utf8.toBytes(PASSWORD);
    const decrypted = await wallet.decrypt(password);

    expect(decrypted).toEqual(WORDS);

    wallet.settings.cipherOrders = [
      CipherOrders.AESGCM256,
      CipherOrders.NTRUP761,
    ];
    wallet.settings.hashFnParams = WalletHashParams.default();
    await wallet.encrypt(password, utils.utf8.toBytes(String(decrypted)));
    const decryptedWithArgon = await wallet.decrypt(password);

    expect(TypeOf.isString(decryptedWithArgon)).toBe(true);
    expect(decryptedWithArgon).toEqual(WORDS);
  });

  it("test migrate and decrypt storage v3", async () => {
    const result = migrateToV4(STORAGE_V3);
    const wallet = result.wallets[0];
    const password = utils.utf8.toBytes(PASSWORD);
    const decrypted = await wallet.decrypt(password);

    expect(TypeOf.isString(decrypted)).toBe(true);
    expect(decrypted).toEqual(WORDS);

    wallet.settings.hashFnParams = WalletHashParams.default();
    wallet.settings.cipherOrders = [
      CipherOrders.AESGCM256,
      CipherOrders.KUZNECHIK,
    ];

    await wallet.encrypt(password, utils.utf8.toBytes(String(decrypted)));
    const decryptedWithArgon = await wallet.decrypt(password);

    expect(TypeOf.isString(decryptedWithArgon)).toBe(true);
    expect(decryptedWithArgon).toEqual(WORDS);
  });
});

```

`zil-pay/__tests__/storage/storage.test.ts`:

```ts
import {
  BackgroundState,
} from "../../background/storage/background";
import { Themes } from "../../config/theme";
import { Locales } from "../../config/locale";
import { ChainConfig } from "../../background/storage/chain";
import {
  Wallet,
} from "../../background/storage/wallet";
import { WalletTypes, AuthMethod } from "../../config/wallet";
import { HashTypes } from "../../background/storage/argon";
import { CipherOrders } from "../../crypto/keychain";
import { AddressType } from "../../crypto/address";
import { ShaAlgorithms } from "../../config/pbkdf2";
import { describe, expect, it } from "vitest";
import { CHAINS } from "../data";

describe("BackgroundState", () => {
  it("should initialize with correct properties", () => {
    const mockData = {
      wallets: [
        {
          walletType: WalletTypes.SecretPhrase,
          walletName: "Test Wallet",
          authType: AuthMethod.None,
          walletAddress: "zil1testaddress",
          accounts: [
            {
              addr: "zil1testaddress",
              addrType: AddressType.Bech32,
              name: "Test Account",
              pubKey: "testPubKey",
              chainHash: 1,
              chainId: 1,
              slip44: 313,
              index: 0,
            },
          ],
          selectedAccount: 0,
          tokens: [
            {
              name: "Zilliqa",
              symbol: "ZIL",
              decimals: 12,
              addr: "zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz",
              addrType: AddressType.Bech32,
              logo: null,
              balances: { 0: "1000" },
              rate: 0,
              default_: true,
              native: true,
              chainHash: 1,
            },
          ],
          settings: {
            cipherOrders: [CipherOrders.AESCBC],
            hashFnParams: {
              memory: 1024,
              iterations: 0,
              threads: 1,
              secret: "",
              hashType: HashTypes.Pbkdf2,
              hashSize: ShaAlgorithms.sha256,
            },
            currencyConvert: "btc",
            ipfsNode: null,
            ensEnabled: false,
            tokensListFetcher: false,
            nodeRankingEnabled: false,
            maxConnections: 10,
            requestTimeoutSecs: 30,
            ratesApiOptions: 0,
          },
          defaultChainHash: 1,
          vault: "testVault",
        },
      ],
      notificationsGlobalEnabled: true,
      locale: "en",
      appearances: Themes.System,
      abbreviatedNumber: true,
      hideBalance: false,
      chains: CHAINS,
    };

    const state = new BackgroundState(mockData);

    expect(state.storageVersion).toBe(4);
    expect(state.wallets).toHaveLength(1);
    expect(state.wallets[0]).toBeInstanceOf(Wallet);
    expect(state.notificationsGlobalEnabled).toBe(true);
    expect(state.locale).toBe("en");
    expect(state.appearances).toBe(Themes.System);
    expect(state.abbreviatedNumber).toBe(true);
    expect(state.hideBalance).toBe(false);
    expect(state.chains).toHaveLength(3);
    expect(state.chains[0]).toBeInstanceOf(ChainConfig);
  });

  it("should handle null locale correctly", () => {
    const mockData = {
      wallets: [],
      notificationsGlobalEnabled: false,
      locale: null,
      appearances: Themes.Dark,
      abbreviatedNumber: false,
      hideBalance: true,
      chains: [],
    };

    const state = new BackgroundState(mockData);

    expect(state.locale).toBe(Locales.Auto);
    expect(state.appearances).toBe(Themes.Dark);
    expect(state.abbreviatedNumber).toBe(false);
    expect(state.hideBalance).toBe(true);
  });
});

```

`zil-pay/__tests__/storage/wallet.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import {
  Wallet,
} from "../../background/storage/wallet";
import {
  WalletSettings,
} from "../../background/storage/settings";
import { AuthMethod, WalletTypes } from "../../config/wallet";
import { RatesApiOptions } from "../../config/api";
import { ChainConfig } from "../../background/storage/chain";
import { WORD_LIST } from "../crypto/word_list";
import { CHAINS, PASSWORD } from "../data";
import { CipherOrders } from "../../crypto/keychain";
import { ShaAlgorithms } from "../../config/pbkdf2";
import { uint8ArrayToBase64 } from "../../crypto/b64";
import { randomBytes } from "../../crypto/random";
import { KeyPair } from "../../crypto/keypair";
import { hexToUint8Array } from '../../lib/utils/hex';
import { utf8ToUint8Array } from '../../lib/utils/utf8';

describe("Wallet", () => {
  const MNEMONIC =
    "green process gate doctor slide whip priority shrug diamond crumble average help";
  const settings = new WalletSettings({
    cipherOrders: [CipherOrders.NTRUP761],
    hashFnParams: {
      memory: 4096,
      iterations: 3,
      threads: 1,
      secret: "",
      hashType: 0,
      hashSize: ShaAlgorithms.Sha512,
    },
    currencyConvert: "btc",
    ipfsNode: null,
    ensEnabled: false,
    tokensListFetcher: false,
    nodeRankingEnabled: false,
    maxConnections: 10,
    requestTimeoutSecs: 30,
    ratesApiOptions: RatesApiOptions.CoinGecko,
    sessionTime: 3600,
  });
  const chain = new ChainConfig(CHAINS[0]);
  const bip32Accounts = [{ index: 0, name: "account 0" }];
  const SK_KEY = hexToUint8Array(
      "e93c035175b08613c4b0251ca92cd007026ca032ba53bafa3c839838f8b52d04",
  );
  const PK_KEY = hexToUint8Array(
      "03150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da",
  );

  describe("revealMnemonic", () => {
    it("reveals mnemonic for SecretPhrase wallet with correct password", async () => {
      const wallet = await Wallet.fromBip39(
        MNEMONIC,
        true,
        "Test Wallet",
        bip32Accounts,
        settings,
        chain,
        PASSWORD,
        WORD_LIST,
      );

      const mnemonic = await wallet.revealMnemonic(
        utf8ToUint8Array(PASSWORD),
        chain,
      );
      expect(mnemonic).toBe(MNEMONIC);
    });

    it("throws error for invalid chain hash", async () => {
      const wallet = await Wallet.fromBip39(
        MNEMONIC,
        true,
        "Test Wallet",
        bip32Accounts,
        settings,
        chain,
        PASSWORD,
        WORD_LIST,
      );
      const wrongChain = new ChainConfig(CHAINS[2]);

      await expect(
        wallet.revealMnemonic(utf8ToUint8Array(PASSWORD), wrongChain),
      ).rejects.toThrow("invlid chain");
    });

    it("throws error for non-SecretPhrase wallet", async () => {
      const wallet = new Wallet({
        walletType: WalletTypes.SecretKey,
        walletName: "Test Wallet",
        authType: AuthMethod.None,
        accounts: [],
        selectedAccount: 0,
        tokens: [],
        settings,
        defaultChainHash: chain.hash(),
        uuid: "test-uuid",
        vault: "",
      });

      await expect(
        wallet.revealMnemonic(utf8ToUint8Array(PASSWORD), chain),
      ).rejects.toThrow(
        `Invalid wallet type ${WalletTypes[WalletTypes.SecretKey]}`,
      );
    });
  });

  describe("revealKeypair", () => {
    it("reveals keypair for SecretPhrase wallet", async () => {
      const wallet = await Wallet.fromBip39(
        MNEMONIC,
        true,
        "Test Wallet",
        bip32Accounts,
        settings,
        chain,
        PASSWORD,
        WORD_LIST,
      );

      await wallet.unlock(utf8ToUint8Array(PASSWORD));
      const keypair = await wallet.revealKeypair(0, chain);

      expect(keypair.pubKey).toEqual(PK_KEY);
      expect(keypair.privateKey).toEqual(SK_KEY);
    });

    it("throws error for invalid chain hash", async () => {
      const wallet = await Wallet.fromBip39(
        MNEMONIC,
        true,
        "Test Wallet",
        bip32Accounts,
        settings,
        chain,
        PASSWORD,
        WORD_LIST,
      );
      const wrongChain = new ChainConfig(CHAINS[2]);

      await expect(wallet.revealKeypair(0, wrongChain)).rejects.toThrow(
        "invlid chain",
      );
    });

    it("throws error for invalid wallet type", async () => {
      const wallet = new Wallet({
        walletType: WalletTypes.Ledger,
        walletName: "Test Wallet",
        authType: AuthMethod.None,
        accounts: [],
        selectedAccount: 0,
        tokens: [],
        settings,
        defaultChainHash: chain.hash(),
        uuid: "test-uuid",
        vault: "",
      });

      await expect(wallet.revealKeypair(0, chain)).rejects.toThrow(
        `Invalid wallet type ${WalletTypes[WalletTypes.Ledger]}`,
      );
    });
  });

  describe("unlock", () => {
    it("unlocks SecretPhrase wallet and sets session", async () => {
      const wallet = await Wallet.fromBip39(
        MNEMONIC,
        true,
        "Test Wallet",
        bip32Accounts,
        settings,
        chain,
        PASSWORD,
        WORD_LIST,
      );

      await wallet.unlock(utf8ToUint8Array(PASSWORD));
      const keypair = await wallet.revealKeypair(0, chain);

      expect(keypair.pubKey).toEqual(PK_KEY);
      expect(keypair.privateKey).toEqual(SK_KEY);
    });

    it("throws error for invalid vault type", async () => {
      const wallet = new Wallet({
        walletType: WalletTypes.SecretPhrase,
        walletName: "Test Wallet",
        authType: AuthMethod.None,
        accounts: [],
        selectedAccount: 0,
        tokens: [],
        settings,
        defaultChainHash: chain.hash(),
        uuid: "test-uuid",
        vault: uint8ArrayToBase64(randomBytes(220)),
      });

      await expect(
        wallet.unlock(utf8ToUint8Array(PASSWORD)),
      ).rejects.toThrow();
    });
  });

  describe("fromPrivateKey", () => {
    it("creates a wallet from a private key", async () => {
      const keyPair = await KeyPair.fromPrivateKey(SK_KEY, chain.slip44);
      const wallet = await Wallet.fromPrivateKey(
        keyPair,
        "My SK Wallet",
        "Primary Account",
        settings,
        chain,
        PASSWORD,
      );

      expect(wallet.walletName).toBe("My SK Wallet");
      expect(wallet.walletType).toBe(WalletTypes.SecretKey);
      expect(wallet.accounts.length).toBe(1);

      const account = wallet.accounts[0];
      expect(account.name).toBe("Primary Account");

      const address = await keyPair.address();
      
     expect(account.addr).toBe(await address.toZilBech32());
    });

    it("fails to unlock and reveal keypair due to incorrect wallet type", async () => {
      const keyPair = await KeyPair.fromPrivateKey(SK_KEY, chain.slip44);
      const wallet = await Wallet.fromPrivateKey(
        keyPair,
        "My SK Wallet",
        "Primary Account",
        settings,
        chain,
        PASSWORD,
      );
      
      await expect(wallet.revealMnemonic(utf8ToUint8Array(PASSWORD), chain)).rejects.toThrow(
        "Invalid wallet type SecretKey",
      );
    });
  });
});

```

`zil-pay/__tests__/stream/stream.test.ts`:

```ts
import { describe, it, expect, beforeEach, vi } from "vitest";
import { Message, ReqBody } from "lib/streem/message";
import { Runtime } from "lib/runtime/extensionizer";

vi.mock("lib/runtime/extensionizer", () => ({
  Runtime: {
    runtime: {
      sendMessage: vi.fn(),
    },
  },
}));

describe("Basic Test Message - Error Handling", () => {
  const mockConsoleError = vi.fn();

  beforeEach(() => {
    console.error = mockConsoleError;
    (Runtime.runtime.sendMessage as ReturnType<typeof vi.fn>).mockClear();
  });

  it("should catch sendMessage error and log it", async () => {
    const message = Message.signal("ERROR_MESSAGE");
    const sendMessageMock = Runtime.runtime.sendMessage as ReturnType<
      typeof vi.fn
    >;
    const errorMessage = "Simulated send error";
    sendMessageMock.mockImplementation(() => {
      throw new Error(errorMessage);
    });

    await expect(message.send()).rejects.toThrow("service_worker_stopped");
    expect(sendMessageMock).toHaveBeenCalledTimes(10);
  });
});

describe("Basic Test Message - Successful Send and Receive", () => {
  beforeEach(() => {
    (Runtime.runtime.sendMessage as ReturnType<typeof vi.fn>).mockClear();
  });

  it("should send the message and receive a response", async () => {
    const body: ReqBody<{ data: string }> = {
      type: "TEST_MESSAGE",
      payload: { data: "test" },
    };
    const message = new Message(body);
    const mockResponse = { result: "success" };

    (
      Runtime.runtime.sendMessage as ReturnType<typeof vi.fn>
    ).mockImplementation((_msg, callback) => {
      callback(mockResponse);
    });

    const response = await message.send();

    expect(Runtime.runtime.sendMessage).toHaveBeenCalledOnce();
    expect(Runtime.runtime.sendMessage).toHaveBeenCalledWith(
      body,
      expect.any(Function),
    );
    expect(response).toEqual(mockResponse);
  });
});

```

`zil-pay/__tests__/types/checker.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import { TypeOf } from "lib/types/checker.ts";

describe("TypeOf", () => {
  it("should correctly identify arrays", () => {
    expect(TypeOf.isArray([])).toBe(true);
    expect(TypeOf.isArray([1, 2, 3])).toBe(true);
    expect(TypeOf.isArray(new Array(3))).toBe(true);
    expect(TypeOf.isArray({})).toBe(false);
    expect(TypeOf.isArray(null)).toBe(false);
    expect(TypeOf.isArray(undefined)).toBe(false);
    expect(TypeOf.isArray("abc")).toBe(false);
  });

  it("should correctly identify plain objects", () => {
    expect(TypeOf.isObject({})).toBe(true);
    expect(TypeOf.isObject({ a: 1, b: 2 })).toBe(true);
    expect(TypeOf.isObject(new Object())).toBe(true);
    expect(TypeOf.isObject([])).toBe(false);
    expect(TypeOf.isObject(null)).toBe(false);
    expect(TypeOf.isObject(undefined)).toBe(false);
    expect(TypeOf.isObject("abc")).toBe(false);
    expect(TypeOf.isObject(new Date())).toBe(false);
    expect(TypeOf.isObject(new Error())).toBe(false);
    class MyClass {}
    expect(TypeOf.isObject(new MyClass())).toBe(false);
  });

  it("should correctly identify numbers", () => {
    expect(TypeOf.isNumber(0)).toBe(true);
    expect(TypeOf.isNumber(10)).toBe(true);
    expect(TypeOf.isNumber(-5)).toBe(true);
    expect(TypeOf.isNumber(3.14)).toBe(true);
    expect(TypeOf.isNumber(NaN)).toBe(false);
    expect(TypeOf.isNumber(Infinity)).toBe(true);
    expect(TypeOf.isNumber(-Infinity)).toBe(true);
    expect(TypeOf.isNumber("10")).toBe(false);
    expect(TypeOf.isNumber(null)).toBe(false);
    expect(TypeOf.isNumber(undefined)).toBe(false);
    expect(TypeOf.isNumber({})).toBe(false);
  });

  it("should correctly identify integers", () => {
    expect(TypeOf.isInt(0)).toBe(true);
    expect(TypeOf.isInt(10)).toBe(true);
    expect(TypeOf.isInt(-5)).toBe(true);
    expect(TypeOf.isInt(3.14)).toBe(false);
    expect(TypeOf.isInt(NaN)).toBe(false);
    expect(TypeOf.isInt(Infinity)).toBe(false);
    expect(TypeOf.isInt("10")).toBe(false);
    expect(TypeOf.isInt(null)).toBe(false);
    expect(TypeOf.isInt(undefined)).toBe(false);
    expect(TypeOf.isInt({})).toBe(false);
    expect(TypeOf.isInt(Number.MAX_SAFE_INTEGER)).toBe(true);
    expect(TypeOf.isInt(Number.MIN_SAFE_INTEGER)).toBe(true);
  });

  it("should correctly identify error objects", () => {
    expect(TypeOf.isError(new Error())).toBe(true);
    expect(TypeOf.isError(new TypeError())).toBe(true);
    expect(TypeOf.isError(new SyntaxError())).toBe(true);
    expect(TypeOf.isError({})).toBe(false);
    expect(TypeOf.isError(null)).toBe(false);
    expect(TypeOf.isError(undefined)).toBe(false);
    expect(TypeOf.isError("Error")).toBe(false);
  });

  it("should correctly identify strings", () => {
    expect(TypeOf.isString("")).toBe(true);
    expect(TypeOf.isString("abc")).toBe(true);
    expect(TypeOf.isString(new String("abc"))).toBe(true);
    expect(TypeOf.isString(123)).toBe(false);
    expect(TypeOf.isString(null)).toBe(false);
    expect(TypeOf.isString(undefined)).toBe(false);
    expect(TypeOf.isString({})).toBe(false);
  });

  it("should correctly identify booleans", () => {
    expect(TypeOf.isBoolean(true)).toBe(true);
    expect(TypeOf.isBoolean(false)).toBe(true);
    expect(TypeOf.isBoolean(new Boolean(true))).toBe(true);
    expect(TypeOf.isBoolean(0)).toBe(false);
    expect(TypeOf.isBoolean(1)).toBe(false);
    expect(TypeOf.isBoolean(null)).toBe(false);
    expect(TypeOf.isBoolean(undefined)).toBe(false);
    expect(TypeOf.isBoolean({})).toBe(false);
  });

  it("should correctly identify null", () => {
    expect(TypeOf.isNull(null)).toBe(true);
    expect(TypeOf.isNull(undefined)).toBe(false);
    expect(TypeOf.isNull(0)).toBe(false);
    expect(TypeOf.isNull("")).toBe(false);
    expect(TypeOf.isNull({})).toBe(false);
  });

  it("should correctly identify undefined", () => {
    expect(TypeOf.isUndefined(undefined)).toBe(true);
    expect(TypeOf.isUndefined(null)).toBe(false);
    expect(TypeOf.isUndefined(0)).toBe(false);
    expect(TypeOf.isUndefined("")).toBe(false);
    expect(TypeOf.isUndefined({})).toBe(false);
  });

  it("should correctly identify empty objects", () => {
    expect(TypeOf.isEmptyObject({})).toBe(true);
    expect(TypeOf.isEmptyObject({ a: 1 })).toBe(false);
    expect(TypeOf.isEmptyObject(new Object())).toBe(true);
    expect(TypeOf.isEmptyObject(null)).toBe(false);
    expect(TypeOf.isEmptyObject(undefined)).toBe(false);
    expect(TypeOf.isEmptyObject([])).toBe(false);
  });

  it("should correctly identify empty arrays", () => {
    expect(TypeOf.isEmptyArray([])).toBe(true);
    expect(TypeOf.isEmptyArray([1, 2, 3])).toBe(false);
    expect(TypeOf.isEmptyArray(new Array(0))).toBe(true);
    expect(TypeOf.isEmptyArray(null)).toBe(false);
    expect(TypeOf.isEmptyArray(undefined)).toBe(false);
    expect(TypeOf.isEmptyArray({})).toBe(false);
  });
});

```

`zil-pay/__tests__/utils/hex.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import {
  hasHexPrefix,
  stripHexPrefix,
  uint8ArrayToHex,
  hexToUint8Array,
  hexToBigInt,
} from "../../lib/utils/hex";

describe("Hex Utility Functions", () => {
  describe("hasHexPrefix", () => {
    it("should return true for lowercase prefix", () => {
      expect(hasHexPrefix("0x123")).toBe(true);
    });

    it("should return true for uppercase prefix", () => {
      expect(hasHexPrefix("0X123")).toBe(true);
    });

    it("should return false for no prefix", () => {
      expect(hasHexPrefix("123")).toBe(false);
    });

    it("should return false for an empty string", () => {
      expect(hasHexPrefix("")).toBe(false);
    });

    it("should return false when '0x' is in the middle", () => {
      expect(hasHexPrefix("120x34")).toBe(false);
    });
  });

  describe("stripHexPrefix", () => {
    it("should strip lowercase prefix", () => {
      expect(stripHexPrefix("0xabcdef")).toBe("abcdef");
    });

    it("should strip uppercase prefix", () => {
      expect(stripHexPrefix("0XABCDEF")).toBe("ABCDEF");
    });

    it("should not change a string without a prefix", () => {
      expect(stripHexPrefix("abcdef")).toBe("abcdef");
    });

    it("should handle an empty string", () => {
      expect(stripHexPrefix("")).toBe("");
    });
  });

  describe("uint8ArrayToHex", () => {
    it("should convert a Uint8Array to a hex string without prefix", () => {
      const arr = new Uint8Array([72, 101, 108, 108, 111]); // "Hello"
      expect(uint8ArrayToHex(arr)).toBe("48656c6c6f");
    });

    it("should convert a Uint8Array to a hex string with prefix", () => {
      const arr = new Uint8Array([72, 101, 108, 108, 111]);
      expect(uint8ArrayToHex(arr, true)).toBe("0x48656c6c6f");
    });

    it("should handle an empty Uint8Array", () => {
      const arr = new Uint8Array([]);
      expect(uint8ArrayToHex(arr)).toBe("");
      expect(uint8ArrayToHex(arr, true)).toBe("0x");
    });

    it("should handle single-digit hex values correctly with padding", () => {
      const arr = new Uint8Array([1, 15, 16]);
      expect(uint8ArrayToHex(arr)).toBe("010f10");
    });
  });

  describe("hexToUint8Array", () => {
    it("should convert a hex string without prefix to a Uint8Array", () => {
      const hex = "48656c6c6f";
      const expected = new Uint8Array([72, 101, 108, 108, 111]);
      expect(hexToUint8Array(hex)).toEqual(expected);
    });

    it("should convert a hex string with prefix to a Uint8Array", () => {
      const hex = "0x48656c6c6f";
      const expected = new Uint8Array([72, 101, 108, 108, 111]);
      expect(hexToUint8Array(hex)).toEqual(expected);
    });

    it("should handle mixed-case hex strings", () => {
      const hex = "0x48eLLO"; // Invalid, but tests parser logic
      const hexMixed = "0x48656C6c6F";
      const expected = new Uint8Array([72, 101, 108, 108, 111]);
      expect(hexToUint8Array(hexMixed)).toEqual(expected);
    });

    it("should return an empty Uint8Array for an empty string", () => {
      expect(hexToUint8Array("")).toEqual(new Uint8Array());
    });

    it("should return an empty Uint8Array for '0x'", () => {
      expect(hexToUint8Array("0x")).toEqual(new Uint8Array());
    });

    it("should throw an error for an odd number of characters", () => {
      const hex = "0x123";
      expect(() => hexToUint8Array(hex)).toThrow(
        "Invalid hex string: must have an even number of characters.",
      );
    });
  });

  describe("hexToBigInt", () => {
    it("should convert a simple hex string to a BigInt", () => {
      expect(hexToBigInt("ff")).toBe(255n);
    });

    it("should convert a hex string with prefix to a BigInt", () => {
      expect(hexToBigInt("0x100")).toBe(256n);
    });

    it("should handle a zero value", () => {
      expect(hexToBigInt("0x0")).toBe(0n);
    });

    it("should throw a SyntaxError for invalid hex", () => {
      expect(() => hexToBigInt("0xgg")).toThrow(SyntaxError);
    });
  });

  describe("Round-trip conversions", () => {
    it("should correctly convert Uint8Array -> hex -> Uint8Array", () => {
      const originalArray = new Uint8Array([0, 5, 10, 15, 250, 255]);
      const hex = uint8ArrayToHex(originalArray);
      const newArray = hexToUint8Array(hex);
      expect(newArray).toEqual(originalArray);
    });

    it("should correctly convert hex -> Uint8Array -> hex", () => {
      const originalHex = "abcdef1234567890";
      const array = hexToUint8Array(originalHex);
      const newHex = uint8ArrayToHex(array);
      expect(newHex).toBe(originalHex);
    });
  });
});

```

`zil-pay/__tests__/utils/locale.test.ts`:

```ts
import { describe, it, expect } from 'vitest';
import { detectLanguage } from '../../lib/utils/locale';


describe('detectLanguage', () => {
  it('detects English', () => {
    expect(detectLanguage('hello')).toBe('en');
  });

  it('detects Russian', () => {
    expect(detectLanguage('привет')).toBe('ru');
  });

  it('detects Japanese', () => {
    expect(detectLanguage('こんにちは')).toBe('ja');
  });

  it('detects Korean', () => {
    expect(detectLanguage('안녕하세요')).toBe('ko');
  });

  it('detects Spanish with accents', () => {
    expect(detectLanguage('niño')).toBe('es');
  });

  it('detects basic Spanish as English', () => {
    expect(detectLanguage('hola')).toBe('en');
  });

  it('throws for unknown language', () => {
    expect(() => detectLanguage('مرحبا')).toThrow('Unknown language');
    expect(() => detectLanguage('')).toThrow('Unknown language');
    expect(() => detectLanguage('123')).toThrow('Unknown language');
  });
});

```

`zil-pay/__tests__/utils/utf8.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import { utf8ToUint8Array, uint8ArrayToUtf8 } from "../../lib/utils/utf8";

describe("UTF-8 Conversion", () => {
  it("should convert a simple string to a Uint8Array", () => {
    const str = "hello";
    const expected = new Uint8Array([104, 101, 108, 108, 111]);
    expect(utf8ToUint8Array(str)).toEqual(expected);
  });

  it("should convert a Uint8Array to a simple string", () => {
    const arr = new Uint8Array([104, 101, 108, 108, 111]);
    const expected = "hello";
    expect(uint8ArrayToUtf8(arr)).toBe(expected);
  });

  it("should handle an empty string", () => {
    const str = "";
    const expected = new Uint8Array([]);
    expect(utf8ToUint8Array(str)).toEqual(expected);
  });

  it("should handle an empty Uint8Array", () => {
    const arr = new Uint8Array([]);
    const expected = "";
    expect(uint8ArrayToUtf8(arr)).toBe(expected);
  });

  it("should correctly handle special UTF-8 characters", () => {
    const str = "ZilPay ❤️ криптография";
    const expected = new Uint8Array([
      90, 105, 108, 80, 97, 121, 32, 226, 157, 164, 239, 184, 143, 32, 208, 186,
      209, 128, 208, 184, 208, 191, 209, 130, 208, 190, 208, 179, 209, 128, 208,
      176, 209, 132, 208, 184, 209, 143,
    ]);
    expect(utf8ToUint8Array(str)).toEqual(expected);
  });

  it("should perform a round-trip conversion correctly", () => {
    const originalStr =
      "This is a test string with various characters: !@#$%^&*()_+";
    const uint8Array = utf8ToUint8Array(originalStr);
    const finalStr = uint8ArrayToUtf8(uint8Array);
    expect(finalStr).toBe(originalStr);
  });
});

```

`zil-pay/__tests__/zilliqa/zil_address.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import {
  toChecksumHexAddress,
  toChecksumBytesAddress,
} from "../../lib/zilliqa/checksum";
import { fromZilPubKey } from "../../lib/zilliqa/pubkey.ts";
import { utils } from "aes-js";
import { toBech32Address, fromBech32Address } from "../../lib/zilliqa/bech32";

describe("Address Conversion Tests", () => {
  describe("toChecksumAddress", () => {
    it("should correctly checksum a valid lowercase address", async () => {
      const address = "8617b72e22090f0c13167865147ec48a6db788ff";
      const checksummed = await toChecksumHexAddress(address);
      expect(checksummed).toBe("0x8617B72E22090f0c13167865147eC48a6dB788ff");
    });

    it("should correctly checksum another valid address", async () => {
      const address = "0000000000000000000000000000000000000000";
      const checksummed = await toChecksumHexAddress(address);
      expect(checksummed).toBe("0x0000000000000000000000000000000000000000");
    });

    it("should correctly derive a bech32 address from a public key", async () => {
      const pubkeyHex =
        "03150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da";
      const pubkeyBytes = utils.hex.toBytes(pubkeyHex);
      const addrBytes = await fromZilPubKey(pubkeyBytes);
      const checksummed = await toChecksumBytesAddress(addrBytes);

      expect(checksummed).toBe("0xEBd8b370Dddb636FAF641040D2181c55190840fb");
    });
  });

  describe("toBech32Address", () => {
    it("should correctly encode a valid hexadecimal address to Bech32", async () => {
      const hexAddress = "0x7793a8e8c09d189d4d421ce5bc5b3674656c5ac1";
      const bech32Address = await toBech32Address(hexAddress);
      expect(bech32Address).toBe("zil1w7f636xqn5vf6n2zrnjmckekw3jkckkpyrd6z8");
    });
  });

  describe("fromBech32Address", () => {
    it("should correctly decode a valid Bech32 address to a checksummed hexadecimal address", async () => {
      const bech32Address = "zil1w7f636xqn5vf6n2zrnjmckekw3jkckkpyrd6z8";
      const hexAddress = fromBech32Address(bech32Address);
      expect(hexAddress).toBe("0x7793a8e8c09d189d4d421ce5bc5b3674656c5ac1");
    });

    it("should throw an error for an invalid Bech32 address length", async () => {
      const invalidBech32 = "zi21w7f636xqn5vf6n2zrnjmckekw3jkckkpyrd6z8";
      expect(() => fromBech32Address(invalidBech32)).toThrow();
    });

    it("should throw an error for a Bech32 address with an incorrect HRP", async () => {
      const wrongHRP = "btc1qwertzuiopasdfghjklmnbvcxy";
      expect(() => fromBech32Address(wrongHRP)).toThrow();
    });
  });
});

```

`zil-pay/background/background.ts`:

```ts
import { MTypePopup } from "config/stream";
import type { GlobalState } from "./state";
import { Runtime } from "lib/runtime";

export function startBackground(core: GlobalState) {
  Runtime.runtime.onMessage.addListener((msg, sender, sendResponse) => {
    if (sender.id !== Runtime.runtime.id) {
      sendResponse(null);
      return true;
    }

    switch (msg.type) {
      case MTypePopup.GET_GLOBAL_STATE:
        core.wallet.getGlobalState(sendResponse);
        return true;
      case MTypePopup.SET_GLOBAL_STATE:
        core.wallet.setGlobalState(msg.payload, sendResponse);
        return true;
      case MTypePopup.GEN_BIP39:
        core.wallet.genBip39Words(msg.payload.count, msg.payload.wordList, sendResponse);
        return true;
      case MTypePopup.VALIDATE_BIP39_CHECK_SUM:
        core.wallet.validateBip39CheckSum(msg.payload.phrase, msg.payload.wordList, sendResponse);
        return true;
      case MTypePopup.GEN_KEYPAIR:
        core.wallet.genKeyPair(msg.payload.slip44, sendResponse);
        return true;
      case MTypePopup.FROM_PRIV_KEY:
        core.wallet.keyPairFromPrivateKey(msg.payload.slip44, msg.payload.key, sendResponse);
        return true;
      case MTypePopup.WALLET_FROM_PRIVATE_KEY:
        core.wallet.walletFromPrivateKey(msg.payload, sendResponse);
        return true;
      case MTypePopup.WALLET_FROM_BIP39:
        core.wallet.walletFromBip39(msg.payload, sendResponse);
        return true;
      default:
        sendResponse(null);
        return true;
    }
  });
}

```

`zil-pay/background/index.ts`:

```ts
import { startBackground } from "background/background";
import { GlobalState } from "background/state";

(async function () {
  const state = await GlobalState.fromStorage();

  startBackground(state);
})();

```

`zil-pay/background/rpc/block.ts`:

```ts
export interface EVMBlock {
  /** The hash of the block. null when it's a pending block. */
  hash: string;
  /** The hash of the parent block. */
  parentHash: string;
  /** The SHA3 of the uncles data in the block. */
  sha3Uncles: string;
  /** The address of the beneficiary to whom the mining rewards were given. */
  miner: string;
  /** The root of the state trie of the block. */
  stateRoot: string;
  /** The root of the transaction trie of the block. */
  transactionsRoot: string;
  /** The root of the receipts trie of the block. */
  receiptsRoot: string;
  /** The bloom filter for the logs of the block. null when it's a pending block. */
  logsBloom: string;
  /** The total difficulty of the chain until this block. */
  totalDifficulty: string;
  /** The block number. null when it's a pending block. */
  number: string;
  /** The maximum gas allowed in this block. */
  gasLimit: string;
  /** The total used gas by all transactions in this block. */
  gasUsed: string;
  /** The unix timestamp for when the block was collated. */
  timestamp: string;
  /** The "extra data" field of this block. */
  extraData: string;
  /** The hash of the generated proof-of-work. null when it's a pending block. */
  mixHash: string;
  /** The nonce of the generated proof-of-work. null when it's a pending block. */
  nonce: string;
  /** The size of this block in bytes. */
  size: string;
  /** The difficulty for this block. */
  difficulty: string;
  /** Array of transaction objects, or 32-byte transaction hashes. */
  transactions: string[];
  /** Array of uncle hashes. */
  uncles: string[];
  /** The root of the withdrawals trie of the block. */
  withdrawalsRoot?: string;
  /** An array of withdrawal objects. */
  withdrawals?: any[];
  /** The base fee per gas. */
  baseFeePerGas?: string;
  /** The gas used for blobs. */
  blobGasUsed?: string;
  /** The excess blob gas. */
  excessBlobGas?: string;
  /** The parent beacon block root. */
  parentBeaconBlockRoot?: string;
}

```

`zil-pay/background/rpc/ft_parser.ts`:

```ts
import { RpcProvider, type JsonRPCRequest, type JsonRPCResponse } from './provider';
import { EvmMethods, ZilMethods } from 'config/jsonrpc';
import { createContract } from 'micro-eth-signer/abi.js';
import { hexToBigInt, hexToUint8Array, uint8ArrayToHex } from 'lib/utils/hex';
import { Address, AddressType } from 'crypto/address';
import { TypeOf } from 'lib/types';

const ERC20_ABI = [
  { name: 'name', type: 'function', outputs: [{ type: 'string' }] },
  { name: 'symbol', type: 'function', outputs: [{ type: 'string' }] },
  { name: 'decimals', type: 'function', outputs: [{ type: 'uint8' }] },
  {
    name: 'balanceOf',
    type: 'function',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    name: 'transfer',
    type: 'function',
    inputs: [
      { name: 'recipient', type: 'address' },
      { name: 'amount', type: 'uint256' },
    ],
    outputs: [{ type: 'bool' }],
  },
] as const;

export enum MetadataField {
  Name = 'name',
  Symbol = 'symbol',
  Decimals = 'decimals',
}

type FunctionName = 'name' | 'symbol' | 'decimals' | 'balanceOf' | 'transfer';
type FunctionArgs = {
  name: [];
  symbol: [];
  decimals: [];
  balanceOf: [string];
  transfer: [string, bigint];
};

export type RequestType =
  | { type: 'Metadata'; field: MetadataField; address?: Address }
  | { type: 'Balance'; address: Address };

export interface GetTokenInitItem {
  vname: string;
  type: string;
  value: string;
}

export interface ZilBalanceResponse {
  balance: string;
  nonce: number;
}

export interface ZilSmartContractSubStateResponse {
  balances: {
    [key: string]: string;
  };
}

function validateResponse<T>(response: JsonRPCResponse<T>): T {
  if (response.error) {
    throw new Error(
      `RPC Error (code: ${response.error.code}): ${response.error.message}`,
    );
  }
  if (TypeOf.isUndefined(response.result)) {
    throw new Error('RPC Error: Response missing result field');
  }

  return response.result as T;
}

export class ERC20Helper {
  readonly #contract;

  constructor() {
    this.#contract = createContract(ERC20_ABI);
  }

  encodeFunctionCall<T extends FunctionName>(
    functionName: T,
    args: FunctionArgs[T],
  ): string {
    let encodedData: Uint8Array;

    switch (functionName) {
      case 'name':
        encodedData = this.#contract.name.encodeInput();
        break;
      case 'symbol':
        encodedData = this.#contract.symbol.encodeInput();
        break;
      case 'decimals':
        encodedData = this.#contract.decimals.encodeInput();
        break;
      case 'balanceOf':
        encodedData = this.#contract.balanceOf.encodeInput(String(args[0]));
        break;
      case 'transfer':
        encodedData = this.#contract.transfer.encodeInput({
          recipient: String(args[0]),
          amount: BigInt(args[1] ?? 0), 
        });
        break;
      default:
        throw new Error(`Unsupported function: ${functionName}`);
    }

    return uint8ArrayToHex(encodedData, true);
  }

  decodeFunctionOutput(functionName: FunctionName, data: string) {
    const bytes = hexToUint8Array(data);

    switch (functionName) {
      case 'name':
        return this.#contract.name.decodeOutput(bytes);
      case 'symbol':
        return this.#contract.symbol.decodeOutput(bytes);
      case 'decimals':
        return this.#contract.decimals.decodeOutput(bytes);
      case 'balanceOf':
        return this.#contract.balanceOf.decodeOutput(bytes);
      case 'transfer':
        return this.#contract.transfer.decodeOutput(bytes);
      default:
        throw new Error(`Unsupported function: ${functionName}`);
    }
  }

  public generateTransferInput(to: string, amount: bigint): string {
    return this.encodeFunctionCall('transfer', [to, amount]);
  }
}

export function generateErc20TransferData(to: string, amount: bigint): string {
  const erc20 = new ERC20Helper();
  return erc20.generateTransferInput(to, amount);
}

export async function buildTokenRequests(
  contract: Address,
  accounts: Address[],
  native: boolean,
): Promise<{ payload: JsonRPCRequest; requestType: RequestType }[]> {
  const requests: { payload: JsonRPCRequest; requestType: RequestType }[] = [];
  if (contract.type === AddressType.Bech32) {
    await buildZilRequests(contract, accounts, native, requests);
  } else {
    await buildEthRequests(contract, accounts, native, requests);
  }

  return requests;
}

async function buildZilRequests(
  contract: Address,
  accounts: Address[],
  native: boolean,
  requests: { payload: JsonRPCRequest; requestType: RequestType }[],
): Promise<void> {
  const base16Contract = contract.toBase16();
  requests.push({
    payload: RpcProvider.buildPayload(ZilMethods.GetSmartContractInit, [
      base16Contract,
    ]),
    requestType: { type: 'Metadata', field: MetadataField.Name },
  });
  for (const account of accounts) {
    const base16Account = (await account.toZilChecksum()).toLowerCase();
    let payload;
    if (native) {
      payload = RpcProvider.buildPayload(ZilMethods.GetBalance, [
        base16Account,
      ]);
    } else {
      payload = RpcProvider.buildPayload(ZilMethods.GetSmartContractSubState, [
        base16Contract,
        'balances',
        [base16Account],
      ]);
    }
    requests.push({
      payload,
      requestType: { type: 'Balance', address: account },
    });
  }
}

async function buildEthRequests(
  contract: Address,
  accounts: Address[],
  native: boolean,
  requests: { payload: JsonRPCRequest; requestType: RequestType }[],
): Promise<void> {
  const erc20 = new ERC20Helper();
  const tokenAddr = await contract.toEthChecksum();

  const buildEthCall = (data: string): JsonRPCRequest => {
    return RpcProvider.buildPayload(EvmMethods.Call, [
      {
        to: tokenAddr,
        data,
      },
      'latest',
    ]);
  };

  const metadataFields: FunctionName[] = [
    'name',
    'symbol',
    'decimals',
  ];

  for (const field of metadataFields) {
    const data = erc20.encodeFunctionCall(field, []);
    requests.push({
      payload: buildEthCall(data),
      requestType: { type: 'Metadata', field: field as MetadataField },
    });
  }

  for (const account of accounts) {
    let payload;
    const ethAddress = await account.toEthChecksum();
    if (native) {
      payload = RpcProvider.buildPayload(EvmMethods.GetBalance, [
        ethAddress,
        'latest',
      ]);
    } else {
      const callData = erc20.encodeFunctionCall('balanceOf', [
        ethAddress,
      ]);
      payload = buildEthCall(callData);
    }
    requests.push({
      payload,
      requestType: { type: 'Balance', address: account },
    });
  }
}

export function processEthMetadataResponse(
  response: JsonRPCResponse<string>,
  field: MetadataField,
): string {
  const resultHex = validateResponse(response);
  const erc20 = new ERC20Helper();

  const decoded = erc20.decodeFunctionOutput(
    field as FunctionName,
    resultHex,
  );
  return String(decoded);
}

export function processZilMetadataResponse(
  response: JsonRPCResponse<GetTokenInitItem[]>,
): { name: string; symbol: string; decimals: number } {
  const initData = validateResponse(response);

  const getField = (fieldName: string): string => {
    const item = initData.find((item) => item.vname === fieldName);
    if (!item) {
      throw new Error(`Invalid contract init: missing ${fieldName}`);
    }
    return item.value;
  };

  const name = getField('name');
  const symbol = getField('symbol');
  const decimals = parseInt(getField('decimals'), 10);
  if (isNaN(decimals)) {
    throw new Error('Invalid decimals format in contract init');
  }

  return { name, symbol, decimals };
}

export function processEthBalanceResponse(response: JsonRPCResponse<string>): bigint {
  const resultHex = validateResponse(response);
  return hexToBigInt(resultHex);
}

export async function processZilBalanceResponse(
  response: JsonRPCResponse<ZilBalanceResponse | ZilSmartContractSubStateResponse>,
  account: Address,
  isNative: boolean,
): Promise<bigint> {
  try {
    const result = validateResponse(response);
    if (isNative) {
      return BigInt((result as ZilBalanceResponse).balance || '0');
    } else {
      const addr = (await account.toZilChecksum()).toLowerCase();
      const balances = (result as ZilSmartContractSubStateResponse).balances;
      return BigInt(balances?.[addr] || '0');
    }
  } catch (error) {
    return 0n;
  }
}


```

`zil-pay/background/rpc/gas_parse.ts`:

```ts
import { TransactionRequest } from 'crypto/tx';
import { EvmMethods, ZilMethods } from 'config/jsonrpc';
import { Address } from 'crypto/address';
import { buildNonceRequest } from 'background/rpc/nonce_parser';
import { RpcProvider, type JsonRPCRequest } from 'background/rpc/provider';
import { TypeOf } from 'lib/types';

export interface GasFeeHistory {
  maxFee: bigint;
  priorityFee: bigint;
  baseFee: bigint;
}

export interface RequiredTxParams {
  gasPrice: bigint;
  maxPriorityFee: bigint;
  feeHistory: GasFeeHistory;
  txEstimateGas: bigint;
  blobBaseFee: bigint;
  nonce: number;
}

export interface FeeHistoryResult {
  baseFeePerGas: string[];
  reward: string[][];
  oldestBlock: string;
  gasUsedRatio: number[];
}

export const EIP1559 = 1559;
export const EIP4844 = 4844;

class NetworkError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'NetworkError';
    }
}

class TransactionError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'TransactionError';
    }
}

export function buildFeeHistoryRequest(blockCount: number, percentiles: number[]): JsonRPCRequest {
    return RpcProvider.buildPayload(EvmMethods.FeeHistory, [`0x${blockCount.toString(16)}`, 'latest', percentiles]);
}

export function buildEvmEstimateGasRequest(tx: TransactionRequest): JsonRPCRequest {
    if (tx.scilla || !tx.evm) {
        throw new NetworkError("Zilliqa network doesn't support gas estimation or EVM transaction is missing");
    }
    
    try {
        return RpcProvider.buildPayload(EvmMethods.EstimateGas, [tx.evm]);
    } catch (e: any) {
        throw new TransactionError(`Failed to serialize transaction: ${e.message}`);
    }
}

export async function buildBatchGasRequest(
  tx: TransactionRequest,
  blockCount: number,
  percentiles: number[],
  features: number[],
  sender: Address,
): Promise<JsonRPCRequest[]> {
    const requests: JsonRPCRequest[] = [];

    if (tx.scilla) {
        const zilAddress = await sender.toZilBech32();
        requests.push(await buildNonceRequest(sender.type, zilAddress));
        requests.push(RpcProvider.buildPayload(ZilMethods.GetMinimumGasPrice, []));
        return requests;
    } else if (tx.evm) {
        const ethAddress = await sender.toEthChecksum();
        requests.push(await buildNonceRequest(sender.type, ethAddress));
        requests.push(RpcProvider.buildPayload(EvmMethods.GasPrice, []));

        const requestEstimateGas = RpcProvider.buildPayload(EvmMethods.EstimateGas, [tx.toJSON()]);
        requests.push(requestEstimateGas);

        if (features.includes(EIP1559)) {
            requests.push(RpcProvider.buildPayload(EvmMethods.MaxPriorityFeePerGas, []));
            requests.push(buildFeeHistoryRequest(blockCount, percentiles));
        }

        if (features.includes(EIP4844)) {
            requests.push(RpcProvider.buildPayload(EvmMethods.BlobBaseFee, []));
        }

        return requests;
    }
    
    throw new TransactionError('unsupported transaction.');
}

export function processParseFeeHistoryRequest(feeHistoryValue: FeeHistoryResult): GasFeeHistory {
    const lastBaseFeeStr = feeHistoryValue.baseFeePerGas[feeHistoryValue.baseFeePerGas.length - 1];
    if (!lastBaseFeeStr) {
        throw new Error('baseFeePerGas not found or empty in fee history');
    }
    const baseFee = BigInt(lastBaseFeeStr);
    const lastRewardArr = feeHistoryValue.reward[feeHistoryValue.reward.length - 1];

    if (!lastRewardArr || !TypeOf.isArray(lastRewardArr) || !TypeOf.isString(lastRewardArr[1])) {
        throw new Error('reward not found or has invalid format in fee history');
    }

    const priorityFee = BigInt(lastRewardArr[1]);
    const maxFee = baseFee * 2n + priorityFee;

    return {
        maxFee,
        priorityFee,
        baseFee,
    };
}


```

`zil-pay/background/rpc/history_tx.ts`:

```ts
import { TransactionReceipt } from 'crypto/tx';
import { uint8ArrayToBigIntBigEndian } from 'crypto/number';
import { HEX_PREFIX, uint8ArrayToHex } from 'lib/utils/hex';
import { Address, AddressType } from 'crypto/address';
import { uint8ArrayToUtf8 } from 'lib/utils/utf8';
import { ETHEREUM } from 'config/slip44';
import { initSig } from "micro-eth-signer/utils.js";


export enum TransactionStatus {
  Pending,
  Success,
  Failed,
}

export type ChainType = "EVM" | "Scilla";

export interface IHistoricalTransactionState {
  transaction_hash: string;
  amount: bigint;
  sender: string;
  recipient: string;
  contract_address: string | null;
  status: TransactionStatus;
  status_code: number | null;
  timestamp: number;
  block_number: bigint | null;
  gasUsed: bigint | null;
  gasLimit: bigint | null;
  gasPrice: bigint | null;
  blobGasUsed: bigint | null;
  blobGasPrice: bigint | null;
  effectiveGasPrice: bigint | null;
  fee: bigint;
  icon: string | null;
  title: string | null;
  error: string | null;
  sig: string;
  nonce: bigint;
  token_info: TokenInfo | null;
  chain_type: ChainType;
  chain_hash: number;
  data?: string;
  code?: string;
}

export interface TokenInfo {
  value: bigint;
  symbol: string;
  decimals: number;
}

export class HistoricalTransaction implements IHistoricalTransactionState {
  public transaction_hash: string;
  public amount: bigint;
  public sender: string;
  public recipient: string;
  public contract_address: string | null;
  public status: TransactionStatus;
  public status_code: number | null;
  public timestamp: number;
  public block_number: bigint | null;
  public gasUsed: bigint | null;
  public gasLimit: bigint | null;
  public gasPrice: bigint | null;
  public blobGasUsed: bigint | null;
  public blobGasPrice: bigint | null;
  public effectiveGasPrice: bigint | null;
  public fee: bigint;
  public icon: string | null;
  public title: string | null;
  public error: string | null;
  public sig: string;
  public nonce: bigint;
  public token_info: TokenInfo | null;
  public chain_type: ChainType;
  public chain_hash: number;
  public data?: string;
  public code?: string;

  constructor(data: IHistoricalTransactionState) {
    this.transaction_hash = data.transaction_hash;
    this.amount = data.amount;
    this.sender = data.sender;
    this.recipient = data.recipient;
    this.contract_address = data.contract_address;
    this.status = data.status;
    this.status_code = data.status_code;
    this.timestamp = data.timestamp;
    this.block_number = data.block_number;
    this.gasUsed = data.gasUsed;
    this.gasLimit = data.gasLimit;
    this.gasPrice = data.gasPrice;
    this.blobGasUsed = data.blobGasUsed;
    this.blobGasPrice = data.blobGasPrice;
    this.effectiveGasPrice = data.effectiveGasPrice;
    this.fee = data.fee;
    this.icon = data.icon;
    this.title = data.title;
    this.error = data.error;
    this.sig = data.sig;
    this.nonce = data.nonce;
    this.token_info = data.token_info;
    this.chain_type = data.chain_type;
    this.chain_hash = data.chain_hash;
    this.data= data.data;
    this.code = data.code;
  }

  public static async fromReceipt(
    receipt: TransactionReceipt
  ): Promise<HistoricalTransaction> {
    const { metadata } = receipt;

    if (!metadata.hash) {
      throw new Error("Invalid transaction hash");
    }

    if (receipt.scilla) {
      const zil_receipt = receipt.scilla;
      const gas_price = uint8ArrayToBigIntBigEndian(zil_receipt.gasPrice);
      const fee = gas_price * zil_receipt.gasLimit;
      const contract_address = zil_receipt.data.length > 0 ? await new Address(zil_receipt.toAddr, AddressType.Bech32).toZilBech32() : null;
      const data = zil_receipt.data.length > 0 ? uint8ArrayToUtf8(zil_receipt.data) : '';
      const code = zil_receipt.code.length > 0 ? uint8ArrayToUtf8(zil_receipt.code) : '';

      return new HistoricalTransaction({
        data,
        code,
        contract_address,
        sig: uint8ArrayToHex(zil_receipt.signature, true),
        error: null,
        status_code: null,
        gasPrice: gas_price,
        gasLimit: zil_receipt.gasLimit,
        chain_hash: metadata.chainHash,
        chain_type: "Scilla",
        block_number: null,
        transaction_hash: metadata.hash,
        amount: uint8ArrayToBigIntBigEndian(zil_receipt.amount),
        sender: uint8ArrayToHex(zil_receipt.pubKey),
        recipient: await new Address(zil_receipt.toAddr, AddressType.Bech32).toZilBech32(), // TODO: if token transfer need replace with recipient 
        status: TransactionStatus.Pending,
        timestamp: new Date().getTime(),
        fee: fee,
        icon: metadata.icon || null,
        title: metadata.title || null,
        nonce: zil_receipt.nonce,
        token_info: metadata.tokenInfo
          ? {
              value: BigInt(metadata.tokenInfo[0]),
              decimals: metadata.tokenInfo[1],
              symbol: metadata.tokenInfo[2],
            }
          : null,
        gasUsed: null,
        blobGasUsed: null,
        blobGasPrice: null,
        effectiveGasPrice: null,
      });
    }
    else if (receipt.evm) {
      const evm_tx = receipt.evm; 
      const txData = evm_tx.raw as any; // TODO: this is bad
      const data = txData.data;
      const txType = evm_tx.type;
      const sig = initSig({ r: txData.r!, s: txData.s!, }, txData.yParity!);
      let effectiveGasPrice: bigint;
      let gasPrice = null;

      if (
        txType === "legacy" ||
        txType === "eip2930" ||
        txData.gasPrice
      ) {
        effectiveGasPrice = txData.gasPrice ?? 0n;
      } else if (
        (txType === "eip1559" || txType === "eip4844") &&
        txData.maxFeePerGas !== undefined
      ) {
        const max_fee = txData.maxFeePerGas ?? 0n;
        const priority_fee = txData.maxPriorityFeePerGas ?? 0n;
        effectiveGasPrice = max_fee < priority_fee ? max_fee : priority_fee;
      } else {
        effectiveGasPrice = 0n;
      }

      const recipient = txData.to ?? await Address.empty(ETHEREUM).toEthChecksum();
      
      return new HistoricalTransaction({
        gasPrice,
        data,
        error: null,
        sig: HEX_PREFIX + sig.toCompactHex(), // TODO: fix it.
        block_number: null,
        status_code: null,
        contract_address: (txData.to && txData.data && txData.data.length > 2) ? txData.to : null,
        gasLimit: txData.gasLimit ?? null,
        chain_hash: metadata.chainHash,
        chain_type: "EVM",
        transaction_hash: metadata.hash,
        amount: txData.value ?? 0n,
        sender: evm_tx.sender,
        recipient,
        fee: receipt.evm.fee,
        status: TransactionStatus.Pending,
        timestamp: new Date().getTime(),
        icon: metadata.icon || null,
        title: metadata.title || null,
        gasUsed: null,
        blobGasUsed: null,
        blobGasPrice: null,
        effectiveGasPrice: effectiveGasPrice,
        nonce: BigInt(txData.nonce ?? 0),
        token_info: metadata.tokenInfo
          ? {
              value: BigInt(metadata.tokenInfo[0]),
              decimals: metadata.tokenInfo[1],
              symbol: metadata.tokenInfo[2],
            }
          : null,
      });
    }

    throw new Error("Unknown transaction receipt type");
  }

  toJSON(): Record<string, unknown> {
    return {
      transaction_hash: this.transaction_hash,
      amount: this.amount.toString(),
      sender: this.sender,
      recipient: this.recipient,
      contract_address: this.contract_address,
      status: this.status,
      status_code: this.status_code,
      timestamp: this.timestamp,
      block_number: this.block_number?.toString() ?? null,
      gasUsed: this.gasUsed?.toString() ?? null,
      gasLimit: this.gasLimit?.toString() ?? null,
      gasPrice: this.gasPrice?.toString() ?? null,
      blobGasUsed: this.blobGasUsed?.toString() ?? null,
      blobGasPrice: this.blobGasPrice?.toString() ?? null,
      effectiveGasPrice: this.effectiveGasPrice?.toString() ?? null,
      fee: this.fee.toString(),
      icon: this.icon,
      title: this.title,
      error: this.error,
      sig: this.sig,
      nonce: this.nonce.toString(),
      token_info: this.token_info ? {
        value: this.token_info.value.toString(),
        symbol: this.token_info.symbol,
        decimals: this.token_info.decimals
      } : null,
      chain_type: this.chain_type,
      chain_hash: this.chain_hash,
      data: this.data,
      code: this.code
    };
  }
}


```

`zil-pay/background/rpc/index.ts`:

```ts
export * from './provider';
export * from './rpc';
export * from './ft_parser';
export * from './gas_parse';
export * from './nonce_parser';

```

`zil-pay/background/rpc/nonce_parser.ts`:

```ts
import { RpcProvider, type JsonRPCRequest } from './provider';
import { EvmMethods, ZilMethods } from '../../config/jsonrpc';
import { AddressType } from '../../crypto/address';
import { addr } from 'micro-eth-signer';
import { fromBech32Address } from '../../lib/zilliqa';
import { TypeOf } from 'lib/types';
import { hexToBigInt, stripHexPrefix } from 'lib/utils/hex';

export interface ZilBalance {
  balance: string;
  nonce: number;
}

export type NonceResponse = string | ZilBalance;

export async function buildNonceRequest(addressType: AddressType, address: string): Promise<JsonRPCRequest> {
  switch (addressType) {
    case AddressType.Bech32:
      const base16 = await fromBech32Address(address);
      return RpcProvider.buildPayload(
        ZilMethods.GetBalance,
        [stripHexPrefix(base16).toLowerCase()]
      );
    case AddressType.EthCheckSum:
      const ethAddress = addr.addChecksum(address);
      return RpcProvider.buildPayload(
        EvmMethods.GetTransactionCount,
        [ethAddress, 'latest']
      );
    default:
      throw new Error('Unsupported address type');
  }
}

export function processNonceResponse(response: NonceResponse): number {
  if (TypeOf.isObject(response)) {
    const res = response as ZilBalance;
    return res.nonce || 0;
  } else if (TypeOf.isString(response)) {
    return Number(hexToBigInt(String(response)));
  }

  return 0;
}


```

`zil-pay/background/rpc/provider.ts`:

```ts
import type { ChainConfig } from "background/storage";

export interface JsonRPCRequest {
  id: number;
  jsonrpc: string;
  method: string;
  params: unknown[];
}

export interface JsonRPCResponse<T> {
  id: number | string;
  jsonrpc: string;
  result?: T;
  error?: {
    code: number;
    message: string;
    data?: unknown;
  };
}

export class RpcError extends Error {
  public code: number;
  public data?: unknown;

  constructor(message: string, code: number, data?: unknown) {
    super(message);
    this.name = 'RpcError';
    this.code = code;
    this.data = data;
  }
}

export class RpcProvider {
  public network: ChainConfig;

  constructor(network: ChainConfig) {
    this.network = network;
  }

  static buildPayload(method: string, params: unknown[]): JsonRPCRequest {
    return {
      id: 1,
      jsonrpc: '2.0',
      method,
      params,
    };
  }

  public async req<T>(payload: JsonRPCRequest | JsonRPCRequest[]): Promise<T> {
    const client = {
      timeout: 5000,
    };

    let lastError: RpcError | null = null;
    const allNodes = this.network.rpc;

    if (allNodes.length === 0) {
      throw new RpcError('No RPC nodes available in the network configuration.', -32000);
    }

    const batchSize = 3;
    const currentBatch = allNodes.slice(0, batchSize);
    const failedNodesInBatch: string[] = [];

    for (const url of currentBatch) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), client.timeout);

        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
          signal: controller.signal,
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          lastError = new RpcError(
            `Request failed with status ${response.status}`,
            response.status,
          );
          failedNodesInBatch.push(url);
          continue;
        }

        const text = await response.text();
        try {
          const json: JsonRPCResponse<T> | JsonRPCResponse<T>[] = JSON.parse(text);

          if (Array.isArray(json)) {
            const errors = json
              .map((res) => res.error)
              .filter((err): err is NonNullable<typeof err> => !!err);
            if (errors.length > 0) {
              const firstError = errors[0];
              lastError = new RpcError(
                firstError.message,
                firstError.code,
                firstError.data,
              );
              failedNodesInBatch.push(url);
              continue;
            }
          } else if (json.error) {
            lastError = new RpcError(
              json.error.message,
              json.error.code,
              json.error.data,
            );
            failedNodesInBatch.push(url);
            continue;
          }

          return json as T;
        } catch (e: unknown) {
          if (e instanceof Error) {
            lastError = new RpcError(`Failed to parse JSON: ${e.message}`, -32700, text);
          } else {
            lastError = new RpcError('Failed to parse JSON: An unknown error occurred', -32700, text);
          }
          failedNodesInBatch.push(url);
          continue;
        }
      } catch (e: unknown) {
        if (e instanceof Error) {
            if (e.name === 'AbortError') {
              lastError = new RpcError(`Request timed out to ${url}`, -32603);
            } else {
              lastError = new RpcError(`Request to ${url} failed: ${e.message}`, -32603);
            }
        } else {
             lastError = new RpcError(`An unknown error occurred during the request to ${url}`, -32603);
        }
        failedNodesInBatch.push(url);
        continue;
      }
    }

    if (this.network.fallbackEnabled && failedNodesInBatch.length === currentBatch.length && currentBatch.length > 0) {
        const remainingNodes = allNodes.slice(currentBatch.length);
        this.network.rpc = [...remainingNodes, ...failedNodesInBatch];
    }
    
    throw lastError || new RpcError('Network is down or all nodes in batch failed', -32000);
  }
}


```

`zil-pay/background/rpc/rpc.ts`:

```ts
import { ChainConfig, FToken } from '../storage';
import { RpcProvider, type JsonRPCResponse, type JsonRPCRequest } from './provider';
import { Address, AddressType } from '../../crypto/address';
import {
  buildTokenRequests,
  processZilMetadataResponse,
  processEthMetadataResponse,
  processZilBalanceResponse,
  processEthBalanceResponse,
  MetadataField,
  type RequestType
} from './ft_parser';
import type { TransactionReceipt, TransactionRequest } from 'crypto/tx';
import { buildBatchGasRequest, EIP1559, EIP4844, processParseFeeHistoryRequest, type GasFeeHistory, type RequiredTxParams } from './gas_parse';
import { processNonceResponse } from './nonce_parser';
import { bigintToHex, hexToBigInt } from 'lib/utils/hex';
import { EvmMethods } from 'config/jsonrpc';
import type { EVMBlock } from './block';
import { type HistoricalTransaction } from './history_tx';
import { buildPayloadTxReceipt, buildSendSignedTxRequest, processTxReceiptResponse, processTxSendResponse } from './tx_parse';

export class NetworkProvider {
  config: ChainConfig;

  constructor(config: ChainConfig) {
    this.config = config;
  }

  async proxyReq<T>(payload: JsonRPCRequest | JsonRPCRequest[]): Promise<JsonRPCResponse<unknown|T>> {
    const provider = new RpcProvider(this.config);
    return provider.req<JsonRPCResponse<unknown|T>>(payload);
  }

  async getCurrentBlockNumber(): Promise<bigint> {
    const provider = new RpcProvider(this.config);
    const payload = RpcProvider.buildPayload(EvmMethods.BlockNumber, []);
    const response = await provider.req<JsonRPCResponse<string>>(payload);

    if (response.error || !response.result) {
      throw new Error(response.error?.message);
    }

    return hexToBigInt(response.result);
  }

  async estimateBlockTime(): Promise<number> {
    const provider = new RpcProvider(this.config);

    const latestBlockPayload = RpcProvider.buildPayload(EvmMethods.GetBlockByNumber, ['latest', false]);
    const latestBlockResponse = await provider.req<JsonRPCResponse<EVMBlock>>(latestBlockPayload);

    if (latestBlockResponse.error || !latestBlockResponse.result) {
      throw new Error(latestBlockResponse.error?.message);
    }

    const latestBlock = latestBlockResponse.result;
    const latestTimestamp = hexToBigInt(latestBlock.timestamp);
    const latestBlockNumber = hexToBigInt(latestBlock.number);

    const previousBlockNumber = bigintToHex(latestBlockNumber - 1n, true);
    const previousBlockPayload = RpcProvider.buildPayload(EvmMethods.GetBlockByNumber, [previousBlockNumber, false]);
    const previousBlockResponse = await provider.req<JsonRPCResponse<EVMBlock>>(previousBlockPayload);

    if (previousBlockResponse.error || !previousBlockResponse.result) {
      throw new Error(previousBlockResponse.error?.message);
    }

    const previousBlock = previousBlockResponse.result;
    const previousTimestamp = hexToBigInt(previousBlock.timestamp);

    return Number(latestTimestamp - previousTimestamp);
  }

  async estimateParamsBatch(
    tx: TransactionRequest,
    sender: Address,
    blockCount: number,
    percentiles: number[] | null,
  ): Promise<RequiredTxParams> {
    const defaultPercentiles = [25.0, 50.0, 75.0];
    const percentilesToUse = percentiles || defaultPercentiles;
    const requests = await buildBatchGasRequest(
      tx,
      blockCount,
      percentilesToUse,
      this.config.features,
      sender
    );
    const provider = new RpcProvider(this.config);
    const responses = await provider.req<JsonRPCResponse<any>[]>(requests);

    if (responses.every(res => res.error)) {
        const allErrors = responses
            .map(res => res.error?.message)
            .filter(Boolean)
            .join(', ');
        throw new Error(`RPC Error: ${allErrors}`);
    }

    let nonce = 0;
    if (responses[0] && !responses[0].error) {
      nonce = processNonceResponse(responses[0].result);
    }
    
    let gasPrice = 0n;

    if (tx.evm) {
      gasPrice = responses[1]?.result ? hexToBigInt(responses[1].result) : 0n;
    } else if (tx.scilla) {
      gasPrice = BigInt(responses[1]?.result ?? 0);
    }

    const txEstimateGas = responses[2]?.result ? hexToBigInt(responses[2].result) : 0n;

    let maxPriorityFee = 0n;
    let feeHistory: GasFeeHistory = { maxFee: 0n, priorityFee: 0n, baseFee: 0n };
    let blobBaseFee = 0n;

    let responseIndex = 3;

    if (this.config.features.includes(EIP1559)) {
        if (responses[responseIndex] && responses[responseIndex].result) {
            maxPriorityFee = hexToBigInt(responses[responseIndex].result);
        }
        responseIndex++;
        if (responses[responseIndex] && responses[responseIndex].result) {
            feeHistory = processParseFeeHistoryRequest(responses[responseIndex].result);
        }
        responseIndex++;
    }

    if (this.config.features.includes(EIP4844)) {
        if (responses[responseIndex] && responses[responseIndex].result) {
             blobBaseFee = hexToBigInt(responses[responseIndex].result);
        }
    }
    
    return {
      nonce,
      gasPrice,
      txEstimateGas,
      maxPriorityFee,
      feeHistory,
      blobBaseFee
    };
  }

  async ftokenMeta(contract: Address, accounts: Address[]): Promise<FToken> {
    const requestsWithTypes = await buildTokenRequests(contract, accounts, false);
    const provider = new RpcProvider(this.config);

    const payloads = requestsWithTypes.map(r => r.payload);
    const responses = await provider.req<JsonRPCResponse<any>[]>(payloads);
    const balances: Record<number, string> = {};

    if (contract.type === AddressType.Bech32) {
      const { name, symbol, decimals } = processZilMetadataResponse(responses[0]);
      
      for (let i = 1; i < responses.length; i++) {
        const reqWithType = requestsWithTypes[i];

        if (reqWithType.requestType.type === 'Balance') {
          const addresss = reqWithType.requestType.address;
          const balance = await processZilBalanceResponse(responses[i], addresss, false);
          const accountIndex = accounts.findIndex(
            acc => acc === reqWithType.requestType.address
          );

          if (accountIndex !== -1) {
            balances[accountIndex] = balance.toString();
          }
        }
      }

      return new FToken({
        name,
        symbol,
        decimals,
        balances,
        addr: await contract.toZilBech32(),
        addrType: contract.type,
        chainHash: this.config.hash(),
        default_: false,
        native: false,
        logo: null,
        rate: 0
      });
    } else if (contract.type === AddressType.EthCheckSum) {
      let responseIterator = 0;
      const name = processEthMetadataResponse(responses[responseIterator++], MetadataField.Name);
      const symbol = processEthMetadataResponse(responses[responseIterator++], MetadataField.Symbol);
      const decimalsStr = processEthMetadataResponse(responses[responseIterator++], MetadataField.Decimals);
      const decimals = parseInt(decimalsStr, 10);

      requestsWithTypes.slice(3).forEach((reqWithType, index) => {
        if (reqWithType.requestType.type === 'Balance') {
          const response = responses[responseIterator + index];
          const balance = processEthBalanceResponse(response);
          if (reqWithType.requestType.type == 'Balance') {
            const accountIndex = accounts.findIndex(
              acc => acc === reqWithType.requestType.address,
            );
            if (accountIndex !== -1) {
              balances[accountIndex] = balance.toString();
            }
          }
        }
      });

      return new FToken({
        name,
        symbol,
        decimals,
        balances,
        addr: await contract.toEthChecksum(),
        addrType: contract.type,
        chainHash: this.config.hash(),
        default_: false,
        native: false,
        logo: null,
        rate: 0
      });
    }

    throw new Error("unsupported contract");
  }

  async updateTransactionsReceipt(txns: HistoricalTransaction[]): Promise<void> {
    if (txns.length === 0) {
      return;
    }

    const requests = txns.map(tx => buildPayloadTxReceipt(tx));
    const provider = new RpcProvider(this.config);
    const responses = await provider.req<JsonRPCResponse<unknown>[]>(requests);

    await Promise.all(responses.map((res, index) => {
      const tx = txns[index];
      return processTxReceiptResponse(res, tx);
    }));
  }

  async broadcastSignedTransactions(txns: TransactionReceipt[]): Promise<TransactionReceipt[]> {
    const allRequests: JsonRPCRequest[] = [];

    for (const tx of txns) {
      if (!(await tx.verify())) {
        throw new Error('Invalid signature');
      }
      allRequests.push(await buildSendSignedTxRequest(tx));
    }
  
    const provider = new RpcProvider(this.config);
    const responses = await provider.req<JsonRPCResponse<unknown>[]>(allRequests);

    responses.forEach((response, index) => {
      const tx = txns[index];
      processTxSendResponse(response, tx);
    });
  
    return txns;
  }

  async updateBalances(tokens: FToken[], accounts: Address[]): Promise<void> {
    const allRequests: { payload: JsonRPCRequest; requestType: RequestType; tokenIndex: number; }[] = [];

    for (let tokenIndex = 0; tokenIndex < tokens.length; tokenIndex++) {
      const token = tokens[tokenIndex];
      const tokenAddress = Address.fromStr(token.addr);
      const requests = await buildTokenRequests(tokenAddress, accounts, token.native);

      for (const req of requests) {
        if (req.requestType.type === 'Balance') {
          allRequests.push({ ...req, tokenIndex });
        }
      }
    }

    if (allRequests.length === 0) {
      return;
    }

    const provider = new RpcProvider(this.config);
    const payloads = allRequests.map(r => r.payload);
    const responses = await provider.req<JsonRPCResponse<any>[]>(payloads);

    for (let i = 0; i < allRequests.length; i++) {
      const requestInfo = allRequests[i];
      const response = responses[i];
      const token = tokens[requestInfo.tokenIndex];
      const tokenAddress = Address.fromStr(token.addr);
    
      if (requestInfo.requestType.type !== 'Balance') continue;

      const account = requestInfo.requestType.address;
    
      if (tokenAddress.type === AddressType.Bech32) {
        const balance = await processZilBalanceResponse(response, account, token.native);
        token.balances[await account.autoFormat()] = balance.toString();
      } else if (tokenAddress.type === AddressType.EthCheckSum) {
        const balance = processEthBalanceResponse(response);
        token.balances[await account.autoFormat()] = balance.toString();
      }
    }
  }
}

```

`zil-pay/background/rpc/tx_parse.ts`:

```ts
import { RpcProvider, type JsonRPCRequest, type JsonRPCResponse } from './provider';
import { EvmMethods, ZilMethods } from 'config/jsonrpc';
import { HistoricalTransaction, TransactionStatus } from './history_tx';
import { TransactionReceipt } from 'crypto/tx';
import { Address } from 'crypto/address';
import { ZILLIQA } from 'config/slip44';
import { stripHexPrefix } from 'lib/utils/hex';

const MINUTES_IN_SECONDS = 10 * 60;

export async function buildSendSignedTxRequest(tx: TransactionReceipt): Promise<JsonRPCRequest> {
  if (tx.scilla) {
    return RpcProvider.buildPayload(ZilMethods.CreateTransaction, [await tx.scilla.toJSON()]);
  } else if (tx.evm) {
    const encodedTx = tx.evm.toHex(true);
    return RpcProvider.buildPayload(EvmMethods.SendRawTransaction, [encodedTx]);
  }
  
  throw new Error('Invalid transaction type');
}

export function buildPayloadTxReceipt(tx: HistoricalTransaction): JsonRPCRequest {
  if (tx.chain_type === 'Scilla') {
    return RpcProvider.buildPayload(ZilMethods.GetTransactionStatus, [stripHexPrefix(tx.transaction_hash)]);
  } else if (tx.chain_type === 'EVM') {
    return RpcProvider.buildPayload(EvmMethods.GetTransactionReceipt, [tx.transaction_hash]);
  }
  
  throw new Error('Invalid chain type');
}

export async function processTxReceiptResponse(
  response: JsonRPCResponse<any>,
  tx: HistoricalTransaction
): Promise<void> {
  if (response.error) {
    const now = Math.floor(Date.now() / 1000);
    const cutoff = now - MINUTES_IN_SECONDS;

    if (tx.timestamp < cutoff) {
      tx.status = TransactionStatus.Failed;
      tx.error = response.error.message;
    }
    return;
  }

  if (!response.result) {
    throw new Error(`No transaction found with hash: ${tx.transaction_hash}`);
  }

  const result = response.result;

  if (tx.chain_type === 'Scilla') {
    const amount = result.amount ? BigInt(result.amount) : tx.amount;
    const gasLimit = result.gasLimit ? BigInt(result.gasLimit) : tx.gasLimit || 0n;
    const gasPrice = result.gasPrice ? BigInt(result.gasPrice) : tx.gasPrice || 0n;
    const nonce = result.nonce ? BigInt(result.nonce) : tx.nonce;
    const statusCode = result.status ? Number(result.status) : null;
    const pubKey = result.senderAddr;

    tx.amount = amount;
    tx.gasLimit = gasLimit;
    tx.gasPrice = gasPrice;
    tx.nonce = nonce;
    tx.fee = gasPrice * gasLimit;

    if (statusCode) {
      tx.status_code = statusCode;
      switch (statusCode) {
        case 1:
        case 2:
        case 4:
        case 5:
        case 6:
          tx.status = TransactionStatus.Pending;
          break;
        case 3:
          tx.status = TransactionStatus.Success;
          break;
        default:
          tx.status = TransactionStatus.Failed;
      }
    }

    if (tx.status === TransactionStatus.Pending) {
      const now = Math.floor(Date.now() / 1000);
      const cutoff = now - MINUTES_IN_SECONDS;

      if (tx.timestamp < cutoff) {
        tx.status = TransactionStatus.Failed;
        tx.error = 'timeout';
      }
    }

    if (pubKey) {
      tx.sender = await (await Address.fromPubKey(pubKey, ZILLIQA)).toZilBech32();
    }
  } else if (tx.chain_type === 'EVM') {
    tx.sender = result.from;
    tx.contract_address = result.contractAddress || null;

    if (result.to) {
      tx.recipient = result.to;
    }

    tx.block_number = result.blockNumber ? BigInt(result.blockNumber) : null;
    tx.gasUsed = result.gasUsed ? BigInt(result.gasUsed) : null;
    tx.blobGasUsed = result.blobGasUsed ? BigInt(result.blobGasUsed) : null;
    tx.blobGasPrice = result.blobGasPrice ? BigInt(result.blobGasPrice) : null;
    tx.effectiveGasPrice = result.effectiveGasPrice ? BigInt(result.effectiveGasPrice) : null;

    const isSuccess = result.status === '0x1' || result.status === 1;
    tx.status = isSuccess ? TransactionStatus.Success : TransactionStatus.Failed;

    let totalCost = BigInt(result.gasUsed || 0) * BigInt(result.effectiveGasPrice || 0);

    if (result.blobGasUsed && result.blobGasPrice) {
      totalCost += BigInt(result.blobGasUsed) * BigInt(result.blobGasPrice);
    }

    tx.fee = totalCost;
  }
}

export function processTxSendResponse(
  response: JsonRPCResponse<any>,
  tx: TransactionReceipt
): void {
  if (response.error) {
    throw new Error(`RPC Error: ${response.error.message}`);
  }

  if (!response.result) {
    throw new Error('Invalid response: missing result');
  }

  if (tx.scilla) {
    const result = response.result;
    const info = result.Info || '';
    const txId = result.TranID;

    if (!txId) {
      throw new Error('Invalid transaction hash');
    }

    tx.metadata.hash = txId;
    tx.metadata.info = info;
  } else if (tx.evm) {
    const hash = response.result;

    if (typeof hash !== 'string') {
      throw new Error('Invalid transaction hash');
    }

    tx.metadata.hash = hash;
  }
}

```

`zil-pay/background/secure/index.ts`:

```ts
export * from './migrator';
export * from './session';

```

`zil-pay/background/secure/migrator.ts`:

```ts
import { BackgroundState, type IBackgroundState } from '../storage/background';
import { ChainConfig } from '../storage/chain';
import { FToken } from '../storage/ftoken';
import { Wallet } from '../storage/wallet';
import { Account } from '../storage/account';
import { WalletSettings } from '../storage/settings';
import { HashTypes, WalletHashParams } from '../storage/argon';
import { CipherOrders } from '../../crypto/keychain';
import { ShaAlgorithms } from '../../config/pbkdf2';
import { AddressType } from 'crypto/address';
import { uuid } from 'crypto/uuid';
import { Themes } from 'config/theme';
import { RatesApiOptions } from 'config/api';
import { AuthMethod, WalletTypes } from 'config/wallet';
import { Locales } from 'config/locale';

interface WalletIdentities {
  selectedAddress: number;
  identities: {
    name: string;
    bech32: string;
    index: number;
    base16: string;
    type: number;
    pubKey: string;
    privKey?: string;
    zrc2: Record<string, string>;
    nft: Record<string, unknown>;
  }[];
}

interface TokenData {
  base16: string;
  bech32: string;
  decimals: number;
  name: string;
  symbol: string;
  rate: number;
  pool?: string[];
}

type TokenWithBase16 = { ftoken: FToken; base16: string };

const ZILLIQA_MAINNET_CHAIN = new ChainConfig({
    name: 'Zilliqa',
    chain: 'ZIL',
    logo: 'https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/%{shortName}%/chain/%{dark,light}%.svg',
    rpc: [
      'https://api.zilliqa.com',
      'https://ssn.zilpay.io/api',
      'https://zilliqa.avely.fi/api',
      'https://ssn.zillet.io',
    ],
    features: [],
    ftokens: [
      new FToken({
        native: true,
        logo: 'https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/%{contract_address}%/%{dark,light}%.webp',
        addr: '0x0000000000000000000000000000000000000000',
        name: 'Zilliqa',
        symbol: 'ZIL',
        decimals: 18,
        addrType: AddressType.EthCheckSum,
        balances: {},
        rate: 0,
        default_: true,
        chainHash: 1
      }),
      new FToken({
        native: true,
        logo: 'https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/%{contract_address}%/%{dark,light}%.webp',
        addr: 'zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz',
        name: 'Zilliqa',
        symbol: 'ZIL',
        decimals: 12,
        addrType: AddressType.Bech32,
        balances: {},
        rate: 0,
        default_: true,
        chainHash: 1
      }),
    ],
    chainIds: [32769, 1],
    shortName: 'zilliqa',
    slip44: 313,
    explorers: [
      {
        name: 'Viewblock',
        url: 'https://viewblock.io/zilliqa',
        icon: 'https://viewblock.io/apple-touch-icon.png',
        standard: 3091,
      },
      {
        name: 'Otterscan',
        icon: 'https://otterscan.zilliqa.com/assets/otter-DYFeLtFi.png',
        url: 'https://otterscan.zilliqa.com/',
        standard: 3091,
      },
    ],
    chainId: 1,
    diffBlockTime: 30,
    ens: null,
    fallbackEnabled: false,
    testnet: false
});

export function migrateToV4(storage: IBackgroundState): BackgroundState {
  if (storage.storageVersion == 4) {
    return new BackgroundState(storage);
  } else {
      return migrateFromV2orV3(storage as any);
  }
}

function parseTokens(tokensJson: string, chainHash: number): TokenWithBase16[] {
    const tokens: TokenData[] = JSON.parse(tokensJson);
    return tokens.map(token => ({
      ftoken: new FToken({
        name: token.name,
        symbol: token.symbol,
        decimals: token.decimals,
        addr: token.bech32,
        addrType: AddressType.Bech32,
        logo: `https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/${token.bech32}/%{dark,light}%.webp`,
        balances: {},
        rate: token.rate,
        default_: token.symbol === 'ZIL',
        native: token.base16 === '0x0000000000000000000000000000000000000000',
        chainHash,
      }),
      base16: token.base16,
    }));
  }

function migrateFromV2orV3(storage: Record<string, unknown>): BackgroundState {
    const walletIdentities: WalletIdentities = JSON.parse(storage['wallet-identities'] as string);
    const mainChain = ZILLIQA_MAINNET_CHAIN;
    const cipher = 'guard-configuration' in storage ? CipherOrders.AESGCM256 : CipherOrders.AESCBC;
    const parsedTokens = parseTokens(storage['tokens-list/mainnet'] as string, mainChain.hash());
    let [algorithm, iteractions] = String(storage["guard-configuration"]).split(":");

    if (!iteractions) {
      iteractions = '0';
    }

    if (!algorithm || (algorithm != ShaAlgorithms.sha256 && algorithm != ShaAlgorithms.Sha512)) {
      algorithm = ShaAlgorithms.sha256;
    }

    const accounts = walletIdentities.identities.map(identity => new Account({
        addr: identity.bech32,
        addrType: AddressType.Bech32,
        name: identity.name,
        pubKey: identity.pubKey,
        chainHash: mainChain.hash(),
        chainId: mainChain.chainId,
        slip44: mainChain.slip44,
        index: identity.index,
    }));

    const walletTokens = parsedTokens.map(({ ftoken, base16 }) => {
        const balances: Record<number, string> = {};
        accounts.forEach((_, index) => {
            const identity = walletIdentities.identities[index];
            balances[index] = identity.zrc2[base16.toLowerCase()] || '0';
        });
        return new FToken({ ...ftoken, balances });
    });

    const wallet = new Wallet({
        history: [],
        confirm: [],
        walletType: WalletTypes.SecretPhrase,
        walletName: 'Zilliqa Wallet',
        authType: AuthMethod.None,
        uuid: uuid(),
        accounts,
        selectedAccount: walletIdentities.selectedAddress,
        tokens: walletTokens, 
        settings: new WalletSettings({
            cipherOrders: [cipher],
            hashFnParams: new WalletHashParams({
                memory: 1024,
                iterations: Number(iteractions),
                threads: 1,
                secret: '',
                hashType: HashTypes.Pbkdf2, 
                hashSize: algorithm as ShaAlgorithms ?? ShaAlgorithms.sha256,
            }),
            currencyConvert: String(storage['selected-currency']),
            ipfsNode: null,
            ensEnabled: false,
            tokensListFetcher: false,
            nodeRankingEnabled: false,
            maxConnections: 10,
            requestTimeoutSecs: 30,
            ratesApiOptions: RatesApiOptions.CoinGecko,
                sessionTime: Number(storage['time_before_lock']) || 3600,
        }),
        defaultChainHash: mainChain.hash(),
        vault: String(storage.vault),
    });

    const backgroundState = new BackgroundState({
        storageVersion: 4,
        wallets: [wallet],
        selected_wallet: 0,
        notificationsGlobalEnabled: true,
        locale: Locales.Auto,
        appearances: Themes.System,
        abbreviatedNumber: true,
        hideBalance: false,
        chains: [mainChain], 
    });

    return backgroundState;
}


```

`zil-pay/background/secure/session.ts`:

```ts
import { AESCipherV3 } from '../../crypto/aes256';
import { uint8ArrayToBase64, base64ToUint8Array } from '../../crypto/b64';
import { randomBytes } from '../../crypto/random';
import { Runtime } from '../../lib/runtime';

export enum SessionStorageKeys {
  EndSession = 'SESSION_END',
  SessionKey = 'SESSION_KEY',
  VaultCipher = 'VAULT_CIPHER',
}

export class Session {
  #uuid: string;

  constructor(uuid: string) {
    Runtime.storage.session.setAccessLevel({ accessLevel: 'TRUSTED_CONTEXTS' });
    this.#uuid = uuid;
  }

  private getKey(key: SessionStorageKeys): string {
    return `${key}:${this.#uuid}`;
  }

  async setSession(sessionTime: number, vaultContent: Uint8Array): Promise<void> {
    const endSession = Date.now() + sessionTime * 1000;
    const key = randomBytes(32);
    const vaultCipher = AESCipherV3.encrypt(vaultContent, key);

    const data = {
      [this.getKey(SessionStorageKeys.EndSession)]: endSession,
      [this.getKey(SessionStorageKeys.SessionKey)]: uint8ArrayToBase64(key),
      [this.getKey(SessionStorageKeys.VaultCipher)]: uint8ArrayToBase64(vaultCipher),
    };
    await Runtime.storage.session.set(data);
  }

  async clearSession(): Promise<void> {
    await Runtime.storage.session.clear();
  }

  async getVault(): Promise<Uint8Array> {
    const data = await Runtime.storage.session.get([
      this.getKey(SessionStorageKeys.EndSession),
      this.getKey(SessionStorageKeys.SessionKey),
      this.getKey(SessionStorageKeys.VaultCipher),
    ]);

    const endSession = data[this.getKey(SessionStorageKeys.EndSession)];
    if (!endSession) {
      throw new Error('Session does not exist');
    }
    if (Date.now() > endSession) {
      await this.clearSession();
      throw new Error('Session has expired');
    }

    const sessionKeyBase64 = data[this.getKey(SessionStorageKeys.SessionKey)];
    const vaultCipherBase64 = data[this.getKey(SessionStorageKeys.VaultCipher)];

    if (!sessionKeyBase64 || !vaultCipherBase64) {
      throw new Error('Session data is incomplete');
    }

    const sessionKey = base64ToUint8Array(sessionKeyBase64);
    const vaultCipher = base64ToUint8Array(vaultCipherBase64);

    return AESCipherV3.decrypt(vaultCipher, sessionKey);
  }
}

```

`zil-pay/background/services/index.ts`:

```ts
export * from './wallet';
export * from './provider';
export * from './tx';



```

`zil-pay/background/services/provider.ts`:

```ts
import { NetworkProvider } from "background/rpc";
import type { BackgroundState } from "background/storage";
import { Address } from "crypto/address";
import type { StreamResponse } from "lib/streem";

export class ProviderService {
  #state: BackgroundState;

  constructor(state: BackgroundState) {
    this.#state = state;
  }

  async balanceUpdate(walletIndex: number, sendResponse: StreamResponse) {
    try {
      const wallet = this.#state.wallets[walletIndex];
      const account = wallet.accounts[wallet.selectedAccount];
      const chainConfig = this.#state.getChain(account.chainHash)!;
      const provider = new NetworkProvider(chainConfig);
      const addresses = wallet.accounts.map((a) => Address.fromStr(a.addr));

      await provider.updateBalances(wallet.tokens, addresses);
      this.#state.sync();

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async sendSignedTransaction(sendResponse: StreamResponse) {}

  async getCurrentBlock(walletIndex: number, accountIndex: number, sendResponse: StreamResponse) {
    try {
      const wallet = this.#state.wallets[walletIndex];
      const account = wallet.accounts[accountIndex];
      const chainConfig = this.#state.getChain(account.chainHash)!;
      const provider = new NetworkProvider(chainConfig);
      const blockNumber = await provider.getCurrentBlockNumber();

      sendResponse({
        resolve: blockNumber.toString(),
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async proxyChannel(sendResponse: StreamResponse) {}

  async estimateBlockTime(walletIndex: number, accountIndex: number, sendResponse: StreamResponse) {
    try {
      const wallet = this.#state.wallets[walletIndex];
      const account = wallet.accounts[accountIndex];
      const chainConfig = this.#state.getChain(account.chainHash)!;
      const provider = new NetworkProvider(chainConfig);
      const blockTime = await provider.estimateBlockTime();

      sendResponse({
        resolve: blockTime,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async estimateGasParamsBatch(sendResponse: StreamResponse) {}

  async fetchFtokenMeta(contract: string, walletIndex: number, accountIndex: number, sendResponse: StreamResponse) {
    try {
      const contractAddr = Address.fromStr(contract);
      const wallet = this.#state.wallets[walletIndex];
      const account = wallet.accounts[accountIndex];
      const chainConfig = this.#state.getChain(account.chainHash)!;
      const provider = new NetworkProvider(chainConfig);
      const addresses = wallet.accounts.map((a) => Address.fromStr(a.addr));
      const metadata = await provider.ftokenMeta(contractAddr, addresses);

      sendResponse({
        resolve: metadata,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }
}


```

`zil-pay/background/services/tx.ts`:

```ts
import type { BackgroundState } from "background/storage";
import type { StreamResponse } from "lib/streem";
import { ConfirmState, type IConfirmState } from "background/storage/confirm";

export class TransactionService {
  #state: BackgroundState;

  constructor(state: BackgroundState) {
    this.#state = state;
  }

  async add(payload: IConfirmState, walletIndex: number, sendResponse: StreamResponse) {
    try {
      const wallet = this.#state.wallets[walletIndex];
      const scillaTx = new ConfirmState(payload);

      wallet.confirm.push(scillaTx);
      await this.#state.sync();

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async reject(index: number, walletIndex: number, sendResponse: StreamResponse) {
    try {
      const wallet = this.#state.wallets[walletIndex];

      wallet.confirm.splice(index, 1);
      await this.#state.sync();
      // TODO: sending response to Tab with uuid.

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }
}

```

`zil-pay/background/services/wallet.ts`:

```ts
import { ChainConfig, Wallet, WalletSettings, type BackgroundState, type IBackgroundState, type IChainConfigState } from "background/storage";
import type { StreamResponse } from "lib/streem";
import { utf8ToUint8Array } from "lib/utils/utf8";
import { hexToUint8Array, uint8ArrayToHex } from "lib/utils/hex";
import type { SetPasswordPayload, WalletFromBip39Params, WalletFromPrivateKeyParams } from "types/wallet";
import { TypeOf } from "lib/types";
import { KeyPair } from "crypto/keypair";
import { HistoricalTransaction } from "background/rpc/history_tx";
import { randomBytes } from "crypto/random";
import { Bip39 } from "crypto/bip39";

export class WalletService {
  #state: BackgroundState;

  constructor(state: BackgroundState) {
    this.#state = state;
  }

  async addLedgerWallet() {}

  async genBip39Words(count: number, wordList: string[], sendResponse: StreamResponse) {
    try {
      const entropyBits = (count * 11) - Math.floor(count / 3);
      const entropyBytes = entropyBits / 8;
      const entropy = randomBytes(entropyBytes);
      const mnemonic = await Bip39.entropyToMnemonic(entropy, wordList);

      sendResponse({
        resolve: mnemonic.phrase
      });
    } catch(err) {
      sendResponse({
        reject: String(err)
      });
    }
  }

    async validateBip39CheckSum(phrase: string, wordList: string[], sendResponse: StreamResponse) {
      try {
        const isValid = await Bip39.validateMnemonic(phrase, wordList);

        sendResponse({
          resolve: isValid
        });
      } catch {
        sendResponse({
          reject: false,
        });
      }
    }


  async genKeyPair(slip44: number, sendResponse: StreamResponse) {
    try {
      const keyPair = await KeyPair.generate( slip44);

      sendResponse({
        resolve: await keyPair.toJSON()
      });
    } catch(err) {
      sendResponse({
        reject: String(err)
      });
    }
  }

  async keyPairFromPrivateKey(slip44: number, key: string, sendResponse: StreamResponse) {
    try {
      const keyBuf = hexToUint8Array(key);
      const keyPair = await KeyPair.fromPrivateKey(keyBuf, slip44);

      sendResponse({
        resolve: await keyPair.toJSON()
      });
    } catch(err) {
      sendResponse({
        reject: String(err)
      });
    }
  }

  async getGlobalState(sendResponse: StreamResponse) {
    sendResponse({
      resolve: this.#state
    });
  }

  async setGlobalState(payload: IBackgroundState, sendResponse: StreamResponse) {
    this.#state.abbreviatedNumber = payload.abbreviatedNumber;
    this.#state.appearances = payload.appearances;
    this.#state.hideBalance = payload.hideBalance;
    this.#state.selected_wallet = payload.selected_wallet;
    this.#state.locale = payload.locale;
    this.#state.notificationsGlobalEnabled = payload.notificationsGlobalEnabled;

    payload.wallets.forEach((wallet, index) => {
      const currentWallet = this.#state.wallets[index];

      if (currentWallet) {
          currentWallet.accounts = wallet.accounts;
          currentWallet.confirm = wallet.confirm;
          currentWallet.history = wallet.history.map((h) =>  new HistoricalTransaction(h));
          currentWallet.selectedAccount = wallet.selectedAccount;
          currentWallet.settings = new WalletSettings(wallet.settings);
          currentWallet.tokens = wallet.tokens;
          currentWallet.walletName = wallet.walletName;
      }
    });

    await this.#state.sync();

    sendResponse({
      resolve: this.#state
    });
  }

  async walletFromPrivateKey(payload: WalletFromPrivateKeyParams, sendResponse: StreamResponse) {
    try {
      const chain = await this.addOrGetChain(payload.chain);
      const keyBytes = hexToUint8Array(payload.key.privateKey);
      const kyepair = await KeyPair.fromPrivateKey(keyBytes, chain.slip44);
      const settings = new WalletSettings(payload.settings);
      const wallet = await Wallet.fromPrivateKey(
        kyepair,
        payload.walletName,
        payload.accountName,
        settings,
        chain,
        payload.password,
      );

      this.#state.wallets.push(wallet);
      await this.#state.sync();

      sendResponse({
        resolve: true
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async walletFromBip39(payload: WalletFromBip39Params, sendResponse: StreamResponse) {
    try {
      const chain = await this.addOrGetChain(payload.chain);
      const settings = new WalletSettings(payload.settings);
      const wallet = await Wallet.fromBip39(
        payload.mnemonic,
        payload.verifyCheckSum,
        payload.walletName,
        payload.accounts,
        settings,
        chain,
        payload.password,
        payload.bip39WordList,
        payload.passphrase, 
      );

      this.#state.wallets.push(wallet);
      await this.#state.sync();

      sendResponse({
        resolve: true
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async exportbip39Words(password: string, walletIndex: number, sendResponse: StreamResponse) {
    try {
      const passwordBytes = utf8ToUint8Array(password);
      const wallet = this.#state.wallets[walletIndex];

      const chain = this.#state.getChain(wallet.defaultChainHash)!;
      const mnemonic = await wallet.revealMnemonic(passwordBytes, chain);

      sendResponse({
        resolve: mnemonic
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async exportKeyPair(password: string, walletIndex: number, accountIndex: number, sendResponse: StreamResponse) {
    try {
      const passwordBytes = utf8ToUint8Array(password);
      const wallet = this.#state.wallets[walletIndex];

      await wallet.unlock(passwordBytes);

      const chain = this.#state.getChain(wallet.defaultChainHash)!;
      const keyPair = await wallet.revealKeypair(accountIndex, chain);

      sendResponse({
        resolve: {
          privKey: uint8ArrayToHex(keyPair.privateKey),
          pubKey: uint8ArrayToHex(keyPair.pubKey),
        }
      });
    } catch (err) {
      sendResponse({
        reject: String(err)
      });
    }
  }

  async changePassword(payload: SetPasswordPayload, sendResponse: StreamResponse) {
     try {
      const passwordBytes = utf8ToUint8Array(payload.currentPassword);
      const wallet = this.#state.wallets[payload.walletIndex];

      await wallet.clearSession();

      const vault = await wallet.decrypt(passwordBytes);
      const newPasswordBytes = utf8ToUint8Array(payload.newPassword);

      wallet.settings.cipherOrders = payload.cipherOrders;
      wallet.settings.hashFnParams.memory = payload.hashSettings.memory;
      wallet.settings.hashFnParams.iterations = payload.hashSettings.iterations;
      wallet.settings.hashFnParams.threads = payload.hashSettings.threads;
      wallet.settings.hashFnParams.secret = payload.hashSettings.secret;
      wallet.settings.hashFnParams.hashType = payload.hashSettings.hashType;
      wallet.settings.hashFnParams.hashSize = payload.hashSettings.hashSize;

      if (TypeOf.isString(vault)) {
        await wallet.encrypt(newPasswordBytes, utf8ToUint8Array(vault as string));
      } else if (vault instanceof Uint8Array) {
        await wallet.encrypt(newPasswordBytes, vault);
      }

      await wallet.unlock(newPasswordBytes);
      await this.#state.sync();

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err)
      });
    } 
  }

  async removeAccount(walletIndex: number, accountIndex: number, sendResponse: StreamResponse) {
    try {
      if (accountIndex == 0) {
        throw new Error(`invalid account index: ${accountIndex}`);
      }

      const wallet = this.#state.wallets[walletIndex];

      wallet.accounts.splice(accountIndex, 1);
      await this.#state.sync();

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async removeWallet(walletIndex: number, password: string, sendResponse: StreamResponse) {
    try {
      const passwordBytes = utf8ToUint8Array(password);
      const wallet = this.#state.wallets[walletIndex];

      await wallet.unlock(passwordBytes);
      this.#state.wallets.splice(walletIndex);
      await this.#state.sync();

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async setAccountName(walletIndex: number, accountIndex: number, name: string, sendResponse: StreamResponse) {
    try {
      const wallet = this.#state.wallets[walletIndex];
      const account = wallet.accounts[accountIndex];

      account.name = name;

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async selectAccount(walletIndex: number, accountIndex: number, sendResponse: StreamResponse) {
    try {
      const wallet = this.#state.wallets[walletIndex];

      if (accountIndex <= wallet.accounts.length - 1 && accountIndex >= 0) {
        wallet.selectedAccount = accountIndex;
      }

      sendResponse({
        resolve: true,
      });
    } catch (err) {
      sendResponse({
        reject: String(err),
      });
    }
  }

  async addOrGetChain(chain: IChainConfigState) {
    const newChain = new ChainConfig(chain);

    const foundChain = this.#state.getChain(newChain.hash());

    if (foundChain) {
      return foundChain;
    }

    this.#state.chains.push(newChain);
    await this.#state.sync();
    
    return newChain;
  }
}

```

`zil-pay/background/state.ts`:

```ts
import { BackgroundState } from "background/storage";
import { TransactionService, WalletService } from "background/services";
import { ProviderService } from "background/services";

export class GlobalState {
  state: BackgroundState;
  readonly wallet: WalletService;
  readonly provider: ProviderService;
  readonly transaction: TransactionService;

  static async fromStorage() {
    const state = await BackgroundState.fromStorage();

    return new GlobalState(state);
  }

  constructor(initialState: BackgroundState) {
    this.state = initialState;
    this.wallet = new WalletService(this.state);
    this.provider = new ProviderService(this.state);
    this.transaction = new TransactionService(this.state);
  }

  async sync() {
    await this.state.sync();
  }
}

```

`zil-pay/background/storage/account.ts`:

```ts
import type { AddressType } from 'crypto/address';
import { utils } from 'aes-js';
import { ChainConfig } from './chain';
import { KeyPair } from 'crypto/keypair';

export interface Bip32Account {
  name: string;
  index: number;
}

export interface IAccountState {
  addr: string;
  addrType: AddressType;
  name: string;
  pubKey: string;
  chainHash: number;
  chainId: number;
  slip44: number;
  index: number;
}

export class Account implements IAccountState {
  addr: string;
  addrType: AddressType;
  name: string;
  pubKey: string;
  chainHash: number;
  chainId: number;
  slip44: number;
  index: number;

  constructor(data: IAccountState) {
    this.addr = data.addr;
    this.addrType = data.addrType;
    this.name = data.name;
    this.pubKey = data.pubKey;
    this.chainHash = data.chainHash;
    this.chainId = data.chainId;
    this.slip44 = data.slip44;
    this.index = data.index;
  }

  static async fromBip39(bip32Account: Bip32Account, chain: ChainConfig, seed: Uint8Array): Promise<Account> {
    const keyPair = await KeyPair.fromSeed(seed, chain.slip44, bip32Account.index);
    const addrType = keyPair.addressType();
    const addr = await (await keyPair.address()).autoFormat();
    const account = new Account({
      addr,
      addrType,
      name: bip32Account.name,
      index: bip32Account.index,
      pubKey: utils.hex.fromBytes(keyPair.pubKey),
      chainHash: chain.hash(),
      slip44: chain.slip44,
      chainId: chain.chainId,
    });

    return account;
  }

  static async fromPrivateKey(privateKey: Uint8Array, chain: ChainConfig, name: string): Promise<Account> {
    const keyPair = await KeyPair.fromPrivateKey(privateKey, chain.slip44);
    const addrType = keyPair.addressType();
    const addr = await keyPair.address();
    const formated = await addr.autoFormat();

    const account = new Account({
      addrType,
      name: name,
      index: 0,
      addr: formated,
      pubKey: utils.hex.fromBytes(keyPair.pubKey),
      chainHash: chain.hash(),
      slip44: chain.slip44,
      chainId: chain.chainId,
    });

    return account;
  }
}

```

`zil-pay/background/storage/argon.ts`:

```ts
import type { Argon2Config } from '../../crypto/argon2';
import { Variant, Version, Config } from '@hicaru/argon2-pure.js';
import { APP_ID } from '../../config/argon2';
import { deriveArgon2Key } from '../../crypto/argon2';
import { ShaAlgorithms } from '../../config/pbkdf2';
import { KeyChain } from '../../crypto/keychain';
import { hexToUint8Array, uint8ArrayToHex } from 'lib/utils/hex';

export enum HashTypes {
  Argon2,
  Pbkdf2,
}

export interface IWalletHashParams {
  memory: number;
  iterations: number;
  threads: number;
  secret: string;
  hashType: HashTypes;
  hashSize: ShaAlgorithms;
}

export class WalletHashParams implements IWalletHashParams {
  memory: number;
  iterations: number;
  threads: number;
  secret: string;
  hashType: HashTypes;
  hashSize: ShaAlgorithms;

  get argon2(): Argon2Config {
    return new Config(
      APP_ID,
      64,
      this.threads,
      this.memory,
      hexToUint8Array(this.secret),
      this.iterations,
      Variant.Argon2id,
      Version.Version13,
    );
  }

  static default(): WalletHashParams {
    const original = Config.original();

    return new WalletHashParams({
      memory: original.memCost, 
      threads: original.lanes,
      secret: uint8ArrayToHex(original.secret),
      iterations: original.timeCost,
      hashType: HashTypes.Argon2,
      hashSize: ShaAlgorithms.Sha512,
    });
  }

  static pq(): WalletHashParams {
    return new WalletHashParams({
      memory: 2097152, 
      threads: 2,
      secret: uint8ArrayToHex(new Uint8Array()),
      iterations: 1,
      hashType: HashTypes.Argon2,
      hashSize: ShaAlgorithms.Sha512,
    });
  }


  constructor(data: IWalletHashParams) {
    this.memory = data.memory;
    this.iterations = data.iterations;
    this.threads = data.threads;
    this.secret = data.secret;
    this.hashType = data.hashType;
    this.hashSize = data.hashSize;
  }

  async deriveKey(password: Uint8Array, salt: Uint8Array): Promise<KeyChain> {
    if (this.hashType == HashTypes.Argon2) {
      const seed = deriveArgon2Key(password, salt, this.argon2);      
      return KeyChain.fromSeed(seed);
    } else if(ShaAlgorithms.Sha512 == this.hashSize) {
      return KeyChain.fromAesV3(password, this.hashSize, this.iterations);
    } else {
      return KeyChain.fromAesV2(password);
    }
  }
}

```

`zil-pay/background/storage/background.ts`:

```ts
import { BrowserStorage, buildObject } from 'lib/storage';
import { ChainConfig, type IChainConfigState } from './chain';
import { Wallet, type IWalletState } from './wallet';
import { Fields } from 'config/fields';
import { migrateToV4 } from 'background/secure';
import { Themes } from 'config/theme';
import { Locales } from 'config/locale';

export interface IBackgroundState {
  storageVersion: number;
  wallets: IWalletState[];
  selected_wallet: number;
  notificationsGlobalEnabled: boolean;
  locale: Locales;
  appearances: Themes;
  abbreviatedNumber: boolean;
  hideBalance: boolean;
  chains: IChainConfigState[];
}

export class BackgroundState implements IBackgroundState {
  readonly storageVersion  = 4;
  wallets: Wallet[];
  selected_wallet: number;
  notificationsGlobalEnabled: boolean;
  locale: Locales;
  appearances: Themes;
  abbreviatedNumber: boolean;
  hideBalance: boolean;
  chains: ChainConfig[];

  static default() {
    return new BackgroundState({
      wallets: [],
      selected_wallet: -1,
      notificationsGlobalEnabled: true,
      locale: Locales.Auto,
      appearances: Themes.System,
      abbreviatedNumber: true,
      hideBalance: false,
      chains: [],
      storageVersion: 4,
    });
  }

  static async fromStorage() {
    const recordsv4 = await BrowserStorage.get<string>(Fields.STORAGE_V4);
    let state: BackgroundState;

    if (!recordsv4) {
      const oldRecords = await BrowserStorage.getAll<IBackgroundState>();

      if (oldRecords) {
        try {
          state = migrateToV4(oldRecords);
          await BrowserStorage.clear();
          await state.sync();
        } catch {
          state = BackgroundState.default();
        }
      } else {
        state = BackgroundState.default();
      }
    } else {
      try {
        state = new BackgroundState(JSON.parse(recordsv4));
      } catch {
        state = BackgroundState.default();
      }
    }

    return state;
  }

  constructor(data: IBackgroundState) {
    this.wallets = (data.wallets ?? []).map(
      (w) => new Wallet(w)
    );
    this.notificationsGlobalEnabled = data.notificationsGlobalEnabled;
    this.locale = data.locale ?? Locales.Auto;
    this.appearances = data.appearances;
    this.abbreviatedNumber = data.abbreviatedNumber;
    this.hideBalance = data.hideBalance;
    this.selected_wallet = Number(data.selected_wallet);
    this.chains = (data.chains).map(
      (c) => new ChainConfig(c)
    );
  }

  getChain(hash: number) {
    return this.chains.find((c) => c.hash() == hash);
  }

  async sync() {
    await BrowserStorage.set(
      buildObject(Fields.STORAGE_V4, JSON.stringify(this)),
    );
  }
}

```

`zil-pay/background/storage/chain.ts`:

```ts
import { FToken, type IFTokenState } from './ftoken';
import { Explorer, type IExplorerState } from './explorer';
import { KeyPair } from 'crypto/keypair';

export interface IChainConfigState {
  name: string;
  logo: string;
  chain: string;
  shortName: string;
  rpc: string[];
  features: number[];
  chainId: number;
  chainIds: number[];
  slip44: number;
  diffBlockTime: number;
  ens: string | null;
  explorers: IExplorerState[];
  fallbackEnabled: boolean;
  testnet: boolean | null;
  ftokens: IFTokenState[];
}

function hashNumber(hash: number, value: number): number {
  hash = (hash << 5) - hash + value;
  return hash >>> 0; 
}

function hashString(hash: number, str: string): number {
  for (let i = 0; i < str.length; i++) {
    hash = (hash << 5) - hash + str.charCodeAt(i);
    hash = hash >>> 0; 
  }
  return hash;
}

function hashChainConfig(chainIds: number[], slip44: number, chain: string): number {
  let hash = 0;
  const chainIdsSum = chainIds[0] + chainIds[1];
  hash = hashNumber(hash, chainIdsSum);
  hash = hashNumber(hash, slip44);
  hash = hashString(hash, chain);
  return hash >>> 0;
}

export class ChainConfig implements IChainConfigState {
  name: string;
  logo: string;
  chain: string;
  shortName: string;
  rpc: string[];
  features: number[];
  chainId: number;
  chainIds: number[];
  slip44: number;
  diffBlockTime: number;
  ens: string | null;
  explorers: Explorer[];
  fallbackEnabled: boolean;
  testnet: boolean | null;
  ftokens: FToken[];

  constructor(data: IChainConfigState) {
    this.name = data.name;
    this.logo = data.logo;
    this.chain = data.chain;
    this.shortName = data.shortName;
    this.rpc = data.rpc;
    this.features = data.features;
    this.chainIds = data.chainIds;
    this.chainId = this.chainIds[0];
    this.slip44 = data.slip44;
    this.diffBlockTime = data.diffBlockTime;
    this.ens = data.ens ?? null;
    this.explorers = (data.explorers).map(
      (e) => new Explorer(e)
    );
    this.fallbackEnabled = data.fallbackEnabled;
    this.testnet = data.testnet ?? null;
    this.ftokens = (data.ftokens).map(
      (t) => new FToken({
        ...t,
        default_: true,
        rate: 0,
        chainHash: t.chainHash ?? hashChainConfig(this.chainIds, this.slip44, this.chain),
        addrType: KeyPair.addressType(this.slip44),
        balances: t.balances ?? {},
      })
    );
  }

  hash(): number {
    return hashChainConfig(this.chainIds, this.slip44, this.chain);
  }
}

```

`zil-pay/background/storage/confirm.ts`:

```ts
import type { MinScillaParams, TokenTransferMetadata, TransactionRequestEVM } from "types/tx";

export interface IConfirmState {
  uuid: string;
  title: string;
  icon: string;
  token?: TokenTransferMetadata;
  scilla?: MinScillaParams;
  signMessageScilla?: string;
  evm?: TransactionRequestEVM;
  signPersonalMessageEVM?: string;
  signTypedDataJsonEVM?: string;
}

export class ConfirmState implements IConfirmState {
  uuid: string;
  title: string;
  icon: string;
  token?: TokenTransferMetadata;
  scilla?: MinScillaParams;
  signMessageScilla?: string;
  evm?: TransactionRequestEVM;
  signPersonalMessageEVM?: string;
  signTypedDataJsonEVM?: string;

  constructor(data: IConfirmState) {
    this.uuid = data.uuid;
    this.title = data.title;
    this.icon = data.icon;

    if (data.token) {
      this.token = data.token;
    }

    if (data.scilla) {
      this.scilla = data.scilla;
    }

    if (data.evm) {
      this.evm = data.evm;
    }

    if (data.signPersonalMessageEVM) {
      this.signPersonalMessageEVM = data.signPersonalMessageEVM;
    }

    if (data.signPersonalMessageEVM) {
      this.signPersonalMessageEVM = data.signPersonalMessageEVM;
    }

    if (data.signTypedDataJsonEVM) {
      this.signTypedDataJsonEVM = data.signTypedDataJsonEVM;
    }
  }
}

```

`zil-pay/background/storage/explorer.ts`:

```ts
export interface IExplorerState {
  name: string;
  url: string;
  icon: string | null;
  standard: number;
} 

export class Explorer implements IExplorerState {
  name: string;
  url: string;
  icon: string | null;
  standard: number;

  constructor(data: IExplorerState) {
    this.name = data.name;
    this.url = data.url;
    this.icon = data.icon ?? null;
    this.standard = data.standard;
  }
}

```

`zil-pay/background/storage/ftoken.ts`:

```ts
import { type AddressType } from "crypto/address";

export interface IFTokenState {
  name: string;
  symbol: string;
  decimals: number;
  addr: string;
  addrType: AddressType;
  logo: string | null;
  balances: Record<string, string>;
  rate: number;
  default_: boolean;
  native: boolean;
  chainHash: number;
}

export class FToken implements IFTokenState {
  name: string;
  symbol: string;
  decimals: number;
  addr: string;
  addrType: AddressType;
  logo: string | null;
  balances: Record<string, string>;
  rate: number;
  default_: boolean;
  native: boolean;
  chainHash: number;

  constructor(data: IFTokenState) {
    this.name = data.name;
    this.symbol = data.symbol;
    this.decimals = data.decimals;
    this.addr = data.addr;
    this.addrType = data.addrType;
    this.logo = data.logo ?? null;
    this.balances = data.balances;
    this.rate = data.rate;
    this.default_ = data.default_;
    this.native = data.native;
    this.chainHash = data.chainHash;
  }
}

```

`zil-pay/background/storage/index.ts`:

```ts
export * from './account';
export * from './argon';
export * from './background';
export * from './chain';
export * from './explorer';
export * from './ftoken';
export * from './notification';
export * from './settings';
export * from './wallet';

```

`zil-pay/background/storage/notification.ts`:

```ts
export class Notification {
  transactions: boolean;

  constructor(data: Record<string, unknown>) {
    this.transactions = data.transactions as boolean;
  }
}

```

`zil-pay/background/storage/settings.ts`:

```ts
import { WalletHashParams, type IWalletHashParams } from './argon';
import { CipherOrders } from '../../crypto/keychain';
import type { RatesApiOptions } from 'config/api';

export interface IWalletSettingsState {
  cipherOrders: CipherOrders[];
  hashFnParams: IWalletHashParams;
  currencyConvert: string;
  ipfsNode: string | null;
  ensEnabled: boolean;
  tokensListFetcher: boolean;
  nodeRankingEnabled: boolean;
  maxConnections: number;
  requestTimeoutSecs: number;
  ratesApiOptions: RatesApiOptions;
  sessionTime: number;
}

export class WalletSettings implements IWalletSettingsState {
  cipherOrders: CipherOrders[];
  hashFnParams: WalletHashParams;
  currencyConvert: string;
  ipfsNode: string | null;
  ensEnabled: boolean;
  tokensListFetcher: boolean;
  nodeRankingEnabled: boolean;
  maxConnections: number;
  requestTimeoutSecs: number;
  ratesApiOptions: RatesApiOptions;
  sessionTime: number;

  constructor(data: IWalletSettingsState) {
    this.cipherOrders = data.cipherOrders;
    this.hashFnParams = new WalletHashParams(data.hashFnParams);
    this.currencyConvert = data.currencyConvert;
    this.ipfsNode = data.ipfsNode;
    this.ensEnabled = data.ensEnabled;
    this.tokensListFetcher = data.tokensListFetcher;
    this.nodeRankingEnabled = data.nodeRankingEnabled;
    this.maxConnections = data.maxConnections;
    this.requestTimeoutSecs = data.requestTimeoutSecs;
    this.ratesApiOptions = data.ratesApiOptions;
    this.sessionTime = data.sessionTime ?? 3600;
  }
}

```

`zil-pay/background/storage/wallet.ts`:

```ts
import type { Bip32Account, IAccountState } from './account';
import { base64ToUint8Array, uint8ArrayToBase64 } from '../../crypto/b64';
import { generateSalt } from '../../lib/runtime';
import { Account } from './account';
import { FToken, type IFTokenState } from './ftoken';
import { WalletSettings, type IWalletSettingsState } from './settings';
import { Session } from '../secure/session';
import { ChainConfig } from './chain';
import { Bip39 } from '../../crypto/bip39';
import { uuid } from '../../crypto/uuid';
import { TypeOf } from 'lib/types';
import { KeyPair } from 'crypto/keypair';
import { uint8ArrayToUtf8, utf8ToUint8Array } from 'lib/utils/utf8';
import { HistoricalTransaction, type IHistoricalTransactionState } from 'background/rpc/history_tx';
import { ConfirmState, type IConfirmState } from './confirm';
import { AuthMethod, WalletTypes } from 'config/wallet';

export interface IWalletState {
  uuid: string;
  walletType: WalletTypes;
  walletName: string;
  authType: AuthMethod;
  accounts: IAccountState[];
  selectedAccount: number;
  tokens: IFTokenState[];
  history: IHistoricalTransactionState[];
  confirm: IConfirmState[];
  settings: IWalletSettingsState;
  defaultChainHash: number;
  vault?: string;
}

export class Wallet implements IWalletState {
  #session: Session;
  #vault: string;

  uuid: string;
  walletType: WalletTypes;
  walletName: string;
  authType: AuthMethod;
  accounts: Account[];
  selectedAccount: number;
  tokens: FToken[];
  history: HistoricalTransaction[];
  confirm: ConfirmState[];
  settings: WalletSettings;
  defaultChainHash: number;

  constructor(data: IWalletState) {
    this.walletType = data.walletType as WalletTypes;
    this.walletName = data.walletName as string;
    this.authType = data.authType as AuthMethod;
    this.accounts = (data.accounts).map(
      (a) => new Account(a)
    );
    this.selectedAccount = data.selectedAccount as number;
    this.tokens = (data.tokens).map(
      (t) => new FToken(t)
    );
    this.settings = new WalletSettings(data.settings);
    this.defaultChainHash = data.defaultChainHash as number;
    this.uuid = data.uuid as string;
    this.history = TypeOf.isArray(data.history) ? data.history.map((h) => new HistoricalTransaction(h)) : [];
    this.confirm = TypeOf.isArray(data.confirm) ? data.confirm.map((c) => new ConfirmState(c)) : [];
    this.#session = new Session(this.uuid);

    this.#vault = data.vault as string ?? "";
  }

  static async fromPrivateKey(
    keyPair: KeyPair,
    walletName: string,
    accountName: string,
    settings: WalletSettings,
    chain: ChainConfig,
    password: string,
  ) {
    const passwordBytes = utf8ToUint8Array(password);
    const account = await Account.fromPrivateKey(keyPair.privateKey, chain, accountName);
    const wallet = new Wallet({
      settings,
      walletName,
      walletType: WalletTypes.SecretKey,
      selectedAccount: 0,
      tokens: chain.ftokens,
      defaultChainHash: chain.hash(),
      uuid: uuid(),
      accounts: [account],
      authType: AuthMethod.None,
      history: [],
      confirm: [],
    });

    await wallet.encrypt(passwordBytes, keyPair.privateKey);

    return wallet;
  }

  static async fromBip39(
    words: string,
    verifyCheckSum: boolean,
    walletName: string,
    bip32Accounts: Bip32Account[],
    settings: WalletSettings,
    chain: ChainConfig,
    password: string,
    wordList: string[],
    passphrase?: string
  ) {
    if (verifyCheckSum) {
      await Bip39.validateMnemonic(words, wordList);
    }

    const seed = await Bip39.mnemonicToSeed(words, passphrase);
    const wallet = new Wallet({
      settings,
      walletName,
      walletType: WalletTypes.SecretPhrase,
      selectedAccount: 0,
      tokens: chain.ftokens,
      defaultChainHash: chain.hash(),
      uuid: uuid(),
      accounts: [],
      authType: AuthMethod.None,
      history: [],
      confirm: [],
    });
    const passwordBytes = utf8ToUint8Array(password);
    const wordsBytes = utf8ToUint8Array(words);

    wallet.accounts = await Promise.all(bip32Accounts.map((acc) => Account.fromBip39(acc, chain, seed)));
    await wallet.encrypt(passwordBytes, wordsBytes);

    return wallet;
  }

  async decrypt(password: Uint8Array): Promise<Uint8Array | string> {
    const salt = await generateSalt();
    const keychain = await this.settings.hashFnParams.deriveKey(password, salt);
    const ciphertext = base64ToUint8Array(this.#vault);
    const decrypted = await keychain.decrypt(ciphertext, this.settings.cipherOrders);

    if (this.walletType == WalletTypes.SecretKey) {      
      return decrypted;
    } else if (this.walletType == WalletTypes.SecretPhrase) {
      return uint8ArrayToUtf8(decrypted);
    } else {
      throw new Error("unknown wallet type");
    }
  }

  async encrypt(password: Uint8Array, plaintext: Uint8Array) : Promise<Uint8Array>{
    const salt = await generateSalt();
    const keychain = await this.settings.hashFnParams.deriveKey(password, salt);
    const cipher = await keychain.encrypt(plaintext, this.settings.cipherOrders);

    this.#vault = uint8ArrayToBase64(cipher);

    return cipher;
  }

  async unlock(password: Uint8Array) {
    const wordsOrKey = await this.decrypt(password);
    const sessionTime = this.settings.sessionTime;

    if (TypeOf.isString(wordsOrKey)) {
      const seed = await Bip39.mnemonicToSeed(String(wordsOrKey));

      await this.#session.setSession(sessionTime, seed);
    } else if (wordsOrKey instanceof Uint8Array) {
      await this.#session.setSession(sessionTime, wordsOrKey);
    } else {
      throw new Error("unk vault");
    }
  }

  async revealKeypair(accountIndex: number, chain: ChainConfig): Promise<KeyPair> {
    if (chain.hash() !== this.defaultChainHash) {
      throw new Error("invlid chain");
    }

    switch (this.walletType) {
      case WalletTypes.SecretPhrase:
        const seed = await this.#session.getVault();
        return KeyPair.fromSeed(seed, chain.slip44, accountIndex);
      case WalletTypes.SecretKey:
        const privateKey = await this.#session.getVault();
        return KeyPair.fromPrivateKey(privateKey, chain.slip44);
      default:
        throw new Error(`Invalid wallet type ${WalletTypes[this.walletType]}`);
    }
  }

  async revealMnemonic(password: Uint8Array, chain: ChainConfig): Promise<string> {
    if (chain.hash() !== this.defaultChainHash) {
      throw new Error("invlid chain");
    }

    switch (this.walletType) {
      case WalletTypes.SecretPhrase:
        const words = await this.decrypt(password);

        return String(words);
      default:
        throw new Error(`Invalid wallet type ${WalletTypes[this.walletType]}`);
    }
  }

  async clearSession() {
    await this.#session.clearSession();
  }

  get vault() {
    return this.#vault;
  }
}

```

`zil-pay/config/api.ts`:

```ts
export enum RatesApiOptions {
  CoinGecko,
  None,
}

```

`zil-pay/config/argon2.ts`:

```ts
import { utils } from "aes-js";

export const WALLET_SALT = utils.utf8.toBytes(
  "ZILPAY:54040c2f-1ec1-4eb1-9595-6e4294d14fd6",
);
export const APP_ID = utils.utf8.toBytes("ZilPay-wallet-app");

```

`zil-pay/config/bip39.ts`:

```ts
export const LANGUAGE_OPTIONS = [
  { code: 'en', label: 'English' },
  { code: 'ja', label: '日本語' },
  { code: 'ko', label: '한국어' },
  { code: 'es', label: 'Español' }
];
export const ALLOWED_COUNTS = [12, 15, 18, 21, 24];

```

`zil-pay/config/common.ts`:

```ts
export enum Common {
  TIME_BEFORE_LOCK = 3,
  POPUP_WIDTH = 320,
  POPUP_HEIGHT = 600,
  PROMT_PAGE = "index.html",
  NONCE_DIFFICULTY = 10,
  MAX_TX_QUEUE = 20,
}

export const WORKER_POOLING = 8000; // Seconds

```

`zil-pay/config/fields.ts`:

```ts
export enum OldFields {
  VAULT = "vault",
  VAULT_IMPORTED = "importedvault",
  CONFIG = "config",
  OLD_WALLET = "wallet",
  WALLET = "wallet-identities",
  SELECTED_NET = "selectednet",
  BLOCK_NUMBER = "blocknumber",
  TRANSACTIONS = "transactions",
  ENCRYPT_DATA = "encryption-data",
  DECRYPT_DATA = "decryption-data",
  CONFIRM_TX = "confirm",
  CONFIRM_MESSAGE = "confirm-message",
  STATIC = "static",
  LOCK_TIME = "time_before_lock",
  GUARD_CONFIG = "guard-configuration",
  CONNECT_DAPP = "connect",
  CONNECT_LIST = "connection-list",
  THEME = "theme",
  CONTACTS = "contacts",
  SELECTED_COIN = "selectedcoin",
  TOKENS = "tokens-list",
  COLLECTION = "collections-list",
  SSN = "ssn-list",
  GAS = "chain-gas",
  RATE_CURRENCIES = "rate-of-currencies",
  SELECTED_CURRENCY = "selected-currency",
  LOCALE = "selected-local",
  FORMAT = "address-format",
  POPUP_ENABLED = "popup-enabled",
  PHISHING = "phishing-detection",
  DEX = "dex-proto",
  BADGE_COUNTER = "badge-counter",
}

export enum Fields {
  STORAGE_V4 = "storage-v4",
}

```

`zil-pay/config/jsonrpc.ts`:

```ts
/**
 * Enum for Zilliqa JSON-RPC methods.
 */
export enum ZilMethods {
  GetSmartContractInit = "GetSmartContractInit",
  GetBalance = "GetBalance",
  GetSmartContractSubState = "GetSmartContractSubState",
  GetNetworkId = "GetNetworkId",
  GetPendingTxn = "GetPendingTxn",
  GetTransaction = "GetTransaction",
  CreateTransaction = "CreateTransaction",
  GetTransactionStatus = "GetTransactionStatus",
  GetLatestTxBlock = "GetLatestTxBlock",
  GetTxBlock = "GetTxBlock",
  GetRecentTransactions = "GetRecentTransactions",
  GetMinimumGasPrice = "GetMinimumGasPrice",
}

/**
 * Enum for EVM-compatible JSON-RPC methods.
 */
export enum EvmMethods {
  // State Methods
  GetBalance = "eth_getBalance",
  GetStorageAt = "eth_getStorageAt",
  GetTransactionCount = "eth_getTransactionCount",
  GetBlockTransactionCountByHash = "eth_getBlockTransactionCountByHash",
  GetBlockTransactionCountByNumber = "eth_getBlockTransactionCountByNumber",
  GetCode = "eth_getCode",
  Call = "eth_call",
  EstimateGas = "eth_estimateGas",

  // Block Methods
  BlockNumber = "eth_blockNumber",
  GetBlockByHash = "eth_getBlockByHash",
  GetBlockByNumber = "eth_getBlockByNumber",
  GetBlockReceipts = "eth_getBlockReceipts",

  // Transaction Methods
  SendRawTransaction = "eth_sendRawTransaction",
  GetTransactionByHash = "eth_getTransactionByHash",
  GetTransactionByBlockHashAndIndex = "eth_getTransactionByBlockHashAndIndex",
  GetTransactionByBlockNumberAndIndex = "eth_getTransactionByBlockNumberAndIndex",
  GetTransactionReceipt = "eth_getTransactionReceipt",

  // Account Methods
  Accounts = "eth_accounts",
  GetProof = "eth_getProof",

  // Chain State
  ChainId = "eth_chainId",
  NetworkVersion = "net_version",
  Syncing = "eth_syncing",
  GasPrice = "eth_gasPrice",
  MaxPriorityFeePerGas = "eth_maxPriorityFeePerGas",
  FeeHistory = "eth_feeHistory",
  BlobBaseFee = "eth_blobBaseFee",

  // Filter Methods
  NewFilter = "eth_newFilter",
  NewBlockFilter = "eth_newBlockFilter",
  NewPendingTransactionFilter = "eth_newPendingTransactionFilter",
  UninstallFilter = "eth_uninstallFilter",
  GetFilterChanges = "eth_getFilterChanges",
  GetFilterLogs = "eth_getFilterLogs",
  GetLogs = "eth_getLogs",

  // Contract Methods
  Sign = "eth_sign",
  SignTransaction = "eth_signTransaction",
}

```

`zil-pay/config/locale.ts`:

```ts
export enum Locales {
  Auto = "auto",
  EN = "en",
  RU = "ru",
  JA = "ja",
  ZH = "zh",
}

```

`zil-pay/config/manifest.ts`:

```ts
export enum ManifestVersions {
  V2 = 2,
  V3 = 3,
}

```

`zil-pay/config/pbkdf2.ts`:

```ts
export enum ShaAlgorithms {
  Sha512 = "SHA-512",
  sha256 = "SHA-256",
}

```

`zil-pay/config/sha.ts`:

```ts
export enum ShaAlgorithms {
  Sha512 = "SHA-512",
  sha256 = "SHA-256",
}

```

`zil-pay/config/slip44.ts`:

```ts
export const ETHEREUM = 60;
export const ZILLIQA = 313;

```

`zil-pay/config/stream.ts`:

```ts
const app = "BearBy";

export const MTypePopup = {
  GET_GLOBAL_STATE: `@/${app}/get-global-state`,
  SET_GLOBAL_STATE: `@/${app}/set-global-state`,

  GEN_BIP39: `@/${app}/gen-bip39-words`,
  VALIDATE_BIP39_CHECK_SUM: `@/${app}/validate-bip39-checksum`,
  GEN_KEYPAIR: `@/${app}/gen-key-pair`,
  FROM_PRIV_KEY: `@/${app}/keypair-from-private-key`,

  WALLET_FROM_PRIVATE_KEY: `@/${app}/create-wallet-from-private-key`,
  WALLET_FROM_BIP39: `@/${app}/create-wallet-from-bip39`,
}


```

`zil-pay/config/theme.ts`:

```ts
export enum Themes {
  System = "system",
  Light = "light",
  Dark = "dark",
}

```

`zil-pay/config/wallet.ts`:

```ts
export enum WalletTypes {
    Ledger,
    SecretPhrase,
    SecretKey,
}

export enum AuthMethod {
    Biometric,
    None,
}

```

`zil-pay/crypto/address.ts`:

```ts
import { addr as ethAddr } from "micro-eth-signer";
import {
  fromBech32Address,
  fromZilPubKey,
  toBech32Address,
  toChecksumBytesAddress,
} from "lib/zilliqa";
import { KeyPair } from "./keypair";
import { HRP } from "lib/zilliqa/config";
import { hasHexPrefix, hexToUint8Array, uint8ArrayToHex } from "lib/utils/hex";

export enum AddressType {
  Bech32,
  EthCheckSum,
}

export class Address {
  readonly #bytes: Uint8Array;
  #type: AddressType;

  get bytes() {
    return this.#bytes;
  }

  get type() {
    return this.#type;
  }

  static empty(slip44: number) {
    const addressType = KeyPair.addressType(slip44);
    return new Address(new Uint8Array(20), addressType);
  }

  static fromStr(address: string) {
    if (hasHexPrefix(address)) {
      const ethCheckSumAddress = ethAddr.parse(address);
      const bytes = hexToUint8Array(ethCheckSumAddress.data);

      return new Address(bytes, AddressType.EthCheckSum);
    } else if (address.startsWith(HRP)) {
      const checkSumZil = fromBech32Address(address);
      const bytes = hexToUint8Array(checkSumZil);

      return new Address(bytes, AddressType.Bech32);
    }

    throw new Error("Unsupported address format");
  }

  static async fromPubKey(pubKey: Uint8Array, slip44: number) {
    const addressType = KeyPair.addressType(slip44);

    switch (addressType) {
      case AddressType.Bech32:
        const zilBytes = await fromZilPubKey(pubKey);

        return new Address(zilBytes, addressType);
      case AddressType.EthCheckSum:
        const ethChecsumAddress = ethAddr.fromPublicKey(pubKey);
        const ethBytes = hexToUint8Array(ethChecsumAddress);

        return new Address(ethBytes, addressType);
    }
  }

  static async fromPrivateKey(privateKey: Uint8Array, slip44: number) {
    const keypair = await KeyPair.fromPrivateKey(privateKey, slip44);
    const addressType = keypair.addressType();

    switch (addressType) {
      case AddressType.Bech32:
        const base16 = await fromZilPubKey(keypair.pubKey);
        return new Address(base16, addressType);

      case AddressType.EthCheckSum:
        const ethChecsumAddress = ethAddr.fromPublicKey(keypair.pubKey);
        const ethBytes = hexToUint8Array(ethChecsumAddress);

        return new Address(ethBytes, addressType);
    }
  }

  constructor(bytes: Uint8Array, type: AddressType) {
    this.#bytes = bytes;
    this.#type = type;
  }

  toBase16(): string {
    return uint8ArrayToHex(this.bytes);
  }

  async autoFormat() {
    switch (this.#type) {
      case AddressType.Bech32:
        return this.toZilBech32();
      case AddressType.EthCheckSum:
        return this.toEthChecksum();
    }
  }

  async toEthChecksum(): Promise<string> {
    const nonChecksummedAddress = uint8ArrayToHex(this.bytes);
    return ethAddr.addChecksum(nonChecksummedAddress);
  }

  async toZilChecksum(): Promise<string> {
    return toChecksumBytesAddress(this.bytes);
  }

  async toZilBech32(): Promise<string> {
    const zilChecSum = await this.toZilChecksum();

    return toBech32Address(zilChecSum);
  }
}

```

`zil-pay/crypto/aes256.ts`:

```ts
import { Counter, ModeOfOperation } from "aes-js";
import { randomBytes } from "../crypto/random";
import { md5 } from "js-md5";
import { uint8ArrayToUtf8, utf8ToUint8Array } from "lib/utils/utf8";
import { hexToUint8Array, uint8ArrayToHex } from "lib/utils/hex";

export enum ErrorMessages {
  InvalidKeyLength = "Invalid key length provided. Key must be 16, 24, or 32 bytes.",
  IncorrectParams = "Password is not correct",
}

export const AESCipherV3 = Object.freeze({
  encrypt(content: Uint8Array, key: Uint8Array): Uint8Array {
    if (![16, 24, 32].includes(key.length)) {
      throw new Error(ErrorMessages.InvalidKeyLength);
    }

    const entropy = randomBytes(16);
    const iv = new Counter(entropy);
    const aesCtr = new ModeOfOperation.ctr(key, iv);
    const encrypted = aesCtr.encrypt(content);
    const bytes = utf8ToUint8Array(
      `${uint8ArrayToHex(encrypted)}/${uint8ArrayToHex(entropy)}`,
    );
    return bytes;
  },
  decrypt(bytes: Uint8Array, key: Uint8Array): Uint8Array {
    if (![16, 24, 32].includes(key.length)) {
      throw new Error(ErrorMessages.InvalidKeyLength);
    }

    const [encrypted, iv] = uint8ArrayToUtf8(bytes).split("/");
    const counter = new Counter(hexToUint8Array(iv));
    const aesCtr = new ModeOfOperation.ctr(key, counter);
    return aesCtr.decrypt(hexToUint8Array(encrypted));
  },
});

export const AESCipherV2 = Object.freeze({
  async decrypt(data: Uint8Array, key: Uint8Array): Promise<any> {
    const combined = data;

    const prefix = new TextDecoder().decode(combined.slice(0, 8));
    if (prefix !== "Salted__") {
      throw new Error(ErrorMessages.IncorrectParams);
    }

    const salt = combined.slice(8, 16);
    const ciphertext = combined.slice(16);
    const passwordBytes = key;
    const { key: derivedKey, iv } = await AESCipherV2.evpKDF(
      passwordBytes,
      salt,
      32,
      16,
    );

    const cryptoKey = await crypto.subtle.importKey(
      "raw",
      derivedKey,
      { name: "AES-CBC" },
      false,
      ["decrypt"],
    );

    let decrypted: ArrayBuffer;
    try {
      decrypted = await crypto.subtle.decrypt(
        { name: "AES-CBC", iv },
        cryptoKey,
        ciphertext,
      );
    } catch {
      throw new Error("ErrorMessages.IncorrectPassword");
    }

    const content = new TextDecoder().decode(decrypted);
    if (!content) {
      throw new Error("ErrorMessages.IncorrectPassword");
    }

    try {
      return JSON.parse(content);
    } catch {
      return content;
    }
  },

  async evpKDF(
    password: Uint8Array,
    salt: Uint8Array,
    keySize: number,
    ivSize: number,
  ): Promise<{ key: Uint8Array; iv: Uint8Array }> {
    const totalSize = keySize + ivSize;
    let derived = new Uint8Array(0);
    let previousBlock = new Uint8Array(0);

    while (derived.length < totalSize) {
      const input = new Uint8Array([...previousBlock, ...password, ...salt]);
      const block = await AESCipherV2.md5Hash(input);
      derived = new Uint8Array([...derived, ...block]);
      previousBlock = Uint8Array.from(block);
    }

    const key = derived.slice(0, keySize);
    const iv = derived.slice(keySize, keySize + ivSize);
    return { key, iv };
  },

  async md5Hash(data: Uint8Array): Promise<Uint8Array> {
    const hasher = md5.create();
    hasher.update(data);
    const hash = hasher.arrayBuffer();
    return new Uint8Array(hash);
  },
});

```

`zil-pay/crypto/argon2.ts`:

```ts
import { Config, hashRaw } from "@hicaru/argon2-pure.js";
import { WALLET_SALT } from "../config/argon2";

export type Argon2Config = Config;

export function deriveArgon2Key(
  password: Uint8Array,
  saltBytes: Uint8Array,
  config: Argon2Config,
) {
  const combinedSalt = new Uint8Array(saltBytes.length + WALLET_SALT.length);

  combinedSalt.set(saltBytes, 0);
  combinedSalt.set(WALLET_SALT, saltBytes.length);

  const hash = hashRaw(password, combinedSalt, config);

  return hash;
}

```

`zil-pay/crypto/b64.ts`:

```ts
/**
 * Converts a base64 string to a Uint8Array.
 * @param base64 - The base64 string to convert.
 * @returns A Uint8Array containing the decoded data.
 * @throws {Error} If the input string is not a valid base64 string.
 */
export function base64ToUint8Array(base64: string): Uint8Array {
  try {
    const binaryString = atob(base64);
    const length = binaryString.length;
    const bytes = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  } catch (error) {
    throw new Error("Invalid base64 string");
  }
}

/**
 * Converts a Uint8Array to a base64 string.
 * @param uint8Array - The Uint8Array to convert.
 * @returns A base64 string representing the input data.
 */
export function uint8ArrayToBase64(uint8Array: Uint8Array): string {
  const binaryString = String.fromCharCode(...uint8Array);
  return btoa(binaryString);
}

```

`zil-pay/crypto/bip32.ts`:

```ts
import { getPublicKey } from "@noble/secp256k1";
import { utils } from "@noble/secp256k1";
import {
  bigIntToUint8ArrayBigEndian,
  uint8ArrayToBigIntBigEndian,
} from "./number";
import { ShaAlgorithms } from "../config/pbkdf2";
import { ETHEREUM, ZILLIQA } from "../config/slip44";

const HARDENED_BIT = 0x80000000;
const BITCOIN_SEED = new TextEncoder().encode("Bitcoin seed");

export enum Bip32ErrorCode {
  InvalidChild = "InvalidChild",
  InvalidPath = "InvalidPath",
  InvalidSlip44 = "invalid slip44",
  InvalidKey = "InvalidKey",
  HmacError = "HmacError",
}

export class Bip32Error extends Error {
  constructor(code: Bip32ErrorCode, message: string) {
    super(message);
    this.name = `Bip32Error:${code}`;
  }
}

export class ChildNumber {
  constructor(public value: number) {}

  isHardened(): boolean {
    return this.value < 0;
  }

  toBytes(): Uint8Array {
    const buffer = new Uint8Array(4);
    buffer[0] = (this.value >>> 24) & 0xff;
    buffer[1] = (this.value >>> 16) & 0xff;
    buffer[2] = (this.value >>> 8) & 0xff;
    buffer[3] = this.value & 0xff;
    return buffer;
  }

  static fromString(s: string): ChildNumber {
    let numStr = s;
    let hardened = false;
    if (s.endsWith("'")) {
      numStr = s.slice(0, -1);
      hardened = true;
    }
    const index = parseInt(numStr, 10);
    if (isNaN(index) || index < 0) {
      throw new Bip32Error(
        Bip32ErrorCode.InvalidChild,
        `Failed to parse child number: ${s}`,
      );
    }
    const value = hardened ? index | HARDENED_BIT : index;
    return new ChildNumber(value);
  }
}

async function hmacSha512(
  key: Uint8Array,
  data: Uint8Array,
): Promise<Uint8Array> {
  try {
    const importedKey = await globalThis.crypto.subtle.importKey(
      "raw",
      key,
      {
        name: "HMAC",
        hash: { name: ShaAlgorithms.Sha512 },
      },
      false,
      ["sign"],
    );

    const signature = await globalThis.crypto.subtle.sign(
      "HMAC",
      importedKey,
      data,
    );

    return new Uint8Array(signature);
  } catch (error) {
    throw new Bip32Error(
      Bip32ErrorCode.HmacError,
      `HMAC computation failed: ${error}`,
    );
  }
}

export async function deriveMasterKey(
  seed: Uint8Array,
): Promise<{ key: Uint8Array; chainCode: Uint8Array }> {
  const hmacResult = await hmacSha512(BITCOIN_SEED, seed);
  const key = new Uint8Array(hmacResult.slice(0, 32));
  const chainCode = new Uint8Array(hmacResult.slice(32, 64));

  if (!utils.isValidPrivateKey(key)) {
    throw new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid master key");
  }

  return { key, chainCode };
}

export async function deriveChildKey(
  parentKey: Uint8Array,
  chainCode: Uint8Array,
  child: ChildNumber,
): Promise<{ key: Uint8Array; chainCode: Uint8Array }> {
  if (!utils.isValidPrivateKey(parentKey)) {
    throw new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid parent key");
  }

  let dataToHash: Uint8Array;

  if (child.isHardened()) {
    dataToHash = new Uint8Array([0, ...parentKey, ...child.toBytes()]);
  } else {
    const publicKey = getPublicKey(parentKey, true);
    dataToHash = new Uint8Array([...publicKey, ...child.toBytes()]);
  }

  const hmacResult = await hmacSha512(chainCode, dataToHash);
  const childKeyPart = new Uint8Array(hmacResult.slice(0, 32));
  const newChainCode = new Uint8Array(hmacResult.slice(32, 64));

  const curveOrder = BigInt(
    "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141",
  );

  let parentScalar = uint8ArrayToBigIntBigEndian(parentKey);
  let childScalar = uint8ArrayToBigIntBigEndian(childKeyPart);

  childScalar = childScalar % curveOrder;

  let sum = (parentScalar + childScalar) % curveOrder;

  if (sum === 0n) {
    throw new Bip32Error(
      Bip32ErrorCode.InvalidKey,
      "Invalid child key: sum is zero",
    );
  }

  const resultKey = bigIntToUint8ArrayBigEndian(sum, 32);

  if (!utils.isValidPrivateKey(resultKey)) {
    throw new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid child key");
  }

  return { key: resultKey, chainCode: newChainCode };
}

export async function derivePrivateKey(
  seed: Uint8Array,
  path: string,
): Promise<Uint8Array> {
  if (!path.startsWith("m/")) {
    throw new Bip32Error(
      Bip32ErrorCode.InvalidPath,
      "Path must start with 'm/'",
    );
  }

  const pathParts = path
    .slice(2)
    .split("/")
    .filter((part) => part !== "");

  let { key, chainCode } = await deriveMasterKey(seed);

  for (const part of pathParts) {
    const childNumber = ChildNumber.fromString(part);
    const result = await deriveChildKey(key, chainCode, childNumber);
    key = result.key;
    chainCode = result.chainCode;
  }

  return key;
}

export async function deriveFromPrivateKeyPublicKey(
  privateKey: Uint8Array,
  slip44: number,
  compressed = true,
): Promise<Uint8Array> {
  if (slip44 == ZILLIQA || slip44 == ETHEREUM) {
    return getPublicKey(privateKey, compressed);
  }

  throw new Error(Bip32ErrorCode.InvalidSlip44);
}

```

`zil-pay/crypto/bip39.ts`:

```ts
import { pbkdf2 } from "./pbkdf2";
import { ShaAlgorithms } from "../config/pbkdf2";
import { randomBytes } from "./random";
import { assert } from "../lib/runtime/assert";
import { sha256 } from "./sha256";

// BIP-39 constants
const ENTROPY_BITS = [128, 160, 192, 224, 256];
const PBKDF2_ITERATIONS = 2048;
const SEED_LENGTH = 64; // 512 bits

export interface Mnemonic {
  phrase: string;
  words: string[];
}

export enum Bip39Error {
  InvalidEntropy = "Invalid entropy length. Must be 128, 160, 192, 224, or 256 bits.",
  InvalidMnemonic = "Invalid mnemonic phrase.",
  InvalidWord = "Mnemonic contains invalid word(s) not in wordlist.",
  InvalidWordCount = "Invalid number of words. Must be 12, 15, 18, 21, or 24.",
  InvalidChecksum = "Mnemonic checksum is invalid.",
}

export const Bip39 = Object.freeze({
  /**
   * Generates a BIP-39 mnemonic from random entropy.
   * @param entropyBits - Number of entropy bits (128, 160, 192, 224, or 256).
   * @returns A mnemonic object with phrase and words.
   * @throws Error if entropyBits is invalid.
   */
  async generateMnemonic(
    entropyBits: number = 128,
    wordList: string[],
  ): Promise<Mnemonic> {
    assert(ENTROPY_BITS.includes(entropyBits), Bip39Error.InvalidEntropy);

    const entropyBytes = entropyBits / 8;
    const entropy = randomBytes(entropyBytes);
    const checksumBits = entropyBits / 32;
    const totalBits = entropyBits + checksumBits;
    const wordCount = totalBits / 11;

    // Compute SHA-256 checksum
    const hash = await sha256(entropy);
    const checksum = hash[0] >> (8 - checksumBits);

    // Combine entropy and checksum
    const entropyBitsStr = Array.from(entropy)
      .map((byte) => byte.toString(2).padStart(8, "0"))
      .join("");
    const checksumBitsStr = checksum.toString(2).padStart(checksumBits, "0");
    const bits = entropyBitsStr + checksumBitsStr;

    // Split into 11-bit chunks to select words
    const words: string[] = [];
    for (let i = 0; i < wordCount; i++) {
      const start = i * 11;
      const chunk = bits.slice(start, start + 11);
      const index = parseInt(chunk, 2);
      words.push(wordList[index]);
    }

    return {
      phrase: words.join(" "),
      words,
    };
  },

  /**
   * Validates a BIP-39 mnemonic phrase.
   * @param mnemonic - The mnemonic phrase to validate.
   * @returns True if valid, throws error otherwise.
   * @throws Error if mnemonic is invalid.
   */
  async validateMnemonic(
    mnemonic: string,
    wordList: string[],
  ): Promise<boolean> {
    const words = mnemonic.trim().split(/\s+/);
    const wordCount = words.length;
    const validWordCounts = [12, 15, 18, 21, 24];

    assert(validWordCounts.includes(wordCount), Bip39Error.InvalidWordCount);

    // Verify all words are in wordlist
    for (const word of words) {
      assert(wordList.includes(word), `${Bip39Error.InvalidWord}, ${word}`);
    }

    // Reconstruct entropy and checksum
    const bits = words
      .map((word) => {
        const index = wordList.indexOf(word);
        return index.toString(2).padStart(11, "0");
      })
      .join("");

    const entropyBits = wordCount * 11 - wordCount / 3;
    const entropy = bits.slice(0, entropyBits);
    const checksum = bits.slice(entropyBits);

    // Convert entropy bits to bytes
    const entropyBytes = new Uint8Array(entropyBits / 8);
    for (let i = 0; i < entropyBytes.length; i++) {
      entropyBytes[i] = parseInt(entropy.slice(i * 8, (i + 1) * 8), 2);
    }

    // Verify checksum
    const hash = await sha256(entropyBytes);
    const computedChecksum = hash[0] >> (8 - wordCount / 3);
    const expectedChecksum = parseInt(checksum, 2);

    assert(computedChecksum === expectedChecksum, Bip39Error.InvalidChecksum);

    return true;
  },

  /**
   * Derives a seed from a BIP-39 mnemonic using PBKDF2.
   * @param mnemonic - The mnemonic phrase.
   * @param passphrase - Optional passphrase (default: empty string).
   * @returns A 512-bit seed as Uint8Array.
   * @throws Error if mnemonic is invalid.
   */
  async mnemonicToSeed(
    mnemonic: string,
    passphrase: string = "",
  ): Promise<Uint8Array> {
    const password = new TextEncoder().encode(mnemonic);
    const salt = new TextEncoder().encode(`mnemonic${passphrase}`);
    const seed = await pbkdf2(
      password,
      salt,
      PBKDF2_ITERATIONS,
      ShaAlgorithms.Sha512,
    );

    return seed;
  },

  /**
   * Converts a mnemonic to entropy.
   * @param mnemonic - The mnemonic phrase.
   * @returns The original entropy as Uint8Array.
   * @throws Error if mnemonic is invalid.
   */
  async mnemonicToEntropy(
    mnemonic: string,
    wordList: string[],
  ): Promise<Uint8Array> {
    assert(
      await Bip39.validateMnemonic(mnemonic, wordList),
      Bip39Error.InvalidMnemonic,
    );

    const words = mnemonic.trim().split(/\s+/);
    const wordCount = words.length;
    const entropyBits = wordCount * 11 - wordCount / 3;

    const bits = words
      .map((word) => {
        const index = wordList.indexOf(word);
        return index.toString(2).padStart(11, "0");
      })
      .join("");

    const entropy = bits.slice(0, entropyBits);
    const entropyBytes = new Uint8Array(entropyBits / 8);
    for (let i = 0; i < entropyBytes.length; i++) {
      entropyBytes[i] = parseInt(entropy.slice(i * 8, (i + 1) * 8), 2);
    }

    return entropyBytes;
  },

  /**
   * Converts entropy to a BIP-39 mnemonic phrase.
   * @param entropy - The entropy as a Uint8Array (must be 16, 20, 24, 28, or 32 bytes).
   * @param wordList - The BIP-39 wordlist.
   * @returns A mnemonic object with phrase and words.
   * @throws Error if entropy length is invalid.
   */
  async entropyToMnemonic(
    entropy: Uint8Array,
    wordList: string[],
  ): Promise<Mnemonic> {
    const entropyBits = entropy.length * 8;
    assert(ENTROPY_BITS.includes(entropyBits), Bip39Error.InvalidEntropy);

    const checksumBits = entropyBits / 32;
    const totalBits = entropyBits + checksumBits;
    const wordCount = totalBits / 11;

    // Compute SHA-256 checksum
    const hash = await sha256(entropy);
    const checksum = hash[0] >> (8 - checksumBits);

    // Combine entropy and checksum
    const entropyBitsStr = Array.from(entropy)
      .map((byte) => byte.toString(2).padStart(8, "0"))
      .join("");
    const checksumBitsStr = checksum.toString(2).padStart(checksumBits, "0");
    const bits = entropyBitsStr + checksumBitsStr;

    // Split into 11-bit chunks to select words
    const words: string[] = [];
    for (let i = 0; i < wordCount; i++) {
      const start = i * 11;
      const chunk = bits.slice(start, start + 11);
      const index = parseInt(chunk, 2);
      words.push(wordList[index]);
    }

    return {
      phrase: words.join(" "),
      words,
    };
  },
});

```

`zil-pay/crypto/bip49.ts`:

```ts
import { ZILLIQA, ETHEREUM } from "../config/slip44";

export class DerivationPath {
  private slip44: number;
  private index: number;

  constructor(slip44: number, index: number) {
    this.slip44 = slip44;
    this.index = index;
  }

  public getPath(): string {
    return `m/44'/${this.slip44}'/0'/0/${this.index}`;
  }

  public getBasePath(): string {
    return `m/44'/${this.slip44}'/0'/0/`;
  }

  public getIndex(): number {
    return this.index;
  }

  public toString(): string {
    return this.getPath();
  }
}

```

`zil-pay/crypto/keychain.ts`:

```ts
import type { Argon2Config } from "./argon2";
import { PrivKey, PubKey } from "@hicaru/ntrup.js";
import {
  NTRU_CONFIG,
  ntruDecrypt,
  ntruEncrypt,
  ntruKeysFromSeed,
} from "./ntrup";
import { sha256 } from "./sha256";
import { EXTENSION_ID } from "../lib/runtime";
import { deriveArgon2Key } from "./argon2";
import {
  kuznechikDecrypt,
  kuznechikEncrypt,
  KUZNECHIK_KEY_SIZE,
} from "./kuznechik";
import { AESCipherV3, AESCipherV2 } from "./aes256";
import { pbkdf2 } from "./pbkdf2";
import { ShaAlgorithms } from "../config/pbkdf2";
import { uint8ArrayToHex } from "lib/utils/hex";
import { utf8ToUint8Array } from "lib/utils/utf8";

export const PUBLICKEYS_BYTES = NTRU_CONFIG.PUBLICKEYS_BYTES;
export const SECRETKEYS_BYTES = NTRU_CONFIG.SECRETKEYS_BYTES;
export const AES_GCM_KEY_SIZE = KUZNECHIK_KEY_SIZE;
export const KEYCHAIN_BYTES_SIZE =
  PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE + KUZNECHIK_KEY_SIZE;

export async function deriveKeyFromSeed(
  seed: Uint8Array,
  idx: number,
): Promise<Uint8Array> {
  const hasher = new Uint8Array([...seed, idx]);
  return sha256(hasher);
}

export enum CipherOrders {
  AESCBC,
  AESGCM256,
  KUZNECHIK,
  NTRUP761,
}

export class KeyChain {
  public readonly ntrupKeys: { pk: PubKey; sk: PrivKey };
  public readonly aesKey: Uint8Array;
  public readonly kuznechikKey: Uint8Array;

  constructor(
    ntrupKeys: { pk: PubKey; sk: PrivKey },
    aesKey: Uint8Array,
    kuznechikKey: Uint8Array,
  ) {
    this.ntrupKeys = ntrupKeys;
    this.aesKey = aesKey;
    this.kuznechikKey = kuznechikKey;
  }

  static async fromSeed(seed: Uint8Array): Promise<KeyChain> {
    const ntrupKeys = ntruKeysFromSeed(seed);
    const aesKey = await deriveKeyFromSeed(seed, 0);
    const kuznechikKey = await deriveKeyFromSeed(seed, 1);

    return new KeyChain(ntrupKeys, aesKey, kuznechikKey);
  }

  static async fromAesV2(password: Uint8Array): Promise<KeyChain> {
    const keyHashBytes = await sha256(password);

    const keyHashHex = uint8ArrayToHex(keyHashBytes);
    const aesKeyForV2 = utf8ToUint8Array(keyHashHex);

    const ntrupKeys = ntruKeysFromSeed(
      Uint8Array.from([...keyHashBytes, ...keyHashBytes]),
    );

    return new KeyChain(ntrupKeys, aesKeyForV2, keyHashBytes);
  }

  static async fromAesV3(
    password: Uint8Array,
    algorithm: ShaAlgorithms,
    iteractions: number,
  ): Promise<KeyChain> {
    const salt = utf8ToUint8Array(EXTENSION_ID);
    const key = await pbkdf2(password, salt, iteractions, algorithm);
    const keyBytes = await sha256(key);
    const ntrupKeys = ntruKeysFromSeed(
      Uint8Array.from([...keyBytes, ...keyBytes]),
    );

    return new KeyChain(ntrupKeys, keyBytes, keyBytes);
  }

  static async fromPass(
    password: Uint8Array,
    fingerprint: Uint8Array,
    argonConfig: Argon2Config,
  ): Promise<KeyChain> {
    const seed = deriveArgon2Key(password, fingerprint, argonConfig);
    return KeyChain.fromSeed(seed);
  }

  static async fromBytes(bytes: Uint8Array): Promise<KeyChain> {
    if (bytes.length !== KEYCHAIN_BYTES_SIZE) {
      throw new Error("Invalid byte length");
    }
    const pkBytes = bytes.slice(0, PUBLICKEYS_BYTES);
    const skBytes = bytes.slice(
      PUBLICKEYS_BYTES,
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES,
    );
    const aesKey = bytes.slice(
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES,
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE,
    );
    const kuznechikKey = bytes.slice(
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE,
      KEYCHAIN_BYTES_SIZE,
    );

    const pk = PubKey.import(pkBytes, NTRU_CONFIG);
    const sk = PrivKey.import(skBytes, NTRU_CONFIG);

    return new KeyChain({ pk, sk }, aesKey, kuznechikKey);
  }

  toBytes(): Uint8Array {
    const pkBytes = this.ntrupKeys.pk.toBytes(NTRU_CONFIG);
    const skBytes = this.ntrupKeys.sk.toBytes(NTRU_CONFIG);
    const aesKey = this.aesKey;
    const kuznechikKey = this.kuznechikKey;

    const res = new Uint8Array(KEYCHAIN_BYTES_SIZE);
    res.set(pkBytes, 0);
    res.set(skBytes, PUBLICKEYS_BYTES);
    res.set(aesKey, PUBLICKEYS_BYTES + SECRETKEYS_BYTES);
    res.set(
      kuznechikKey,
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE,
    );
    return res;
  }

  async encrypt(
    plaintext: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    let data = plaintext;
    for (const o of options) {
      switch (o) {
        case CipherOrders.AESCBC:
          throw new Error("OLD method, AESCBC");
        case CipherOrders.AESGCM256:
          data = AESCipherV3.encrypt(data, this.aesKey);
          break;
        case CipherOrders.KUZNECHIK:
          data = kuznechikEncrypt(this.kuznechikKey, data);
          break;
        case CipherOrders.NTRUP761:
          data = ntruEncrypt(this.ntrupKeys.pk, data);
          break;
      }
    }
    return data;
  }

  async decrypt(
    ciphertext: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    let data = ciphertext;
    for (const o of options.slice().reverse()) {
      switch (o) {
        case CipherOrders.AESCBC:
          const decryptedString = await AESCipherV2.decrypt(data, this.aesKey);
          data = new TextEncoder().encode(decryptedString);
          break;
        case CipherOrders.AESGCM256:
          data = AESCipherV3.decrypt(data, this.aesKey);
          break;
        case CipherOrders.KUZNECHIK:
          data = kuznechikDecrypt(this.kuznechikKey, data);
          break;
        case CipherOrders.NTRUP761:
          data = ntruDecrypt(this.ntrupKeys.sk, data);
          break;
      }
    }
    return data;
  }

  async makeProof(
    seed: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    return this.encrypt(seed, options);
  }

  async getProof(
    cipherProof: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    return this.decrypt(cipherProof, options);
  }
}

```

`zil-pay/crypto/keypair.ts`:

```ts
import type { TypedData } from "micro-eth-signer/typed-data.js";

import { ETHEREUM, ZILLIQA } from "config/slip44";
import { deriveFromPrivateKeyPublicKey, derivePrivateKey } from "./bip32";
import { DerivationPath } from "./bip49";
import { sign, verify } from "./zilliqa/schnorr";
import {
  personal,
  signTyped,
  verifyTyped,
} from "micro-eth-signer/typed-data.js";
import { hexToUint8Array, uint8ArrayToHex } from "lib/utils/hex";
import { Signature } from "@noble/secp256k1";
import { randomBytes } from "./random";
import { Address, AddressType } from "./address";

export class KeyPair {
  #privateKey: Uint8Array;
  #pubKey: Uint8Array;
  #slip44: number;

  static addressType(slip44: number): AddressType {
    switch (slip44) {
      case ZILLIQA:
        return AddressType.Bech32;
      case ETHEREUM:
        return AddressType.EthCheckSum;
      default:
        return AddressType.EthCheckSum;
    }
  }

  static async fromPrivateKey(privateKey: Uint8Array, slip44: number) {
    const pubKey = await deriveFromPrivateKeyPublicKey(privateKey, slip44);

    return new KeyPair(privateKey, pubKey, slip44);
  }

  static async generate(slip44: number) {
    const privateKey = randomBytes(32);
    const pubKey = await deriveFromPrivateKeyPublicKey(privateKey, slip44);

    return new KeyPair(privateKey, pubKey, slip44);
  }

  static async fromSeed(seed: Uint8Array, slip44: number, index: number) {
    const hdPath = new DerivationPath(slip44, index);
    const privateKey = await derivePrivateKey(seed, hdPath.getPath());
    const pubKey = await deriveFromPrivateKeyPublicKey(privateKey, slip44);

    return new KeyPair(privateKey, pubKey, slip44);
  }

  get privateKey() {
    return this.#privateKey;
  }

  get pubKey() {
    return this.#pubKey;
  }

  get slip44() {
    return this.#slip44;
  }

  constructor(privateKey: Uint8Array, pubKey: Uint8Array, slip44: number) {
    this.#privateKey = privateKey;
    this.#pubKey = pubKey;
    this.#slip44 = slip44;
  }

  addressType(): AddressType {
    return KeyPair.addressType(this.#slip44);
  }

  async address(): Promise<Address> {
    return await Address.fromPubKey(this.pubKey, this.slip44);
  }

  async signMessage(msg: Uint8Array) {
    switch (this.addressType()) {
      case AddressType.Bech32:
        const sigZil = await sign(msg, this.privateKey);
        return Uint8Array.from(sigZil.toBytes());
      case AddressType.EthCheckSum:
        const sigEth = personal.sign(msg, this.privateKey);
        return hexToUint8Array(sigEth);
    }
  }

  signDataEIP712(typedData: TypedData<any, any>): Uint8Array {
    switch (this.addressType()) {
      case AddressType.EthCheckSum:
        const signature = signTyped(typedData, this.privateKey);
        return hexToUint8Array(signature);
      default:
        throw new Error("Unsupported");
    }
  }

  async verifyTypedEIP712(
    signature: Uint8Array,
    typedData: TypedData<any, any>,
    address: Address,
  ): Promise<boolean> {
    switch (this.addressType()) {
      case AddressType.EthCheckSum:
        const sigHex = uint8ArrayToHex(signature, true);
        const ethChecsumAddr = await address.toEthChecksum();

        return verifyTyped(sigHex, typedData, ethChecsumAddr);
      default:
        throw new Error("Unsupported");
    }
  }

  async verifySig(msg: Uint8Array, sig: Uint8Array): Promise<boolean> {
    switch (this.addressType()) {
      case AddressType.Bech32:
        return await verify(msg, this.pubKey, Signature.fromBytes(sig));
      case AddressType.EthCheckSum:
        const address = await this.address();
        const ethChecsum = await address.toEthChecksum();
        const sigHex = uint8ArrayToHex(sig);

        return personal.verify(sigHex, msg, ethChecsum);
    }
  }

  async toJSON() {
    return {
      address: await (await this.address()).autoFormat(),
      privateKey: uint8ArrayToHex(this.#privateKey),
      publicKey: uint8ArrayToHex(this.#pubKey),
      slip44: this.#slip44,
    };
  }
}

```

`zil-pay/crypto/kuznechik.ts`:

```ts
import {
  KeyStore,
  AlgOfb,
  MIN_GAMMA_SIZE,
  MASTER_KEY_SIZE,
} from "@hicaru/kuznechik.js";
import { randomBytes } from "./random";

export const KUZNECHIK_KEY_SIZE = MASTER_KEY_SIZE;

export function kuznechikEncrypt(
  key: Uint8Array,
  plaintext: Uint8Array,
): Uint8Array {
  const keyStore = new KeyStore();
  keyStore.setMasterKey(key);
  const gamma = randomBytes(MIN_GAMMA_SIZE);
  const alg = new AlgOfb(keyStore);
  alg.setGamma(gamma);
  const encrypted = alg.encrypt(plaintext);
  const finalCiphertext = new Uint8Array(encrypted.length + gamma.length);
  finalCiphertext.set(encrypted, 0);
  finalCiphertext.set(gamma, encrypted.length);
  return finalCiphertext;
}

export function kuznechikDecrypt(
  key: Uint8Array,
  ciphertext: Uint8Array,
): Uint8Array {
  const gamma = ciphertext.slice(ciphertext.length - MIN_GAMMA_SIZE);
  const actualCiphertext = ciphertext.slice(
    0,
    ciphertext.length - MIN_GAMMA_SIZE,
  );
  const keyStore = new KeyStore();
  keyStore.setMasterKey(key);
  const alg = new AlgOfb(keyStore);
  alg.setGamma(gamma);
  const plaintext = alg.decrypt(actualCiphertext);
  return plaintext;
}

```

`zil-pay/crypto/ntrup.ts`:

```ts
import type { ParamsConfig } from "@hicaru/ntrup.js";
import { ChaCha20Rng, ChaChaRng } from "@hicaru/chacharand.js";
import {
  bytesRqDecode,
  ErrorType,
  generateKeyPair,
  packBytes,
  params761,
  PrivKey,
  PubKey,
  R3,
  r3DecodeChunks,
  r3EncodeChunks,
  r3Encrypt,
  r3MergeWChunks,
  r3SplitWChunks,
  Rq,
  rqDecrypt,
  unpackBytes,
} from "@hicaru/ntrup.js";

import { randomBytes } from "../crypto/random";

export const NTRU_CONFIG = params761;

function bytesEncrypt(
  rng: ChaChaRng,
  plaintext: Uint8Array,
  pubKey: PubKey,
  params: ParamsConfig,
): Uint8Array {
  const unlimitedPoly = r3DecodeChunks(plaintext);
  const getU32 = () => rng.nextU32();
  const { chunks, size, seed } = r3SplitWChunks(unlimitedPoly, getU32, params);
  const encryptedBytes: Uint8Array[] = [];

  for (const chunk of chunks) {
    const r3 = R3.from(chunk, params);
    const hr = r3Encrypt(r3, pubKey, params);
    const rqBytes = hr.toBytes(params);
    encryptedBytes.push(rqBytes);
  }

  const totalLength = encryptedBytes.reduce((sum, arr) => sum + arr.length, 0);
  const dataBytes = new Uint8Array(totalLength);

  let offset = 0;

  for (const arr of encryptedBytes) {
    dataBytes.set(arr, offset);
    offset += arr.length;
  }

  return packBytes(dataBytes, size, seed);
}

function bytesDecrypt(
  cipher: Uint8Array,
  privKey: PrivKey,
  params: ParamsConfig,
): Uint8Array {
  const { dataBytes, size, seed } = unpackBytes(cipher);
  const chunkCount = Math.floor(dataBytes.length / params.RQ_BYTES);

  if (dataBytes.length % params.RQ_BYTES !== 0) {
    throw ErrorType.InvalidRqChunkSize;
  }

  const decryptedChunks: Int8Array[] = [];

  for (let i = 0; i < chunkCount; i++) {
    const start = i * params.RQ_BYTES;
    const end = start + params.RQ_BYTES;
    const chunkBytes = dataBytes.subarray(start, end);
    if (chunkBytes.length !== params.RQ_BYTES) {
      throw ErrorType.InvalidRqChunkSize;
    }
    const coeffs = bytesRqDecode(chunkBytes, params);
    const rq = Rq.from(coeffs, params);
    const r3 = rqDecrypt(rq, privKey, params);
    decryptedChunks.push(r3.coeffs);
  }

  const outR3 = r3MergeWChunks(decryptedChunks, size, seed, params);

  return r3EncodeChunks(outR3);
}

export function ntruKeysFromSeed(seedBytes: Uint8Array): {
  pk: PubKey;
  sk: PrivKey;
} {
  const seedPq = seedBytes.slice(0, 32);
  const pqRng = ChaCha20Rng(seedPq);

  return generateKeyPair(pqRng, NTRU_CONFIG);
}

export function ntruEncrypt(pk: PubKey, plaintext: Uint8Array) {
  const seed = randomBytes(32);
  const rng = ChaCha20Rng(seed);
  return bytesEncrypt(rng, plaintext, pk, NTRU_CONFIG);
}

export function ntruDecrypt(sk: PrivKey, ciphertext: Uint8Array) {
  return bytesDecrypt(ciphertext, sk, NTRU_CONFIG);
}

```

`zil-pay/crypto/number.ts`:

```ts
/**
 * Converts a Uint8Array to a bigint, assuming big-endian byte order.
 * In big-endian, the most significant byte is placed at the beginning of the array.
 * This format is commonly used in network protocols and cryptography.
 *
 * @param array - The Uint8Array to convert to a bigint.
 * @returns The bigint representation of the input Uint8Array.
 * @throws TypeError if the input parameter is not an instance of Uint8Array.
 */
export function uint8ArrayToBigIntBigEndian(array: Uint8Array): bigint {
  if (!(array instanceof Uint8Array)) {
    array = Uint8Array.from(array);
  }

  let result: bigint = 0n;
  for (const byte of array) {
    result = (result << 8n) | BigInt(byte);
  }
  return result;
}

/**
 * Converts a Uint8Array to a bigint, assuming little-endian byte order.
 * In little-endian, the least significant byte is placed at the beginning of the array.
 * This format is sometimes used for representing numbers in computer memory.
 *
 * @param array - The Uint8Array to convert to a bigint.
 * @returns The bigint representation of the input Uint8Array.
 * @throws TypeError if the input parameter is not an instance of Uint8Array.
 */
export function uint8ArrayToBigIntLittleEndian(array: Uint8Array): bigint {
  if (!(array instanceof Uint8Array)) {
    array = Uint8Array.from(array);
  }

  let result: bigint = 0n;
  for (let i = array.length - 1; i >= 0; i--) {
    result = (result << 8n) | BigInt(array[i]);
  }
  return result;
}

/**
 * Converts a bigint to a big-endian Uint8Array of specified length.
 * @param value - The bigint to convert.
 * @param length - The desired length of the output array.
 * @returns The Uint8Array representation of the bigint.
 */
export function bigIntToUint8ArrayBigEndian(
  value: bigint,
  length: number,
): Uint8Array {
  const hex = value.toString(16).padStart(length * 2, "0");
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    bytes[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
  }
  return bytes;
}

```

`zil-pay/crypto/pbkdf2.ts`:

```ts
import { ShaAlgorithms } from "../config/pbkdf2";

export async function pbkdf2(
  password: Uint8Array,
  salt: Uint8Array,
  iterations: number,
  algorithms = ShaAlgorithms.Sha512,
) {
  const passphraseKey = await globalThis.crypto.subtle.importKey(
    "raw",
    password,
    { name: "PBKDF2" },
    false,
    ["deriveBits", "deriveKey"],
  );
  const webKey = await globalThis.crypto.subtle.deriveKey(
    {
      salt,
      iterations,
      name: "PBKDF2",
      hash: algorithms,
    },
    passphraseKey,
    {
      name: "HMAC",
      hash: algorithms,
      length: 512,
    },
    true,
    ["sign", "verify"],
  );
  const hash = await globalThis.crypto.subtle.exportKey("raw", webKey);

  return new Uint8Array(hash);
}

```

`zil-pay/crypto/proto/zq1.ts`:

```ts
export interface ByteArray {
  data: Uint8Array;
}

export function encodeByteArray(message: ByteArray): Uint8Array {
  let bb = popByteBuffer();
  _encodeByteArray(message, bb);
  return toUint8Array(bb);
}

function _encodeByteArray(message: ByteArray, bb: ByteBuffer): void {
  // required bytes data = 1;
  let $data = message.data;
  if ($data !== undefined) {
    writeVarint32(bb, 10);
    writeVarint32(bb, $data.length), writeBytes(bb, $data);
  }
}

export function decodeByteArray(binary: Uint8Array): ByteArray {
  return _decodeByteArray(wrapByteBuffer(binary));
}

function _decodeByteArray(bb: ByteBuffer): ByteArray {
  let message: ByteArray = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required bytes data = 1;
      case 1: {
        message.data = readBytes(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.data === undefined)
    throw new Error("Missing required field: data");

  return message;
}

export interface ProtoTransactionCoreInfo {
  version?: number;
  nonce?: Long;
  toaddr?: Uint8Array;
  senderpubkey?: ByteArray;
  amount?: ByteArray;
  gasprice?: ByteArray;
  gaslimit?: Long;
  code?: Uint8Array;
  data?: Uint8Array;
}

export function encodeProtoTransactionCoreInfo(message: ProtoTransactionCoreInfo): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransactionCoreInfo(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransactionCoreInfo(message: ProtoTransactionCoreInfo, bb: ByteBuffer): void {
  // optional uint32 version = 1;
  let $version = message.version;
  if ($version !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32(bb, $version);
  }

  // optional uint64 nonce = 2;
  let $nonce = message.nonce;
  if ($nonce !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $nonce);
  }

  // optional bytes toaddr = 3;
  let $toaddr = message.toaddr;
  if ($toaddr !== undefined) {
    writeVarint32(bb, 26);
    writeVarint32(bb, $toaddr.length), writeBytes(bb, $toaddr);
  }

  // optional ByteArray senderpubkey = 4;
  let $senderpubkey = message.senderpubkey;
  if ($senderpubkey !== undefined) {
    writeVarint32(bb, 34);
    let nested = popByteBuffer();
    _encodeByteArray($senderpubkey, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ByteArray amount = 5;
  let $amount = message.amount;
  if ($amount !== undefined) {
    writeVarint32(bb, 42);
    let nested = popByteBuffer();
    _encodeByteArray($amount, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ByteArray gasprice = 6;
  let $gasprice = message.gasprice;
  if ($gasprice !== undefined) {
    writeVarint32(bb, 50);
    let nested = popByteBuffer();
    _encodeByteArray($gasprice, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional uint64 gaslimit = 7;
  let $gaslimit = message.gaslimit;
  if ($gaslimit !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, $gaslimit);
  }

  // optional bytes code = 8;
  let $code = message.code;
  if ($code !== undefined) {
    writeVarint32(bb, 66);
    writeVarint32(bb, $code.length), writeBytes(bb, $code);
  }

  // optional bytes data = 9;
  let $data = message.data;
  if ($data !== undefined) {
    writeVarint32(bb, 74);
    writeVarint32(bb, $data.length), writeBytes(bb, $data);
  }
}

export function decodeProtoTransactionCoreInfo(binary: Uint8Array): ProtoTransactionCoreInfo {
  return _decodeProtoTransactionCoreInfo(wrapByteBuffer(binary));
}

function _decodeProtoTransactionCoreInfo(bb: ByteBuffer): ProtoTransactionCoreInfo {
  let message: ProtoTransactionCoreInfo = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional uint32 version = 1;
      case 1: {
        message.version = readVarint32(bb) >>> 0;
        break;
      }

      // optional uint64 nonce = 2;
      case 2: {
        message.nonce = readVarint64(bb, /* unsigned */ true);
        break;
      }

      // optional bytes toaddr = 3;
      case 3: {
        message.toaddr = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional ByteArray senderpubkey = 4;
      case 4: {
        let limit = pushTemporaryLength(bb);
        message.senderpubkey = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      // optional ByteArray amount = 5;
      case 5: {
        let limit = pushTemporaryLength(bb);
        message.amount = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      // optional ByteArray gasprice = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        message.gasprice = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      // optional uint64 gaslimit = 7;
      case 7: {
        message.gaslimit = readVarint64(bb, /* unsigned */ true);
        break;
      }

      // optional bytes code = 8;
      case 8: {
        message.code = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional bytes data = 9;
      case 9: {
        message.data = readBytes(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface ProtoTransaction {
  tranid?: Uint8Array;
  info?: ProtoTransactionCoreInfo;
  signature?: ByteArray;
}

export function encodeProtoTransaction(message: ProtoTransaction): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransaction(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransaction(message: ProtoTransaction, bb: ByteBuffer): void {
  // optional bytes tranid = 1;
  let $tranid = message.tranid;
  if ($tranid !== undefined) {
    writeVarint32(bb, 10);
    writeVarint32(bb, $tranid.length), writeBytes(bb, $tranid);
  }

  // optional ProtoTransactionCoreInfo info = 2;
  let $info = message.info;
  if ($info !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodeProtoTransactionCoreInfo($info, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ByteArray signature = 3;
  let $signature = message.signature;
  if ($signature !== undefined) {
    writeVarint32(bb, 26);
    let nested = popByteBuffer();
    _encodeByteArray($signature, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }
}

export function decodeProtoTransaction(binary: Uint8Array): ProtoTransaction {
  return _decodeProtoTransaction(wrapByteBuffer(binary));
}

function _decodeProtoTransaction(bb: ByteBuffer): ProtoTransaction {
  let message: ProtoTransaction = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional bytes tranid = 1;
      case 1: {
        message.tranid = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional ProtoTransactionCoreInfo info = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.info = _decodeProtoTransactionCoreInfo(bb);
        bb.limit = limit;
        break;
      }

      // optional ByteArray signature = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        message.signature = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface ProtoTransactionReceipt {
  receipt?: Uint8Array;
  cumgas?: Long;
}

export function encodeProtoTransactionReceipt(message: ProtoTransactionReceipt): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransactionReceipt(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransactionReceipt(message: ProtoTransactionReceipt, bb: ByteBuffer): void {
  // optional bytes receipt = 1;
  let $receipt = message.receipt;
  if ($receipt !== undefined) {
    writeVarint32(bb, 10);
    writeVarint32(bb, $receipt.length), writeBytes(bb, $receipt);
  }

  // optional uint64 cumgas = 2;
  let $cumgas = message.cumgas;
  if ($cumgas !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $cumgas);
  }
}

export function decodeProtoTransactionReceipt(binary: Uint8Array): ProtoTransactionReceipt {
  return _decodeProtoTransactionReceipt(wrapByteBuffer(binary));
}

function _decodeProtoTransactionReceipt(bb: ByteBuffer): ProtoTransactionReceipt {
  let message: ProtoTransactionReceipt = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional bytes receipt = 1;
      case 1: {
        message.receipt = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional uint64 cumgas = 2;
      case 2: {
        message.cumgas = readVarint64(bb, /* unsigned */ true);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface ProtoTransactionWithReceipt {
  transaction?: ProtoTransaction;
  receipt?: ProtoTransactionReceipt;
}

export function encodeProtoTransactionWithReceipt(message: ProtoTransactionWithReceipt): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransactionWithReceipt(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransactionWithReceipt(message: ProtoTransactionWithReceipt, bb: ByteBuffer): void {
  // optional ProtoTransaction transaction = 1;
  let $transaction = message.transaction;
  if ($transaction !== undefined) {
    writeVarint32(bb, 10);
    let nested = popByteBuffer();
    _encodeProtoTransaction($transaction, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ProtoTransactionReceipt receipt = 2;
  let $receipt = message.receipt;
  if ($receipt !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodeProtoTransactionReceipt($receipt, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }
}

export function decodeProtoTransactionWithReceipt(binary: Uint8Array): ProtoTransactionWithReceipt {
  return _decodeProtoTransactionWithReceipt(wrapByteBuffer(binary));
}

function _decodeProtoTransactionWithReceipt(bb: ByteBuffer): ProtoTransactionWithReceipt {
  let message: ProtoTransactionWithReceipt = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional ProtoTransaction transaction = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        message.transaction = _decodeProtoTransaction(bb);
        bb.limit = limit;
        break;
      }

      // optional ProtoTransactionReceipt receipt = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.receipt = _decodeProtoTransactionReceipt(bb);
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface Long {
  low: number;
  high: number;
  unsigned: boolean;
}

interface ByteBuffer {
  bytes: Uint8Array;
  offset: number;
  limit: number;
}

function pushTemporaryLength(bb: ByteBuffer): number {
  let length = readVarint32(bb);
  let limit = bb.limit;
  bb.limit = bb.offset + length;
  return limit;
}

function skipUnknownField(bb: ByteBuffer, type: number): void {
  switch (type) {
    case 0: while (readByte(bb) & 0x80) { } break;
    case 2: skip(bb, readVarint32(bb)); break;
    case 5: skip(bb, 4); break;
    case 1: skip(bb, 8); break;
    default: throw new Error("Unimplemented type: " + type);
  }
}

// The code below was modified from https://github.com/protobufjs/bytebuffer.js
// which is under the Apache License 2.0.

let bbStack: ByteBuffer[] = [];

function popByteBuffer(): ByteBuffer {
  const bb = bbStack.pop();
  if (!bb) return { bytes: new Uint8Array(64), offset: 0, limit: 0 };
  bb.offset = bb.limit = 0;
  return bb;
}

function pushByteBuffer(bb: ByteBuffer): void {
  bbStack.push(bb);
}

function wrapByteBuffer(bytes: Uint8Array): ByteBuffer {
  return { bytes, offset: 0, limit: bytes.length };
}

function toUint8Array(bb: ByteBuffer): Uint8Array {
  let bytes = bb.bytes;
  let limit = bb.limit;
  return bytes.length === limit ? bytes : bytes.subarray(0, limit);
}

function skip(bb: ByteBuffer, offset: number): void {
  if (bb.offset + offset > bb.limit) {
    throw new Error('Skip past limit');
  }
  bb.offset += offset;
}

function isAtEnd(bb: ByteBuffer): boolean {
  return bb.offset >= bb.limit;
}

function grow(bb: ByteBuffer, count: number): number {
  let bytes = bb.bytes;
  let offset = bb.offset;
  let limit = bb.limit;
  let finalOffset = offset + count;
  if (finalOffset > bytes.length) {
    let newBytes = new Uint8Array(finalOffset * 2);
    newBytes.set(bytes);
    bb.bytes = newBytes;
  }
  bb.offset = finalOffset;
  if (finalOffset > limit) {
    bb.limit = finalOffset;
  }
  return offset;
}

function advance(bb: ByteBuffer, count: number): number {
  let offset = bb.offset;
  if (offset + count > bb.limit) {
    throw new Error('Read past limit');
  }
  bb.offset += count;
  return offset;
}

function readBytes(bb: ByteBuffer, count: number): Uint8Array {
  let offset = advance(bb, count);
  return bb.bytes.subarray(offset, offset + count);
}

function writeBytes(bb: ByteBuffer, buffer: Uint8Array): void {
  let offset = grow(bb, buffer.length);
  bb.bytes.set(buffer, offset);
}



function writeByteBuffer(bb: ByteBuffer, buffer: ByteBuffer): void {
  let offset = grow(bb, buffer.limit);
  let from = bb.bytes;
  let to = buffer.bytes;

  // This for loop is much faster than subarray+set on V8
  for (let i = 0, n = buffer.limit; i < n; i++) {
    from[i + offset] = to[i];
  }
}

function readByte(bb: ByteBuffer): number {
  return bb.bytes[advance(bb, 1)];
}

function writeByte(bb: ByteBuffer, value: number): void {
  let offset = grow(bb, 1);
  bb.bytes[offset] = value;
}
function readVarint32(bb: ByteBuffer): number {
  let c = 0;
  let value = 0;
  let b: number;
  do {
    b = readByte(bb);
    if (c < 32) value |= (b & 0x7F) << c;
    c += 7;
  } while (b & 0x80);
  return value;
}

function writeVarint32(bb: ByteBuffer, value: number): void {
  value >>>= 0;
  while (value >= 0x80) {
    writeByte(bb, (value & 0x7f) | 0x80);
    value >>>= 7;
  }
  writeByte(bb, value);
}

function readVarint64(bb: ByteBuffer, unsigned: boolean): Long {
  let part0 = 0;
  let part1 = 0;
  let part2 = 0;
  let b: number;

  b = readByte(bb); part0 = (b & 0x7F); if (b & 0x80) {
    b = readByte(bb); part0 |= (b & 0x7F) << 7; if (b & 0x80) {
      b = readByte(bb); part0 |= (b & 0x7F) << 14; if (b & 0x80) {
        b = readByte(bb); part0 |= (b & 0x7F) << 21; if (b & 0x80) {

          b = readByte(bb); part1 = (b & 0x7F); if (b & 0x80) {
            b = readByte(bb); part1 |= (b & 0x7F) << 7; if (b & 0x80) {
              b = readByte(bb); part1 |= (b & 0x7F) << 14; if (b & 0x80) {
                b = readByte(bb); part1 |= (b & 0x7F) << 21; if (b & 0x80) {

                  b = readByte(bb); part2 = (b & 0x7F); if (b & 0x80) {
                    b = readByte(bb); part2 |= (b & 0x7F) << 7;
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return {
    low: part0 | (part1 << 28),
    high: (part1 >>> 4) | (part2 << 24),
    unsigned,
  };
}

function writeVarint64(bb: ByteBuffer, value: Long): void {
  let part0 = value.low >>> 0;
  let part1 = ((value.low >>> 28) | (value.high << 4)) >>> 0;
  let part2 = value.high >>> 24;

  let size =
    part2 === 0 ?
      part1 === 0 ?
        part0 < 1 << 14 ?
          part0 < 1 << 7 ? 1 : 2 :
          part0 < 1 << 21 ? 3 : 4 :
        part1 < 1 << 14 ?
          part1 < 1 << 7 ? 5 : 6 :
          part1 < 1 << 21 ? 7 : 8 :
      part2 < 1 << 7 ? 9 : 10;

  let offset = grow(bb, size);
  let bytes = bb.bytes;

  switch (size) {
    case 10: bytes[offset + 9] = (part2 >>> 7) & 0x01;
    case 9: bytes[offset + 8] = size !== 9 ? part2 | 0x80 : part2 & 0x7F;
    case 8: bytes[offset + 7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
    case 7: bytes[offset + 6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
    case 6: bytes[offset + 5] = size !== 6 ? (part1 >>> 7) | 0x80 : (part1 >>> 7) & 0x7F;
    case 5: bytes[offset + 4] = size !== 5 ? part1 | 0x80 : part1 & 0x7F;
    case 4: bytes[offset + 3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
    case 3: bytes[offset + 2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
    case 2: bytes[offset + 1] = size !== 2 ? (part0 >>> 7) | 0x80 : (part0 >>> 7) & 0x7F;
    case 1: bytes[offset] = size !== 1 ? part0 | 0x80 : part0 & 0x7F;
  }
}

```

`zil-pay/crypto/random.ts`:

```ts
import { ChaCha20Rng } from "@hicaru/chacharand.js";

export function randomBytes(length: number): Uint8Array {
  const buffer = new Uint8Array(length);
  const randomSeed = new Uint8Array(32);

  globalThis.crypto.getRandomValues(randomSeed);

  const rng = ChaCha20Rng(randomSeed);

  rng.fillBytes(buffer);

  return buffer;
}

```

`zil-pay/crypto/sha256.ts`:

```ts
import { ShaAlgorithms } from "config/pbkdf2";

export async function sha256(value: Uint8Array) {
  if (!(value instanceof Uint8Array)) {
    value = Uint8Array.from(value);
  }

  const crypto = globalThis.crypto;
  const hash = await crypto.subtle.digest(ShaAlgorithms.sha256, value);
  return new Uint8Array(hash);
}

```

`zil-pay/crypto/sha512.ts`:

```ts
import { ShaAlgorithms } from "../config/pbkdf2";

export async function sha512(value: Uint8Array): Promise<Uint8Array> {
  const crypto = globalThis.crypto;
  const hash = await crypto.subtle.digest(ShaAlgorithms.Sha512, value);

  return new Uint8Array(hash);
}

```

`zil-pay/crypto/tx.ts`:

```ts
import type { TxType } from "micro-eth-signer/esm/tx";
import { ZILTransactionRequest, ZILTransactionReceipt } from "./zilliqa_tx";
import { Transaction } from "micro-eth-signer";
import { KeyPair } from "./keypair";
import { randomBytes } from "./random";
import { convertBigIntsToHex } from "lib/utils/hex";

export interface TransactionMetadata {
  chainHash: number;
  hash?: string;
  info?: string;
  icon?: string;
  title?: string;
  signer?: string;
  tokenInfo?: [string, number, string];
}

export class TransactionRequest {
  constructor(
    public metadata: TransactionMetadata,
    public scilla?: ZILTransactionRequest,
    public evm?: Transaction<TxType>,
  ) {}

  async sign(keypair: KeyPair) {
    if (this.scilla) {
      const receipt = await this.scilla.sign(keypair);

      return new TransactionReceipt(this.metadata, receipt);
    } else if (this.evm) {
      const entropy = randomBytes(128);
      const receipt = this.evm.signBy(keypair.privateKey, entropy);

      return new TransactionReceipt(this.metadata, undefined, receipt);
    }

    throw new Error("Invlid tx type");
  }

  toJSON() {
    if (this.scilla) {
      return this.scilla.toJSON();
    } else if (this.evm) {
      return convertBigIntsToHex(this.evm.raw);
    }

    throw new Error("Invlid tx type");
  }
}

export class TransactionReceipt {
  constructor(
    public metadata: TransactionMetadata,
    public scilla?: ZILTransactionReceipt,
    public evm?: Transaction<TxType>,
  ) {}

  async verify() {
    if (this.scilla) {
      return this.scilla.verify();
    } else if (this.evm) {
      return this.evm.verifySignature();
    }

    throw new Error("Invlid tx type");
  }
}

```

`zil-pay/crypto/uuid.ts`:

```ts
import { randomBytes } from "./random";

/**
 * Generates a version 4 UUID.
 * Uses the native `crypto.randomUUID` if available, otherwise falls back to a
 * custom implementation using the `randomBytes` function.
 * @returns A UUID string.
 */
export function uuid(): string {
  if (globalThis.crypto.randomUUID) {
    return globalThis.crypto.randomUUID();
  }

  const bytes = randomBytes(16);

  bytes[6] = (bytes[6] & 0x0f) | 0x40;
  bytes[8] = (bytes[8] & 0x3f) | 0x80;
  const hex = Array.from(bytes, (byte) =>
    byte.toString(16).padStart(2, "0"),
  ).join("");

  return `${hex.substring(0, 8)}-${hex.substring(8, 12)}-${hex.substring(12, 16)}-${hex.substring(16, 20)}-${hex.substring(20)}`;
}

```

`zil-pay/crypto/zilliqa/pubkey.ts`:

```ts
import { getPublicKey } from '@noble/secp256k1';

export function fromZILPrivateKey(privateKey: Uint8Array): Uint8Array {
  const publicKey = getPublicKey(Uint8Array.from(privateKey), true);
  return publicKey;
}


```

`zil-pay/crypto/zilliqa/schnorr.ts`:

```ts
import { Signature } from '@noble/secp256k1';
import { ProjectivePoint } from '@noble/secp256k1';
import { CURVE } from '@noble/secp256k1';
import { randomBytes } from '../random';
import { sha256 } from '../sha256';
import { uint8ArrayToBigIntBigEndian } from '../number';
import { fromZILPrivateKey } from './pubkey';

const MAX_TRY_SIGN = 100_000_000;

export async function sign(message: Uint8Array, secretKey: Uint8Array): Promise<Signature> {
  let safeCounter = 0;

  while (safeCounter < MAX_TRY_SIGN) {
    const kBytes = randomBytes(32);
    const k = uint8ArrayToBigIntBigEndian(kBytes) % CURVE.n;

    const signature = await signInner(k, message, secretKey);
    if (signature) {
      return signature;
    }

    safeCounter++;
  }

  throw new Error('InvalidSignTry: Exceeded maximum signing attempts');
}

export async function signInner(k: bigint, message: Uint8Array, secretKey: Uint8Array): Promise<Signature | null> {
  const publicKey = fromZILPrivateKey(secretKey);

  const QPoint = ProjectivePoint.BASE.multiply(k);
  const Q = QPoint.toRawBytes(true);

  const hasherInput = new Uint8Array([...Q, ...publicKey, ...message]);
  const hash = await sha256(hasherInput);
  const r = uint8ArrayToBigIntBigEndian(hash) % CURVE.n;

  if (r === 0n) {
    return null;
  }

  const secretKeyScalar = uint8ArrayToBigIntBigEndian(secretKey);
  const rTimesSecret = (r * secretKeyScalar) % CURVE.n;
  const s = (k - rTimesSecret + CURVE.n) % CURVE.n;

  if (s === 0n) {
    return null;
  }

  return new Signature(r, s);
}

export async function verify(
  message: Uint8Array,
  publicKey: Uint8Array,
  signature: Signature
): Promise<boolean> {
  const r = signature.r;
  const s = signature.s;

  const sG = ProjectivePoint.BASE.multiply(s);
  const publicKeyPoint = ProjectivePoint.fromHex(Uint8Array.from(publicKey));
  const rPub = publicKeyPoint.multiply(r);
  const QPoint = sG.add(rPub);
  const Q = QPoint.toRawBytes(true);

  if (QPoint.equals(ProjectivePoint.ZERO)) {
    return false;
  }

  const hasherInput = new Uint8Array([...Q, ...publicKey, ...message]);
  const hash = await sha256(hasherInput);
  const rDash = uint8ArrayToBigIntBigEndian(hash) % CURVE.n;

  return rDash === r;
}


```

`zil-pay/crypto/zilliqa_tx.ts`:

```ts
import { Signature } from "@noble/secp256k1";
import type { KeyPair } from "./keypair";
import {
  bigIntToUint8ArrayBigEndian,
  uint8ArrayToBigIntBigEndian,
} from "./number";
import {
  encodeProtoTransactionCoreInfo,
  type Long,
  type ProtoTransactionCoreInfo,
} from "./proto/zq1";
import { verify } from "./zilliqa/schnorr";
import { uint8ArrayToHex } from "lib/utils/hex";
import { uint8ArrayToUtf8 } from "lib/utils/utf8";
import { Address, AddressType } from "./address";

const U128LEN = 16;

export function bigintToLong(value: bigint): Long {
  const low = Number(value & 0xffffffffn);
  const high = Number((value >> 32n) & 0xffffffffn);
  return { low, high, unsigned: true };
}

export function versionFromChainId(chainId: number): number {
  return (chainId << 16) | 1;
}

export function chainIdFromVersion(version: number): number {
  return (version >> 16) & 0xffff;
}

export class ZILTransactionRequest {
  constructor(
    public chainId: number,
    public nonce: bigint,
    public gasPrice: bigint,
    public gasLimit: bigint,
    public toAddr: Uint8Array,
    public amount: bigint,
    public code: Uint8Array = new Uint8Array(),
    public data: Uint8Array = new Uint8Array(),
  ) {}

  toProto(pubKey: Uint8Array): ProtoTransactionCoreInfo {
    return {
      version: versionFromChainId(this.chainId),
      nonce: bigintToLong(this.nonce),
      toaddr: this.toAddr,
      senderpubkey: { data: pubKey },
      amount: { data: bigIntToUint8ArrayBigEndian(this.amount, U128LEN) },
      gasprice: { data: bigIntToUint8ArrayBigEndian(this.gasPrice, U128LEN) },
      gaslimit: bigintToLong(this.gasLimit),
      code: this.code.length > 0 ? this.code : undefined,
      data: this.data.length > 0 ? this.data : undefined,
    };
  }

  encode(pubKey: Uint8Array): Uint8Array {
    const proto = this.toProto(pubKey);
    return encodeProtoTransactionCoreInfo(proto);
  }

  async sign(keypair: KeyPair) {
    const proto = this.toProto(keypair.pubKey);
    const bytes = encodeProtoTransactionCoreInfo(proto);
    const sig = await keypair.signMessage(bytes);

    return new ZILTransactionReceipt(
      proto.version ?? versionFromChainId(this.chainId),
      this.nonce,
      bigIntToUint8ArrayBigEndian(this.gasPrice, U128LEN),
      this.gasLimit,
      this.toAddr,
      bigIntToUint8ArrayBigEndian(this.amount, U128LEN),
      keypair.pubKey,
      this.code,
      this.data,
      sig,
      false,
    );
  }

  toJSON() {
    return {
      chainId: this.chainId,
      nonce: this.nonce.toString(),
      toAddr: uint8ArrayToHex(this.toAddr),
      amount: this.amount.toString(),
      gasPrice: this.gasPrice.toString(),
      gasLimit: this.gasLimit.toString(),
      code: this.code.length > 0 ? uint8ArrayToUtf8(this.code) : "",
      data: this.data.length > 0 ? uint8ArrayToUtf8(this.data) : "",
    };
  }
}

export class ZILTransactionReceipt {
  constructor(
    public version: number,
    public nonce: bigint,
    public gasPrice: Uint8Array,
    public gasLimit: bigint,
    public toAddr: Uint8Array,
    public amount: Uint8Array,
    public pubKey: Uint8Array,
    public code: Uint8Array,
    public data: Uint8Array,
    public signature: Uint8Array,
    public priority: boolean,
  ) {}

  toProto(): ProtoTransactionCoreInfo {
    return {
      version: this.version,
      nonce: bigintToLong(this.nonce),
      toaddr: this.toAddr,
      senderpubkey: { data: this.pubKey },
      amount: { data: this.amount },
      gasprice: { data: this.gasPrice },
      gaslimit: bigintToLong(this.gasLimit),
      code: this.code.length > 0 ? this.code : undefined,
      data: this.data.length > 0 ? this.data : undefined,
    };
  }

  async verify(): Promise<boolean> {
    const proto = this.toProto();
    const bytes = encodeProtoTransactionCoreInfo(proto);
    const signature = Signature.fromBytes(this.signature);

    return verify(bytes, this.pubKey, signature);
  }

  async toJSON() {
    return {
      version: this.version,
      nonce: Number(this.nonce),
      toAddr: await new Address(
        this.toAddr,
        AddressType.Bech32,
      ).toZilChecksum(),
      amount: uint8ArrayToBigIntBigEndian(this.amount).toString(),
      pubKey: uint8ArrayToHex(this.pubKey),
      gasPrice: uint8ArrayToBigIntBigEndian(this.gasPrice).toString(),
      gasLimit: this.gasLimit.toString(),
      code: this.code.length > 0 ? uint8ArrayToUtf8(this.code) : "",
      data: this.data.length > 0 ? uint8ArrayToUtf8(this.data) : "",
      signature: uint8ArrayToHex(this.signature),
      priority: this.priority,
    };
  }
}

```

`zil-pay/lib/array/chunk.ts`:

```ts
/**
 * Splits an array into chunks of a specified size.
 * @template T - The type of elements in the input array.
 * @param array - The input array to be chunked.
 * @param size - The size of each chunk (must be greater than 0).
 * @returns A new array containing the chunks.
 * @throws {Error} If the size is not a positive number.
 */
export function chunk<T>(array: T[], size: number): T[][] {
    if (size <= 0) {
        throw new Error("Size must be a positive number.");
    }

    const result: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
        result.push(array.slice(i, i + size));
    }
    return result;
}


```

`zil-pay/lib/array/shuffle.ts`:

```ts
/**
 * Shuffles the elements of an array in place using the Fisher-Yates algorithm.
 * @template T - The type of elements in the array.
 * @param array - The array to shuffle.
 */
export function shuffle<T>(array: T[]): T[] {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}


```

`zil-pay/lib/popup/clipboard.ts`:

```ts
/**
 * Asynchronously copies the provided text to the user's clipboard using the modern
 * `navigator.clipboard` API. If the modern API is not available, it attempts
 * to use the deprecated `document.execCommand('copy')` as a fallback.
 *
 * @param text The string to be copied to the clipboard.
 * @returns A Promise that resolves to `true` if the copy operation was successful,
 * or `false` if it failed (e.g., due to browser limitations or user denial of permissions).
 */
export async function clipboardCopy(text: string): Promise<boolean> {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (_) {
      return fallbackCopyToClipboard(text);
    }
  } else {
    // Fallback for browsers that do not support the modern Clipboard API.
    return fallbackCopyToClipboard(text);
  }
}

/**
 * Attempts to copy text to the clipboard using the deprecated `document.execCommand('copy')` method.
 * This method is less reliable and may require user interaction or specific browser permissions.
 *
 * @param text The string to be copied to the clipboard.
 * @returns `true` if the copy command was successful, `false` otherwise.
 */
function fallbackCopyToClipboard(text: string): boolean {
  try {
    const span = document.createElement('span');
    span.textContent = text;
    span.style.whiteSpace = 'pre';
    span.style.userSelect = 'all';
    document.body.appendChild(span);
    const selection = window.getSelection();
    const range = window.document.createRange();
    selection?.removeAllRanges();
    range.selectNode(span);
    selection?.addRange(range);
    const successful = window.document.execCommand('copy');
    selection?.removeAllRanges();
    document.body.removeChild(span);
    return successful;
  } catch (err) {
    console.error('Failed to copy text using document.execCommand:', err);
    return false;
  }
}

```

`zil-pay/lib/popup/url.ts`:

```ts
import type { IExplorerState, IChainConfigState, IFTokenState } from "background/storage";
import { Themes } from "config/theme";

function selectVariant(theme: Themes, options: string[]): string {
  if (options.length === 0) return '';
  if (theme === Themes.Light) return options[0];
  if (theme === Themes.Dark && options.length >= 2) return options[1];
  return options[0];
}

function processUrlTemplate({
  template,
  theme,
  replacements = {},
}: {
  template: string;
  theme: Themes;
  replacements?: Record<string, string>;
}): string {
  if (!template.includes('%{')) return template;

  let processed = template;

  const funcRegex = /%\{(\w+)\(([^)]+)\)\}%/g;
  processed = processed.replace(funcRegex, (_match, _, optionsStr) => {
    const options = optionsStr.split(',').map((s: string) => s.trim());
    return selectVariant(theme, options);
  });

  if (processed.includes('%{dark,light}%')) {
    processed = processed.replace(/%\{dark,light\}%/g, theme === Themes.Dark ? 'light' : 'dark');
  }

  for (const [key, value] of Object.entries(replacements)) {
    processed = processed.replace(new RegExp(`%{${key}}%`, 'g'), value);
  }

  return processed;
}

export function processTokenLogo({
  token,
  shortName,
  theme,
}: {
  token: IFTokenState;
  shortName: string;
  theme: Themes;
}): string {
  if (!token.logo) return 'assets/icons/warning.svg';

  const replacements = {
    'symbol': token.symbol.toLowerCase(),
    'contract_address': token.addr.toLowerCase(),
    'name': token.name,
    'shortName': shortName,
  };

  return processUrlTemplate({
    template: token.logo,
    theme: theme,
    replacements: replacements,
  });
}

export function formExplorerUrl(explorer: IExplorerState, transactionHash: string): string {
  const baseUrl = explorer.url.endsWith('/')
    ? explorer.url.substring(0, explorer.url.length - 1)
    : explorer.url;

  return `${baseUrl}/tx/${transactionHash}`;
}

export function viewChain({
  network,
  theme,
}: {
  network: IChainConfigState;
  theme: Themes;
}): string {
  const defaultIcon = 'assets/icons/default_chain.svg';

  if (!network.logo) return defaultIcon;

  const replacements = {
    'shortName': network.shortName.toLowerCase(),
  };

  return processUrlTemplate({
    template: network.logo,
    theme: theme,
    replacements: replacements,
  });
}

```

`zil-pay/lib/popup/warp-message.ts`:

```ts
export type Params = object[] | string[] | number[] | (string | string[] | number[])[];

export interface SendResponseParams {
  resolve?: unknown;
  reject?: unknown;
}
export type StreamResponse = (params: SendResponseParams) => void;

export interface ProxyContentType {
  params: Params;
  method: string;
  uuid: string;
}

export function warpMessage<T>(msg: SendResponseParams): T | undefined {
  if (!msg) {
    return;
  }

  if (msg.reject) {
    throw new Error(String(msg.reject));
  }

  return msg.resolve as T;
}

```

`zil-pay/lib/runtime/assert.ts`:

```ts
export function assert(expressions: boolean, msg: string) {
  if (!expressions) {
    throw new Error(msg);
  }
}

```

`zil-pay/lib/runtime/ext-id.ts`:

```ts
import { Runtime } from "./extensionizer";

export const EXTENSION_ID = Runtime.runtime.id;

```

`zil-pay/lib/runtime/extensionizer.ts`:

```ts
export const Runtime = globalThis.chrome;

```

`zil-pay/lib/runtime/fingerprint.ts`:

```ts
import { utils } from 'aes-js';
import { EXTENSION_ID, Runtime } from './';

export async function generateSalt(): Promise<Uint8Array> {
  let salt = EXTENSION_ID;

  try {
    const dynamicId = await Runtime.runtime.getPlatformInfo();
    salt += `${dynamicId.arch}:${dynamicId.nacl_arch}:${dynamicId.os}`;
  } catch {
    //
  }

  return utils.utf8.toBytes(salt);
}

```

`zil-pay/lib/runtime/get-url.ts`:

```ts
import { Runtime } from "./extensionizer";

export function getExtensionURL(content: string) {
  return Runtime.runtime.getURL(content);
}


```

`zil-pay/lib/runtime/index.ts`:

```ts
export * from './assert';
export * from './ext-id';
export * from './extensionizer';
export * from './manifest';
export * from './get-url';
export * from './fingerprint';


```

`zil-pay/lib/runtime/manifest.ts`:

```ts
import { Runtime } from './extensionizer';

export function getManifestVersion() {
  return Runtime.runtime.getManifest().manifest_version;
}

```

`zil-pay/lib/storage/builder.ts`:

```ts
import type { OldFields } from 'config/fields';
import { TypeOf } from '../types/checker';

export type StorageKeyValue = Record<string, unknown>;

export function buildObject(key: OldFields | string, value: string | object | any[]): StorageKeyValue { 
    let data: string;

    if (TypeOf.isObject(value) || TypeOf.isArray(value)) {
        try {
            data = JSON.stringify(value);
        } catch (error) {
            console.error('Error serializing value to JSON:', error);
            return { [key]: '' };
        }
    } else {
        data = String(value);
    }

    return {
        [key]: data,
    };
}


```

`zil-pay/lib/storage/index.ts`:

```ts
export * from './builder';
export * from './storage';

```

`zil-pay/lib/storage/storage.ts`:

```ts
import type { StorageKeyValue } from './builder';
import type { OldFields } from 'config/fields';
import { Runtime } from 'lib/runtime/extensionizer';

type StorageChangesCallback = { [key: string]: chrome.storage.StorageChange; };

export const BrowserStorage = Object.freeze({
    subscribe(callback: (changes: StorageChangesCallback) => void) {
        const listener = (changes: StorageChangesCallback) => {
            try {
                callback(changes);
            } catch (error) {
                console.error("Error in storage change callback:", error);
            }
        };

        Runtime.storage.onChanged.addListener(listener);

        return {
            unsubscribe() {
                Runtime.storage.onChanged.removeListener(listener);
            },
        };
    },

    async set(...items: StorageKeyValue[]): Promise<void> {
        if (items.length === 0) return;

        const data: StorageKeyValue = {};
        for (const item of items) {
            Object.assign(data, item);
        }

        await Runtime.storage.local.set(data);
    },

    async get<T>(...keys: (OldFields | string)[]): Promise<T> { 
        const result = await Runtime.storage.local.get(keys);

        if (keys.length === 1 && result) {
            return result[keys[0]];
        }
        
        return result as T;
    },

    async getAll<T>(): Promise<T> {
        return Runtime.storage.local.get(null);
    },

    async rm(...keys: (OldFields | string)[]): Promise<void> {
        await Runtime.storage.local.remove(keys);
    },

    async clear(): Promise<void> {
        await Runtime.storage.local.clear();
    },
});

```

`zil-pay/lib/streem/index.ts`:

```ts
export * from './keys';
export * from './secure-message';

export interface SendResponseParams {
  resolve?: unknown;
  reject?: unknown;
}
export type StreamResponse = (params: SendResponseParams) => void;

```

`zil-pay/lib/streem/keys.ts`:

```ts
const app = 'zil-pay';

export const MTypeTabContent = {
  CONTENT: `@/${app}/content-script`,
  INJECTED: `@/${app}/injected-script`
};

export const MTypePopupWallet = {
  GET_RANDOM_SEED: `@/${app}/generate-random-seed`,
  CREATE_ACCOUNT_BY_SEED: `@/${app}/set-account-by-seed-words`,
  SET_PASSWORD: `@/${app}/popup-set-password`,
  LOG_OUT: `@/${app}/popup-logout`,
  SET_SEED_AND_PASSWORD: `@/${app}/popup-set-seed-words-and-password`,
  WALET_PASSWORD_CHANGE: `@/${app}/change-password`,
  GET_WALLET_STATE: `@/${app}/get-wallet-state`,
  EXPORT_SEED: `@/${app}/popup-export-seed-words`,
  EXPORT_PRIVATE_KEY: `@/${app}/popup-export-private-key`,
  EXPORT_QR_CODE_WALLET: `@/${app}/export-qr-code-wallet`,
  IMPORT_PRIVATE_KEY: `@/${app}/popup-import-private-key`,
  IMPORT_TRACK_ACCOUNT: `@/${app}/popup-import-track-account`,
  IMPORT_KEYSTORE: `@/${app}/popup-import-keystore`,
  ENCRYPT_WALLET: `@/${app}/encrypt-wallet-aes`,
  RES_ENCRYPTION: `@/${app}/response-encryption`,
  RES_DECRYPTION: `@/${app}/response-decryption`,
};

export const MTypePopupAccount = {
  RM_ACCOUNT: `@/${app}/remove-selected-account`,
  SELECT_ACCOUNT: `@/${app}/select-account`,
  SET_ACCOUNT_NAME: `@/${app}/set-account-name`,
  UPDATE_BALANCE: `@/${app}/popup-account-balance-upadte`,
};

export const MTypePopupTransaction = {
  UPDATE_TXNS: `@/${app}/check-processed-txns`,
  REJECT_CONFIRM_TX: `@/${app}/popup-reject-confirm-tx`,
  REJECT_ALL_CONFIRM_TXNS: `@/${app}/popup-reject-al-confirm-txns`,
  SEND_TO_SIGN_TX: `@/${app}/popup-send-to-sign-tx`,
  GET_REQUIRED_PARAMS: `@/${app}/get-required-params`,
  CLEAR_ALL_TXNS: `@/${app}/clear-all-txns`,
  GET_CURRENT_NONCE: `@/${app}/get-current-nonce`,
  RESET_NONCE: `@/${app}/reset-nonce`,
};

export const MTypePopupToken = {
  GET_ZRC2_STATE: `@/${app}/get-zrc2-token-info`,
  ADD_ZRC2_TOKEN: `@/${app}/add-new-zrc2-token`,
  RM_TOKEN: `@/${app}/remove-token`,
  GET_ZRC2_ALLOWANCES_FOR_SWAP: `@/${app}/get-zrc2-allowances-for-swap`,
};

export const MTypePopupNFT = {
  UPDATE_NFT_LIST: `@/${app}/update-nft-list`,
  GET_NFT_LIST: `@/${app}/get-nft-list`,
  FETCH_NFT: `@/${app}/fetch-nft`,
  ADD_NFT: `@/${app}/add-nft`,
  REMOVE_NFT: `@/${app}/remove-nft`,
};

export const MTypePopupNetwork = {
  SELECT_SSN: `@/${app}/select-from-ssn-list`,
  RESET_NETWROK: `@/${app}/reset-netwrok-settings`,
  SET_NET_CONFIG: `@/${app}/set-netwrok-config`,
  SELECT_NETWORK: `@/${app}/select-network`,
  UPDATE_SSN_LIST: `@/${app}/update-ssn-list`,
  GET_LATEST_BLOCK: `@/${app}/get-latest-block-number`,
};

export const MTypePopupDApp = {
  USER_RESPONSE_DAPP: `@/${app}/user-response-connect-dapp`,
  RM_APP: `@/${app}/remove-dapp`,
  CLEAR_APPS: `@/${app}/clear-all-apps`,
  SET_PHISHING_DETECTION: `@/${app}/set-phishing-detection`,
};

export const MTypePopupContact = {
  ADD_CONTACT: `@/${app}/add-a-contact`,
  RM_CONTACT: `@/${app}/remove-a-contact`,
};

export const MTypePopupSettings = {
  CHANGE_CURRENCY: `@/${app}/change-currency`,
  UPDATE_RATE: `@/${app}/update-rate`,
  RESET_CURRENCY: `@/${app}/reset-currency`,
  SET_THEME: `@/${app}/set-theme-mode`,
  RESET_THEME: `@/${app}/reset-theme`,
  SET_LOCALE: `@/${app}/set-locale`,
  RESET_LOCALE: `@/${app}/reset-locale`,
  SET_GAS_MULTIPLIER: `@/${app}/set-gas-multiplier`,
  RESET_GAS: `@/${app}/reset-gas`,
  SET_LOCK_TIME: `@/${app}/set-lock-timer`,
  SET_ADDRESS_FORMAT: `@/${app}/set-address-format`,
  SET_PROMT_ENABLED: `@/${app}/set-promt-enabled`,
};

export const MTypePopupSign = {
  REJECT_SIGN_MESSAGE: `@/${app}/reject-sign-message`,
  SIGN_MESSAGE_APPROVE: `@/${app}/approve-sign-message`,
};

export const MTypePopupUtil = {
  FROM_BECH32: `@/${app}/convert-from-bech32`,
};

export const MTypePopupDex = {
  UPDATE_DEX_DATA: `@/${app}/update-dex-data`,
  UPDATE_DEX_SETTINGS: `@/${app}/update-dex-settings`,
};

export const MTypePopupStake = {
  GET_STAKE_PROPS: `@/${app}/get-stake-props`,
};

export const MTypePopupLedger = {
  ADD_LEDGER_ACCOUNT: `@/${app}/add-ledger-account`,
};

export const MTypeTab = {
  GET_WALLET_DATA: `@/${app}/injected-get-wallet-data`,
  ADDRESS_CHANGED: `@/${app}/address-changed`,
  NETWORK_CHANGED: `@/${app}/network-changed`,
  LOCK_STAUS: `@/${app}/lack-status-updated`,
  CONTENT_PROXY_MEHTOD: `@/${app}/request-through-content`,
  CONTENT_PROXY_RESULT: `@/${app}/response-from-content`,
  CALL_TO_SIGN_TX: `@/${app}/request-to-sign-tx`,
  TX_RESULT: `@/${app}/response-tx-result`,
  SIGN_MESSAGE: `@/${app}/request-to-sign-message`,
  SING_MESSAGE_RES: `@/${app}/response-sign-message`,
  NEW_BLOCK: `@/${app}/new-block-created`,
  ADD_ENCRYPTION: `@/${app}/request-add-encryption`,
  RES_ENCRYPTION: `@/${app}/response-encryption`,
  ADD_DECRYPTION: `@/${app}/add-decryption`,
  RES_DECRYPTION: `@/${app}/response-decryption`,
  CONNECT_APP: `@/${app}/request-to-connect-dapp`,
  RESPONSE_TO_DAPP: `@/${app}/response-dapp-connect`,
  DISCONNECT_APP: `@/${app}/request-to-disconnect-dapp`
};


```

`zil-pay/lib/streem/message.ts`:

```ts
import { Runtime } from "lib/runtime/extensionizer";


export interface ReqBody<T = unknown> {
    type: string;
    payload?: T;
    domain?: string;
    from?: string;
}

export class Message<T = unknown> {
    constructor(public readonly body: ReqBody<unknown>) {}

    static signal(type: string): Message<object> {
        return new Message({ type });
    }

    async send(): Promise<T> {
        for (let i = 0; i < 10; i++) {
            try {
                const res = await this.#trySend();
                if (res) return res;
            } catch {}
        }
        throw new Error("service_worker_stopped");
    }

    #trySend(): Promise<T> {
        return new Promise((resolve) => {
            let data = JSON.parse(JSON.stringify(this.body));
            Runtime.runtime.sendMessage(data, resolve);
        });
    }
}

```

`zil-pay/lib/streem/secure-message.ts`:

```ts
import type { ReqBody } from './message';
import type { TabStream } from './tab-stream';

export class SecureContentMessage<T = unknown> {
    constructor(public readonly body: ReqBody<T>) {}

    get type() { return this.body.type; }
    get payload() { return this.body.payload; }

    send(stream: TabStream, recipient: string) {
        stream.send(this.body, recipient);
    }
}

```

`zil-pay/lib/streem/tab-stream.ts`:

```ts
import type { ReqBody } from './message';
import { Runtime } from "lib/runtime";
import { MTypeTabContent } from './keys';

export class TabStream {
    constructor(public readonly eventName: string) {}

    listen(cb: (payload: ReqBody) => void) {
        globalThis.document?.addEventListener(this.eventName, (event: Event) => {
            const detail = (event as CustomEvent).detail;
            if (detail) {
                try {
                    cb(JSON.parse(detail));
                } catch (e) {
                    console.error("Error parsing event detail", e, event);
                }
            }
        });
    }

    send(data: ReqBody, to: string) {
        data.from = this.eventName;
        if (Object.values(MTypeTabContent).includes(to)) {
            this.#dispatch(JSON.stringify(data), to);
        }
    }

    #dispatch(data: string, to: string) {
        globalThis.document?.dispatchEvent(this.#getEvent(data, to));
    }

    #getEvent(detail: string, to: string) {
        return new CustomEvent(to, { detail });
    }

    /**
     * Sends a signal message to the specified tab.
     * @param tabId - The ID of the tab.
     * @param message - The message to send.
     */
    async sendSignalToTab(tabId: number, message: ReqBody): Promise<void> {
        try {
            await Runtime.tabs.sendMessage(tabId, message);
        } catch (error) {
            console.error(`Failed to send signal to tab ${tabId}:`, error);
            throw error; // Re-throw the error to be handled by the caller
        }
    }

    /**
      * Sends message to all tabs except the excluded tabIds
      * @param message
      * @param excludedTabIds
      */
    async sendToAllTabs(message: ReqBody, excludedTabIds: number[] = []): Promise<void> {
        try {
            const tabs = await Runtime.tabs.query({});
            for (const tab of tabs) {
                if (tab?.id && !excludedTabIds.includes(tab.id)) {
                    await Runtime.tabs.sendMessage(tab.id, message);
                }
            }
        } catch (error) {
            console.error("Failed to send message to all tabs:", error);
            throw error; // Re-throw the error
        }
    }
}

```

`zil-pay/lib/streem/tabs-message.ts`:

```ts
import type { ReqBody } from './message';
import { Runtime } from "lib/runtime";


export class TabsMessage<T = any> {
    constructor(public readonly body: ReqBody<T>) {}

    static async getTabs(): Promise<chrome.tabs.Tab[]> {
        return Runtime.tabs.query({});
    }

    async signal(domain: string): Promise<string> {
        return new Promise<string>((resolve, reject) => {
            Runtime.tabs.query({ active: true, currentWindow: true }, (tabs: chrome.tabs.Tab[]) => {
                const tab = tabs[0];
                if (!tab) {
                    reject(new Error("no active tabs"));
                    return;
                }

                const { hostname } = new URL(tab.url!);

                if (hostname !== domain) {
                    reject(new Error("invalid domain"));
                    return;
                }
                Runtime.tabs.sendMessage(Number(tab.id), this.body)
                    .then(() => resolve(""))
                    .catch(reject);
            });
        });
    }



    async send(...domains: string[]): Promise<void> {
        const tabs = await TabsMessage.getTabs();

        tabs.forEach(async (tab) => {
            if (tab?.url && domains.includes(new URL(tab.url).hostname)) {
                try {
                    await Runtime.tabs.sendMessage(Number(tab.id), this.body);
                } catch (err) {
                    console.error(`Failed to send message to tab ${tab.id}`, err);
                }
            }
        });
    }

    async sendAll(): Promise<void> {
        const tabs = (await TabsMessage.getTabs())
            .filter((tab) => tab?.url && !tab.url.startsWith("chrome://"));

        try {
            for (const tab of tabs) {
                await Runtime.tabs.sendMessage(Number(tab.id), this.body);
            }
        } catch (err) {
            console.error("TabsMessage", err);
        }
    }
}

```

`zil-pay/lib/types/checker.ts`:

```ts
type Arg = unknown;

export const TypeOf = Object.freeze({
    /**
     * Checks if the given argument is an array.
     * @param arg The argument to check.
     * @returns True if the argument is an array, false otherwise.
     */
    isArray(arg: Arg): boolean {
        return Array.isArray(arg);
    },

    /**
     * Checks if the given argument is a plain object.
     * @param arg The argument to check.
     * @returns True if the argument is a plain object, false otherwise.
     */
    isObject(arg: Arg): boolean {
        return typeof arg === 'object' && arg !== null && !Array.isArray(arg) && !(arg instanceof Date) && !(arg instanceof Error) && Object.getPrototypeOf(arg) === Object.prototype;
    },

    /**
     * Checks if the given argument is a number.
     * @param arg The argument to check.
     * @returns True if the argument is a number, false otherwise.
     */
    isNumber(arg: Arg): boolean {
        return typeof arg === 'number' && !isNaN(arg as number);
    },

    /**
     * Checks if the given argument is an integer.
     * @param arg The argument to check.
     * @returns True if the argument is an integer, false otherwise.
     */
    isInt(arg: Arg): boolean {
        return Number.isInteger(arg as number);
    },

    /**
     * Checks if the given argument is a BigInt.
     * @param arg The argument to check.
     * @returns True if the argument is a BigInt, false otherwise.
     */
    isBigInt(arg: Arg): boolean {
        return typeof arg === 'bigint';
    },

    /**
     * Checks if the given argument is an error object.
     * @param arg The argument to check.
     * @returns True if the argument is an error object, false otherwise.
     */
    isError(arg: Arg): boolean {
        return arg instanceof Error;
    },

    /**
     * Checks if the given argument is a string.
     * @param arg The argument to check.
     * @returns True if the argument is a string, false otherwise.
     */
    isString(arg: Arg): boolean {
        return typeof arg === 'string' || arg instanceof String;
    },

    /**
     * Checks if the given argument is a boolean.
     * @param arg The argument to check.
     * @returns True if the argument is a boolean, false otherwise.
     */
    isBoolean(arg: Arg): boolean {
        return typeof arg === 'boolean' || arg instanceof Boolean;
    },

    /**
     * Checks if the given argument is null.
     * @param arg The argument to check.
     * @returns True if the argument is null, false otherwise.
     */
    isNull(arg: Arg): boolean {
        return arg === null;
    },

    /**
     * Checks if the given argument is undefined.
     * @param arg The argument to check.
     * @returns True if the argument is undefined, false otherwise.
     */
    isUndefined(arg: Arg): boolean {
        return arg === undefined;
    },

    /**
     * Checks if the given argument is an empty object.
     * @param arg The argument to check.
     * @returns True if the argument is an empty object, false otherwise.
     */
    isEmptyObject(arg: Arg): boolean {
        return this.isObject(arg) && Object.keys(arg as object).length === 0;
    },

    /**
     * Checks if the given argument is an empty array.
     * @param arg The argument to check.
     * @returns True if the argument is an empty array, false otherwise.
     */
    isEmptyArray(arg: Arg): boolean {
        return this.isArray(arg) && (arg as Array<unknown>).length === 0;
    },
});


```

`zil-pay/lib/types/index.ts`:

```ts
export * from './checker';


```

`zil-pay/lib/utils/hex.ts`:

```ts
import { TypeOf } from "lib/types";

export const HEX_PREFIX = "0x";

/**
 * Checks if a string starts with the '0x' prefix (case-insensitive).
 *
 * @param str The string to check.
 * @returns True if the string starts with '0x', false otherwise.
 */
export function hasHexPrefix(str: string): boolean {
  return str.toLowerCase().startsWith(HEX_PREFIX);
}


export function stripHexPrefix(hex: string): string {
  return hasHexPrefix(hex) ? hex.slice(2) : hex;
}

/**
 * A lookup table for fast number-to-hex conversion.
 */
const HEX_CHAR_TABLE: string[] = Array.from({ length: 256 }, (_, i) =>
    i.toString(16).padStart(2, '0')
);

/**
 * Efficiently converts a Uint8Array to a hexadecimal string.
 * This function uses a pre-computed lookup table for maximum performance.
 *
 * @param {Uint8Array} uint8Array The byte array (numbers 0-255) to convert.
 * @param {boolean} [prefix=false] Whether to include the '0x' prefix in the output.
 * @returns {string} The resulting hexadecimal string.
 */
export function uint8ArrayToHex(uint8Array: Uint8Array, prefix: boolean = false): string {
    const hexParts = new Array(uint8Array.length);
    for (let i = 0; i < uint8Array.length; i++) {
        hexParts[i] = HEX_CHAR_TABLE[uint8Array[i]];
    }
    const hexString = hexParts.join('');

    return prefix ? HEX_PREFIX + hexString : hexString;
}

/**
 * Efficiently converts a hexadecimal string to a Uint8Array.
 * This function is optimized to minimize memory allocation and avoid
 * unnecessary intermediate conversions.
 *
 * @param {string} hexString The hexadecimal string (may start with '0x').
 * @returns {Uint8Array} A Uint8Array representing the hexadecimal data.
 * @throws {Error} if the string has an odd number of characters or contains invalid hex characters.
 */
export function hexToUint8Array(hexString: string): Uint8Array {
    if (hexString == '' || hexString == HEX_PREFIX) {
        return new Uint8Array();
    }

    const str = stripHexPrefix(hexString);

    if (str.length % 2 !== 0) {
        throw new Error('Invalid hex string: must have an even number of characters.');
    }

    const arrayBuffer = new Uint8Array(str.length / 2);

    for (let i = 0; i < str.length; i += 2) {
        const byteString = str.substring(i, i + 2);
        const byteValue = parseInt(byteString, 16);

        if (isNaN(byteValue)) {
            throw new Error(`Invalid hex character "${byteString}" at position ${i}.`);
        }
        
        arrayBuffer[i / 2] = byteValue;
    }

    return Uint8Array.from(arrayBuffer);
}


/**
 * Converts a hexadecimal string to a BigInt.
 * This is the most direct and performant way to perform the conversion.
 *
 * @param {string} hexString The hexadecimal string (may start with '0x').
 * @returns {bigint} The BigInt representation of the hexadecimal string.
 * @throws {SyntaxError} if the string is not a valid hexadecimal number.
 */
export function hexToBigInt(hexString: string): bigint {
    const cleanHex = hexString.startsWith(HEX_PREFIX) ? hexString : `${HEX_PREFIX}${hexString}`;
    return BigInt(cleanHex);
}

export function bigintToHex(value: bigint, prefix = true): string {
    return (prefix ? HEX_PREFIX : '') + value.toString(16);
}


export function convertBigIntsToHex(obj: { [key: string]: unknown }): { [key: string]: unknown } {
  const newObj: { [key: string]: unknown } = {};

  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const value = obj[key];
      
      if (TypeOf.isBigInt(value)) {
        newObj[key] = HEX_PREFIX + (value as bigint).toString(16);
      } else {
        newObj[key] = value;
      }
    }
  }

  return newObj;
}

```

`zil-pay/lib/utils/locale.ts`:

```ts
export function detectLanguage(word: string): string {
  if (/^[a-zA-Z]+$/.test(word)) return 'en';
  if (/[\u0400-\u04FF]/.test(word)) return 'ru';
  if (/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF]/.test(word)) return 'ja';
  if (/[\uAC00-\uD7A3]/.test(word)) return 'ko';
  if (/[\u00C0-\u00FF]/.test(word)) return 'es';

  throw new Error('Unknown language');
}

```

`zil-pay/lib/utils/utf8.ts`:

```ts
export function utf8ToUint8Array(str: string): Uint8Array {
  const encoder = new TextEncoder();
  return encoder.encode(str);
}

export function uint8ArrayToUtf8(arr: Uint8Array): string {
  const decoder = new TextDecoder();
  return decoder.decode(arr);
}


```

`zil-pay/lib/zilliqa/bech32.ts`:

```ts
import { assert } from 'lib/runtime/assert';
import { CHARSET, HRP, GENERATOR } from 'lib/zilliqa/config';
import { toChecksumHexAddress } from 'lib/zilliqa/checksum';
import { hexToUint8Array, uint8ArrayToHex } from '../utils/hex';

const polymod = (values: Uint8Array): number => {
    let chk: number = 1;
    for (let p: number = 0; p < values.length; ++p) {
        const top: number = chk >> 25;
        chk = ((chk & 0x1ffffff) << 5) ^ values[p];
        for (let i: number = 0; i < 5; ++i) {
            if ((top >> i) & 1) {
                chk ^= GENERATOR[i];
            }
        }
    }
    return chk;
};

const hrpExpand = (hrp: string): Uint8Array => {
    const ret: number[] = [];
    for (let i: number = 0; i < hrp.length; ++i) {
        ret.push(hrp.charCodeAt(i) >> 5);
    }
    ret.push(0);
    for (let i: number = 0; i < hrp.length; ++i) {
        ret.push(hrp.charCodeAt(i) & 31);
    }
    return new Uint8Array(ret);
};

export function convertBits(data: Uint8Array, fromWidth: number, toWidth: number, pad: boolean = true): Uint8Array | null {
    let acc: number = 0;
    let bits: number = 0;
    const ret: number[] = [];
    const maxv: number = (1 << toWidth) - 1;

    for (const value of data) {
        if (value < 0 || (value >> fromWidth) !== 0) {
            return null;
        }
        acc = (acc << fromWidth) | value;
        bits += fromWidth;
        while (bits >= toWidth) {
            bits -= toWidth;
            ret.push((acc >> bits) & maxv);
        }
    }

    if (pad) {
        if (bits > 0) {
            ret.push((acc << (toWidth - bits)) & maxv);
        }
    } else if (bits >= fromWidth || (acc << (toWidth - bits)) & maxv) {
        return null;
    }

    return new Uint8Array(ret);
}

function verifyChecksum(hrp: string, data: Uint8Array): boolean {
    return polymod(new Uint8Array([...hrpExpand(hrp), ...data])) === 1;
}

function createChecksum(hrp: string, data: Uint8Array): Uint8Array {
    const values: Uint8Array = new Uint8Array([...hrpExpand(hrp), ...data, 0, 0, 0, 0, 0, 0]);
    const mod: number = polymod(values) ^ 1;
    const ret: number[] = [];
    for (let p: number = 0; p < 6; ++p) {
        ret.push((mod >> (5 * (5 - p))) & 31);
    }
    return new Uint8Array(ret);
}

export const encode = (hrp: string, data: Uint8Array): string => {
    const checksum: Uint8Array = createChecksum(hrp, data);
    const combined: Uint8Array = new Uint8Array([...data, ...checksum]);
    let ret: string = hrp + '1';
    for (const value of combined) {
        ret += CHARSET.charAt(value);
    }
    return ret;
};

export const decode = (bechString: string): { hrp: string; data: Uint8Array } | null => {
    let hasLower: boolean = false;
    let hasUpper: boolean = false;
    for (let i: number = 0; i < bechString.length; ++i) {
        const charCode: number = bechString.charCodeAt(i);
        if (charCode < 33 || charCode > 126) {
            return null;
        }
        if (charCode >= 97 && charCode <= 122) {
            hasLower = true;
        }
        if (charCode >= 65 && charCode <= 90) {
            hasUpper = true;
        }
    }

    if (hasLower && hasUpper) {
        return null;
    }

    const lowerBechString: string = bechString.toLowerCase();
    const pos: number = lowerBechString.lastIndexOf('1');

    if (pos < 1 || pos + 7 > lowerBechString.length || lowerBechString.length > 90) {
        return null;
    }

    const hrp: string = lowerBechString.substring(0, pos);
    const data: number[] = [];
    for (let i: number = pos + 1; i < lowerBechString.length; ++i) {
        const d: number = CHARSET.indexOf(lowerBechString.charAt(i));
        if (d === -1) {
            return null;
        }
        data.push(d);
    }

    const dataBytes: Uint8Array = new Uint8Array(data);
    if (!verifyChecksum(hrp, dataBytes)) {
        return null;
    }

    return { hrp, data: dataBytes.slice(0, dataBytes.length - 6) };
};

export const toBech32Address = async (address: string): Promise<string> => {
    const addressBytes = hexToUint8Array(address);
    const addrBz = convertBits(addressBytes, 8, 5);
    assert(addrBz !== null, 'Cannot convert bytes to Bech32 bits.');

    return encode(HRP, addrBz as Uint8Array);
};

export const fromBech32Address = (address: string): string => {
    const res = decode(address);
    assert(res !== null, 'Invalid Bech32 address.');

    const { hrp, data } = res as { hrp: string; data: Uint8Array };
    assert(hrp === HRP, `Expected HRP '${HRP}', but got '${hrp}'.`);

    const buf = convertBits(data, 5, 8, false);
    assert(buf !== null, 'Cannot convert Bech32 bits to bytes.');

    const hexAddress = uint8ArrayToHex(buf as Uint8Array, true);

    return hexAddress;
};


```

`zil-pay/lib/zilliqa/checksum.ts`:

```ts
import { sha256 } from 'crypto/sha256';
import { 
    HEX_PREFIX, 
    stripHexPrefix, 
    uint8ArrayToHex, 
    hexToUint8Array, 
    hexToBigInt 
} from 'lib/utils/hex';

export async function toChecksumBytesAddress(addressBytes: Uint8Array): Promise<string> {
  const addressHex = uint8ArrayToHex(addressBytes);
  const hashBytes = await sha256(addressBytes);
  const hashBigInt = hexToBigInt(uint8ArrayToHex(hashBytes));

  let checksummedHex = '';

  for (let i = 0; i < addressHex.length; i++) {
    const char = addressHex[i];
    if (/[0-9]/.test(char)) {
        checksummedHex += char;
    } else {
      const bitPosition = BigInt(255 - 6 * i);
      const mask = BigInt(2) ** bitPosition;
      const shouldBeUpper = (hashBigInt & mask) >= BigInt(1);

      if (shouldBeUpper) {
        checksummedHex += char.toUpperCase();
      } else {
        checksummedHex += char.toLowerCase();
      }
    }
  }

  return HEX_PREFIX + checksummedHex;
}

export async function toChecksumHexAddress(address: string): Promise<string> {
  const unprefixedAddress = stripHexPrefix(address);
  const addressBytes = hexToUint8Array(unprefixedAddress);
  return toChecksumBytesAddress(addressBytes);
}


```

`zil-pay/lib/zilliqa/config.ts`:

```ts
export const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
export const HRP = 'zil';
export const GENERATOR = [
  0x3b6a57b2,
  0x26508e6d,
  0x1ea119fa,
  0x3d4233dd,
  0x2a1462b3
];

```

`zil-pay/lib/zilliqa/index.ts`:

```ts
export * from './bech32';
export * from './checksum';
export * from './config';
export * from './pubkey';

```

`zil-pay/lib/zilliqa/pubkey.ts`:

```ts
import { sha256 } from 'crypto/sha256';

export async function fromZilPubKey(pubKey: Uint8Array): Promise<Uint8Array> {
  const hashBytes = await sha256(pubKey);
  const addressBytes = hashBytes.slice(12);

  if (addressBytes.length !== 20) {
    throw new Error('Invalid public key length or unexpected hash output length.');
  }

  return addressBytes;
}

```

`zil-pay/popup/background/wallet.ts`:

```ts
import type { BackgroundState } from "background/storage";

import { get } from "svelte/store";
import { MTypePopup } from "config/stream";
import { Themes } from "config/theme";
import { warpMessage, type SendResponseParams } from "lib/popup/warp-message";
import { Message } from "lib/streem/message";
import { themeDetect } from "popup/mixins/theme";
import globalStore from "popup/store/global";
import type { IKeyPair, WalletFromBip39Params, WalletFromPrivateKeyParams } from "types/wallet";
 
export async function getGlobalState() {
  const data = await Message.signal(MTypePopup.GET_GLOBAL_STATE).send();
  let resolve = warpMessage(data) as BackgroundState;

  if (resolve.appearances == Themes.System) {
    resolve.appearances = themeDetect();
  }

  document.body.setAttribute("theme", resolve.appearances);
  globalStore.set(resolve);

  return resolve;
}

export async function generateKeyPair(slip44: number) {
  const data =    await new Message<SendResponseParams>({
    type: MTypePopup.GEN_KEYPAIR,
    payload: {
      slip44,
    },
  }).send();
  let resolve = warpMessage(data) as IKeyPair;
  return resolve;
}

export async function fromRpivKey(slip44: number, key: string) {
  const data =    await new Message<SendResponseParams>({
    type: MTypePopup.FROM_PRIV_KEY,
    payload: {
      slip44,
      key,
    },
  }).send();
  let resolve = warpMessage(data) as IKeyPair;
  return resolve;
}

export async function validateBip39Checksum(phrase: string, wordList: string[]) {
  const data =    await new Message<SendResponseParams>({
    type: MTypePopup.VALIDATE_BIP39_CHECK_SUM,
    payload: {
      phrase,
      wordList,
    },
  }).send();
  let resolve = warpMessage(data) as boolean;
  return resolve;
}



export async function generateBip39Words(count: number, wordList: string[]) {
  const data =    await new Message<SendResponseParams>({
    type: MTypePopup.GEN_BIP39,
    payload: {
      count,
      wordList
    },
  }).send();
  let resolve = warpMessage(data) as string;

  return resolve;
}


export async function setGlobalState() {
  const globalState = get(globalStore);

   await new Message({
    type: MTypePopup.SET_GLOBAL_STATE,
    payload: globalState,
  }).send();
}

export async function walletFromPrivateKey(payload: WalletFromPrivateKeyParams) {
  const data =    await new Message<SendResponseParams>({
    payload,
    type: MTypePopup.WALLET_FROM_PRIVATE_KEY,
  }).send();
  let resolve = warpMessage(data) as BackgroundState;

  globalStore.set(resolve);

  return resolve;
}

export async function walletFromBip39Mnemonic(payload: WalletFromBip39Params) {
  const data =    await new Message<SendResponseParams>({
    payload,
    type: MTypePopup.WALLET_FROM_BIP39,
  }).send();
  let resolve = warpMessage(data) as BackgroundState;

  globalStore.set(resolve);

  return resolve;
}


```

`zil-pay/popup/i18n.ts`:

```ts
import { derived } from "svelte/store";
import { dictionary, locale, _, date, time, number } from "svelte-i18n";

const MESSAGE_FILE_URL_TEMPLATE = "/lang/{locale}.json";

let cachedLocale: string | string[];

async function setupI18n({ withLocale: _locale } = { withLocale: "en" }) {
  const messsagesFileUrl = MESSAGE_FILE_URL_TEMPLATE.replace(
    "{locale}",
    _locale,
  );
  const response = await fetch(messsagesFileUrl);
  const messages = await response.json();
  dictionary.set({ [_locale]: messages });
  cachedLocale = _locale;
  locale.set(_locale);
}

function formatDate(
  date: string | number | Date,
  options: Intl.DateTimeFormatOptions,
): string {
  return new Intl.DateTimeFormat(cachedLocale, options).format(new Date(date));
}

const isLocaleLoaded = derived(
  locale,
  ($locale) => typeof $locale === "string",
);
const dir = derived(locale, ($locale) => ($locale === "en" ? "rtl" : "ltr"));

export {
  _,
  locale,
  dir,
  setupI18n,
  formatDate,
  isLocaleLoaded,
  date,
  time,
  number,
};

```

`zil-pay/popup/main.ts`:

```ts
import { mount } from "svelte";
import App from "./App.svelte";
import { getGlobalState } from "./background/wallet";

let app = {};

getGlobalState().finally(() => {
  app = mount(App, {
    target: document.body,
  });
});

export default app;

```

`zil-pay/popup/mixins/chains.ts`:

```ts
import type { IChainConfigState } from "background/storage";

export interface Explorer {
  name: string;
  url: string;
  icon: string;
  standard: string;
}

export interface FToken {
  native: boolean;
  logo: string;
  addr: string;
  name: string;
  symbol: string;
  decimals: number;
}

export interface ChainData {
  mainnet: IChainConfigState[];
  testnet: IChainConfigState[];
}

export async function getChains(): Promise<ChainData> {
  try {
    const baseUrl = "/chains";
    const [mainnetResponse, testnetResponse] = await Promise.all([
      fetch(`${baseUrl}/mainnet.json`),
      fetch(`${baseUrl}/testnet.json`) 
    ]);
  
    const mainnet = await mainnetResponse.json() as IChainConfigState[];
    const testnet = testnetResponse.ok ? await testnetResponse.json() as IChainConfigState[] : [];

    return {
      mainnet,
      testnet
    };
  } catch (error) {
    return {
      mainnet: [],
      testnet: []
    };
  }
}

```

`zil-pay/popup/mixins/theme.ts`:

```ts
import { Themes } from "config/theme";

export function themeDetect() {
  const darkThemeMq = window.matchMedia("(prefers-color-scheme: dark)");
  const isDark = Boolean(darkThemeMq.matches);

  return isDark ? Themes.Dark : Themes.Light;
}

```

`zil-pay/popup/router/guard.ts`:

```ts
import { get } from "svelte/store";
import globalStore from "popup/store/global";
import { type Route } from "./index";
import StartPage from "../pages/Start.svelte";
import LockPage from "../pages/Lock.svelte";
import ConnectPage from "../pages/Connect.svelte";
import ConfirmPopupPage from "../pages/ConfirmPopup.svelte";
import SignMessagePopupPage from "../pages/SignMessagePopup.svelte";

export class RouteGuard {
  private static navigate(path: string) {
    window.location.hash = path;
  }

  static checkRoute(route: Route): Route {
    if (!route.isProtected) {
      return route;
    }

    const globalState = get(globalStore);

    if (globalState.wallets.length == 0) {
      this.navigate("/start");

      return { path: "/start", component: StartPage };
    }

    const wallet = globalState.wallets[globalState.selected_wallet]; 

    if (globalState.selected_wallet == -1 || !wallet) {
      this.navigate("lock");
      return {
        path: "/lock",
        component: LockPage,
      };
    }


    if (wallet.confirm.length != 0) {
      // detect if really conect
      this.navigate("connect");
      return {
        path: "/connect",
        component: ConnectPage,
      };
    }

    if (wallet.confirm.length != 0) {
      // detect if really confirm
      this.navigate("confirm");
      return {
        path: "/confirm",
        component: ConfirmPopupPage,
      };
    }

    if (wallet.confirm.length != 0) {
      // detect if really sign-message
      this.navigate("sign-message");
      return {
        path: "/sign-message",
        component: SignMessagePopupPage,
      };
    }

    return route;
  }
}

```

`zil-pay/popup/router/index.ts`:

```ts
import type { Component } from "svelte";
import NotFoundPage from "../pages/NotFoundPage.svelte";
import HomePage from "../pages/Home.svelte";
import LockPage from "../pages/Lock.svelte";
import StartPage from "../pages/Start.svelte";
import ConnectPage from "../pages/Connect.svelte";
import ConfirmPopupPage from "../pages/ConfirmPopup.svelte";
import SignMessagePopupPage from "../pages/SignMessagePopup.svelte";
import LocalePage from "../pages/Locale.svelte";
import NewWalletOptionsPage from "../pages/NewWalletOptions.svelte";
import GenerateWalletPage from "../pages/GenerateWallet.svelte";
import RestoreWalletPage from "../pages/RestoreWallet.svelte";
import Bip39GeneratePage from "../pages/Bip39Generate.svelte";
import Bip39VerifyPage from "../pages/Bip39Verify.svelte";
import KeyPairGenPage from "../pages/KeyPairGen.svelte";
import Bip39RestorePage from "../pages/Bip39Restore.svelte"; 
import KeyPairRestorePage from "../pages/KeyPairRestore.svelte";
import NetworkSetupPage from '../pages/NetworkSetup.svelte';
import PasswordSetupPage from '../pages/PasswordSetup.svelte';


export type ParamsRecord = Record<string, string | null>;
export interface Route {
  path: string;
  component: Component;
  isProtected?: boolean;
}

export const notFoundRoute: Route = {
  path: "*",
  component: NotFoundPage,
};

export const protectedRoutes: Route[] = [
  { path: "/", component: HomePage, isProtected: true },
  { path: "/connect", component: ConnectPage, isProtected: true },
  { path: "/confirm", component: ConfirmPopupPage, isProtected: true },
  { path: "/sign-message", component: SignMessagePopupPage, isProtected: true },
];

export const publicRoutes: Route[] = [
  { path: "/lock", component: LockPage },
  { path: "/start", component: StartPage },
  { path: "/locale", component: LocalePage },
  { path: "/new-wallet-options", component: NewWalletOptionsPage },
  { path: "/generate-wallet", component: GenerateWalletPage },
  { path: "/restore-wallet", component: RestoreWalletPage },
  { path: "/restore-bip39", component: Bip39RestorePage },
  { path: "/generate-bip39", component: Bip39GeneratePage },
  { path: "/verify-bip39", component: Bip39VerifyPage },
  { path: "/keypair-generate", component: KeyPairGenPage },
  { path: "/restore-private-key", component: KeyPairRestorePage },
  { path: "/network-setup", component: NetworkSetupPage },
  { path: "/password-setup", component: PasswordSetupPage },
];

export const routes = [...protectedRoutes, ...publicRoutes];

export function matchRoute(url: string, routes: Route[]): Route | null {
  const urlParts = url.split("/").filter(Boolean);

  for (const route of routes) {
    const routeParts = route.path.split("/").filter(Boolean);

    if (!isMatchingLength(routeParts, urlParts)) {
      continue;
    }

    let isMatch = true;

    for (let i = 0; i < routeParts.length; i++) {
      const routePart = routeParts[i];
      const urlPart = urlParts[i];

      if (routePart.startsWith(":")) {
        const isOptional = routePart.endsWith("?");
        if (!urlPart && !isOptional) {
          isMatch = false;
          break;
        }
        continue;
      }

      if (routePart !== urlPart) {
        isMatch = false;
        break;
      }
    }

    if (isMatch) {
      return route;
    }
  }

  return null;
}

export function parseUrlParams(pattern: string, url: string): ParamsRecord {
  const params: ParamsRecord = {};
  const patternParts: string[] = pattern.split("/").filter(Boolean);
  const urlParts: string[] = url.split("/").filter(Boolean);

  for (let i = 0; i < patternParts.length; i++) {
    const patternPart = patternParts[i];

    if (!patternPart.startsWith(":")) {
      continue;
    }

    let paramName = patternPart.slice(1);
    const isOptional = paramName.endsWith("?");

    if (isOptional) {
      paramName = paramName.slice(0, -1);
    }

    const value = urlParts[i];
    params[paramName] = value || null;
  }

  return params;
}

function isMatchingLength(routeParts: string[], urlParts: string[]): boolean {
  const optionalParams = routeParts.filter((part) => part.endsWith("?")).length;
  return (
    urlParts.length >= routeParts.length - optionalParams &&
    urlParts.length <= routeParts.length
  );
}

```

`zil-pay/popup/router/navigation.ts`:

```ts
import { get } from "svelte/store";
import { currentRoute } from "popup/store/route";

export function getCurrentRoute(): string {
  let rote = get(currentRoute);

  return rote?.path || "";
}

export function push(path: string) {
  window.location.hash = path;
}

export function replace(path: string) {
  const normalizedPath = path.startsWith("/") ? path : `/${path}`;
  const targetHash = `#${normalizedPath}`;

  if (window.location.hash !== targetHash) {
    window.location.replace(targetHash);
  }
}

export function pop() {
  window.history.back();
}

export function route(node: HTMLAnchorElement) {
  const handleClick = (event: Event) => {
    event.preventDefault();
    const path = new URL(node.href).pathname;
    push(path);

    const navigationEvent = new CustomEvent("navigation", {
      detail: { href: path },
    });
    window.dispatchEvent(navigationEvent);
  };

  node.addEventListener("click", handleClick);

  return {
    destroy() {
      node.removeEventListener("click", handleClick);
    },
  };
}

```

`zil-pay/popup/store/cache.ts`:

```ts
import type { IChainConfigState } from 'background/storage';
import type { IKeyPair } from 'types/wallet';
import { writable } from 'svelte/store';

export interface ICache {
  verifyPhrase?: string[];
  bip39WordList?: string[];
  verifyCheckSum?: boolean;
  keyPair?: IKeyPair;
  chain?: IChainConfigState;
}

export const cacheStore = writable<ICache>({});

```

`zil-pay/popup/store/global.ts`:

```ts
import type { IBackgroundState } from "background/storage";
import { Locales } from "config/locale";
import { Themes } from "config/theme";
import { writable } from "svelte/store";


export default writable<IBackgroundState>({
  storageVersion: 4,
  wallets: [],
  selected_wallet: -1,
  notificationsGlobalEnabled: true,
  locale: Locales.Auto,
  appearances: Themes.System,
  abbreviatedNumber: true,
  hideBalance: false,
  chains: [] 
});


```

`zil-pay/popup/store/route.ts`:

```ts
import type { ParamsRecord, Route } from "popup/router";
import { writable } from "svelte/store";

export const currentRoute = writable<Route | null>(null);
export const currentParams = writable<ParamsRecord>({});

```

`zil-pay/types/micro-eth-signer.d.ts`:

```ts
declare module "micro-eth-signer/abi.js" {
  export * from "micro-eth-signer/abi";
}

```

`zil-pay/types/tx.d.ts`:

```ts
export interface MinScillaParams {
  chainId?: number;
  nonce?: string | number;
  gasPrice?: string | number;
  gasLimit?: string | number;
  priority?: boolean;
  code?: string;
  data?: string;
  toAddr: string;
  amount: string;
}

export interface TokenTransferMetadata {
  decimals: number;
  symbol: string;
  name: string;
  to: string;
}

export interface TransactionRequestEVM {
  nonce?: number;
  from?: string;
  to?: string;
  value?: string;
  gasLimit?: number;
  data?: string;
  maxFeePerGas?: string;
  maxPriorityFeePerGas?: string;
  gasPrice?: string;
  chainId?: number;
  accessList?: AccessListItem[];
  blobVersionedHashes?: string[];
  maxFeePerBlobGas?: string;
}

export interface AccessListItem {
  address: string;
  storageKeys: string[];
}

```

`zil-pay/types/wallet.d.ts`:

```ts
import type { IChainConfigState } from 'background/storage';
import type { Bip32Account } from 'background/storage';

export interface SetPasswordPayload {
  cipherOrders: CipherOrders[];
  walletIndex: number;
  hashSettings: RequiredHashSettings;
  currentPassword: string;
  newPassword: string;
}

export interface WalletFromPrivateKeyParams {
  key: IKeyPair;
  walletName: string;
  accountName: string;
  chain: IChainConfigState;
  password: string;
  settings: IWalletSettingsState;
}

export interface WalletFromBip39Params {
  mnemonic: string;
  bip39WordList: string[];
  walletName: string;
  accounts: Bip32Account[];
  verifyCheckSum: boolean;
  chain: IChainConfigState;
  password: string;
  passphrase?: string;
  settings: IWalletSettingsState;
}

export interface IKeyPair {
  address: string;
  privateKey: string;
  publicKey: string;
  slip44: number;
};

```

`zil-pay/vitest.config.ts`:

```ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    setupFiles: '__tests__/setupTests.ts',
    include: ['__tests__/**/*.test.{ts,tsx}'],
  },
});

```