Project Path: zil-pay

Source Tree:

```txt
zil-pay
├── background
│   ├── index.ts
│   ├── rpc
│   │   ├── ft_parser.ts
│   │   ├── gas_parse.ts
│   │   ├── index.ts
│   │   ├── nonce_parser.ts
│   │   ├── provider.ts
│   │   └── rpc.ts
│   ├── secure
│   │   ├── index.ts
│   │   ├── migrator.ts
│   │   └── session.ts
│   ├── services
│   │   ├── guard.ts
│   │   └── index.ts
│   └── storage
│       ├── account.ts
│       ├── argon.ts
│       ├── background.ts
│       ├── chain.ts
│       ├── explorer.ts
│       ├── ftoken.ts
│       ├── index.ts
│       ├── notification.ts
│       ├── settings.ts
│       └── wallet.ts
├── compile-protos.mjs
├── config
│   ├── argon2.ts
│   ├── common.ts
│   ├── errors.ts
│   ├── fields.ts
│   ├── jsonrpc.ts
│   ├── manifest.ts
│   ├── pbkdf2.ts
│   ├── sha.ts
│   └── slip44.ts
├── content
│   └── index.ts
├── crypto
│   ├── address.ts
│   ├── aes256.ts
│   ├── argon2.ts
│   ├── b64.ts
│   ├── bip32.ts
│   ├── bip39.ts
│   ├── bip49.ts
│   ├── index.ts
│   ├── keychain.ts
│   ├── keypair.ts
│   ├── kuznechik.ts
│   ├── ntrup.ts
│   ├── number.ts
│   ├── pbkdf2.ts
│   ├── proto
│   │   └── zq1.ts
│   ├── random.ts
│   ├── sha256.ts
│   ├── sha512.ts
│   ├── tx.ts
│   ├── uuid.ts
│   ├── zilliqa
│   │   ├── pubkey.ts
│   │   └── schnorr.ts
│   └── zilliqa_tx.ts
├── lib
│   ├── array
│   │   ├── chunk.ts
│   │   └── shuffle.ts
│   ├── popup
│   │   ├── clipboard.ts
│   │   ├── printer.ts
│   │   └── warp-message.ts
│   ├── runtime
│   │   ├── assert.ts
│   │   ├── ext-id.ts
│   │   ├── extensionizer.ts
│   │   ├── fingerprint.ts
│   │   ├── get-url.ts
│   │   ├── index.ts
│   │   └── manifest.ts
│   ├── storage
│   │   ├── builder.ts
│   │   ├── index.ts
│   │   └── storage.ts
│   ├── streem
│   │   ├── TabsMessage.ts
│   │   ├── keys.ts
│   │   ├── message.ts
│   │   ├── secure-message.ts
│   │   ├── tab-stream.ts
│   │   └── tabs-message.ts
│   ├── types
│   │   ├── checker.ts
│   │   └── index.ts
│   ├── utils
│   │   ├── hex.ts
│   │   └── utf8.ts
│   └── zilliqa
│       ├── bech32.ts
│       ├── checksum.ts
│       ├── config.ts
│       ├── index.ts
│       └── pubkey.ts
├── popup
│   ├── index.ts
│   └── main.ts
├── rollup.config.mjs
├── types
│   └── micro-eth-signer.d.ts
└── vitest.config.ts

```

`zil-pay/background/index.ts`:

```ts
import {} from "./secure";
import {} from "./services";
import {} from "./storage";

import { addr } from "micro-eth-signer";
const priv =
  "0x0687640ee33ef844baba3329db9e16130bd1735cbae3657bd64aed25e9a5c377";
const pub =
  "030fba7ba5cfbf8b00dd6f3024153fc44ddda93727da58c99326eb0edd08195cdb";
const nonChecksummedAddress = "0x0089d53f703f7e0843953d48133f74ce247184c2";
const checksummedAddress = addr.addChecksum(nonChecksummedAddress);
console.log(
  checksummedAddress, // 0x0089d53F703f7E0843953D48133f74cE247184c2
  addr.isValid(checksummedAddress), // true
  addr.isValid(nonChecksummedAddress), // also true
  addr.fromPrivateKey(priv),
  addr.fromPublicKey(pub),
);

```

`zil-pay/background/rpc/ft_parser.ts`:

```ts
import { RpcProvider, type JsonRPCRequest, type JsonRPCResponse } from './provider';
import { EvmMethods, ZilMethods } from 'config/jsonrpc';
import { createContract } from 'micro-eth-signer/abi.js';
import { hexToBigInt, hexToUint8Array, uint8ArrayToHex } from 'lib/utils/hex';
import { Address, AddressType } from 'crypto/address';
import { TypeOf } from 'lib/types';

const ERC20_ABI = [
  { name: 'name', type: 'function', outputs: [{ type: 'string' }] },
  { name: 'symbol', type: 'function', outputs: [{ type: 'string' }] },
  { name: 'decimals', type: 'function', outputs: [{ type: 'uint8' }] },
  {
    name: 'balanceOf',
    type: 'function',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    name: 'transfer',
    type: 'function',
    inputs: [
      { name: 'recipient', type: 'address' },
      { name: 'amount', type: 'uint256' },
    ],
    outputs: [{ type: 'bool' }],
  },
] as const;

export enum MetadataField {
  Name = 'name',
  Symbol = 'symbol',
  Decimals = 'decimals',
}

type FunctionName = 'name' | 'symbol' | 'decimals' | 'balanceOf' | 'transfer';
type FunctionArgs = {
  name: [];
  symbol: [];
  decimals: [];
  balanceOf: [string];
  transfer: [string, bigint];
};

export type RequestType =
  | { type: 'Metadata'; field: MetadataField }
  | { type: 'Balance'; address: string };

export interface GetTokenInitItem {
  vname: string;
  type: string;
  value: string;
}

export interface ZilBalanceResponse {
  balance: string;
  nonce: number;
}

export interface ZilSmartContractSubStateResponse {
  balances: {
    [key: string]: string;
  };
}

function validateResponse<T>(response: JsonRPCResponse<T>): T {
  if (response.error) {
    throw new Error(
      `RPC Error (code: ${response.error.code}): ${response.error.message}`,
    );
  }
  if (TypeOf.isUndefined(response.result)) {
    throw new Error('RPC Error: Response missing result field');
  }

  return response.result as T;
}

export class ERC20Helper {
  readonly #contract;

  constructor() {
    this.#contract = createContract(ERC20_ABI);
  }

  encodeFunctionCall<T extends FunctionName>(
    functionName: T,
    args: FunctionArgs[T],
  ): string {
    let encodedData: Uint8Array;

    switch (functionName) {
      case 'name':
        encodedData = this.#contract.name.encodeInput();
        break;
      case 'symbol':
        encodedData = this.#contract.symbol.encodeInput();
        break;
      case 'decimals':
        encodedData = this.#contract.decimals.encodeInput();
        break;
      case 'balanceOf':
        encodedData = this.#contract.balanceOf.encodeInput(String(args[0]));
        break;
      case 'transfer':
        encodedData = this.#contract.transfer.encodeInput({
          recipient: String(args[0]),
          amount: BigInt(args[1] ?? 0), 
        });
        break;
      default:
        throw new Error(`Unsupported function: ${functionName}`);
    }

    return uint8ArrayToHex(encodedData, true);
  }

  decodeFunctionOutput(functionName: FunctionName, data: string) {
    const bytes = hexToUint8Array(data);

    switch (functionName) {
      case 'name':
        return this.#contract.name.decodeOutput(bytes);
      case 'symbol':
        return this.#contract.symbol.decodeOutput(bytes);
      case 'decimals':
        return this.#contract.decimals.decodeOutput(bytes);
      case 'balanceOf':
        return this.#contract.balanceOf.decodeOutput(bytes);
      case 'transfer':
        return this.#contract.transfer.decodeOutput(bytes);
      default:
        throw new Error(`Unsupported function: ${functionName}`);
    }
  }

  public generateTransferInput(to: string, amount: bigint): string {
    return this.encodeFunctionCall('transfer', [to, amount]);
  }
}

export function generateErc20TransferData(to: string, amount: bigint): string {
  const erc20 = new ERC20Helper();
  return erc20.generateTransferInput(to, amount);
}

export async function buildTokenRequests(
  contract: Address,
  accounts: Address[],
  native: boolean,
): Promise<{ payload: JsonRPCRequest; requestType: RequestType }[]> {
  const requests: { payload: JsonRPCRequest; requestType: RequestType }[] = [];
  if (contract.type === AddressType.Bech32) {
    await buildZilRequests(contract, accounts, native, requests);
  } else {
    await buildEthRequests(contract, accounts, native, requests);
  }

  return requests;
}

async function buildZilRequests(
  contract: Address,
  accounts: Address[],
  native: boolean,
  requests: { payload: JsonRPCRequest; requestType: RequestType }[],
): Promise<void> {
  const base16Contract = contract.toBase16();
  requests.push({
    payload: RpcProvider.buildPayload(ZilMethods.GetSmartContractInit, [
      base16Contract,
    ]),
    requestType: { type: 'Metadata', field: MetadataField.Name },
  });
  for (const account of accounts) {
    const base16Account = (await account.toZilChecksum()).toLowerCase();
    let payload;
    if (native) {
      payload = RpcProvider.buildPayload(ZilMethods.GetBalance, [
        base16Account,
      ]);
    } else {
      payload = RpcProvider.buildPayload(ZilMethods.GetSmartContractSubState, [
        base16Contract,
        'balances',
        [base16Account],
      ]);
    }
    requests.push({
      payload,
      requestType: { type: 'Balance', address: (await account.toZilBech32()) },
    });
  }
}

async function buildEthRequests(
  contract: Address,
  accounts: Address[],
  native: boolean,
  requests: { payload: JsonRPCRequest; requestType: RequestType }[],
): Promise<void> {
  const erc20 = new ERC20Helper();
  const tokenAddr = await contract.toEthChecksum();

  const buildEthCall = (data: string): JsonRPCRequest => {
    return RpcProvider.buildPayload(EvmMethods.Call, [
      {
        to: tokenAddr,
        data,
      },
      'latest',
    ]);
  };

  const metadataFields: FunctionName[] = [
    'name',
    'symbol',
    'decimals',
  ];

  for (const field of metadataFields) {
    const data = erc20.encodeFunctionCall(field, []);
    requests.push({
      payload: buildEthCall(data),
      requestType: { type: 'Metadata', field: field as MetadataField },
    });
  }

  for (const account of accounts) {
    let payload;
    const ethAddress = await account.toEthChecksum();
    if (native) {
      payload = RpcProvider.buildPayload(EvmMethods.GetBalance, [
        ethAddress,
        'latest',
      ]);
    } else {
      const callData = erc20.encodeFunctionCall('balanceOf', [
        ethAddress,
      ]);
      payload = buildEthCall(callData);
    }
    requests.push({
      payload,
      requestType: { type: 'Balance', address: ethAddress },
    });
  }
}

export function processEthMetadataResponse(
  response: JsonRPCResponse<string>,
  field: MetadataField,
): string {
  const resultHex = validateResponse(response);
  const erc20 = new ERC20Helper();

  const decoded = erc20.decodeFunctionOutput(
    field as FunctionName,
    resultHex,
  );
  return String(decoded);
}

export function processZilMetadataResponse(
  response: JsonRPCResponse<GetTokenInitItem[]>,
): { name: string; symbol: string; decimals: number } {
  const initData = validateResponse(response);

  const getField = (fieldName: string): string => {
    const item = initData.find((item) => item.vname === fieldName);
    if (!item) {
      throw new Error(`Invalid contract init: missing ${fieldName}`);
    }
    return item.value;
  };

  const name = getField('name');
  const symbol = getField('symbol');
  const decimals = parseInt(getField('decimals'), 10);
  if (isNaN(decimals)) {
    throw new Error('Invalid decimals format in contract init');
  }

  return { name, symbol, decimals };
}

export function processEthBalanceResponse(response: JsonRPCResponse<string>): bigint {
  const resultHex = validateResponse(response);
  return hexToBigInt(resultHex);
}

export async function processZilBalanceResponse(
  response: JsonRPCResponse<ZilBalanceResponse | ZilSmartContractSubStateResponse>,
  account: Address,
  isNative: boolean,
): Promise<bigint> {
  try {
    const result = validateResponse(response);
    if (isNative) {
      return BigInt((result as ZilBalanceResponse).balance || '0');
    } else {
      const addr = (await account.toZilChecksum()).toLowerCase();
      const balances = (result as ZilSmartContractSubStateResponse).balances;
      return BigInt(balances?.[addr] || '0');
    }
  } catch (error) {
    return 0n;
  }
}


```

`zil-pay/background/rpc/gas_parse.ts`:

```ts
import { TransactionRequest } from 'crypto/tx';
import { EvmMethods, ZilMethods } from 'config/jsonrpc';
import { Address } from 'crypto/address';
import { buildNonceRequest } from 'background/rpc/nonce_parser';
import { RpcProvider, type JsonRPCRequest } from 'background/rpc/provider';
import { TypeOf } from 'lib/types';

export interface GasFeeHistory {
  maxFee: bigint;
  priorityFee: bigint;
  baseFee: bigint;
}

export interface RequiredTxParams {
  gasPrice: bigint;
  maxPriorityFee: bigint;
  feeHistory: GasFeeHistory;
  txEstimateGas: bigint;
  blobBaseFee: bigint;
  nonce: number;
}

export interface FeeHistoryResult {
  baseFeePerGas: string[];
  reward: string[][];
  oldestBlock: string;
  gasUsedRatio: number[];
}

export const EIP1559 = 1559;
export const EIP4844 = 4844;

class NetworkError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'NetworkError';
    }
}

class TransactionError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'TransactionError';
    }
}

export function buildFeeHistoryRequest(blockCount: number, percentiles: number[]): JsonRPCRequest {
    return RpcProvider.buildPayload(EvmMethods.FeeHistory, [`0x${blockCount.toString(16)}`, 'latest', percentiles]);
}

export function buildEvmEstimateGasRequest(tx: TransactionRequest): JsonRPCRequest {
    if (tx.scilla || !tx.evm) {
        throw new NetworkError("Zilliqa network doesn't support gas estimation or EVM transaction is missing");
    }
    
    try {
        return RpcProvider.buildPayload(EvmMethods.EstimateGas, [tx.evm]);
    } catch (e: any) {
        throw new TransactionError(`Failed to serialize transaction: ${e.message}`);
    }
}

export async function buildBatchGasRequest(
  tx: TransactionRequest,
  blockCount: number,
  percentiles: number[],
  features: number[],
  sender: Address,
): Promise<JsonRPCRequest[]> {
    const requests: JsonRPCRequest[] = [];

    if (tx.scilla) {
        const zilAddress = await sender.toZilBech32();
        requests.push(await buildNonceRequest(sender.type, zilAddress));
        requests.push(RpcProvider.buildPayload(ZilMethods.GetMinimumGasPrice, []));
        return requests;
    }
    
    if (!tx.evm) {
        throw new TransactionError('EVM transaction is required for gas estimation.');
    }

    const ethAddress = await sender.toEthChecksum();
    requests.push(await buildNonceRequest(sender.type, ethAddress));
    requests.push(RpcProvider.buildPayload(EvmMethods.GasPrice, []));
    
    const requestEstimateGas = RpcProvider.buildPayload(EvmMethods.EstimateGas, [tx.evm]);
    requests.push(requestEstimateGas);

    if (features.includes(EIP1559)) {
        requests.push(RpcProvider.buildPayload(EvmMethods.MaxPriorityFeePerGas, []));
        requests.push(buildFeeHistoryRequest(blockCount, percentiles));
    }

    if (features.includes(EIP4844)) {
        requests.push(RpcProvider.buildPayload(EvmMethods.BlobBaseFee, []));
    }

    return requests;
}

export function processParseFeeHistoryRequest(feeHistoryValue: FeeHistoryResult): GasFeeHistory {
    const lastBaseFeeStr = feeHistoryValue.baseFeePerGas.at(-1);
    if (!lastBaseFeeStr) {
        throw new Error('baseFeePerGas not found or empty in fee history');
    }
    const baseFee = BigInt(lastBaseFeeStr);
    const lastRewardArr = feeHistoryValue.reward.at(-1);

    if (!lastRewardArr || !TypeOf.isArray(lastRewardArr) || !TypeOf.isString(lastRewardArr[1])) {
        throw new Error('reward not found or has invalid format in fee history');
    }

    const priorityFee = BigInt(lastRewardArr[1]);
    const maxFee = baseFee * 2n + priorityFee;

    return {
        maxFee,
        priorityFee,
        baseFee,
    };
}


```

`zil-pay/background/rpc/index.ts`:

```ts
export * from './provider';
export * from './rpc';
export * from './ft_parser';
export * from './gas_parse';
export * from './nonce_parser';

```

`zil-pay/background/rpc/nonce_parser.ts`:

```ts
import { RpcProvider, type JsonRPCRequest } from './provider';
import { EvmMethods, ZilMethods } from '../../config/jsonrpc';
import { AddressType } from '../../crypto/address';
import { addr } from 'micro-eth-signer';
import { fromBech32Address } from '../../lib/zilliqa';
import { TypeOf } from 'lib/types';
import { hexToBigInt, stripHexPrefix } from 'lib/utils/hex';

export interface ZilBalance {
  balance: string;
  nonce: number;
}

export type NonceResponse = string | ZilBalance;

export async function buildNonceRequest(addressType: AddressType, address: string): Promise<JsonRPCRequest> {
  switch (addressType) {
    case AddressType.Bech32:
      const base16 = await fromBech32Address(address);
      return RpcProvider.buildPayload(
        ZilMethods.GetBalance,
        [stripHexPrefix(base16).toLowerCase()]
      );
    case AddressType.EthCheckSum:
      const ethAddress = addr.addChecksum(address);
      return RpcProvider.buildPayload(
        EvmMethods.GetTransactionCount,
        [ethAddress, 'latest']
      );
    default:
      throw new Error('Unsupported address type');
  }
}

export function processNonceResponse(response: NonceResponse): number {
  if (TypeOf.isObject(response)) {
    const res = response as ZilBalance;
    return res.nonce || 0;
  } else if (TypeOf.isString(response)) {
    return Number(hexToBigInt(String(response)));
  }

  return 0;
}


```

`zil-pay/background/rpc/provider.ts`:

```ts
import type { ChainConfig } from "background/storage";

export interface JsonRPCRequest {
  id: number;
  jsonrpc: string;
  method: string;
  params: unknown[];
}

export interface JsonRPCResponse<T> {
  id: number;
  jsonrpc: string;
  result?: T;
  error?: {
    code: number;
    message: string;
    data?: unknown;
  };
}

export class RpcError extends Error {
  public code: number;
  public data?: unknown;

  constructor(message: string, code: number, data?: unknown) {
    super(message);
    this.name = 'RpcError';
    this.code = code;
    this.data = data;
  }
}

export class RpcProvider {
  public network: ChainConfig;

  constructor(network: ChainConfig) {
    this.network = network;
  }

  static buildPayload(method: string, params: unknown[]): JsonRPCRequest {
    return {
      id: 1,
      jsonrpc: '2.0',
      method,
      params,
    };
  }

  public async req<T>(payload: JsonRPCRequest | JsonRPCRequest[]): Promise<T> {
    const client = {
      timeout: 5000,
    };

    let lastError: RpcError | null = null;
    const allNodes = this.network.rpc;

    if (allNodes.length === 0) {
      throw new RpcError('No RPC nodes available in the network configuration.', -32000);
    }

    const batchSize = 3;
    const currentBatch = allNodes.slice(0, batchSize);
    const failedNodesInBatch: string[] = [];

    for (const url of currentBatch) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), client.timeout);

        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
          signal: controller.signal,
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          lastError = new RpcError(
            `Request failed with status ${response.status}`,
            response.status,
          );
          failedNodesInBatch.push(url);
          continue;
        }

        const text = await response.text();
        try {
          const json: JsonRPCResponse<T> | JsonRPCResponse<T>[] = JSON.parse(text);

          if (Array.isArray(json)) {
            const errors = json
              .map((res) => res.error)
              .filter((err): err is NonNullable<typeof err> => !!err);
            if (errors.length > 0) {
              const firstError = errors[0];
              lastError = new RpcError(
                firstError.message,
                firstError.code,
                firstError.data,
              );
              failedNodesInBatch.push(url);
              continue;
            }
          } else if (json.error) {
            lastError = new RpcError(
              json.error.message,
              json.error.code,
              json.error.data,
            );
            failedNodesInBatch.push(url);
            continue;
          }

          return json as T;
        } catch (e: unknown) {
          if (e instanceof Error) {
            lastError = new RpcError(`Failed to parse JSON: ${e.message}`, -32700, text);
          } else {
            lastError = new RpcError('Failed to parse JSON: An unknown error occurred', -32700, text);
          }
          failedNodesInBatch.push(url);
          continue;
        }
      } catch (e: unknown) {
        if (e instanceof Error) {
            if (e.name === 'AbortError') {
              lastError = new RpcError(`Request timed out to ${url}`, -32603);
            } else {
              lastError = new RpcError(`Request to ${url} failed: ${e.message}`, -32603);
            }
        } else {
             lastError = new RpcError(`An unknown error occurred during the request to ${url}`, -32603);
        }
        failedNodesInBatch.push(url);
        continue;
      }
    }

    if (this.network.fallbackEnabled && failedNodesInBatch.length === currentBatch.length && currentBatch.length > 0) {
        const remainingNodes = allNodes.slice(currentBatch.length);
        this.network.rpc = [...remainingNodes, ...failedNodesInBatch];
    }
    
    throw lastError || new RpcError('Network is down or all nodes in batch failed', -32000);
  }
}


```

`zil-pay/background/secure/index.ts`:

```ts
export * from './migrator';
export * from './session';

```

`zil-pay/background/secure/migrator.ts`:

```ts
import { BackgroundState, AppearancesTheme } from '../storage/background';
import { ChainConfig } from '../storage/chain';
import { FToken } from '../storage/ftoken';
import { AuthMethod, Wallet, WalletTypes } from '../storage/wallet';
import { Account } from '../storage/account';
import { WalletSettings, RatesApiOptions } from '../storage/settings';
import { HashTypes, WalletHashParams } from '../storage/argon';
import { CipherOrders } from '../../crypto/keychain';
import { ShaAlgorithms } from '../../config/pbkdf2';
import { AddressType } from 'crypto/address';

interface WalletIdentities {
  selectedAddress: number;
  identities: {
    name: string;
    bech32: string;
    index: number;
    base16: string;
    type: number;
    pubKey: string;
    privKey?: string;
    zrc2: Record<string, string>;
    nft: Record<string, unknown>;
  }[];
}

interface TokenData {
  base16: string;
  bech32: string;
  decimals: number;
  name: string;
  symbol: string;
  rate: number;
  pool?: string[];
}

type TokenWithBase16 = { ftoken: FToken; base16: string };

const ZILLIQA_MAINNET_CHAIN = new ChainConfig({
    name: 'Zilliqa',
    chain: 'ZIL',
    logo: 'https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/%{shortName}%/chain/%{dark,light}%.svg',
    rpc: [
      'https://api.zilliqa.com',
      'https://ssn.zilpay.io/api',
      'https://zilliqa.avely.fi/api',
      'https://ssn.zillet.io',
    ],
    features: [],
    ftokens: [
      new FToken({
        native: true,
        logo: 'https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/%{contract_address}%/%{dark,light}%.webp',
        addr: '0x0000000000000000000000000000000000000000',
        name: 'Zilliqa',
        symbol: 'ZIL',
        decimals: 18,
        addrType: AddressType.EthCheckSum,
        balances: {},
        rate: 0,
        default_: true,
        chainHash: 1
      }),
      new FToken({
        native: true,
        logo: 'https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/%{contract_address}%/%{dark,light}%.webp',
        addr: 'zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz',
        name: 'Zilliqa',
        symbol: 'ZIL',
        decimals: 12,
        addrType: AddressType.Bech32,
        balances: {},
        rate: 0,
        default_: true,
        chainHash: 1
      }),
    ],
    chainIds: [32769, 1],
    infoURL: 'https://www.zilliqa.com/',
    shortName: 'zilliqa',
    slip44: 313,
    explorers: [
      {
        name: 'Viewblock',
        url: 'https://viewblock.io/zilliqa',
        icon: 'https://viewblock.io/apple-touch-icon.png',
        standard: 'EIP3091',
      },
      {
        name: 'Otterscan',
        icon: 'https://otterscan.zilliqa.com/assets/otter-DYFeLtFi.png',
        url: 'https://otterscan.zilliqa.com/',
        standard: 'EIP3091',
      },
    ],
    chainId: 1,
    chainHash: 1,
    diffBlockTime: 30,
    ens: null,
    fallbackEnabled: false,
    testnet: false
});

export function migrateToV4(storage: Record<string, unknown>): BackgroundState {
  if (storage['storageVersion'] == 4) {
    return new BackgroundState(storage);
  } else {
      return migrateFromV2orV3(storage);
  }
}

function parseTokens(tokensJson: string, chainHash: number): TokenWithBase16[] {
    const tokens: TokenData[] = JSON.parse(tokensJson);
    return tokens.map(token => ({
      ftoken: new FToken({
        name: token.name,
        symbol: token.symbol,
        decimals: token.decimals,
        addr: token.bech32,
        addrType: AddressType.Bech32,
        logo: `https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/${token.bech32}/%{dark,light}%.webp`,
        balances: {},
        rate: token.rate,
        default_: token.symbol === 'ZIL',
        native: token.base16 === '0x0000000000000000000000000000000000000000',
        chainHash,
      }),
      base16: token.base16,
    }));
  }

function migrateFromV2orV3(storage: Record<string, unknown>): BackgroundState {
    const walletIdentities: WalletIdentities = JSON.parse(storage['wallet-identities'] as string);
    const mainChain = ZILLIQA_MAINNET_CHAIN;
    const cipher = 'guard-configuration' in storage ? CipherOrders.AESGCM256 : CipherOrders.AESCBC;
    const parsedTokens = parseTokens(storage['tokens-list/mainnet'] as string, mainChain.hash());
    let [algorithm, iteractions] = String(storage["guard-configuration"]).split(":");

    if (!iteractions) {
      iteractions = '0';
    }

    if (!algorithm || (algorithm != ShaAlgorithms.sha256 && algorithm != ShaAlgorithms.Sha512)) {
      algorithm = ShaAlgorithms.sha256;
    }

    const accounts = walletIdentities.identities.map(identity => new Account({
        addr: identity.bech32,
        addrType: AddressType.Bech32,
        name: identity.name,
        pubKey: identity.pubKey,
        chainHash: mainChain.hash(),
        chainId: mainChain.chainId,
        slip44: mainChain.slip44,
        index: identity.index,
    }));

    const walletTokens = parsedTokens.map(({ ftoken, base16 }) => {
        const balances: Record<number, string> = {};
        accounts.forEach((_, index) => {
            const identity = walletIdentities.identities[index];
            balances[index] = identity.zrc2[base16.toLowerCase()] || '0';
        });
        return new FToken({ ...ftoken, balances });
    });

    const wallet = new Wallet({
        walletType: WalletTypes.SecretPhrase,
        walletName: 'Zilliqa Wallet',
        authType: AuthMethod.None,
        walletAddress: accounts[0].addr,
        accounts,
        selectedAccount: walletIdentities.selectedAddress,
        tokens: walletTokens, 
        settings: new WalletSettings({
            cipherOrders: [cipher],
            hashFnParams: new WalletHashParams({
                memory: 1024,
                iterations: Number(iteractions),
                threads: 1,
                secret: '',
                hashType: HashTypes.Pbkdf2, 
                hashSize: algorithm ?? ShaAlgorithms.sha256,
            }),
            currencyConvert: storage['selected-currency'],
            ipfsNode: null,
            ensEnabled: false,
            tokensListFetcher: false,
            nodeRankingEnabled: false,
            maxConnections: 10,
            requestTimeoutSecs: 30,
            ratesApiOptions: RatesApiOptions.CoinGecko,
        }),
        defaultChainHash: mainChain.hash(),
        vault: storage.vault,
    });

    const backgroundState = new BackgroundState({
        wallets: [wallet],
        notificationsGlobalEnabled: true,
        locale: 'auto',
        appearances: AppearancesTheme.System,
        abbreviatedNumber: true,
        hideBalance: false,
        chains: [mainChain], 
    });

    return backgroundState;
}


```

`zil-pay/background/secure/session.ts`:

```ts
import { AESCipherV3 } from '../../crypto/aes256';
import { uint8ArrayToBase64, base64ToUint8Array } from '../../crypto/b64';
import { randomBytes } from '../../crypto/random';
import { Runtime } from '../../lib/runtime';

export enum SessionStorageKeys {
  EndSession = 'SESSION_END',
  SessionKey = 'SESSION_KEY',
  VaultCipher = 'VAULT_CIPHER',
}

export class Session {
  #uuid: string;

  constructor(uuid: string) {
    Runtime.storage.session.setAccessLevel({ accessLevel: 'TRUSTED_CONTEXTS' });
    this.#uuid = uuid;
  }

  private getKey(key: SessionStorageKeys): string {
    return `${key}:${this.#uuid}`;
  }

  async setSession(sessionTime: number, vaultContent: Uint8Array): Promise<void> {
    const endSession = Date.now() + sessionTime * 1000;
    const key = randomBytes(32);
    const vaultCipher = AESCipherV3.encrypt(vaultContent, key);

    const data = {
      [this.getKey(SessionStorageKeys.EndSession)]: endSession,
      [this.getKey(SessionStorageKeys.SessionKey)]: uint8ArrayToBase64(key),
      [this.getKey(SessionStorageKeys.VaultCipher)]: uint8ArrayToBase64(vaultCipher),
    };
    await Runtime.storage.session.set(data);
  }

  async clearSession(): Promise<void> {
    await Runtime.storage.session.clear();
  }

  async getVault(): Promise<Uint8Array> {
    const data = await Runtime.storage.session.get([
      this.getKey(SessionStorageKeys.EndSession),
      this.getKey(SessionStorageKeys.SessionKey),
      this.getKey(SessionStorageKeys.VaultCipher),
    ]);

    const endSession = data[this.getKey(SessionStorageKeys.EndSession)];
    if (!endSession) {
      throw new Error('Session does not exist');
    }
    if (Date.now() > endSession) {
      await this.clearSession();
      throw new Error('Session has expired');
    }

    const sessionKeyBase64 = data[this.getKey(SessionStorageKeys.SessionKey)];
    const vaultCipherBase64 = data[this.getKey(SessionStorageKeys.VaultCipher)];

    if (!sessionKeyBase64 || !vaultCipherBase64) {
      throw new Error('Session data is incomplete');
    }

    const sessionKey = base64ToUint8Array(sessionKeyBase64);
    const vaultCipher = base64ToUint8Array(vaultCipherBase64);

    return AESCipherV3.decrypt(vaultCipher, sessionKey);
  }
}

```

`zil-pay/background/services/index.ts`:

```ts
export * from './guard';


```

`zil-pay/background/storage/account.ts`:

```ts
import type { AddressType } from 'crypto/address';
import { utils } from 'aes-js';
import { ChainConfig } from './chain';
import { KeyPair } from 'crypto/keypair';

export interface Bip32Account {
  name: string;
  index: number;
}

export class Account {
  addr: string;
  addrType: AddressType;
  name: string;
  pubKey: string;
  chainHash: number;
  chainId: number;
  slip44: number;
  index: number;

  constructor(data: Record<string, unknown>) {
    this.addr = data.addr as string;
    this.addrType = data.addrType as AddressType;
    this.name = data.name as string;
    this.pubKey = data.pubKey as string;
    this.chainHash = data.chainHash as number;
    this.chainId = data.chainId as number;
    this.slip44 = data.slip44 as number;
    this.index = data.index as number;
  }

  static async fromBip39(bip32Account: Bip32Account, chain: ChainConfig, seed: Uint8Array): Promise<Account> {
    const keyPair = await KeyPair.fromSeed(seed, chain.slip44, bip32Account.index);
    const addrType = keyPair.addressType();
    const addr = await keyPair.address();
    const account = new Account({
      addr,
      addrType,
      name: bip32Account.name,
      index: bip32Account.index,
      pubKey: utils.hex.fromBytes(keyPair.pubKey),
      chainHash: chain.hash(),
      slip44: chain.slip44,
      chainId: chain.chainId,
    });

    return account;
  }

  static async fromPrivateKey(privateKey: Uint8Array, chain: ChainConfig, name: string): Promise<Account> {
    const keyPair = await KeyPair.fromPrivateKey(privateKey, chain.slip44);
    const addrType = keyPair.addressType();
    const addr = await keyPair.address();

    const account = new Account({
      addr,
      addrType,
      name: name,
      index: 0,
      pubKey: utils.hex.fromBytes(keyPair.pubKey),
      chainHash: chain.hash(),
      slip44: chain.slip44,
      chainId: chain.chainId,
    });

    return account;
  }
}

```

`zil-pay/background/storage/argon.ts`:

```ts
import type { Argon2Config } from '../../crypto/argon2';
import { Variant, Version, Config } from '@hicaru/argon2-pure.js';
import { APP_ID } from '../../config/argon2';
import { deriveArgon2Key } from '../../crypto/argon2';
import { ShaAlgorithms } from '../../config/pbkdf2';
import { KeyChain } from '../../crypto/keychain';
import { hexToUint8Array } from 'lib/utils/hex';

export enum HashTypes {
  Argon2,
  Pbkdf2,
}

export class WalletHashParams {
  memory: number;
  iterations: number;
  threads: number;
  secret: string;
  hashType: HashTypes;
  hashSize: ShaAlgorithms;

  get argon2(): Argon2Config {
    return new Config(
      APP_ID,
      64,
      this.threads,
      this.memory,
      hexToUint8Array(this.secret),
      this.iterations,
      Variant.Argon2id,
      Version.Version13,
    );
  }

  static default(): WalletHashParams {
    const original = Config.original();

    return new WalletHashParams({
      memory: original.memCost, 
      threads: original.lanes,
      secret: original.secret,
      iterations: original.timeCost,
      hashType: HashTypes.Argon2,
      hashSize: ShaAlgorithms.Sha512,
    });
  }

  static pq(): WalletHashParams {
    return new WalletHashParams({
      memory: 2097152, 
      threads: 2,
      secret: new Uint8Array(),
      iterations: 1,
      hashType: HashTypes.Argon2,
      hashSize: ShaAlgorithms.Sha512,
    });
  }


  constructor(data: Record<string, unknown>) {
    this.memory = data.memory as number;
    this.iterations = data.iterations as number;
    this.threads = data.threads as number;
    this.secret = data.secret as string;
    this.hashType = data.hashType as HashTypes;
    this.hashSize = data.hashSize as ShaAlgorithms;
  }

  async deriveKey(password: Uint8Array, salt: Uint8Array): Promise<KeyChain> {
    if (this.hashType == HashTypes.Argon2) {
      const seed = deriveArgon2Key(password, salt, this.argon2);      
      return KeyChain.fromSeed(seed);
    } else if(ShaAlgorithms.Sha512 == this.hashSize) {
      return KeyChain.fromAesV3(password, this.hashSize, this.iterations);
    } else {
      return KeyChain.fromAesV2(password);
    }
  }
}

```

`zil-pay/background/storage/background.ts`:

```ts
import { ChainConfig } from './chain';
import { Wallet } from './wallet';

export enum AppearancesTheme {
  System,
  Dark,
  Light
}

export class BackgroundState {
  readonly storageVersion  = 4;
  wallets: Wallet[];
  notificationsGlobalEnabled: boolean;
  locale: string | null;
  appearances: AppearancesTheme;
  abbreviatedNumber: boolean;
  hideBalance: boolean;
  chains: ChainConfig[];

  constructor(data: Record<string, unknown>) {
    this.wallets = (data.wallets as Record<string, unknown>[]).map(
      (w) => new Wallet(w)
    );
    this.notificationsGlobalEnabled = data.notificationsGlobalEnabled as boolean;
    this.locale = data.locale as string | null ?? null;
    this.appearances = data.appearances as AppearancesTheme;
    this.abbreviatedNumber = data.abbreviatedNumber as boolean;
    this.hideBalance= data.hideBalance as boolean;
    this.chains = (data.chains as Record<string, unknown>[]).map(
      (c) => new ChainConfig(c)
    );
  }
}

```

`zil-pay/background/storage/chain.ts`:

```ts
import { FToken } from './ftoken';
import { Explorer } from './explorer';
import { KeyPair } from 'crypto/keypair';

function hashNumber(hash: number, value: number): number {
  hash = (hash << 5) - hash + value;
  return hash >>> 0; 
}

function hashString(hash: number, str: string): number {
  for (let i = 0; i < str.length; i++) {
    hash = (hash << 5) - hash + str.charCodeAt(i);
    hash = hash >>> 0; 
  }
  return hash;
}

function hashChainConfig(chainIds: number[], slip44: number, chain: string): number {
  let hash = 0;
  const chainIdsSum = chainIds[0] + chainIds[1];
  hash = hashNumber(hash, chainIdsSum);
  hash = hashNumber(hash, slip44);
  hash = hashString(hash, chain);
  return hash >>> 0;
}

export class ChainConfig {
  name: string;
  logo: string;
  chain: string;
  shortName: string;
  rpc: string[];
  features: number[];
  chainId: number;
  chainIds: number[];
  slip44: number;
  diffBlockTime: number;
  ens: string | null;
  explorers: Explorer[];
  fallbackEnabled: boolean;
  testnet: boolean | null;
  ftokens: FToken[];

  constructor(data: Record<string, unknown>) {
    this.name = data.name as string;
    this.logo = data.logo as string;
    this.chain = data.chain as string;
    this.shortName = data.shortName as string;
    this.rpc = data.rpc as string[];
    this.features = data.features as number[];
    this.chainIds = data.chainIds as number[];
    this.chainId = this.chainIds[0];
    this.slip44 = data.slip44 as number;
    this.diffBlockTime = data.diffBlockTime as number;
    this.ens = data.ens as string | null ?? null;
    this.explorers = (data.explorers as Record<string, unknown>[]).map(
      (e) => new Explorer(e)
    );
    this.fallbackEnabled = data.fallbackEnabled as boolean;
    this.testnet = data.testnet as boolean | null ?? null;
    this.ftokens = (data.ftokens as Record<string, unknown>[]).map(
      (t) => new FToken({
        ...t,
        default_: true,
        rate: 0,
        chainHash: t.chainHash ?? hashChainConfig(this.chainIds, this.slip44, this.chain),
        addrType: KeyPair.addressType(this.slip44),
        balances: t.balances ?? {},
      })
    );
  }

  hash(): number {
    return hashChainConfig(this.chainIds, this.slip44, this.chain);
  }
}

```

`zil-pay/background/storage/explorer.ts`:

```ts
export class Explorer {
  name: string;
  url: string;
  icon: string | null;
  standard: number;

  constructor(data: Record<string, unknown>) {
    this.name = data.name as string;
    this.url = data.url as string;
    this.icon = data.icon as string | null ?? null;
    this.standard = data.standard as number;
  }
}

```

`zil-pay/background/storage/ftoken.ts`:

```ts
import type { AddressType } from "crypto/address";

export class FToken {
  name: string;
  symbol: string;
  decimals: number;
  addr: string;
  addrType: AddressType;
  logo: string | null;
  balances: Record<number, string>;
  rate: number;
  default_: boolean;
  native: boolean;
  chainHash: number;

  constructor(data: Record<string, unknown>) {
    this.name = data.name as string;
    this.symbol = data.symbol as string;
    this.decimals = data.decimals as number;
    this.addr = data.addr as string;
    this.addrType = data.addrType as AddressType;
    this.logo = data.logo as string | null ?? null;
    this.balances = data.balances as Record<number, string>;
    this.rate = data.rate as number;
    this.default_ = data.default_ as boolean;
    this.native = data.native as boolean;
    this.chainHash = data.chainHash as number;
  }
}

```

`zil-pay/background/storage/index.ts`:

```ts
export * from './account';
export * from './argon';
export * from './background';
export * from './chain';
export * from './explorer';
export * from './ftoken';
export * from './notification';
export * from './settings';
export * from './wallet';

```

`zil-pay/background/storage/notification.ts`:

```ts
export class Notification {
  transactions: boolean;

  constructor(data: Record<string, unknown>) {
    this.transactions = data.transactions as boolean;
  }
}

```

`zil-pay/background/storage/settings.ts`:

```ts
import { WalletHashParams } from './argon';
import { CipherOrders } from '../../crypto/keychain';

export enum RatesApiOptions {
  CoinGecko
} 

export class WalletSettings {
  cipherOrders: CipherOrders[];
  hashFnParams: WalletHashParams;
  currencyConvert: string;
  ipfsNode: string | null;
  ensEnabled: boolean;
  tokensListFetcher: boolean;
  nodeRankingEnabled: boolean;
  maxConnections: number;
  requestTimeoutSecs: number;
  ratesApiOptions: RatesApiOptions;
  sessionTime: number;

  constructor(data: Record<string, unknown>) {
    this.cipherOrders = data.cipherOrders as CipherOrders[];
    this.hashFnParams = new WalletHashParams(data.hashFnParams as Record<string, unknown>);
    this.currencyConvert = data.currencyConvert as string;
    this.ipfsNode = data.ipfsNode as string || null;
    this.ensEnabled = data.ensEnabled as boolean;
    this.tokensListFetcher = data.tokensListFetcher as boolean;
    this.nodeRankingEnabled = data.nodeRankingEnabled as boolean;
    this.maxConnections = data.maxConnections as number;
    this.requestTimeoutSecs = data.requestTimeoutSecs as number;
    this.ratesApiOptions = data.ratesApiOptions as RatesApiOptions;
    this.sessionTime = data.sessionTime as number ?? 3600;
  }
}

```

`zil-pay/background/storage/wallet.ts`:

```ts
import type { Bip32Account } from './account';
import { base64ToUint8Array, uint8ArrayToBase64 } from '../../crypto/b64';
import { generateSalt } from '../../lib/runtime';
import { Account } from './account';
import { FToken } from './ftoken';
import { WalletSettings } from './settings';
import { Session } from '../secure/session';
import { ChainConfig } from './chain';
import { Bip39 } from '../../crypto/bip39';
import { uuid } from '../../crypto/uuid';
import { TypeOf } from 'lib/types';
import { KeyPair } from 'crypto/keypair';
import { uint8ArrayToUtf8, utf8ToUint8Array } from 'lib/utils/utf8';

export enum WalletTypes {
    Ledger,
    SecretPhrase,
    SecretKey,
}

export enum AuthMethod {
    Biometric,
    None,
}

export class Wallet {
  #session: Session;

  uuid: string;
  walletType: WalletTypes;
  walletName: string;
  authType: AuthMethod;
  accounts: Account[];
  selectedAccount: number;
  tokens: FToken[];
  settings: WalletSettings;
  defaultChainHash: number;
  vault: string;

  constructor(data: Record<string, unknown>) {
    this.walletType = data.walletType as WalletTypes;
    this.walletName = data.walletName as string;
    this.authType = data.authType as AuthMethod;
    this.accounts = (data.accounts as Record<string, unknown>[]).map(
      (a) => new Account(a)
    );
    this.selectedAccount = data.selectedAccount as number;
    this.tokens = (data.tokens as Record<string, unknown>[]).map(
      (t) => new FToken(t)
    );
    this.settings = new WalletSettings(data.settings as Record<string, unknown>);
    this.defaultChainHash = data.defaultChainHash as number;
    this.uuid = data.uuid as string;
    this.#session = new Session(this.uuid);

    this.vault = data.vault as string ?? "";
  }

  static async fromBip39(
    words: string,
    verifyCheckSum: boolean,
    walletName: string,
    bip32Accounts: Bip32Account[],
    settings: WalletSettings,
    chain: ChainConfig,
    password: string,
    wordList: string[],
    passphrase?: string
  ) {
    if (verifyCheckSum) {
      await Bip39.validateMnemonic(words, wordList);
    }

    const seed = await Bip39.mnemonicToSeed(words, passphrase);
    const wallet = new Wallet({
      settings,
      walletName,
      walletType: WalletTypes.SecretPhrase,
      selectedAccount: 0,
      tokens: chain.ftokens,
      defaultChainHash: chain.hash(),
      uuid: uuid(),
      accounts: [],
      authType: AuthMethod.None,
    });
    const passwordBytes = utf8ToUint8Array(password);
    const wordsBytes = utf8ToUint8Array(words);

    wallet.accounts = await Promise.all(bip32Accounts.map((acc) => Account.fromBip39(acc, chain, seed)));
    await wallet.encrypt(passwordBytes, wordsBytes);

    return wallet;
  }

  async decrypt(password: Uint8Array): Promise<Uint8Array | string> {
    const salt = await generateSalt();
    const keychain = await this.settings.hashFnParams.deriveKey(password, salt);
    const ciphertext = base64ToUint8Array(this.vault);
    const decrypted = await keychain.decrypt(ciphertext, this.settings.cipherOrders);

    if (this.walletType == WalletTypes.SecretKey) {      
      return decrypted;
    } else if (this.walletType == WalletTypes.SecretPhrase) {
      return uint8ArrayToUtf8(decrypted);
    } else {
      throw new Error("unknown wallet type");
    }
  }

  async encrypt(password: Uint8Array, plaintext: Uint8Array) : Promise<Uint8Array>{
    const salt = await generateSalt();
    const keychain = await this.settings.hashFnParams.deriveKey(password, salt);
    const cipher = await keychain.encrypt(plaintext, this.settings.cipherOrders);

    this.vault = uint8ArrayToBase64(cipher);

    return cipher;
  }

  async unlock(password: Uint8Array) {
    const wordsOrKey = await this.decrypt(password);
    const sessionTime = this.settings.sessionTime;

    if (TypeOf.isString(wordsOrKey)) {
      const seed = await Bip39.mnemonicToSeed(String(wordsOrKey));

      await this.#session.setSession(sessionTime, seed);
    } else if (wordsOrKey instanceof Uint8Array) {
      await this.#session.setSession(sessionTime, wordsOrKey);
    } else {
      throw new Error("unk vault");
    }
  }

  async revealKeypair(accountIndex: number, chain: ChainConfig): Promise<KeyPair> {
    if (chain.hash() !== this.defaultChainHash) {
      throw new Error("invlid chain");
    }

    switch (this.walletType) {
      case WalletTypes.SecretPhrase:
        const seed = await this.#session.getVault();
        return KeyPair.fromSeed(seed, chain.slip44, accountIndex);
      case WalletTypes.SecretKey:
        const privateKey = await this.#session.getVault();
        return KeyPair.fromPrivateKey(privateKey, chain.slip44);
      default:
        throw new Error(`Invalid wallet type ${WalletTypes[this.walletType]}`);
    }
  }

  async revealMnemonic(password: Uint8Array, chain: ChainConfig): Promise<string> {
    if (chain.hash() !== this.defaultChainHash) {
      throw new Error("invlid chain");
    }

    switch (this.walletType) {
      case WalletTypes.SecretPhrase:
        const words = await this.decrypt(password);

        return String(words);
      default:
        throw new Error(`Invalid wallet type ${WalletTypes[this.walletType]}`);
    }
  }
}

```

`zil-pay/compile-protos.mjs`:

```mjs
import { readdirSync } from 'fs';
import { join, basename, extname } from 'path';
import { execSync } from 'child_process';

const protoDir = 'crypto/proto/';
const outputDir = 'crypto/proto/';

const protoFiles = readdirSync(protoDir).filter(file => extname(file) === '.proto');

protoFiles.forEach(protoFile => {
  const protoPath = join(protoDir, protoFile);
  const name = basename(protoFile, '.proto');
  const tsOutput = join(outputDir, `${name}.ts`);

  try {
    execSync(`npx pbjs --ts ${tsOutput} ${protoPath}`, { stdio: 'inherit' });
  } catch (error) {
    console.error(`Failed to process ${protoFile}:`, error.message);
    process.exit(1);
  }
});

```

`zil-pay/config/argon2.ts`:

```ts
import { utils } from "aes-js";

export const WALLET_SALT = utils.utf8.toBytes(
  "ZILPAY:54040c2f-1ec1-4eb1-9595-6e4294d14fd6",
);
export const APP_ID = utils.utf8.toBytes("ZilPay-wallet-app");

```

`zil-pay/config/common.ts`:

```ts
export enum Common {
  TIME_BEFORE_LOCK = 3,
  POPUP_WIDTH = 320,
  POPUP_HEIGHT = 600,
  PROMT_PAGE = "index.html",
  NONCE_DIFFICULTY = 10,
  MAX_TX_QUEUE = 20,
}

export const WORKER_POOLING = 8000; // Seconds

```

`zil-pay/config/fields.ts`:

```ts
export enum OldFields {
  VAULT = "vault",
  VAULT_IMPORTED = "importedvault",
  CONFIG = "config",
  OLD_WALLET = "wallet",
  WALLET = "wallet-identities",
  SELECTED_NET = "selectednet",
  BLOCK_NUMBER = "blocknumber",
  TRANSACTIONS = "transactions",
  ENCRYPT_DATA = "encryption-data",
  DECRYPT_DATA = "decryption-data",
  CONFIRM_TX = "confirm",
  CONFIRM_MESSAGE = "confirm-message",
  STATIC = "static",
  LOCK_TIME = "time_before_lock",
  GUARD_CONFIG = "guard-configuration",
  CONNECT_DAPP = "connect",
  CONNECT_LIST = "connection-list",
  THEME = "theme",
  CONTACTS = "contacts",
  SELECTED_COIN = "selectedcoin",
  TOKENS = "tokens-list",
  COLLECTION = "collections-list",
  SSN = "ssn-list",
  GAS = "chain-gas",
  RATE_CURRENCIES = "rate-of-currencies",
  SELECTED_CURRENCY = "selected-currency",
  LOCALE = "selected-local",
  FORMAT = "address-format",
  POPUP_ENABLED = "popup-enabled",
  PHISHING = "phishing-detection",
  DEX = "dex-proto",
  BADGE_COUNTER = "badge-counter",
}

```

`zil-pay/config/jsonrpc.ts`:

```ts
/**
 * Enum for Zilliqa JSON-RPC methods.
 */
export enum ZilMethods {
  GetSmartContractInit = "GetSmartContractInit",
  GetBalance = "GetBalance",
  GetSmartContractSubState = "GetSmartContractSubState",
  GetNetworkId = "GetNetworkId",
  GetPendingTxn = "GetPendingTxn",
  GetTransaction = "GetTransaction",
  CreateTransaction = "CreateTransaction",
  GetTransactionStatus = "GetTransactionStatus",
  GetLatestTxBlock = "GetLatestTxBlock",
  GetTxBlock = "GetTxBlock",
  GetRecentTransactions = "GetRecentTransactions",
  GetMinimumGasPrice = "GetMinimumGasPrice",
}

/**
 * Enum for EVM-compatible JSON-RPC methods.
 */
export enum EvmMethods {
  // State Methods
  GetBalance = "eth_getBalance",
  GetStorageAt = "eth_getStorageAt",
  GetTransactionCount = "eth_getTransactionCount",
  GetBlockTransactionCountByHash = "eth_getBlockTransactionCountByHash",
  GetBlockTransactionCountByNumber = "eth_getBlockTransactionCountByNumber",
  GetCode = "eth_getCode",
  Call = "eth_call",
  EstimateGas = "eth_estimateGas",

  // Block Methods
  BlockNumber = "eth_blockNumber",
  GetBlockByHash = "eth_getBlockByHash",
  GetBlockByNumber = "eth_getBlockByNumber",
  GetBlockReceipts = "eth_getBlockReceipts",

  // Transaction Methods
  SendRawTransaction = "eth_sendRawTransaction",
  GetTransactionByHash = "eth_getTransactionByHash",
  GetTransactionByBlockHashAndIndex = "eth_getTransactionByBlockHashAndIndex",
  GetTransactionByBlockNumberAndIndex = "eth_getTransactionByBlockNumberAndIndex",
  GetTransactionReceipt = "eth_getTransactionReceipt",

  // Account Methods
  Accounts = "eth_accounts",
  GetProof = "eth_getProof",

  // Chain State
  ChainId = "eth_chainId",
  NetworkVersion = "net_version",
  Syncing = "eth_syncing",
  GasPrice = "eth_gasPrice",
  MaxPriorityFeePerGas = "eth_maxPriorityFeePerGas",
  FeeHistory = "eth_feeHistory",
  BlobBaseFee = "eth_blobBaseFee",

  // Filter Methods
  NewFilter = "eth_newFilter",
  NewBlockFilter = "eth_newBlockFilter",
  NewPendingTransactionFilter = "eth_newPendingTransactionFilter",
  UninstallFilter = "eth_uninstallFilter",
  GetFilterChanges = "eth_getFilterChanges",
  GetFilterLogs = "eth_getFilterLogs",
  GetLogs = "eth_getLogs",

  // Contract Methods
  Sign = "eth_sign",
  SignTransaction = "eth_signTransaction",
}

```

`zil-pay/config/manifest.ts`:

```ts
export enum ManifestVersions {
  V2 = 2,
  V3 = 3,
}

```

`zil-pay/config/pbkdf2.ts`:

```ts
export enum ShaAlgorithms {
  Sha512 = "SHA-512",
  sha256 = "SHA-256",
}

```

`zil-pay/config/sha.ts`:

```ts
export enum ShaAlgorithms {
  Sha512 = "SHA-512",
  sha256 = "SHA-256",
}

```

`zil-pay/config/slip44.ts`:

```ts
export const ETHEREUM = 60;
export const ZILLIQA = 313;

```

`zil-pay/crypto/address.ts`:

```ts
import { addr as ethAddr } from "micro-eth-signer";
import {
  fromBech32Address,
  fromZilPubKey,
  toBech32Address,
  toChecksumBytesAddress,
} from "lib/zilliqa";
import { KeyPair } from "./keypair";
import { HRP } from "lib/zilliqa/config";
import { hasHexPrefix, hexToUint8Array, uint8ArrayToHex } from "lib/utils/hex";

export enum AddressType {
  Bech32,
  EthCheckSum,
}

export class Address {
  readonly #bytes: Uint8Array;
  #type: AddressType;

  get bytes() {
    return this.#bytes;
  }

  get type() {
    return this.#type;
  }

  static async fromStr(address: string) {
    if (hasHexPrefix(address)) {
      const ethCheckSumAddress = ethAddr.parse(address);
      const bytes = hexToUint8Array(ethCheckSumAddress.data);

      return new Address(bytes, AddressType.EthCheckSum);
    } else if (address.startsWith(HRP)) {
      const checkSumZil = await fromBech32Address(address);
      const bytes = hexToUint8Array(checkSumZil);

      return new Address(bytes, AddressType.Bech32);
    }

    throw new Error("Unsupported address format");
  }

  static async fromPubKey(pubKey: Uint8Array, slip44: number) {
    const addressType = KeyPair.addressType(slip44);

    switch (addressType) {
      case AddressType.Bech32:
        const zilBytes = await fromZilPubKey(pubKey);

        return new Address(zilBytes, addressType);
      case AddressType.EthCheckSum:
        const ethChecsumAddress = ethAddr.fromPublicKey(pubKey);
        const ethBytes = hexToUint8Array(ethChecsumAddress);

        return new Address(ethBytes, addressType);
    }
  }

  static async fromPrivateKey(privateKey: Uint8Array, slip44: number) {
    const keypair = await KeyPair.fromPrivateKey(privateKey, slip44);
    const addressType = keypair.addressType();

    switch (addressType) {
      case AddressType.Bech32:
        const base16 = await fromZilPubKey(keypair.pubKey);
        return new Address(base16, addressType);

      case AddressType.EthCheckSum:
        const ethChecsumAddress = ethAddr.fromPublicKey(keypair.pubKey);
        const ethBytes = hexToUint8Array(ethChecsumAddress);

        return new Address(ethBytes, addressType);
    }
  }

  constructor(bytes: Uint8Array, type: AddressType) {
    this.#bytes = bytes;
    this.#type = type;
  }

  toBase16(): string {
    return uint8ArrayToHex(this.bytes);
  }

  async toEthChecksum(): Promise<string> {
    const nonChecksummedAddress = uint8ArrayToHex(this.bytes);
    return ethAddr.addChecksum(nonChecksummedAddress);
  }

  async toZilChecksum(): Promise<string> {
    return toChecksumBytesAddress(this.bytes);
  }

  async toZilBech32(): Promise<string> {
    const zilChecSum = await this.toZilChecksum();

    return toBech32Address(zilChecSum);
  }
}

```

`zil-pay/crypto/aes256.ts`:

```ts
import { Counter, ModeOfOperation } from "aes-js";
import { randomBytes } from "../crypto/random";
import { md5 } from "js-md5";
import { uint8ArrayToUtf8, utf8ToUint8Array } from "lib/utils/utf8";
import { hexToUint8Array, uint8ArrayToHex } from "lib/utils/hex";

export enum ErrorMessages {
  InvalidKeyLength = "Invalid key length provided. Key must be 16, 24, or 32 bytes.",
  IncorrectParams = "Password is not correct",
}

export const AESCipherV3 = Object.freeze({
  encrypt(content: Uint8Array, key: Uint8Array): Uint8Array {
    if (![16, 24, 32].includes(key.length)) {
      throw new Error(ErrorMessages.InvalidKeyLength);
    }

    const entropy = randomBytes(16);
    const iv = new Counter(entropy);
    const aesCtr = new ModeOfOperation.ctr(key, iv);
    const encrypted = aesCtr.encrypt(content);
    const bytes = utf8ToUint8Array(
      `${uint8ArrayToHex(encrypted)}/${uint8ArrayToHex(entropy)}`,
    );
    return bytes;
  },
  decrypt(bytes: Uint8Array, key: Uint8Array): Uint8Array {
    if (![16, 24, 32].includes(key.length)) {
      throw new Error(ErrorMessages.InvalidKeyLength);
    }

    const [encrypted, iv] = uint8ArrayToUtf8(bytes).split("/");
    const counter = new Counter(hexToUint8Array(iv));
    const aesCtr = new ModeOfOperation.ctr(key, counter);
    return aesCtr.decrypt(hexToUint8Array(encrypted));
  },
});

export const AESCipherV2 = Object.freeze({
  async decrypt(data: Uint8Array, key: Uint8Array): Promise<any> {
    const combined = data;

    const prefix = new TextDecoder().decode(combined.slice(0, 8));
    if (prefix !== "Salted__") {
      throw new Error(ErrorMessages.IncorrectParams);
    }

    const salt = combined.slice(8, 16);
    const ciphertext = combined.slice(16);
    const passwordBytes = key;
    const { key: derivedKey, iv } = await AESCipherV2.evpKDF(
      passwordBytes,
      salt,
      32,
      16,
    );

    const cryptoKey = await crypto.subtle.importKey(
      "raw",
      derivedKey,
      { name: "AES-CBC" },
      false,
      ["decrypt"],
    );

    let decrypted: ArrayBuffer;
    try {
      decrypted = await crypto.subtle.decrypt(
        { name: "AES-CBC", iv },
        cryptoKey,
        ciphertext,
      );
    } catch {
      throw new Error("ErrorMessages.IncorrectPassword");
    }

    const content = new TextDecoder().decode(decrypted);
    if (!content) {
      throw new Error("ErrorMessages.IncorrectPassword");
    }

    try {
      return JSON.parse(content);
    } catch {
      return content;
    }
  },

  async evpKDF(
    password: Uint8Array,
    salt: Uint8Array,
    keySize: number,
    ivSize: number,
  ): Promise<{ key: Uint8Array; iv: Uint8Array }> {
    const totalSize = keySize + ivSize;
    let derived = new Uint8Array(0);
    let previousBlock = new Uint8Array(0);

    while (derived.length < totalSize) {
      const input = new Uint8Array([...previousBlock, ...password, ...salt]);
      const block = await AESCipherV2.md5Hash(input);
      derived = new Uint8Array([...derived, ...block]);
      previousBlock = Uint8Array.from(block);
    }

    const key = derived.slice(0, keySize);
    const iv = derived.slice(keySize, keySize + ivSize);
    return { key, iv };
  },

  async md5Hash(data: Uint8Array): Promise<Uint8Array> {
    const hasher = md5.create();
    hasher.update(data);
    const hash = hasher.arrayBuffer();
    return new Uint8Array(hash);
  },
});

```

`zil-pay/crypto/argon2.ts`:

```ts
import { Config, hashRaw } from "@hicaru/argon2-pure.js";
import { WALLET_SALT } from "../config/argon2";

export type Argon2Config = Config;

export function deriveArgon2Key(
  password: Uint8Array,
  saltBytes: Uint8Array,
  config: Argon2Config,
) {
  const combinedSalt = new Uint8Array(saltBytes.length + WALLET_SALT.length);

  combinedSalt.set(saltBytes, 0);
  combinedSalt.set(WALLET_SALT, saltBytes.length);

  const hash = hashRaw(password, combinedSalt, config);

  return hash;
}

```

`zil-pay/crypto/b64.ts`:

```ts
/**
 * Converts a base64 string to a Uint8Array.
 * @param base64 - The base64 string to convert.
 * @returns A Uint8Array containing the decoded data.
 * @throws {Error} If the input string is not a valid base64 string.
 */
export function base64ToUint8Array(base64: string): Uint8Array {
  try {
    const binaryString = atob(base64);
    const length = binaryString.length;
    const bytes = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  } catch (error) {
    throw new Error("Invalid base64 string");
  }
}

/**
 * Converts a Uint8Array to a base64 string.
 * @param uint8Array - The Uint8Array to convert.
 * @returns A base64 string representing the input data.
 */
export function uint8ArrayToBase64(uint8Array: Uint8Array): string {
  const binaryString = String.fromCharCode(...uint8Array);
  return btoa(binaryString);
}

```

`zil-pay/crypto/bip32.ts`:

```ts
import { getPublicKey } from "@noble/secp256k1";
import { utils } from "@noble/secp256k1";
import {
  bigIntToUint8ArrayBigEndian,
  uint8ArrayToBigIntBigEndian,
} from "./number";
import { ShaAlgorithms } from "../config/pbkdf2";
import { ETHEREUM, ZILLIQA } from "../config/slip44";

const HARDENED_BIT = 0x80000000;
const BITCOIN_SEED = new TextEncoder().encode("Bitcoin seed");

export enum Bip32ErrorCode {
  InvalidChild = "InvalidChild",
  InvalidPath = "InvalidPath",
  InvalidSlip44 = "invalid slip44",
  InvalidKey = "InvalidKey",
  HmacError = "HmacError",
}

export class Bip32Error extends Error {
  constructor(code: Bip32ErrorCode, message: string) {
    super(message);
    this.name = `Bip32Error:${code}`;
  }
}

export class ChildNumber {
  constructor(public value: number) {}

  isHardened(): boolean {
    return this.value < 0;
  }

  toBytes(): Uint8Array {
    const buffer = new Uint8Array(4);
    buffer[0] = (this.value >>> 24) & 0xff;
    buffer[1] = (this.value >>> 16) & 0xff;
    buffer[2] = (this.value >>> 8) & 0xff;
    buffer[3] = this.value & 0xff;
    return buffer;
  }

  static fromString(s: string): ChildNumber {
    let numStr = s;
    let hardened = false;
    if (s.endsWith("'")) {
      numStr = s.slice(0, -1);
      hardened = true;
    }
    const index = parseInt(numStr, 10);
    if (isNaN(index) || index < 0) {
      throw new Bip32Error(
        Bip32ErrorCode.InvalidChild,
        `Failed to parse child number: ${s}`,
      );
    }
    const value = hardened ? index | HARDENED_BIT : index;
    return new ChildNumber(value);
  }
}

async function hmacSha512(
  key: Uint8Array,
  data: Uint8Array,
): Promise<Uint8Array> {
  try {
    const importedKey = await globalThis.crypto.subtle.importKey(
      "raw",
      key,
      {
        name: "HMAC",
        hash: { name: ShaAlgorithms.Sha512 },
      },
      false,
      ["sign"],
    );

    const signature = await globalThis.crypto.subtle.sign(
      "HMAC",
      importedKey,
      data,
    );

    return new Uint8Array(signature);
  } catch (error) {
    throw new Bip32Error(
      Bip32ErrorCode.HmacError,
      `HMAC computation failed: ${error}`,
    );
  }
}

export async function deriveMasterKey(
  seed: Uint8Array,
): Promise<{ key: Uint8Array; chainCode: Uint8Array }> {
  const hmacResult = await hmacSha512(BITCOIN_SEED, seed);
  const key = new Uint8Array(hmacResult.slice(0, 32));
  const chainCode = new Uint8Array(hmacResult.slice(32, 64));

  if (!utils.isValidPrivateKey(key)) {
    throw new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid master key");
  }

  return { key, chainCode };
}

export async function deriveChildKey(
  parentKey: Uint8Array,
  chainCode: Uint8Array,
  child: ChildNumber,
): Promise<{ key: Uint8Array; chainCode: Uint8Array }> {
  if (!utils.isValidPrivateKey(parentKey)) {
    throw new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid parent key");
  }

  let dataToHash: Uint8Array;

  if (child.isHardened()) {
    dataToHash = new Uint8Array([0, ...parentKey, ...child.toBytes()]);
  } else {
    const publicKey = getPublicKey(parentKey, true);
    dataToHash = new Uint8Array([...publicKey, ...child.toBytes()]);
  }

  const hmacResult = await hmacSha512(chainCode, dataToHash);
  const childKeyPart = new Uint8Array(hmacResult.slice(0, 32));
  const newChainCode = new Uint8Array(hmacResult.slice(32, 64));

  const curveOrder = BigInt(
    "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141",
  );

  let parentScalar = uint8ArrayToBigIntBigEndian(parentKey);
  let childScalar = uint8ArrayToBigIntBigEndian(childKeyPart);

  childScalar = childScalar % curveOrder;

  let sum = (parentScalar + childScalar) % curveOrder;

  if (sum === 0n) {
    throw new Bip32Error(
      Bip32ErrorCode.InvalidKey,
      "Invalid child key: sum is zero",
    );
  }

  const resultKey = bigIntToUint8ArrayBigEndian(sum, 32);

  if (!utils.isValidPrivateKey(resultKey)) {
    throw new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid child key");
  }

  return { key: resultKey, chainCode: newChainCode };
}

export async function derivePrivateKey(
  seed: Uint8Array,
  path: string,
): Promise<Uint8Array> {
  if (!path.startsWith("m/")) {
    throw new Bip32Error(
      Bip32ErrorCode.InvalidPath,
      "Path must start with 'm/'",
    );
  }

  const pathParts = path
    .slice(2)
    .split("/")
    .filter((part) => part !== "");

  let { key, chainCode } = await deriveMasterKey(seed);

  for (const part of pathParts) {
    const childNumber = ChildNumber.fromString(part);
    const result = await deriveChildKey(key, chainCode, childNumber);
    key = result.key;
    chainCode = result.chainCode;
  }

  return key;
}

export async function deriveFromPrivateKeyPublicKey(
  privateKey: Uint8Array,
  slip44: number,
  compressed = true,
): Promise<Uint8Array> {
  if (slip44 == ZILLIQA || slip44 == ETHEREUM) {
    return getPublicKey(privateKey, compressed);
  }

  throw new Error(Bip32ErrorCode.InvalidSlip44);
}

```

`zil-pay/crypto/bip39.ts`:

```ts
import { pbkdf2 } from "./pbkdf2";
import { ShaAlgorithms } from "../config/pbkdf2";
import { randomBytes } from "./random";
import { assert } from "../lib/runtime/assert";
import { sha256 } from "./sha256";

// BIP-39 constants
const ENTROPY_BITS = [128, 160, 192, 224, 256];
const PBKDF2_ITERATIONS = 2048;
const SEED_LENGTH = 64; // 512 bits

export interface Mnemonic {
  phrase: string;
  words: string[];
}

export enum Bip39Error {
  InvalidEntropy = "Invalid entropy length. Must be 128, 160, 192, 224, or 256 bits.",
  InvalidMnemonic = "Invalid mnemonic phrase.",
  InvalidWord = "Mnemonic contains invalid word(s) not in wordlist.",
  InvalidWordCount = "Invalid number of words. Must be 12, 15, 18, 21, or 24.",
  InvalidChecksum = "Mnemonic checksum is invalid.",
}

export const Bip39 = Object.freeze({
  /**
   * Generates a BIP-39 mnemonic from random entropy.
   * @param entropyBits - Number of entropy bits (128, 160, 192, 224, or 256).
   * @returns A mnemonic object with phrase and words.
   * @throws Error if entropyBits is invalid.
   */
  async generateMnemonic(
    entropyBits: number = 128,
    wordList: string[],
  ): Promise<Mnemonic> {
    assert(ENTROPY_BITS.includes(entropyBits), Bip39Error.InvalidEntropy);

    const entropyBytes = entropyBits / 8;
    const entropy = randomBytes(entropyBytes);
    const checksumBits = entropyBits / 32;
    const totalBits = entropyBits + checksumBits;
    const wordCount = totalBits / 11;

    // Compute SHA-256 checksum
    const hash = await sha256(entropy);
    const checksum = hash[0] >> (8 - checksumBits);

    // Combine entropy and checksum
    const entropyBitsStr = Array.from(entropy)
      .map((byte) => byte.toString(2).padStart(8, "0"))
      .join("");
    const checksumBitsStr = checksum.toString(2).padStart(checksumBits, "0");
    const bits = entropyBitsStr + checksumBitsStr;

    // Split into 11-bit chunks to select words
    const words: string[] = [];
    for (let i = 0; i < wordCount; i++) {
      const start = i * 11;
      const chunk = bits.slice(start, start + 11);
      const index = parseInt(chunk, 2);
      words.push(wordList[index]);
    }

    return {
      phrase: words.join(" "),
      words,
    };
  },

  /**
   * Validates a BIP-39 mnemonic phrase.
   * @param mnemonic - The mnemonic phrase to validate.
   * @returns True if valid, throws error otherwise.
   * @throws Error if mnemonic is invalid.
   */
  async validateMnemonic(
    mnemonic: string,
    wordList: string[],
  ): Promise<boolean> {
    const words = mnemonic.trim().split(/\s+/);
    const wordCount = words.length;
    const validWordCounts = [12, 15, 18, 21, 24];

    assert(validWordCounts.includes(wordCount), Bip39Error.InvalidWordCount);

    // Verify all words are in wordlist
    for (const word of words) {
      assert(wordList.includes(word), `${Bip39Error.InvalidWord}, ${word}`);
    }

    // Reconstruct entropy and checksum
    const bits = words
      .map((word) => {
        const index = wordList.indexOf(word);
        return index.toString(2).padStart(11, "0");
      })
      .join("");

    const entropyBits = wordCount * 11 - wordCount / 3;
    const entropy = bits.slice(0, entropyBits);
    const checksum = bits.slice(entropyBits);

    // Convert entropy bits to bytes
    const entropyBytes = new Uint8Array(entropyBits / 8);
    for (let i = 0; i < entropyBytes.length; i++) {
      entropyBytes[i] = parseInt(entropy.slice(i * 8, (i + 1) * 8), 2);
    }

    // Verify checksum
    const hash = await sha256(entropyBytes);
    const computedChecksum = hash[0] >> (8 - wordCount / 3);
    const expectedChecksum = parseInt(checksum, 2);

    assert(computedChecksum === expectedChecksum, Bip39Error.InvalidChecksum);

    return true;
  },

  /**
   * Derives a seed from a BIP-39 mnemonic using PBKDF2.
   * @param mnemonic - The mnemonic phrase.
   * @param passphrase - Optional passphrase (default: empty string).
   * @returns A 512-bit seed as Uint8Array.
   * @throws Error if mnemonic is invalid.
   */
  async mnemonicToSeed(
    mnemonic: string,
    passphrase: string = "",
  ): Promise<Uint8Array> {
    const password = new TextEncoder().encode(mnemonic);
    const salt = new TextEncoder().encode(`mnemonic${passphrase}`);
    const seed = await pbkdf2(
      password,
      salt,
      PBKDF2_ITERATIONS,
      ShaAlgorithms.Sha512,
    );

    return seed;
  },

  /**
   * Converts a mnemonic to entropy.
   * @param mnemonic - The mnemonic phrase.
   * @returns The original entropy as Uint8Array.
   * @throws Error if mnemonic is invalid.
   */
  async mnemonicToEntropy(
    mnemonic: string,
    wordList: string[],
  ): Promise<Uint8Array> {
    assert(
      await Bip39.validateMnemonic(mnemonic, wordList),
      Bip39Error.InvalidMnemonic,
    );

    const words = mnemonic.trim().split(/\s+/);
    const wordCount = words.length;
    const entropyBits = wordCount * 11 - wordCount / 3;

    const bits = words
      .map((word) => {
        const index = wordList.indexOf(word);
        return index.toString(2).padStart(11, "0");
      })
      .join("");

    const entropy = bits.slice(0, entropyBits);
    const entropyBytes = new Uint8Array(entropyBits / 8);
    for (let i = 0; i < entropyBytes.length; i++) {
      entropyBytes[i] = parseInt(entropy.slice(i * 8, (i + 1) * 8), 2);
    }

    return entropyBytes;
  },

  /**
   * Converts entropy to a BIP-39 mnemonic phrase.
   * @param entropy - The entropy as a Uint8Array (must be 16, 20, 24, 28, or 32 bytes).
   * @param wordList - The BIP-39 wordlist.
   * @returns A mnemonic object with phrase and words.
   * @throws Error if entropy length is invalid.
   */
  async entropyToMnemonic(
    entropy: Uint8Array,
    wordList: string[],
  ): Promise<Mnemonic> {
    const entropyBits = entropy.length * 8;
    assert(ENTROPY_BITS.includes(entropyBits), Bip39Error.InvalidEntropy);

    const checksumBits = entropyBits / 32;
    const totalBits = entropyBits + checksumBits;
    const wordCount = totalBits / 11;

    // Compute SHA-256 checksum
    const hash = await sha256(entropy);
    const checksum = hash[0] >> (8 - checksumBits);

    // Combine entropy and checksum
    const entropyBitsStr = Array.from(entropy)
      .map((byte) => byte.toString(2).padStart(8, "0"))
      .join("");
    const checksumBitsStr = checksum.toString(2).padStart(checksumBits, "0");
    const bits = entropyBitsStr + checksumBitsStr;

    // Split into 11-bit chunks to select words
    const words: string[] = [];
    for (let i = 0; i < wordCount; i++) {
      const start = i * 11;
      const chunk = bits.slice(start, start + 11);
      const index = parseInt(chunk, 2);
      words.push(wordList[index]);
    }

    return {
      phrase: words.join(" "),
      words,
    };
  },
});

```

`zil-pay/crypto/bip49.ts`:

```ts
import { ZILLIQA, ETHEREUM } from "../config/slip44";

export class DerivationPath {
  private slip44: number;
  private index: number;

  constructor(slip44: number, index: number) {
    this.slip44 = slip44;
    this.index = index;
  }

  public getPath(): string {
    return `m/44'/${this.slip44}'/0'/0/${this.index}`;
  }

  public getBasePath(): string {
    return `m/44'/${this.slip44}'/0'/0/`;
  }

  public getIndex(): number {
    return this.index;
  }

  public toString(): string {
    return this.getPath();
  }
}

```

`zil-pay/crypto/keychain.ts`:

```ts
import type { Argon2Config } from "./argon2";
import { PrivKey, PubKey } from "@hicaru/ntrup.js";
import {
  NTRU_CONFIG,
  ntruDecrypt,
  ntruEncrypt,
  ntruKeysFromSeed,
} from "./ntrup";
import { sha256 } from "./sha256";
import { EXTENSION_ID } from "../lib/runtime";
import { deriveArgon2Key } from "./argon2";
import {
  kuznechikDecrypt,
  kuznechikEncrypt,
  KUZNECHIK_KEY_SIZE,
} from "./kuznechik";
import { AESCipherV3, AESCipherV2 } from "./aes256";
import { pbkdf2 } from "./pbkdf2";
import { ShaAlgorithms } from "../config/pbkdf2";
import { uint8ArrayToHex } from "lib/utils/hex";
import { utf8ToUint8Array } from "lib/utils/utf8";

export const PUBLICKEYS_BYTES = NTRU_CONFIG.PUBLICKEYS_BYTES;
export const SECRETKEYS_BYTES = NTRU_CONFIG.SECRETKEYS_BYTES;
export const AES_GCM_KEY_SIZE = KUZNECHIK_KEY_SIZE;
export const KEYCHAIN_BYTES_SIZE =
  PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE + KUZNECHIK_KEY_SIZE;

export async function deriveKeyFromSeed(
  seed: Uint8Array,
  idx: number,
): Promise<Uint8Array> {
  const hasher = new Uint8Array([...seed, idx]);
  return sha256(hasher);
}

export enum CipherOrders {
  AESCBC,
  AESGCM256,
  KUZNECHIK,
  NTRUP761,
}

export class KeyChain {
  public readonly ntrupKeys: { pk: PubKey; sk: PrivKey };
  public readonly aesKey: Uint8Array;
  public readonly kuznechikKey: Uint8Array;

  constructor(
    ntrupKeys: { pk: PubKey; sk: PrivKey },
    aesKey: Uint8Array,
    kuznechikKey: Uint8Array,
  ) {
    this.ntrupKeys = ntrupKeys;
    this.aesKey = aesKey;
    this.kuznechikKey = kuznechikKey;
  }

  static async fromSeed(seed: Uint8Array): Promise<KeyChain> {
    const ntrupKeys = ntruKeysFromSeed(seed);
    const aesKey = await deriveKeyFromSeed(seed, 0);
    const kuznechikKey = await deriveKeyFromSeed(seed, 1);

    return new KeyChain(ntrupKeys, aesKey, kuznechikKey);
  }

  static async fromAesV2(password: Uint8Array): Promise<KeyChain> {
    const keyHashBytes = await sha256(password);

    const keyHashHex = uint8ArrayToHex(keyHashBytes);
    const aesKeyForV2 = utf8ToUint8Array(keyHashHex);

    const ntrupKeys = ntruKeysFromSeed(
      Uint8Array.from([...keyHashBytes, ...keyHashBytes]),
    );

    return new KeyChain(ntrupKeys, aesKeyForV2, keyHashBytes);
  }

  static async fromAesV3(
    password: Uint8Array,
    algorithm: ShaAlgorithms,
    iteractions: number,
  ): Promise<KeyChain> {
    const salt = utf8ToUint8Array(EXTENSION_ID);
    const key = await pbkdf2(password, salt, iteractions, algorithm);
    const keyBytes = await sha256(key);
    const ntrupKeys = ntruKeysFromSeed(
      Uint8Array.from([...keyBytes, ...keyBytes]),
    );

    return new KeyChain(ntrupKeys, keyBytes, keyBytes);
  }

  static async fromPass(
    password: Uint8Array,
    fingerprint: Uint8Array,
    argonConfig: Argon2Config,
  ): Promise<KeyChain> {
    const seed = deriveArgon2Key(password, fingerprint, argonConfig);
    return KeyChain.fromSeed(seed);
  }

  static async fromBytes(bytes: Uint8Array): Promise<KeyChain> {
    if (bytes.length !== KEYCHAIN_BYTES_SIZE) {
      throw new Error("Invalid byte length");
    }
    const pkBytes = bytes.slice(0, PUBLICKEYS_BYTES);
    const skBytes = bytes.slice(
      PUBLICKEYS_BYTES,
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES,
    );
    const aesKey = bytes.slice(
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES,
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE,
    );
    const kuznechikKey = bytes.slice(
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE,
      KEYCHAIN_BYTES_SIZE,
    );

    const pk = PubKey.import(pkBytes, NTRU_CONFIG);
    const sk = PrivKey.import(skBytes, NTRU_CONFIG);

    return new KeyChain({ pk, sk }, aesKey, kuznechikKey);
  }

  toBytes(): Uint8Array {
    const pkBytes = this.ntrupKeys.pk.toBytes(NTRU_CONFIG);
    const skBytes = this.ntrupKeys.sk.toBytes(NTRU_CONFIG);
    const aesKey = this.aesKey;
    const kuznechikKey = this.kuznechikKey;

    const res = new Uint8Array(KEYCHAIN_BYTES_SIZE);
    res.set(pkBytes, 0);
    res.set(skBytes, PUBLICKEYS_BYTES);
    res.set(aesKey, PUBLICKEYS_BYTES + SECRETKEYS_BYTES);
    res.set(
      kuznechikKey,
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE,
    );
    return res;
  }

  async encrypt(
    plaintext: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    let data = plaintext;
    for (const o of options) {
      switch (o) {
        case CipherOrders.AESCBC:
          throw new Error("OLD method, AESCBC");
        case CipherOrders.AESGCM256:
          data = AESCipherV3.encrypt(data, this.aesKey);
          break;
        case CipherOrders.KUZNECHIK:
          data = kuznechikEncrypt(this.kuznechikKey, data);
          break;
        case CipherOrders.NTRUP761:
          data = ntruEncrypt(this.ntrupKeys.pk, data);
          break;
      }
    }
    return data;
  }

  async decrypt(
    ciphertext: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    let data = ciphertext;
    for (const o of options.slice().reverse()) {
      switch (o) {
        case CipherOrders.AESCBC:
          const decryptedString = await AESCipherV2.decrypt(data, this.aesKey);
          data = new TextEncoder().encode(decryptedString);
          break;
        case CipherOrders.AESGCM256:
          data = AESCipherV3.decrypt(data, this.aesKey);
          break;
        case CipherOrders.KUZNECHIK:
          data = kuznechikDecrypt(this.kuznechikKey, data);
          break;
        case CipherOrders.NTRUP761:
          data = ntruDecrypt(this.ntrupKeys.sk, data);
          break;
      }
    }
    return data;
  }

  async makeProof(
    seed: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    return this.encrypt(seed, options);
  }

  async getProof(
    cipherProof: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    return this.decrypt(cipherProof, options);
  }
}

```

`zil-pay/crypto/keypair.ts`:

```ts
import type { TypedData } from "micro-eth-signer/typed-data.js";

import { ETHEREUM, ZILLIQA } from "config/slip44";
import { deriveFromPrivateKeyPublicKey, derivePrivateKey } from "./bip32";
import { DerivationPath } from "./bip49";
import { sign, verify } from "./zilliqa/schnorr";
import {
  personal,
  signTyped,
  verifyTyped,
} from "micro-eth-signer/typed-data.js";
import { hexToUint8Array, uint8ArrayToHex } from "lib/utils/hex";
import { Signature } from "@noble/secp256k1";
import { randomBytes } from "./random";
import { Address, AddressType } from "./address";

export class KeyPair {
  #privateKey: Uint8Array;
  #pubKey: Uint8Array;
  #slip44: number;

  static addressType(slip44: number): AddressType {
    switch (slip44) {
      case ZILLIQA:
        return AddressType.Bech32;
      case ETHEREUM:
        return AddressType.EthCheckSum;
      default:
        return AddressType.EthCheckSum;
    }
  }

  static async fromPrivateKey(privateKey: Uint8Array, slip44: number) {
    const pubKey = await deriveFromPrivateKeyPublicKey(privateKey, slip44);

    return new KeyPair(privateKey, pubKey, slip44);
  }

  static async generate(slip44: number) {
    const privateKey = randomBytes(32);
    const pubKey = await deriveFromPrivateKeyPublicKey(privateKey, slip44);

    return new KeyPair(privateKey, pubKey, slip44);
  }

  static async fromSeed(seed: Uint8Array, slip44: number, index: number) {
    const hdPath = new DerivationPath(slip44, index);
    const privateKey = await derivePrivateKey(seed, hdPath.getPath());
    const pubKey = await deriveFromPrivateKeyPublicKey(privateKey, slip44);

    return new KeyPair(privateKey, pubKey, slip44);
  }

  get privateKey() {
    return this.#privateKey;
  }

  get pubKey() {
    return this.#pubKey;
  }

  get slip44() {
    return this.#slip44;
  }

  constructor(privateKey: Uint8Array, pubKey: Uint8Array, slip44: number) {
    this.#privateKey = privateKey;
    this.#pubKey = pubKey;
    this.#slip44 = slip44;
  }

  addressType(): AddressType {
    return KeyPair.addressType(this.#slip44);
  }

  async address(): Promise<Address> {
    return await Address.fromPubKey(this.pubKey, this.slip44);
  }

  async signMessage(msg: Uint8Array) {
    switch (this.addressType()) {
      case AddressType.Bech32:
        const sigZil = await sign(msg, this.privateKey);
        return Uint8Array.from(sigZil.toBytes());
      case AddressType.EthCheckSum:
        const sigEth = personal.sign(msg, this.privateKey);
        return hexToUint8Array(sigEth);
    }
  }

  signDataEIP712(typedData: TypedData<any, any>): Uint8Array {
    switch (this.addressType()) {
      case AddressType.EthCheckSum:
        const signature = signTyped(typedData, this.privateKey);
        return hexToUint8Array(signature);
      default:
        throw new Error("Unsupported");
    }
  }

  async verifyTypedEIP712(
    signature: Uint8Array,
    typedData: TypedData<any, any>,
    address: Address,
  ): Promise<boolean> {
    switch (this.addressType()) {
      case AddressType.EthCheckSum:
        const sigHex = uint8ArrayToHex(signature, true);
        const ethChecsumAddr = await address.toEthChecksum();

        return verifyTyped(sigHex, typedData, ethChecsumAddr);
      default:
        throw new Error("Unsupported");
    }
  }

  async verifySig(msg: Uint8Array, sig: Uint8Array): Promise<boolean> {
    switch (this.addressType()) {
      case AddressType.Bech32:
        return await verify(msg, this.pubKey, Signature.fromBytes(sig));
      case AddressType.EthCheckSum:
        const address = await this.address();
        const ethChecsum = await address.toEthChecksum();
        const sigHex = uint8ArrayToHex(sig);

        return personal.verify(sigHex, msg, ethChecsum);
    }
  }
}

```

`zil-pay/crypto/kuznechik.ts`:

```ts
import {
  KeyStore,
  AlgOfb,
  MIN_GAMMA_SIZE,
  MASTER_KEY_SIZE,
} from "@hicaru/kuznechik.js";
import { randomBytes } from "./random";

export const KUZNECHIK_KEY_SIZE = MASTER_KEY_SIZE;

export function kuznechikEncrypt(
  key: Uint8Array,
  plaintext: Uint8Array,
): Uint8Array {
  const keyStore = new KeyStore();
  keyStore.setMasterKey(key);
  const gamma = randomBytes(MIN_GAMMA_SIZE);
  const alg = new AlgOfb(keyStore);
  alg.setGamma(gamma);
  const encrypted = alg.encrypt(plaintext);
  const finalCiphertext = new Uint8Array(encrypted.length + gamma.length);
  finalCiphertext.set(encrypted, 0);
  finalCiphertext.set(gamma, encrypted.length);
  return finalCiphertext;
}

export function kuznechikDecrypt(
  key: Uint8Array,
  ciphertext: Uint8Array,
): Uint8Array {
  const gamma = ciphertext.slice(ciphertext.length - MIN_GAMMA_SIZE);
  const actualCiphertext = ciphertext.slice(
    0,
    ciphertext.length - MIN_GAMMA_SIZE,
  );
  const keyStore = new KeyStore();
  keyStore.setMasterKey(key);
  const alg = new AlgOfb(keyStore);
  alg.setGamma(gamma);
  const plaintext = alg.decrypt(actualCiphertext);
  return plaintext;
}

```

`zil-pay/crypto/ntrup.ts`:

```ts
import type { ParamsConfig } from "@hicaru/ntrup.js";
import { ChaCha20Rng, ChaChaRng } from "@hicaru/chacharand.js";
import {
  bytesRqDecode,
  ErrorType,
  generateKeyPair,
  packBytes,
  params761,
  PrivKey,
  PubKey,
  R3,
  r3DecodeChunks,
  r3EncodeChunks,
  r3Encrypt,
  r3MergeWChunks,
  r3SplitWChunks,
  Rq,
  rqDecrypt,
  unpackBytes,
} from "@hicaru/ntrup.js";

import { randomBytes } from "../crypto/random";

export const NTRU_CONFIG = params761;

function bytesEncrypt(
  rng: ChaChaRng,
  plaintext: Uint8Array,
  pubKey: PubKey,
  params: ParamsConfig,
): Uint8Array {
  const unlimitedPoly = r3DecodeChunks(plaintext);
  const getU32 = () => rng.nextU32();
  const { chunks, size, seed } = r3SplitWChunks(unlimitedPoly, getU32, params);
  const encryptedBytes: Uint8Array[] = [];

  for (const chunk of chunks) {
    const r3 = R3.from(chunk, params);
    const hr = r3Encrypt(r3, pubKey, params);
    const rqBytes = hr.toBytes(params);
    encryptedBytes.push(rqBytes);
  }

  const totalLength = encryptedBytes.reduce((sum, arr) => sum + arr.length, 0);
  const dataBytes = new Uint8Array(totalLength);

  let offset = 0;

  for (const arr of encryptedBytes) {
    dataBytes.set(arr, offset);
    offset += arr.length;
  }

  return packBytes(dataBytes, size, seed);
}

function bytesDecrypt(
  cipher: Uint8Array,
  privKey: PrivKey,
  params: ParamsConfig,
): Uint8Array {
  const { dataBytes, size, seed } = unpackBytes(cipher);
  const chunkCount = Math.floor(dataBytes.length / params.RQ_BYTES);

  if (dataBytes.length % params.RQ_BYTES !== 0) {
    throw ErrorType.InvalidRqChunkSize;
  }

  const decryptedChunks: Int8Array[] = [];

  for (let i = 0; i < chunkCount; i++) {
    const start = i * params.RQ_BYTES;
    const end = start + params.RQ_BYTES;
    const chunkBytes = dataBytes.subarray(start, end);
    if (chunkBytes.length !== params.RQ_BYTES) {
      throw ErrorType.InvalidRqChunkSize;
    }
    const coeffs = bytesRqDecode(chunkBytes, params);
    const rq = Rq.from(coeffs, params);
    const r3 = rqDecrypt(rq, privKey, params);
    decryptedChunks.push(r3.coeffs);
  }

  const outR3 = r3MergeWChunks(decryptedChunks, size, seed, params);

  return r3EncodeChunks(outR3);
}

export function ntruKeysFromSeed(seedBytes: Uint8Array): {
  pk: PubKey;
  sk: PrivKey;
} {
  const seedPq = seedBytes.slice(0, 32);
  const pqRng = ChaCha20Rng(seedPq);

  return generateKeyPair(pqRng, NTRU_CONFIG);
}

export function ntruEncrypt(pk: PubKey, plaintext: Uint8Array) {
  const seed = randomBytes(32);
  const rng = ChaCha20Rng(seed);
  return bytesEncrypt(rng, plaintext, pk, NTRU_CONFIG);
}

export function ntruDecrypt(sk: PrivKey, ciphertext: Uint8Array) {
  return bytesDecrypt(ciphertext, sk, NTRU_CONFIG);
}

```

`zil-pay/crypto/number.ts`:

```ts
/**
 * Converts a Uint8Array to a bigint, assuming big-endian byte order.
 * In big-endian, the most significant byte is placed at the beginning of the array.
 * This format is commonly used in network protocols and cryptography.
 *
 * @param array - The Uint8Array to convert to a bigint.
 * @returns The bigint representation of the input Uint8Array.
 * @throws TypeError if the input parameter is not an instance of Uint8Array.
 */
export function uint8ArrayToBigIntBigEndian(array: Uint8Array): bigint {
  if (!(array instanceof Uint8Array)) {
    array = Uint8Array.from(array);
  }

  let result: bigint = 0n;
  for (const byte of array) {
    result = (result << 8n) | BigInt(byte);
  }
  return result;
}

/**
 * Converts a Uint8Array to a bigint, assuming little-endian byte order.
 * In little-endian, the least significant byte is placed at the beginning of the array.
 * This format is sometimes used for representing numbers in computer memory.
 *
 * @param array - The Uint8Array to convert to a bigint.
 * @returns The bigint representation of the input Uint8Array.
 * @throws TypeError if the input parameter is not an instance of Uint8Array.
 */
export function uint8ArrayToBigIntLittleEndian(array: Uint8Array): bigint {
  if (!(array instanceof Uint8Array)) {
    array = Uint8Array.from(array);
  }

  let result: bigint = 0n;
  for (let i = array.length - 1; i >= 0; i--) {
    result = (result << 8n) | BigInt(array[i]);
  }
  return result;
}

/**
 * Converts a bigint to a big-endian Uint8Array of specified length.
 * @param value - The bigint to convert.
 * @param length - The desired length of the output array.
 * @returns The Uint8Array representation of the bigint.
 */
export function bigIntToUint8ArrayBigEndian(
  value: bigint,
  length: number,
): Uint8Array {
  const hex = value.toString(16).padStart(length * 2, "0");
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    bytes[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
  }
  return bytes;
}

```

`zil-pay/crypto/pbkdf2.ts`:

```ts
import { ShaAlgorithms } from "../config/pbkdf2";

export async function pbkdf2(
  password: Uint8Array,
  salt: Uint8Array,
  iterations: number,
  algorithms = ShaAlgorithms.Sha512,
) {
  const passphraseKey = await globalThis.crypto.subtle.importKey(
    "raw",
    password,
    { name: "PBKDF2" },
    false,
    ["deriveBits", "deriveKey"],
  );
  const webKey = await globalThis.crypto.subtle.deriveKey(
    {
      salt,
      iterations,
      name: "PBKDF2",
      hash: algorithms,
    },
    passphraseKey,
    {
      name: "HMAC",
      hash: algorithms,
      length: 512,
    },
    true,
    ["sign", "verify"],
  );
  const hash = await globalThis.crypto.subtle.exportKey("raw", webKey);

  return new Uint8Array(hash);
}

```

`zil-pay/crypto/proto/zq1.ts`:

```ts
export interface ByteArray {
  data: Uint8Array;
}

export function encodeByteArray(message: ByteArray): Uint8Array {
  let bb = popByteBuffer();
  _encodeByteArray(message, bb);
  return toUint8Array(bb);
}

function _encodeByteArray(message: ByteArray, bb: ByteBuffer): void {
  // required bytes data = 1;
  let $data = message.data;
  if ($data !== undefined) {
    writeVarint32(bb, 10);
    writeVarint32(bb, $data.length), writeBytes(bb, $data);
  }
}

export function decodeByteArray(binary: Uint8Array): ByteArray {
  return _decodeByteArray(wrapByteBuffer(binary));
}

function _decodeByteArray(bb: ByteBuffer): ByteArray {
  let message: ByteArray = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required bytes data = 1;
      case 1: {
        message.data = readBytes(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.data === undefined)
    throw new Error("Missing required field: data");

  return message;
}

export interface ProtoTransactionCoreInfo {
  version?: number;
  nonce?: Long;
  toaddr?: Uint8Array;
  senderpubkey?: ByteArray;
  amount?: ByteArray;
  gasprice?: ByteArray;
  gaslimit?: Long;
  code?: Uint8Array;
  data?: Uint8Array;
}

export function encodeProtoTransactionCoreInfo(message: ProtoTransactionCoreInfo): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransactionCoreInfo(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransactionCoreInfo(message: ProtoTransactionCoreInfo, bb: ByteBuffer): void {
  // optional uint32 version = 1;
  let $version = message.version;
  if ($version !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32(bb, $version);
  }

  // optional uint64 nonce = 2;
  let $nonce = message.nonce;
  if ($nonce !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $nonce);
  }

  // optional bytes toaddr = 3;
  let $toaddr = message.toaddr;
  if ($toaddr !== undefined) {
    writeVarint32(bb, 26);
    writeVarint32(bb, $toaddr.length), writeBytes(bb, $toaddr);
  }

  // optional ByteArray senderpubkey = 4;
  let $senderpubkey = message.senderpubkey;
  if ($senderpubkey !== undefined) {
    writeVarint32(bb, 34);
    let nested = popByteBuffer();
    _encodeByteArray($senderpubkey, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ByteArray amount = 5;
  let $amount = message.amount;
  if ($amount !== undefined) {
    writeVarint32(bb, 42);
    let nested = popByteBuffer();
    _encodeByteArray($amount, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ByteArray gasprice = 6;
  let $gasprice = message.gasprice;
  if ($gasprice !== undefined) {
    writeVarint32(bb, 50);
    let nested = popByteBuffer();
    _encodeByteArray($gasprice, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional uint64 gaslimit = 7;
  let $gaslimit = message.gaslimit;
  if ($gaslimit !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, $gaslimit);
  }

  // optional bytes code = 8;
  let $code = message.code;
  if ($code !== undefined) {
    writeVarint32(bb, 66);
    writeVarint32(bb, $code.length), writeBytes(bb, $code);
  }

  // optional bytes data = 9;
  let $data = message.data;
  if ($data !== undefined) {
    writeVarint32(bb, 74);
    writeVarint32(bb, $data.length), writeBytes(bb, $data);
  }
}

export function decodeProtoTransactionCoreInfo(binary: Uint8Array): ProtoTransactionCoreInfo {
  return _decodeProtoTransactionCoreInfo(wrapByteBuffer(binary));
}

function _decodeProtoTransactionCoreInfo(bb: ByteBuffer): ProtoTransactionCoreInfo {
  let message: ProtoTransactionCoreInfo = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional uint32 version = 1;
      case 1: {
        message.version = readVarint32(bb) >>> 0;
        break;
      }

      // optional uint64 nonce = 2;
      case 2: {
        message.nonce = readVarint64(bb, /* unsigned */ true);
        break;
      }

      // optional bytes toaddr = 3;
      case 3: {
        message.toaddr = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional ByteArray senderpubkey = 4;
      case 4: {
        let limit = pushTemporaryLength(bb);
        message.senderpubkey = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      // optional ByteArray amount = 5;
      case 5: {
        let limit = pushTemporaryLength(bb);
        message.amount = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      // optional ByteArray gasprice = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        message.gasprice = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      // optional uint64 gaslimit = 7;
      case 7: {
        message.gaslimit = readVarint64(bb, /* unsigned */ true);
        break;
      }

      // optional bytes code = 8;
      case 8: {
        message.code = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional bytes data = 9;
      case 9: {
        message.data = readBytes(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface ProtoTransaction {
  tranid?: Uint8Array;
  info?: ProtoTransactionCoreInfo;
  signature?: ByteArray;
}

export function encodeProtoTransaction(message: ProtoTransaction): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransaction(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransaction(message: ProtoTransaction, bb: ByteBuffer): void {
  // optional bytes tranid = 1;
  let $tranid = message.tranid;
  if ($tranid !== undefined) {
    writeVarint32(bb, 10);
    writeVarint32(bb, $tranid.length), writeBytes(bb, $tranid);
  }

  // optional ProtoTransactionCoreInfo info = 2;
  let $info = message.info;
  if ($info !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodeProtoTransactionCoreInfo($info, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ByteArray signature = 3;
  let $signature = message.signature;
  if ($signature !== undefined) {
    writeVarint32(bb, 26);
    let nested = popByteBuffer();
    _encodeByteArray($signature, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }
}

export function decodeProtoTransaction(binary: Uint8Array): ProtoTransaction {
  return _decodeProtoTransaction(wrapByteBuffer(binary));
}

function _decodeProtoTransaction(bb: ByteBuffer): ProtoTransaction {
  let message: ProtoTransaction = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional bytes tranid = 1;
      case 1: {
        message.tranid = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional ProtoTransactionCoreInfo info = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.info = _decodeProtoTransactionCoreInfo(bb);
        bb.limit = limit;
        break;
      }

      // optional ByteArray signature = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        message.signature = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface ProtoTransactionReceipt {
  receipt?: Uint8Array;
  cumgas?: Long;
}

export function encodeProtoTransactionReceipt(message: ProtoTransactionReceipt): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransactionReceipt(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransactionReceipt(message: ProtoTransactionReceipt, bb: ByteBuffer): void {
  // optional bytes receipt = 1;
  let $receipt = message.receipt;
  if ($receipt !== undefined) {
    writeVarint32(bb, 10);
    writeVarint32(bb, $receipt.length), writeBytes(bb, $receipt);
  }

  // optional uint64 cumgas = 2;
  let $cumgas = message.cumgas;
  if ($cumgas !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $cumgas);
  }
}

export function decodeProtoTransactionReceipt(binary: Uint8Array): ProtoTransactionReceipt {
  return _decodeProtoTransactionReceipt(wrapByteBuffer(binary));
}

function _decodeProtoTransactionReceipt(bb: ByteBuffer): ProtoTransactionReceipt {
  let message: ProtoTransactionReceipt = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional bytes receipt = 1;
      case 1: {
        message.receipt = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional uint64 cumgas = 2;
      case 2: {
        message.cumgas = readVarint64(bb, /* unsigned */ true);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface ProtoTransactionWithReceipt {
  transaction?: ProtoTransaction;
  receipt?: ProtoTransactionReceipt;
}

export function encodeProtoTransactionWithReceipt(message: ProtoTransactionWithReceipt): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransactionWithReceipt(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransactionWithReceipt(message: ProtoTransactionWithReceipt, bb: ByteBuffer): void {
  // optional ProtoTransaction transaction = 1;
  let $transaction = message.transaction;
  if ($transaction !== undefined) {
    writeVarint32(bb, 10);
    let nested = popByteBuffer();
    _encodeProtoTransaction($transaction, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ProtoTransactionReceipt receipt = 2;
  let $receipt = message.receipt;
  if ($receipt !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodeProtoTransactionReceipt($receipt, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }
}

export function decodeProtoTransactionWithReceipt(binary: Uint8Array): ProtoTransactionWithReceipt {
  return _decodeProtoTransactionWithReceipt(wrapByteBuffer(binary));
}

function _decodeProtoTransactionWithReceipt(bb: ByteBuffer): ProtoTransactionWithReceipt {
  let message: ProtoTransactionWithReceipt = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional ProtoTransaction transaction = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        message.transaction = _decodeProtoTransaction(bb);
        bb.limit = limit;
        break;
      }

      // optional ProtoTransactionReceipt receipt = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.receipt = _decodeProtoTransactionReceipt(bb);
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface Long {
  low: number;
  high: number;
  unsigned: boolean;
}

interface ByteBuffer {
  bytes: Uint8Array;
  offset: number;
  limit: number;
}

function pushTemporaryLength(bb: ByteBuffer): number {
  let length = readVarint32(bb);
  let limit = bb.limit;
  bb.limit = bb.offset + length;
  return limit;
}

function skipUnknownField(bb: ByteBuffer, type: number): void {
  switch (type) {
    case 0: while (readByte(bb) & 0x80) { } break;
    case 2: skip(bb, readVarint32(bb)); break;
    case 5: skip(bb, 4); break;
    case 1: skip(bb, 8); break;
    default: throw new Error("Unimplemented type: " + type);
  }
}

// The code below was modified from https://github.com/protobufjs/bytebuffer.js
// which is under the Apache License 2.0.

let bbStack: ByteBuffer[] = [];

function popByteBuffer(): ByteBuffer {
  const bb = bbStack.pop();
  if (!bb) return { bytes: new Uint8Array(64), offset: 0, limit: 0 };
  bb.offset = bb.limit = 0;
  return bb;
}

function pushByteBuffer(bb: ByteBuffer): void {
  bbStack.push(bb);
}

function wrapByteBuffer(bytes: Uint8Array): ByteBuffer {
  return { bytes, offset: 0, limit: bytes.length };
}

function toUint8Array(bb: ByteBuffer): Uint8Array {
  let bytes = bb.bytes;
  let limit = bb.limit;
  return bytes.length === limit ? bytes : bytes.subarray(0, limit);
}

function skip(bb: ByteBuffer, offset: number): void {
  if (bb.offset + offset > bb.limit) {
    throw new Error('Skip past limit');
  }
  bb.offset += offset;
}

function isAtEnd(bb: ByteBuffer): boolean {
  return bb.offset >= bb.limit;
}

function grow(bb: ByteBuffer, count: number): number {
  let bytes = bb.bytes;
  let offset = bb.offset;
  let limit = bb.limit;
  let finalOffset = offset + count;
  if (finalOffset > bytes.length) {
    let newBytes = new Uint8Array(finalOffset * 2);
    newBytes.set(bytes);
    bb.bytes = newBytes;
  }
  bb.offset = finalOffset;
  if (finalOffset > limit) {
    bb.limit = finalOffset;
  }
  return offset;
}

function advance(bb: ByteBuffer, count: number): number {
  let offset = bb.offset;
  if (offset + count > bb.limit) {
    throw new Error('Read past limit');
  }
  bb.offset += count;
  return offset;
}

function readBytes(bb: ByteBuffer, count: number): Uint8Array {
  let offset = advance(bb, count);
  return bb.bytes.subarray(offset, offset + count);
}

function writeBytes(bb: ByteBuffer, buffer: Uint8Array): void {
  let offset = grow(bb, buffer.length);
  bb.bytes.set(buffer, offset);
}



function writeByteBuffer(bb: ByteBuffer, buffer: ByteBuffer): void {
  let offset = grow(bb, buffer.limit);
  let from = bb.bytes;
  let to = buffer.bytes;

  // This for loop is much faster than subarray+set on V8
  for (let i = 0, n = buffer.limit; i < n; i++) {
    from[i + offset] = to[i];
  }
}

function readByte(bb: ByteBuffer): number {
  return bb.bytes[advance(bb, 1)];
}

function writeByte(bb: ByteBuffer, value: number): void {
  let offset = grow(bb, 1);
  bb.bytes[offset] = value;
}
function readVarint32(bb: ByteBuffer): number {
  let c = 0;
  let value = 0;
  let b: number;
  do {
    b = readByte(bb);
    if (c < 32) value |= (b & 0x7F) << c;
    c += 7;
  } while (b & 0x80);
  return value;
}

function writeVarint32(bb: ByteBuffer, value: number): void {
  value >>>= 0;
  while (value >= 0x80) {
    writeByte(bb, (value & 0x7f) | 0x80);
    value >>>= 7;
  }
  writeByte(bb, value);
}

function readVarint64(bb: ByteBuffer, unsigned: boolean): Long {
  let part0 = 0;
  let part1 = 0;
  let part2 = 0;
  let b: number;

  b = readByte(bb); part0 = (b & 0x7F); if (b & 0x80) {
    b = readByte(bb); part0 |= (b & 0x7F) << 7; if (b & 0x80) {
      b = readByte(bb); part0 |= (b & 0x7F) << 14; if (b & 0x80) {
        b = readByte(bb); part0 |= (b & 0x7F) << 21; if (b & 0x80) {

          b = readByte(bb); part1 = (b & 0x7F); if (b & 0x80) {
            b = readByte(bb); part1 |= (b & 0x7F) << 7; if (b & 0x80) {
              b = readByte(bb); part1 |= (b & 0x7F) << 14; if (b & 0x80) {
                b = readByte(bb); part1 |= (b & 0x7F) << 21; if (b & 0x80) {

                  b = readByte(bb); part2 = (b & 0x7F); if (b & 0x80) {
                    b = readByte(bb); part2 |= (b & 0x7F) << 7;
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return {
    low: part0 | (part1 << 28),
    high: (part1 >>> 4) | (part2 << 24),
    unsigned,
  };
}

function writeVarint64(bb: ByteBuffer, value: Long): void {
  let part0 = value.low >>> 0;
  let part1 = ((value.low >>> 28) | (value.high << 4)) >>> 0;
  let part2 = value.high >>> 24;

  let size =
    part2 === 0 ?
      part1 === 0 ?
        part0 < 1 << 14 ?
          part0 < 1 << 7 ? 1 : 2 :
          part0 < 1 << 21 ? 3 : 4 :
        part1 < 1 << 14 ?
          part1 < 1 << 7 ? 5 : 6 :
          part1 < 1 << 21 ? 7 : 8 :
      part2 < 1 << 7 ? 9 : 10;

  let offset = grow(bb, size);
  let bytes = bb.bytes;

  switch (size) {
    case 10: bytes[offset + 9] = (part2 >>> 7) & 0x01;
    case 9: bytes[offset + 8] = size !== 9 ? part2 | 0x80 : part2 & 0x7F;
    case 8: bytes[offset + 7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
    case 7: bytes[offset + 6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
    case 6: bytes[offset + 5] = size !== 6 ? (part1 >>> 7) | 0x80 : (part1 >>> 7) & 0x7F;
    case 5: bytes[offset + 4] = size !== 5 ? part1 | 0x80 : part1 & 0x7F;
    case 4: bytes[offset + 3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
    case 3: bytes[offset + 2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
    case 2: bytes[offset + 1] = size !== 2 ? (part0 >>> 7) | 0x80 : (part0 >>> 7) & 0x7F;
    case 1: bytes[offset] = size !== 1 ? part0 | 0x80 : part0 & 0x7F;
  }
}

```

`zil-pay/crypto/random.ts`:

```ts
import { ChaCha20Rng } from "@hicaru/chacharand.js";

export function randomBytes(length: number): Uint8Array {
  const buffer = new Uint8Array(length);
  const randomSeed = new Uint8Array(32);

  window.crypto.getRandomValues(randomSeed);

  const rng = ChaCha20Rng(randomSeed);

  rng.fillBytes(buffer);

  return buffer;
}

```

`zil-pay/crypto/sha256.ts`:

```ts
import { ShaAlgorithms } from "config/pbkdf2";

export async function sha256(value: Uint8Array) {
  if (!(value instanceof Uint8Array)) {
    value = Uint8Array.from(value);
  }

  const crypto = globalThis.crypto;
  const hash = await crypto.subtle.digest(ShaAlgorithms.sha256, value);
  return new Uint8Array(hash);
}

```

`zil-pay/crypto/sha512.ts`:

```ts
import { ShaAlgorithms } from "../config/pbkdf2";

export async function sha512(value: Uint8Array): Promise<Uint8Array> {
  const crypto = globalThis.crypto;
  const hash = await crypto.subtle.digest(ShaAlgorithms.Sha512, value);

  return new Uint8Array(hash);
}

```

`zil-pay/crypto/tx.ts`:

```ts
import type { TxType } from "micro-eth-signer/esm/tx";
import { ZILTransactionRequest, ZILTransactionReceipt } from "./zilliqa_tx";
import { Transaction } from "micro-eth-signer";
import { KeyPair } from "./keypair";
import { randomBytes } from "./random";

export interface TransactionMetadata {
  chainHash: number;
  hash?: string;
  info?: string;
  icon?: string;
  title?: string;
  signer?: string;
  tokenInfo?: [string, number, string];
}

export class TransactionRequest {
  constructor(
    public metadata: TransactionMetadata,
    public scilla?: ZILTransactionRequest,
    public evm?: Transaction<TxType>,
  ) {}

  async sign(keypair: KeyPair) {
    if (this.scilla) {
      const receipt = await this.scilla.sign(keypair);

      return new TransactionReceipt(this.metadata, receipt);
    } else if (this.evm) {
      const entropy = randomBytes(128);
      const receipt = this.evm.signBy(keypair.privateKey, entropy);

      return new TransactionReceipt(this.metadata, undefined, receipt);
    }

    throw new Error("Invlid tx type");
  }
}

export class TransactionReceipt {
  constructor(
    public metadata: TransactionMetadata,
    public scilla?: ZILTransactionReceipt,
    public evm?: Transaction<TxType>,
  ) {}

  async verify() {
    if (this.scilla) {
      return this.scilla.verify();
    } else if (this.evm) {
      return this.evm.verifySignature();
    }

    throw new Error("Invlid tx type");
  }
}

```

`zil-pay/crypto/uuid.ts`:

```ts
import { randomBytes } from "./random";

/**
 * Generates a version 4 UUID.
 * Uses the native `crypto.randomUUID` if available, otherwise falls back to a
 * custom implementation using the `randomBytes` function.
 * @returns A UUID string.
 */
export function uuid(): string {
  if (window.crypto.randomUUID) {
    return window.crypto.randomUUID();
  }

  const bytes = randomBytes(16);

  bytes[6] = (bytes[6] & 0x0f) | 0x40;
  bytes[8] = (bytes[8] & 0x3f) | 0x80;
  const hex = Array.from(bytes, (byte) =>
    byte.toString(16).padStart(2, "0"),
  ).join("");

  return `${hex.substring(0, 8)}-${hex.substring(8, 12)}-${hex.substring(12, 16)}-${hex.substring(16, 20)}-${hex.substring(20)}`;
}

```

`zil-pay/crypto/zilliqa/pubkey.ts`:

```ts
import { getPublicKey } from '@noble/secp256k1';

export function fromZILPrivateKey(privateKey: Uint8Array): Uint8Array {
  const publicKey = getPublicKey(Uint8Array.from(privateKey), true);
  return publicKey;
}


```

`zil-pay/crypto/zilliqa/schnorr.ts`:

```ts
import { Signature } from '@noble/secp256k1';
import { ProjectivePoint } from '@noble/secp256k1';
import { CURVE } from '@noble/secp256k1';
import { randomBytes } from '../random';
import { sha256 } from '../sha256';
import { uint8ArrayToBigIntBigEndian } from '../number';
import { fromZILPrivateKey } from './pubkey';

const MAX_TRY_SIGN = 100_000_000;

export async function sign(message: Uint8Array, secretKey: Uint8Array): Promise<Signature> {
  let safeCounter = 0;

  while (safeCounter < MAX_TRY_SIGN) {
    const kBytes = randomBytes(32);
    const k = uint8ArrayToBigIntBigEndian(kBytes) % CURVE.n;

    const signature = await signInner(k, message, secretKey);
    if (signature) {
      return signature;
    }

    safeCounter++;
  }

  throw new Error('InvalidSignTry: Exceeded maximum signing attempts');
}

export async function signInner(k: bigint, message: Uint8Array, secretKey: Uint8Array): Promise<Signature | null> {
  const publicKey = fromZILPrivateKey(secretKey);

  const QPoint = ProjectivePoint.BASE.multiply(k);
  const Q = QPoint.toRawBytes(true);

  const hasherInput = new Uint8Array([...Q, ...publicKey, ...message]);
  const hash = await sha256(hasherInput);
  const r = uint8ArrayToBigIntBigEndian(hash) % CURVE.n;

  if (r === 0n) {
    return null;
  }

  const secretKeyScalar = uint8ArrayToBigIntBigEndian(secretKey);
  const rTimesSecret = (r * secretKeyScalar) % CURVE.n;
  const s = (k - rTimesSecret + CURVE.n) % CURVE.n;

  if (s === 0n) {
    return null;
  }

  return new Signature(r, s);
}

export async function verify(
  message: Uint8Array,
  publicKey: Uint8Array,
  signature: Signature
): Promise<boolean> {
  const r = signature.r;
  const s = signature.s;

  const sG = ProjectivePoint.BASE.multiply(s);
  const publicKeyPoint = ProjectivePoint.fromHex(Uint8Array.from(publicKey));
  const rPub = publicKeyPoint.multiply(r);
  const QPoint = sG.add(rPub);
  const Q = QPoint.toRawBytes(true);

  if (QPoint.equals(ProjectivePoint.ZERO)) {
    return false;
  }

  const hasherInput = new Uint8Array([...Q, ...publicKey, ...message]);
  const hash = await sha256(hasherInput);
  const rDash = uint8ArrayToBigIntBigEndian(hash) % CURVE.n;

  return rDash === r;
}


```

`zil-pay/crypto/zilliqa_tx.ts`:

```ts
import { Signature } from "@noble/secp256k1";
import type { KeyPair } from "./keypair";
import {
  bigIntToUint8ArrayBigEndian,
  uint8ArrayToBigIntBigEndian,
} from "./number";
import {
  encodeProtoTransactionCoreInfo,
  type Long,
  type ProtoTransactionCoreInfo,
} from "./proto/zq1";
import { verify } from "./zilliqa/schnorr";
import { uint8ArrayToHex } from "lib/utils/hex";
import { uint8ArrayToUtf8 } from "lib/utils/utf8";

const U128LEN = 16;

export function bigintToLong(value: bigint): Long {
  const low = Number(value & 0xffffffffn);
  const high = Number((value >> 32n) & 0xffffffffn);
  return { low, high, unsigned: true };
}

export function versionFromChainId(chainId: number): number {
  return (chainId << 16) | 1;
}

export function chainIdFromVersion(version: number): number {
  return (version >> 16) & 0xffff;
}

export class ZILTransactionRequest {
  constructor(
    public chainId: number,
    public nonce: bigint,
    public gasPrice: bigint,
    public gasLimit: bigint,
    public toAddr: Uint8Array,
    public amount: bigint,
    public code: Uint8Array = new Uint8Array(),
    public data: Uint8Array = new Uint8Array(),
  ) {}

  toProto(pubKey: Uint8Array): ProtoTransactionCoreInfo {
    return {
      version: versionFromChainId(this.chainId),
      nonce: bigintToLong(this.nonce),
      toaddr: this.toAddr,
      senderpubkey: { data: pubKey },
      amount: { data: bigIntToUint8ArrayBigEndian(this.amount, U128LEN) },
      gasprice: { data: bigIntToUint8ArrayBigEndian(this.gasPrice, U128LEN) },
      gaslimit: bigintToLong(this.gasLimit),
      code: this.code.length > 0 ? this.code : undefined,
      data: this.data.length > 0 ? this.data : undefined,
    };
  }

  encode(pubKey: Uint8Array): Uint8Array {
    const proto = this.toProto(pubKey);
    return encodeProtoTransactionCoreInfo(proto);
  }

  async sign(keypair: KeyPair) {
    const proto = this.toProto(keypair.pubKey);
    const bytes = encodeProtoTransactionCoreInfo(proto);
    const sig = await keypair.signMessage(bytes);

    return new ZILTransactionReceipt(
      proto.version ?? versionFromChainId(this.chainId),
      this.nonce,
      bigIntToUint8ArrayBigEndian(this.gasPrice, U128LEN),
      this.gasLimit,
      this.toAddr,
      bigIntToUint8ArrayBigEndian(this.amount, U128LEN),
      keypair.pubKey,
      this.code,
      this.data,
      sig,
      false,
    );
  }
}

export class ZILTransactionReceipt {
  constructor(
    public version: number,
    public nonce: bigint,
    public gasPrice: Uint8Array,
    public gasLimit: bigint,
    public toAddr: Uint8Array,
    public amount: Uint8Array,
    public pubKey: Uint8Array,
    public code: Uint8Array,
    public data: Uint8Array,
    public signature: Uint8Array,
    public priority: boolean,
  ) {}

  toProto(): ProtoTransactionCoreInfo {
    return {
      version: this.version,
      nonce: bigintToLong(this.nonce),
      toaddr: this.toAddr,
      senderpubkey: { data: this.pubKey },
      amount: { data: this.amount },
      gasprice: { data: this.gasPrice },
      gaslimit: bigintToLong(this.gasLimit),
      code: this.code.length > 0 ? this.code : undefined,
      data: this.data.length > 0 ? this.data : undefined,
    };
  }

  async verify(): Promise<boolean> {
    const proto = this.toProto();
    const bytes = encodeProtoTransactionCoreInfo(proto);
    const signature = Signature.fromBytes(this.signature);

    return verify(bytes, this.pubKey, signature);
  }

  toJSON() {
    return {
      version: this.version,
      nonce: this.nonce.toString(),
      toAddr: uint8ArrayToHex(this.toAddr),
      amount: uint8ArrayToBigIntBigEndian(this.amount).toString(),
      pubKey: uint8ArrayToHex(this.pubKey),
      gasPrice: uint8ArrayToBigIntBigEndian(this.gasPrice).toString(),
      gasLimit: this.gasLimit.toString(),
      code: this.code.length > 0 ? uint8ArrayToUtf8(this.code) : "",
      data: this.data.length > 0 ? uint8ArrayToUtf8(this.data) : "",
      signature: uint8ArrayToHex(this.signature),
      priority: this.priority,
    };
  }
}

```

`zil-pay/lib/array/chunk.ts`:

```ts
/**
 * Splits an array into chunks of a specified size.
 * @template T - The type of elements in the input array.
 * @param array - The input array to be chunked.
 * @param size - The size of each chunk (must be greater than 0).
 * @returns A new array containing the chunks.
 * @throws {Error} If the size is not a positive number.
 */
export function chunk<T>(array: T[], size: number): T[][] {
    if (size <= 0) {
        throw new Error("Size must be a positive number.");
    }

    const result: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
        result.push(array.slice(i, i + size));
    }
    return result;
}


```

`zil-pay/lib/array/shuffle.ts`:

```ts
/**
 * Shuffles the elements of an array in place using the Fisher-Yates algorithm.
 * @template T - The type of elements in the array.
 * @param array - The array to shuffle.
 */
export function shuffle<T>(array: T[]): T[] {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}


```

`zil-pay/lib/popup/clipboard.ts`:

```ts
/**
 * Asynchronously copies the provided text to the user's clipboard using the modern
 * `navigator.clipboard` API. If the modern API is not available, it attempts
 * to use the deprecated `document.execCommand('copy')` as a fallback.
 *
 * @param text The string to be copied to the clipboard.
 * @returns A Promise that resolves to `true` if the copy operation was successful,
 * or `false` if it failed (e.g., due to browser limitations or user denial of permissions).
 */
export async function clipboardCopy(text: string): Promise<boolean> {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (_) {
      return fallbackCopyToClipboard(text);
    }
  } else {
    // Fallback for browsers that do not support the modern Clipboard API.
    return fallbackCopyToClipboard(text);
  }
}

/**
 * Attempts to copy text to the clipboard using the deprecated `document.execCommand('copy')` method.
 * This method is less reliable and may require user interaction or specific browser permissions.
 *
 * @param text The string to be copied to the clipboard.
 * @returns `true` if the copy command was successful, `false` otherwise.
 */
function fallbackCopyToClipboard(text: string): boolean {
  try {
    const span = document.createElement('span');
    span.textContent = text;
    span.style.whiteSpace = 'pre';
    span.style.userSelect = 'all';
    document.body.appendChild(span);
    const selection = window.getSelection();
    const range = window.document.createRange();
    selection?.removeAllRanges();
    range.selectNode(span);
    selection?.addRange(range);
    const successful = window.document.execCommand('copy');
    selection?.removeAllRanges();
    document.body.removeChild(span);
    return successful;
  } catch (err) {
    console.error('Failed to copy text using document.execCommand:', err);
    return false;
  }
}

```

`zil-pay/lib/popup/printer.ts`:

```ts
interface PrintMnemonicOptions {
  phrase: string;
  translations: string[];
  title: string;
}

export const printMnemonic = (options: PrintMnemonicOptions) => {
  const { phrase, translations, title } = options;
  return `<!DOCTYPE html>
<html id="print-wallet">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f8f9fa; /* Light background for printing */
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
    }

    .print-container {
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      width: 80%; /* Occupies most of the width */
      max-width: 700px; /* Limits maximum width */
      padding: 30px;
      margin-bottom: 50px; /* Bottom margin */
    }

    .print-text {
      text-align: center;
    }

    p {
      margin-bottom: 1em;
      font-size: 1rem;
    }

    h3 {
      color: #555;
      letter-spacing: 0.03rem;
      margin-top: 1.5em;
      margin-bottom: 1em;
      font-size: 1.4rem;
      font-weight: 500;
    }

    .phrase {
      font-family: Menlo, Monaco, Consolas, 'Courier New', monospace !important;
      font-weight: bold !important;
      font-size: 1.2rem;
      background-color: #f0f8ff; /* Light background for the phrase */
      color: #1e3a8a; /* Accent color for the phrase */
      padding: 1rem;
      border: 1px solid #aed9fe;
      border-radius: 4px;
      margin: 2rem auto;
      max-width: 90%;
      word-break: break-word;
    }

    .footer {
      margin-top: 2em;
      font-size: 0.9rem;
      color: #777;
    }

    .footer a {
      color: #777;
      text-decoration: none;
    }

    @media print {
      body {
        background-color: #fff; /* White background when printing */
      }
      .print-container {
        border: 1px solid #000; /* Black border when printing */
        box-shadow: none; /* Removes shadow when printing */
      }
    }
  </style>
</head>
<body>
  <main class="print-container" id="print-container">
    <article class="print-text">
      <p>
        ${translations[0]}<br>
        ${translations[1]}<br>
        ${translations[2]}
      </p>
      <h3>${translations[3]}</h3>
      <div class="phrase">${phrase}</div>
      <p>
        ${translations[4]}
      </p>
      <p>
        ${translations[5]}
      </p>
      <p>
        ${translations[6]}
      </p>
      <aside class="footer">
        <a href="https://zilpay.io/" rel="noopener noreferrer" target="_blank">ZilPay Wallet</a>
      </aside>
    </article>
  </main>
</body>
</html>
`;
};

```

`zil-pay/lib/popup/warp-message.ts`:

```ts
export type Params = object[] | string[] | number[] | (string | string[] | number[])[];

export interface SendResponseParams {
  resolve?: unknown;
  reject?: unknown;
}
export type StreamResponse = (params: SendResponseParams) => void;

export interface ProxyContentType {
  params: Params;
  method: string;
  uuid: string;
}

export function warpMessage<T>(msg: SendResponseParams): T | undefined {
  if (!msg) {
    return;
  }

  if (msg.reject) {
    throw new Error(String(msg.reject));
  }

  return msg.resolve as T;
}

```

`zil-pay/lib/runtime/assert.ts`:

```ts
export function assert(expressions: boolean, msg: string) {
  if (!expressions) {
    throw new Error(msg);
  }
}

```

`zil-pay/lib/runtime/ext-id.ts`:

```ts
import { Runtime } from "./extensionizer";

export const EXTENSION_ID = Runtime.runtime.id;

```

`zil-pay/lib/runtime/extensionizer.ts`:

```ts
export const Runtime = globalThis.chrome;

```

`zil-pay/lib/runtime/fingerprint.ts`:

```ts
import { utils } from 'aes-js';
import { EXTENSION_ID, Runtime } from './';

export async function generateSalt(): Promise<Uint8Array> {
  let salt = EXTENSION_ID;

  try {
    const dynamicId = await Runtime.runtime.getPlatformInfo();
    salt += `${dynamicId.arch}:${dynamicId.nacl_arch}:${dynamicId.os}`;
  } catch {
    //
  }

  return utils.utf8.toBytes(salt);
}

```

`zil-pay/lib/runtime/get-url.ts`:

```ts
import { Runtime } from "./extensionizer";

export function getExtensionURL(content: string) {
  return Runtime.runtime.getURL(content);
}


```

`zil-pay/lib/runtime/index.ts`:

```ts
export * from './assert';
export * from './ext-id';
export * from './extensionizer';
export * from './manifest';
export * from './get-url';
export * from './fingerprint';


```

`zil-pay/lib/runtime/manifest.ts`:

```ts
import { Runtime } from './extensionizer';

export function getManifestVersion() {
  return Runtime.runtime.getManifest().manifest_version;
}

```

`zil-pay/lib/storage/builder.ts`:

```ts
import type { OldFields } from 'config/fields';
import { TypeOf } from '../types/checker';

export type StorageKeyValue = {
    [key: string]: string;
};

/**
 * Builds a payload object for writing to browser storage.
 * Serializes objects and arrays to JSON strings.
 *
 * @example
 * import { buildObject, BrowserStorage } from 'lib/storage';
 *
 * const storage = Object.freeze(new BrowserStorage()); // Предполагается, что BrowserStorage - Singleton
 * storage.set(buildObject('key', 'any payload'));
 * storage.set(buildObject('objectKey', { a: 1, b: 2 }));
 * storage.set(buildObject('arrayKey', [1, 2, 3]));
 */
export function buildObject(key: OldFields | string, value: string | object | any[]): StorageKeyValue { // Added any[]
    let data: string;

    if (TypeOf.isObject(value) || TypeOf.isArray(value)) {
        try {
            data = JSON.stringify(value);
        } catch (error) {
            // Handle the error appropriately.  For example:
            console.error('Error serializing value to JSON:', error);
            // Consider throwing the error, returning a default value, or logging.
            return { [key]: '' }; // Return empty string,  or throw error.  IMPORTANT
        }
    } else {
        data = String(value);
    }

    return {
        [key]: data,
    };
}


```

`zil-pay/lib/storage/index.ts`:

```ts
export * from './builder';
export * from './storage';

```

`zil-pay/lib/storage/storage.ts`:

```ts
import type { StorageKeyValue } from './builder';
import type { OldFields } from 'config/fields';
import { Runtime } from 'lib/runtime/extensionizer';

type StorageChangesCallback = { [key: string]: chrome.storage.StorageChange; };

/**
 * Default class for working with browser Storage.
 * @example
 * import { BrowserStorage } from 'lib/storage'
 * BrowserStorage.get('KEY').then(data => { ... });
 */
export const BrowserStorage = Object.freeze({
    /**
     * Subscribes to storage changes.
     * @param callback - The callback function to be called when storage changes.
     * @returns An object with an unsubscribe method.
     */
    subscribe(callback: (changes: StorageChangesCallback) => void) {
        const listener = (changes: StorageChangesCallback) => {
            try {
                callback(changes);
            } catch (error) {
                console.error("Error in storage change callback:", error);
            }
        };

        Runtime.storage.onChanged.addListener(listener);

        return {
            unsubscribe() {
                Runtime.storage.onChanged.removeListener(listener);
            },
        };
    },

    /**
     * Sets multiple key-value pairs in storage.
     * @param items - An array of key-value objects to be stored.
     * @returns A promise that resolves when all items are set.
     */
    async set(...items: StorageKeyValue[]): Promise<void> {
        if (items.length === 0) return;

        const data: StorageKeyValue = {};
        for (const item of items) {
            Object.assign(data, item); // Merge all items into a single object.  Handles duplicate keys.
        }

        return new Promise((resolve, reject) => {
            Runtime.storage.local.set(data, () => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError); // Reject on error
                } else {
                    resolve();
                }
            });
        });
    },

    /**
     * Gets values from storage for the given keys.
     * @param keys - An array of keys to retrieve from storage.
     * @returns A promise that resolves with the retrieved data.  If one key is provided, the value is returned.  If multiple, an object is returned.
     */
    async get(...keys: (OldFields | string)[]): Promise<StorageKeyValue | any> { // Use 'any' for more flexibility
        return new Promise((resolve, reject) => {
            Runtime.storage.local.get(keys, (result) => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                  if (keys.length === 1) {
                    resolve(result[keys[0]]);
                  } else {
                    resolve(result);
                  }
                }
            });
        });
    },

    /**
     * Gets all items from storage.
     * @returns A promise that resolves with an object containing all stored items.
     */
    async getAll(): Promise<StorageKeyValue> {
        return new Promise((resolve, reject) => {
            Runtime.storage.local.get(null, (items) => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    resolve(items);
                }
            });
        });
    },

    /**
     * Removes items from storage for the given keys.
     * @param keys - An array of keys to remove from storage.
     * @returns A promise that resolves when the items are removed.
     */
    async rm(...keys: (OldFields | string)[]): Promise<void> {
        return new Promise((resolve, reject) => {
            Runtime.storage.local.remove(keys, () => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    resolve();
                }
            });
        });
    },

    /**
     * Clears all items from storage.
     * @returns A promise that resolves when the storage is cleared.
     */
    async clear(): Promise<void> {
        return new Promise((resolve, reject) => {
            Runtime.storage.local.clear(() => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    resolve();
                }
            });
        });
    },
});


```

`zil-pay/lib/streem/keys.ts`:

```ts
const app = 'zil-pay';

export const MTypeTabContent = {
  CONTENT: `@/${app}/content-script`,
  INJECTED: `@/${app}/injected-script`
};

export const MTypePopupWallet = {
  GET_RANDOM_SEED: `@/${app}/generate-random-seed`,
  CREATE_ACCOUNT_BY_SEED: `@/${app}/set-account-by-seed-words`,
  SET_PASSWORD: `@/${app}/popup-set-password`,
  LOG_OUT: `@/${app}/popup-logout`,
  SET_SEED_AND_PASSWORD: `@/${app}/popup-set-seed-words-and-password`,
  WALET_PASSWORD_CHANGE: `@/${app}/change-password`,
  GET_WALLET_STATE: `@/${app}/get-wallet-state`,
  EXPORT_SEED: `@/${app}/popup-export-seed-words`,
  EXPORT_PRIVATE_KEY: `@/${app}/popup-export-private-key`,
  EXPORT_QR_CODE_WALLET: `@/${app}/export-qr-code-wallet`,
  IMPORT_PRIVATE_KEY: `@/${app}/popup-import-private-key`,
  IMPORT_TRACK_ACCOUNT: `@/${app}/popup-import-track-account`,
  IMPORT_KEYSTORE: `@/${app}/popup-import-keystore`,
  ENCRYPT_WALLET: `@/${app}/encrypt-wallet-aes`,
  RES_ENCRYPTION: `@/${app}/response-encryption`,
  RES_DECRYPTION: `@/${app}/response-decryption`,
};

export const MTypePopupAccount = {
  RM_ACCOUNT: `@/${app}/remove-selected-account`,
  SELECT_ACCOUNT: `@/${app}/select-account`,
  SET_ACCOUNT_NAME: `@/${app}/set-account-name`,
  UPDATE_BALANCE: `@/${app}/popup-account-balance-upadte`,
};

export const MTypePopupTransaction = {
  UPDATE_TXNS: `@/${app}/check-processed-txns`,
  REJECT_CONFIRM_TX: `@/${app}/popup-reject-confirm-tx`,
  REJECT_ALL_CONFIRM_TXNS: `@/${app}/popup-reject-al-confirm-txns`,
  SEND_TO_SIGN_TX: `@/${app}/popup-send-to-sign-tx`,
  GET_REQUIRED_PARAMS: `@/${app}/get-required-params`,
  CLEAR_ALL_TXNS: `@/${app}/clear-all-txns`,
  GET_CURRENT_NONCE: `@/${app}/get-current-nonce`,
  RESET_NONCE: `@/${app}/reset-nonce`,
};

export const MTypePopupToken = {
  GET_ZRC2_STATE: `@/${app}/get-zrc2-token-info`,
  ADD_ZRC2_TOKEN: `@/${app}/add-new-zrc2-token`,
  RM_TOKEN: `@/${app}/remove-token`,
  GET_ZRC2_ALLOWANCES_FOR_SWAP: `@/${app}/get-zrc2-allowances-for-swap`,
};

export const MTypePopupNFT = {
  UPDATE_NFT_LIST: `@/${app}/update-nft-list`,
  GET_NFT_LIST: `@/${app}/get-nft-list`,
  FETCH_NFT: `@/${app}/fetch-nft`,
  ADD_NFT: `@/${app}/add-nft`,
  REMOVE_NFT: `@/${app}/remove-nft`,
};

export const MTypePopupNetwork = {
  SELECT_SSN: `@/${app}/select-from-ssn-list`,
  RESET_NETWROK: `@/${app}/reset-netwrok-settings`,
  SET_NET_CONFIG: `@/${app}/set-netwrok-config`,
  SELECT_NETWORK: `@/${app}/select-network`,
  UPDATE_SSN_LIST: `@/${app}/update-ssn-list`,
  GET_LATEST_BLOCK: `@/${app}/get-latest-block-number`,
};

export const MTypePopupDApp = {
  USER_RESPONSE_DAPP: `@/${app}/user-response-connect-dapp`,
  RM_APP: `@/${app}/remove-dapp`,
  CLEAR_APPS: `@/${app}/clear-all-apps`,
  SET_PHISHING_DETECTION: `@/${app}/set-phishing-detection`,
};

export const MTypePopupContact = {
  ADD_CONTACT: `@/${app}/add-a-contact`,
  RM_CONTACT: `@/${app}/remove-a-contact`,
};

export const MTypePopupSettings = {
  CHANGE_CURRENCY: `@/${app}/change-currency`,
  UPDATE_RATE: `@/${app}/update-rate`,
  RESET_CURRENCY: `@/${app}/reset-currency`,
  SET_THEME: `@/${app}/set-theme-mode`,
  RESET_THEME: `@/${app}/reset-theme`,
  SET_LOCALE: `@/${app}/set-locale`,
  RESET_LOCALE: `@/${app}/reset-locale`,
  SET_GAS_MULTIPLIER: `@/${app}/set-gas-multiplier`,
  RESET_GAS: `@/${app}/reset-gas`,
  SET_LOCK_TIME: `@/${app}/set-lock-timer`,
  SET_ADDRESS_FORMAT: `@/${app}/set-address-format`,
  SET_PROMT_ENABLED: `@/${app}/set-promt-enabled`,
};

export const MTypePopupSign = {
  REJECT_SIGN_MESSAGE: `@/${app}/reject-sign-message`,
  SIGN_MESSAGE_APPROVE: `@/${app}/approve-sign-message`,
};

export const MTypePopupUtil = {
  FROM_BECH32: `@/${app}/convert-from-bech32`,
};

export const MTypePopupDex = {
  UPDATE_DEX_DATA: `@/${app}/update-dex-data`,
  UPDATE_DEX_SETTINGS: `@/${app}/update-dex-settings`,
};

export const MTypePopupStake = {
  GET_STAKE_PROPS: `@/${app}/get-stake-props`,
};

export const MTypePopupLedger = {
  ADD_LEDGER_ACCOUNT: `@/${app}/add-ledger-account`,
};

export const MTypeTab = {
  GET_WALLET_DATA: `@/${app}/injected-get-wallet-data`,
  ADDRESS_CHANGED: `@/${app}/address-changed`,
  NETWORK_CHANGED: `@/${app}/network-changed`,
  LOCK_STAUS: `@/${app}/lack-status-updated`,
  CONTENT_PROXY_MEHTOD: `@/${app}/request-through-content`,
  CONTENT_PROXY_RESULT: `@/${app}/response-from-content`,
  CALL_TO_SIGN_TX: `@/${app}/request-to-sign-tx`,
  TX_RESULT: `@/${app}/response-tx-result`,
  SIGN_MESSAGE: `@/${app}/request-to-sign-message`,
  SING_MESSAGE_RES: `@/${app}/response-sign-message`,
  NEW_BLOCK: `@/${app}/new-block-created`,
  ADD_ENCRYPTION: `@/${app}/request-add-encryption`,
  RES_ENCRYPTION: `@/${app}/response-encryption`,
  ADD_DECRYPTION: `@/${app}/add-decryption`,
  RES_DECRYPTION: `@/${app}/response-decryption`,
  CONNECT_APP: `@/${app}/request-to-connect-dapp`,
  RESPONSE_TO_DAPP: `@/${app}/response-dapp-connect`,
  DISCONNECT_APP: `@/${app}/request-to-disconnect-dapp`
};


```

`zil-pay/lib/streem/message.ts`:

```ts
import { Runtime } from "lib/runtime/extensionizer";


export interface ReqBody<T = unknown> {
    type: string;
    payload?: T;
    domain?: string;
    from?: string;
}

export class Message<T = unknown> {
    constructor(public readonly body: ReqBody<T>) {}

    static signal(type: string): Message<object> {
        return new Message({ type });
    }

    async send(): Promise<T> {
        for (let i = 0; i < 10; i++) {
            try {
                const res = await this.#trySend();
                if (res) return res;
            } catch {}
        }
        throw new Error("service_worker_stopped");
    }

    #trySend(): Promise<T> {
        return new Promise((resolve) => {
          try {
            let data = JSON.parse(JSON.stringify(this.body));
            Runtime.runtime.sendMessage(data, resolve);
          } catch (err) {
            console.error(this, err);
            window.location.reload();
          }
        });
    }
}

```

`zil-pay/lib/streem/secure-message.ts`:

```ts
import type { ReqBody } from './message';
import type { TabStream } from './tab-stream';

export class SecureContentMessage<T = unknown> {
    constructor(public readonly body: ReqBody<T>) {}

    get type() { return this.body.type; }
    get payload() { return this.body.payload; }

    send(stream: TabStream, recipient: string) {
        stream.send(this.body, recipient);
    }
}

```

`zil-pay/lib/streem/tab-stream.ts`:

```ts
import type { ReqBody } from './message';
import { Runtime } from "lib/runtime";
import { MTypeTabContent } from './keys';

export class TabStream {
    constructor(public readonly eventName: string) {}

    listen(cb: (payload: ReqBody) => void) {
        globalThis.document?.addEventListener(this.eventName, (event: Event) => {
            const detail = (event as CustomEvent).detail;
            if (detail) {
                try {
                    cb(JSON.parse(detail));
                } catch (e) {
                    console.error("Error parsing event detail", e, event);
                }
            }
        });
    }

    send(data: ReqBody, to: string) {
        data.from = this.eventName;
        if (Object.values(MTypeTabContent).includes(to)) {
            this.#dispatch(JSON.stringify(data), to);
        }
    }

    #dispatch(data: string, to: string) {
        globalThis.document?.dispatchEvent(this.#getEvent(data, to));
    }

    #getEvent(detail: string, to: string) {
        return new CustomEvent(to, { detail });
    }

    /**
     * Sends a signal message to the specified tab.
     * @param tabId - The ID of the tab.
     * @param message - The message to send.
     */
    async sendSignalToTab(tabId: number, message: ReqBody): Promise<void> {
        try {
            await Runtime.tabs.sendMessage(tabId, message);
        } catch (error) {
            console.error(`Failed to send signal to tab ${tabId}:`, error);
            throw error; // Re-throw the error to be handled by the caller
        }
    }

    /**
      * Sends message to all tabs except the excluded tabIds
      * @param message
      * @param excludedTabIds
      */
    async sendToAllTabs(message: ReqBody, excludedTabIds: number[] = []): Promise<void> {
        try {
            const tabs = await Runtime.tabs.query({});
            for (const tab of tabs) {
                if (tab?.id && !excludedTabIds.includes(tab.id)) {
                    await Runtime.tabs.sendMessage(tab.id, message);
                }
            }
        } catch (error) {
            console.error("Failed to send message to all tabs:", error);
            throw error; // Re-throw the error
        }
    }
}

```

`zil-pay/lib/streem/tabs-message.ts`:

```ts
import type { ReqBody } from './message';
import { Runtime } from "lib/runtime";


export class TabsMessage<T = any> {
    constructor(public readonly body: ReqBody<T>) {}

    static async getTabs(): Promise<chrome.tabs.Tab[]> {
        return Runtime.tabs.query({});
    }

    async signal(domain: string): Promise<string> {
        return new Promise<string>((resolve, reject) => {
            Runtime.tabs.query({ active: true, currentWindow: true }, (tabs: chrome.tabs.Tab[]) => {
                const tab = tabs[0];
                if (!tab) {
                    reject(new Error("no active tabs"));
                    return;
                }

                const { hostname } = new URL(tab.url!);

                if (hostname !== domain) {
                    reject(new Error("invalid domain"));
                    return;
                }
                Runtime.tabs.sendMessage(Number(tab.id), this.body)
                    .then(() => resolve(""))
                    .catch(reject);
            });
        });
    }



    async send(...domains: string[]): Promise<void> {
        const tabs = await TabsMessage.getTabs();

        tabs.forEach(async (tab) => {
            if (tab?.url && domains.includes(new URL(tab.url).hostname)) {
                try {
                    await Runtime.tabs.sendMessage(Number(tab.id), this.body);
                } catch (err) {
                    console.error(`Failed to send message to tab ${tab.id}`, err);
                }
            }
        });
    }

    async sendAll(): Promise<void> {
        const tabs = (await TabsMessage.getTabs())
            .filter((tab) => tab?.url && !tab.url.startsWith("chrome://"));

        try {
            for (const tab of tabs) {
                await Runtime.tabs.sendMessage(Number(tab.id), this.body);
            }
        } catch (err) {
            console.error("TabsMessage", err);
        }
    }
}

```

`zil-pay/lib/types/checker.ts`:

```ts
type Arg = unknown;

export const TypeOf = Object.freeze({
    /**
     * Checks if the given argument is an array.
     * @param arg The argument to check.
     * @returns True if the argument is an array, false otherwise.
     */
    isArray(arg: Arg): boolean {
        return Array.isArray(arg);
    },

    /**
     * Checks if the given argument is a plain object.
     * @param arg The argument to check.
     * @returns True if the argument is a plain object, false otherwise.
     */
    isObject(arg: Arg): boolean {
        return typeof arg === 'object' && arg !== null && !Array.isArray(arg) && !(arg instanceof Date) && !(arg instanceof Error) && Object.getPrototypeOf(arg) === Object.prototype;
    },

    /**
     * Checks if the given argument is a number.
     * @param arg The argument to check.
     * @returns True if the argument is a number, false otherwise.
     */
    isNumber(arg: Arg): boolean {
        return typeof arg === 'number' && !isNaN(arg as number);
    },

    /**
     * Checks if the given argument is an integer.
     * @param arg The argument to check.
     * @returns True if the argument is an integer, false otherwise.
     */
    isInt(arg: Arg): boolean {
        return Number.isInteger(arg as number);
    },

    /**
     * Checks if the given argument is an error object.
     * @param arg The argument to check.
     * @returns True if the argument is an error object, false otherwise.
     */
    isError(arg: Arg): boolean {
        return arg instanceof Error;
    },

    /**
     * Checks if the given argument is a string.
     * @param arg The argument to check.
     * @returns True if the argument is a string, false otherwise.
     */
    isString(arg: Arg): boolean {
        return typeof arg === 'string' || arg instanceof String;
    },

    /**
     * Checks if the given argument is a boolean.
     * @param arg The argument to check.
     * @returns True if the argument is a boolean, false otherwise.
     */
    isBoolean(arg: Arg): boolean {
        return typeof arg === 'boolean' || arg instanceof Boolean;
    },

    /**
     * Checks if the given argument is null.
     * @param arg The argument to check.
     * @returns True if the argument is null, false otherwise.
     */
    isNull(arg: Arg): boolean {
        return arg === null;
    },

    /**
     * Checks if the given argument is undefined.
     * @param arg The argument to check.
     * @returns True if the argument is undefined, false otherwise.
     */
    isUndefined(arg: Arg): boolean {
        return arg === undefined;
    },

    /**
     * Checks if the given argument is an empty object.
     * @param arg The argument to check.
     * @returns True if the argument is an empty object, false otherwise.
     */
    isEmptyObject(arg: Arg): boolean {
        return this.isObject(arg) && Object.keys(arg as object).length === 0;
    },

    /**
     * Checks if the given argument is an empty array.
     * @param arg The argument to check.
     * @returns True if the argument is an empty array, false otherwise.
     */
    isEmptyArray(arg: Arg): boolean {
        return this.isArray(arg) && (arg as Array<unknown>).length === 0;
    },
});


```

`zil-pay/lib/types/index.ts`:

```ts
export * from './checker';


```

`zil-pay/lib/utils/hex.ts`:

```ts
export const HEX_PREFIX = "0x";

/**
 * Checks if a string starts with the '0x' prefix (case-insensitive).
 *
 * @param str The string to check.
 * @returns True if the string starts with '0x', false otherwise.
 */
export function hasHexPrefix(str: string): boolean {
  return str.toLowerCase().startsWith(HEX_PREFIX);
}


export function stripHexPrefix(hex: string): string {
  return hasHexPrefix(hex) ? hex.slice(2) : hex;
}

/**
 * A lookup table for fast number-to-hex conversion.
 */
const HEX_CHAR_TABLE: string[] = Array.from({ length: 256 }, (_, i) =>
    i.toString(16).padStart(2, '0')
);

/**
 * Efficiently converts a Uint8Array to a hexadecimal string.
 * This function uses a pre-computed lookup table for maximum performance.
 *
 * @param {Uint8Array} uint8Array The byte array (numbers 0-255) to convert.
 * @param {boolean} [prefix=false] Whether to include the '0x' prefix in the output.
 * @returns {string} The resulting hexadecimal string.
 */
export function uint8ArrayToHex(uint8Array: Uint8Array, prefix: boolean = false): string {
    const hexParts = new Array(uint8Array.length);
    for (let i = 0; i < uint8Array.length; i++) {
        hexParts[i] = HEX_CHAR_TABLE[uint8Array[i]];
    }
    const hexString = hexParts.join('');

    return prefix ? HEX_PREFIX + hexString : hexString;
}

/**
 * Efficiently converts a hexadecimal string to a Uint8Array.
 * This function is optimized to minimize memory allocation and avoid
 * unnecessary intermediate conversions.
 *
 * @param {string} hexString The hexadecimal string (may start with '0x').
 * @returns {Uint8Array} A Uint8Array representing the hexadecimal data.
 * @throws {Error} if the string has an odd number of characters or contains invalid hex characters.
 */
export function hexToUint8Array(hexString: string): Uint8Array {
    if (hexString == '' || hexString == HEX_PREFIX) {
        return new Uint8Array();
    }

    const str = stripHexPrefix(hexString);

    if (str.length % 2 !== 0) {
        throw new Error('Invalid hex string: must have an even number of characters.');
    }

    const arrayBuffer = new Uint8Array(str.length / 2);

    for (let i = 0; i < str.length; i += 2) {
        const byteString = str.substring(i, i + 2);
        const byteValue = parseInt(byteString, 16);

        if (isNaN(byteValue)) {
            throw new Error(`Invalid hex character "${byteString}" at position ${i}.`);
        }
        
        arrayBuffer[i / 2] = byteValue;
    }

    return Uint8Array.from(arrayBuffer);
}


/**
 * Converts a hexadecimal string to a BigInt.
 * This is the most direct and performant way to perform the conversion.
 *
 * @param {string} hexString The hexadecimal string (may start with '0x').
 * @returns {bigint} The BigInt representation of the hexadecimal string.
 * @throws {SyntaxError} if the string is not a valid hexadecimal number.
 */
export function hexToBigInt(hexString: string): bigint {
    const cleanHex = hexString.startsWith(HEX_PREFIX) ? hexString : `${HEX_PREFIX}${hexString}`;
    return BigInt(cleanHex);
}

```

`zil-pay/lib/utils/utf8.ts`:

```ts
export function utf8ToUint8Array(str: string): Uint8Array {
  const encoder = new TextEncoder();
  return encoder.encode(str);
}

export function uint8ArrayToUtf8(arr: Uint8Array): string {
  const decoder = new TextDecoder();
  return decoder.decode(arr);
}


```

`zil-pay/lib/zilliqa/bech32.ts`:

```ts
import { assert } from 'lib/runtime/assert';
import { CHARSET, HRP, GENERATOR } from 'lib/zilliqa/config';
import { toChecksumHexAddress } from 'lib/zilliqa/checksum';
import { hexToUint8Array, uint8ArrayToHex } from '../utils/hex';

const polymod = (values: Uint8Array): number => {
    let chk: number = 1;
    for (let p: number = 0; p < values.length; ++p) {
        const top: number = chk >> 25;
        chk = ((chk & 0x1ffffff) << 5) ^ values[p];
        for (let i: number = 0; i < 5; ++i) {
            if ((top >> i) & 1) {
                chk ^= GENERATOR[i];
            }
        }
    }
    return chk;
};

const hrpExpand = (hrp: string): Uint8Array => {
    const ret: number[] = [];
    for (let i: number = 0; i < hrp.length; ++i) {
        ret.push(hrp.charCodeAt(i) >> 5);
    }
    ret.push(0);
    for (let i: number = 0; i < hrp.length; ++i) {
        ret.push(hrp.charCodeAt(i) & 31);
    }
    return new Uint8Array(ret);
};

export function convertBits(data: Uint8Array, fromWidth: number, toWidth: number, pad: boolean = true): Uint8Array | null {
    let acc: number = 0;
    let bits: number = 0;
    const ret: number[] = [];
    const maxv: number = (1 << toWidth) - 1;

    for (const value of data) {
        if (value < 0 || (value >> fromWidth) !== 0) {
            return null;
        }
        acc = (acc << fromWidth) | value;
        bits += fromWidth;
        while (bits >= toWidth) {
            bits -= toWidth;
            ret.push((acc >> bits) & maxv);
        }
    }

    if (pad) {
        if (bits > 0) {
            ret.push((acc << (toWidth - bits)) & maxv);
        }
    } else if (bits >= fromWidth || (acc << (toWidth - bits)) & maxv) {
        return null;
    }

    return new Uint8Array(ret);
}

function verifyChecksum(hrp: string, data: Uint8Array): boolean {
    return polymod(new Uint8Array([...hrpExpand(hrp), ...data])) === 1;
}

function createChecksum(hrp: string, data: Uint8Array): Uint8Array {
    const values: Uint8Array = new Uint8Array([...hrpExpand(hrp), ...data, 0, 0, 0, 0, 0, 0]);
    const mod: number = polymod(values) ^ 1;
    const ret: number[] = [];
    for (let p: number = 0; p < 6; ++p) {
        ret.push((mod >> (5 * (5 - p))) & 31);
    }
    return new Uint8Array(ret);
}

export const encode = (hrp: string, data: Uint8Array): string => {
    const checksum: Uint8Array = createChecksum(hrp, data);
    const combined: Uint8Array = new Uint8Array([...data, ...checksum]);
    let ret: string = hrp + '1';
    for (const value of combined) {
        ret += CHARSET.charAt(value);
    }
    return ret;
};

export const decode = (bechString: string): { hrp: string; data: Uint8Array } | null => {
    let hasLower: boolean = false;
    let hasUpper: boolean = false;
    for (let i: number = 0; i < bechString.length; ++i) {
        const charCode: number = bechString.charCodeAt(i);
        if (charCode < 33 || charCode > 126) {
            return null;
        }
        if (charCode >= 97 && charCode <= 122) {
            hasLower = true;
        }
        if (charCode >= 65 && charCode <= 90) {
            hasUpper = true;
        }
    }

    if (hasLower && hasUpper) {
        return null;
    }

    const lowerBechString: string = bechString.toLowerCase();
    const pos: number = lowerBechString.lastIndexOf('1');

    if (pos < 1 || pos + 7 > lowerBechString.length || lowerBechString.length > 90) {
        return null;
    }

    const hrp: string = lowerBechString.substring(0, pos);
    const data: number[] = [];
    for (let i: number = pos + 1; i < lowerBechString.length; ++i) {
        const d: number = CHARSET.indexOf(lowerBechString.charAt(i));
        if (d === -1) {
            return null;
        }
        data.push(d);
    }

    const dataBytes: Uint8Array = new Uint8Array(data);
    if (!verifyChecksum(hrp, dataBytes)) {
        return null;
    }

    return { hrp, data: dataBytes.slice(0, dataBytes.length - 6) };
};

export const toBech32Address = async (address: string): Promise<string> => {
    const addressBytes = hexToUint8Array(address);
    const addrBz = convertBits(addressBytes, 8, 5);
    assert(addrBz !== null, 'Cannot convert bytes to Bech32 bits.');

    return encode(HRP, addrBz as Uint8Array);
};

export const fromBech32Address = async (address: string): Promise<string> => {
    const res = decode(address);
    assert(res !== null, 'Invalid Bech32 address.');

    const { hrp, data } = res as { hrp: string; data: Uint8Array };
    assert(hrp === HRP, `Expected HRP '${HRP}', but got '${hrp}'.`);

    const buf = convertBits(data, 5, 8, false);
    assert(buf !== null, 'Cannot convert Bech32 bits to bytes.');

    const hexAddress = uint8ArrayToHex(buf as Uint8Array);

    return toChecksumHexAddress(hexAddress);
};


```

`zil-pay/lib/zilliqa/checksum.ts`:

```ts
import { sha256 } from 'crypto/sha256';
import { 
    HEX_PREFIX, 
    stripHexPrefix, 
    uint8ArrayToHex, 
    hexToUint8Array, 
    hexToBigInt 
} from 'lib/utils/hex';

export async function toChecksumBytesAddress(addressBytes: Uint8Array): Promise<string> {
  const addressHex = uint8ArrayToHex(addressBytes);
  const hashBytes = await sha256(addressBytes);
  const hashBigInt = hexToBigInt(uint8ArrayToHex(hashBytes));

  let checksummedHex = '';

  for (let i = 0; i < addressHex.length; i++) {
    const char = addressHex[i];
    if (/[0-9]/.test(char)) {
        checksummedHex += char;
    } else {
      const bitPosition = BigInt(255 - 6 * i);
      const mask = BigInt(2) ** bitPosition;
      const shouldBeUpper = (hashBigInt & mask) >= BigInt(1);

      if (shouldBeUpper) {
        checksummedHex += char.toUpperCase();
      } else {
        checksummedHex += char.toLowerCase();
      }
    }
  }

  return HEX_PREFIX + checksummedHex;
}

export async function toChecksumHexAddress(address: string): Promise<string> {
  const unprefixedAddress = stripHexPrefix(address);
  const addressBytes = hexToUint8Array(unprefixedAddress);
  return toChecksumBytesAddress(addressBytes);
}


```

`zil-pay/lib/zilliqa/config.ts`:

```ts
export const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
export const HRP = 'zil';
export const GENERATOR = [
  0x3b6a57b2,
  0x26508e6d,
  0x1ea119fa,
  0x3d4233dd,
  0x2a1462b3
];

```

`zil-pay/lib/zilliqa/index.ts`:

```ts
export * from './bech32';
export * from './checksum';
export * from './config';
export * from './pubkey';

```

`zil-pay/lib/zilliqa/pubkey.ts`:

```ts
import { sha256 } from 'crypto/sha256';

export async function fromZilPubKey(pubKey: Uint8Array): Promise<Uint8Array> {
  const hashBytes = await sha256(pubKey);
  const addressBytes = hashBytes.slice(12);

  if (addressBytes.length !== 20) {
    throw new Error('Invalid public key length or unexpected hash output length.');
  }

  return addressBytes;
}

```

`zil-pay/popup/main.ts`:

```ts
import { mount } from "svelte";
import App from "./App.svelte";

export default mount(App, {
  target: document.body,
});

```

`zil-pay/rollup.config.mjs`:

```mjs
import svelte from 'rollup-plugin-svelte';
import commonjs from '@rollup/plugin-commonjs';
import resolve from '@rollup/plugin-node-resolve';
import { sveltePreprocess } from 'svelte-preprocess';
import typescript from '@rollup/plugin-typescript';
import { terser } from 'rollup-plugin-terser';
import json from '@rollup/plugin-json';
import copy from 'rollup-plugin-copy';
import replace from '@rollup/plugin-replace';
import postcss from 'rollup-plugin-postcss';
import { visualizer } from 'rollup-plugin-visualizer';
import cssnano from 'cssnano';
import { readFileSync } from 'fs';

const pkg = JSON.parse(readFileSync('./package.json', 'utf8'));
const production = !process.env.ROLLUP_WATCH;
const manifest = process.env.MANIFEST || 2;

const createConfig = (name, input, output, extraPlugins = []) => ({
  input,
  output: {
    sourcemap: !production,
    format: 'iife',
    name,
    file: output
  },
  plugins: [
    typescript({
      sourceMap: !production,
      inlineSources: !production,
      compilerOptions: {
        target: 'ES2020',
        module: 'esnext',
        moduleResolution: 'node',
        lib: ['ES2020', 'DOM'],
        allowSyntheticDefaultImports: true,
        esModuleInterop: true,
        skipLibCheck: true,
        strict: false,
        noFallthroughCasesInSwitch: false,
        noEmit: false,
        declaration: false,
        declarationMap: false,
        resolveJsonModule: true,
      },
      include: ['**/*.ts', '**/*.tsx'],
      exclude: ['node_modules/**', '__tests__/**']
    }),
    resolve({
      browser: true,
      dedupe: ['svelte'],
      extensions: ['.ts', '.tsx', '.mjs', '.js', '.json', '.svelte'],
      preferBuiltins: false
    }),
    commonjs(),
    json(),
    ...extraPlugins,
    production && terser({
      format: {
        comments: false
      },
      compress: true
    }),
    production && visualizer({
      filename: `stats/${name}.html`
    }),
  ].filter(Boolean),
  watch: {
    clearScreen: false
  },
  external: [],
  onwarn(warning, warn) {
    if (warning.code === 'CIRCULAR_DEPENDENCY') return;
    if (warning.code === 'TS7029' && warning.loc?.file?.includes('proto/zq1.ts')) return;
    warn(warning);
  }
});

const popup = createConfig(
  'popup',
  'popup/main.ts',
  'dist/bundle.js',
  [
    svelte({
      preprocess: sveltePreprocess({
        sourceMap: !production,
        typescript: {
          tsconfigFile: './tsconfig.json',
          compilerOptions: {
            target: 'ES2020',
            module: 'esnext',
            verbatimModuleSyntax: false
          }
        },
        scss: {
          renderSync: true,
          includePaths: ['popup/styles/'],
          prependData: '@use "popup/styles/global.scss";'
        }
      }),
      compilerOptions: {
        dev: !production
      }
    }),
    postcss({
      extract: 'bundle.css',
      minimize: production,
      plugins: [
        cssnano({
          preset: 'default'
        })
      ],
      sourceMap: !production
    })
  ]
);

const background = createConfig(
  'background',
  'background/index.ts',
  'dist/background.js',
  [
    replace({
      preventAssignment: true,
      delimiters: ['', ''],
      values: {
        'process.env.NODE_ENV': JSON.stringify(production ? 'production' : 'development'),
        'global.': 'globalThis.',
        'process.browser': 'true'
      }
    }),
    copy({
      targets: [
        { src: 'public/icons', dest: 'dist/' },
        { src: 'public/fonts', dest: 'dist/' },
        { src: 'public/lang', dest: 'dist/' },
        { src: 'public/imgs', dest: 'dist/' },
        { src: 'public/index.html', dest: 'dist/' },
        { src: 'public/phishing.html', dest: 'dist/' },
        {
          src: `public/manifest_${manifest}.json`,
          dest: 'dist/',
          rename: 'manifest.json',
          transform: (contents) => {
            const jsonContent = JSON.parse(contents);
            jsonContent.version = pkg.version;
            jsonContent.short_name = pkg.shortName || pkg.name;
            jsonContent.description = pkg.description;
            jsonContent.author = pkg.homepage;
            return JSON.stringify(jsonContent, null, 2);
          }
        }
      ]
    })
  ]
);

const content = createConfig(
  'content',
  'content/index.ts',
  'dist/content.js',
  [
    replace({
      preventAssignment: true,
      delimiters: ['', ''],
      values: {}
    })
  ]
);

export default [
  popup,
  background,
  content
];


```

`zil-pay/types/micro-eth-signer.d.ts`:

```ts
declare module "micro-eth-signer/abi.js" {
  export * from "micro-eth-signer/abi";
}

```

`zil-pay/vitest.config.ts`:

```ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    setupFiles: '__tests__/setupTests.ts',
    include: ['__tests__/**/*.test.{ts,tsx}'],
  },
});

```