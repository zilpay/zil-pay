Project Path: zil-pay

Source Tree:

```txt
zil-pay
├── __tests__
│   ├── array
│   │   └── array.test.ts
│   ├── crypto
│   │   ├── aes256.test.ts
│   │   ├── argon2.test.ts
│   │   ├── b64.test.ts
│   │   ├── bip32.test.ts
│   │   ├── bip39.test.ts
│   │   ├── keychain.test.ts
│   │   ├── kuznechik.test.ts
│   │   ├── ntrup.test.ts
│   │   ├── number.test.ts
│   │   ├── pbkdf2.test.ts
│   │   ├── pubkey.test.ts
│   │   ├── random.test.ts
│   │   ├── schnorr.test.ts
│   │   ├── sha256.test.ts
│   │   ├── sha512.test.ts
│   │   └── word_list.ts
│   ├── data.ts
│   ├── setupTests.ts
│   ├── storage
│   │   ├── migrator.test.ts
│   │   └── storage.test.ts
│   ├── stream
│   │   └── stream.test.ts
│   ├── types
│   │   └── checker.test.ts
│   └── zilliqa
│       └── address.test.ts
├── background
│   ├── index.ts
│   ├── secure
│   │   ├── index.ts
│   │   ├── migrator.ts
│   │   ├── session.ts
│   │   └── storage.ts
│   ├── services
│   │   └── guard.ts
│   └── storage
│       ├── account.ts
│       ├── address-type.ts
│       ├── argon.ts
│       ├── background.ts
│       ├── chain.ts
│       ├── explorer.ts
│       ├── ftoken.ts
│       ├── index.ts
│       ├── notification.ts
│       ├── settings.ts
│       └── wallet.ts
├── config
│   ├── argon2.ts
│   ├── common.ts
│   ├── errors.ts
│   ├── fields.ts
│   ├── manifest.ts
│   ├── pbkdf2.ts
│   └── sha.ts
├── content
│   └── index.ts
├── crypto
│   ├── aes256.ts
│   ├── argon2.ts
│   ├── b64.ts
│   ├── bip32.ts
│   ├── bip39.ts
│   ├── index.ts
│   ├── keychain.ts
│   ├── kuznechik.ts
│   ├── ntrup.ts
│   ├── number.ts
│   ├── pbkdf2.ts
│   ├── proto
│   │   └── zq1.ts
│   ├── pubkey.ts
│   ├── random.ts
│   ├── sha256.ts
│   ├── sha512.ts
│   ├── uuid.ts
│   └── zilliqa
│       ├── pubkey.ts
│       └── schnorr.ts
├── lib
│   ├── array
│   │   ├── chunk.ts
│   │   └── shuffle.ts
│   ├── popup
│   │   ├── clipboard.ts
│   │   ├── printer.ts
│   │   └── warp-message.ts
│   ├── runtime
│   │   ├── assert.ts
│   │   ├── ext-id.ts
│   │   ├── extensionizer.ts
│   │   ├── get-url.ts
│   │   ├── index.ts
│   │   └── manifest.ts
│   ├── storage
│   │   ├── builder.ts
│   │   ├── index.ts
│   │   └── storage.ts
│   ├── streem
│   │   ├── TabsMessage.ts
│   │   ├── keys.ts
│   │   ├── message.ts
│   │   ├── secure-message.ts
│   │   ├── tab-stream.ts
│   │   └── tabs-message.ts
│   ├── types
│   │   ├── checker.ts
│   │   └── index.ts
│   └── zilliqa
│       ├── bech32.ts
│       ├── checksum.ts
│       ├── config.ts
│       └── pubkey.ts
├── popup
│   ├── index.ts
│   └── main.ts
└── vitest.config.ts

```

`zil-pay/__tests__/array/array.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import { shuffle } from "../../lib/array/shuffle";
import { chunk } from "../../lib/array/chunk";

describe("shuffle", () => {
  it("should shuffle an array of numbers", () => {
    const array = [1, 2, 3, 4, 5];
    const shuffledArray = shuffle([...array]);

    expect(shuffledArray).toHaveLength(array.length);
    expect(shuffledArray).not.toEqual(array);
    expect(shuffledArray.sort()).toEqual(array.sort());
  });

  it("should shuffle an array of strings", () => {
    const array = ["a", "b", "c", "d", "e"];
    const shuffledArray = shuffle([...array]);

    expect(shuffledArray).toHaveLength(array.length);
    expect(shuffledArray).not.toEqual(array);
    expect(shuffledArray.sort()).toEqual(array.sort());
  });

  it("should handle an empty array", () => {
    const array: number[] = [];
    const shuffledArray = shuffle([...array]);
    expect(shuffledArray).toEqual([]);
  });

  it("should handle an array with one element", () => {
    const array = [1];
    const shuffledArray = shuffle([...array]);
    expect(shuffledArray).toEqual([1]);
  });
});

describe("chunk", () => {
  it("should chunk an array into smaller arrays of the specified size", () => {
    const array = [1, 2, 3, 4, 5, 6, 7, 8];
    const chunkSize = 3;
    const result = chunk(array, chunkSize);
    expect(result).toEqual([
      [1, 2, 3],
      [4, 5, 6],
      [7, 8],
    ]);
  });

  it("should handle a chunk size larger than the array length", () => {
    const array = [1, 2, 3, 4, 5];
    const chunkSize = 10;
    const result = chunk(array, chunkSize);
    expect(result).toEqual([[1, 2, 3, 4, 5]]);
  });

  it("should handle an array with a length that is a multiple of the chunk size", () => {
    const array = [1, 2, 3, 4, 5, 6];
    const chunkSize = 2;
    const result = chunk(array, chunkSize);
    expect(result).toEqual([
      [1, 2],
      [3, 4],
      [5, 6],
    ]);
  });

  it("should handle an empty array", () => {
    const array: number[] = [];
    const chunkSize = 3;
    const result = chunk(array, chunkSize);
    expect(result).toEqual([]);
  });

  it("should throw an error if the chunk size is zero", () => {
    const array = [1, 2, 3, 4, 5];
    const chunkSize = 0;
    expect(() => chunk(array, chunkSize)).toThrowError(
      "Size must be a positive number.",
    );
  });

  it("should throw an error if the chunk size is negative", () => {
    const array = [1, 2, 3, 4, 5];
    const chunkSize = -1;
    expect(() => chunk(array, chunkSize)).toThrowError(
      "Size must be a positive number.",
    );
  });
});

```

`zil-pay/__tests__/crypto/aes256.test.ts`:

```ts
import { test, expect } from "vitest";
import { AESCipherV2, AESCipherV3, ErrorMessages } from "../../crypto/aes256";
import { sha256 } from "../../crypto/sha256";
import {
  IMPORTED_KEY,
  PASSWORD,
  STORAGE_V2,
  STORAGE_V3,
  WORDS,
  EXTENSION_ID,
} from "../data";
import { utils } from "aes-js";
import { pbkdf2 } from "../../crypto/pbkdf2";
import { base64ToUint8Array } from "../../crypto/b64";
import { ShaAlgorithms } from "../../config/pbkdf2";

test("decrypt Storage v3 AES-v3", async () => {
  const salt = utils.utf8.toBytes(EXTENSION_ID);
  const [algorithm, iteractions] = STORAGE_V3["guard-configuration"].split(":");
  const vaultBase64 = STORAGE_V3.vault;
  const vaultBytes = base64ToUint8Array(vaultBase64);
  const passwordBytes = utils.utf8.toBytes(PASSWORD);
  const key = await pbkdf2(
    passwordBytes,
    salt,
    Number(iteractions),
    algorithm as ShaAlgorithms,
  );
  const key32 = await sha256(key);
  const decryptedBytes = AESCipherV3.decrypt(vaultBytes, key32);
  const decrypted = utils.utf8.fromBytes(decryptedBytes);

  expect(decrypted).toEqual(WORDS);
});

test("decrypt accounts Storage v3 AES-v3", async () => {
  const salt = utils.utf8.toBytes(EXTENSION_ID);
  const [algorithm, iteractions] = STORAGE_V3["guard-configuration"].split(":");
  const passwordBytes = utils.utf8.toBytes(PASSWORD);
  const key = await pbkdf2(
    passwordBytes,
    salt,
    Number(iteractions),
    algorithm as ShaAlgorithms,
  );
  const key32 = await sha256(key);
  const walletIdentities = JSON.parse(STORAGE_V3["wallet-identities"]);
  const importedAccount = walletIdentities.identities[1];
  const privKeyBase64 = importedAccount.privKey;
  const privKeyBytes = base64ToUint8Array(privKeyBase64);
  const decryptedBytes = AESCipherV3.decrypt(privKeyBytes, key32);
  const decryptedPrivKey = utils.hex.fromBytes(decryptedBytes);
  expect(decryptedPrivKey).toEqual(IMPORTED_KEY);
});

test("encrypt encrypts data and decrypt successfully recovers it", () => {
  const key = new TextEncoder().encode("1234567890123456"); // 16-byte key
  const content = new TextEncoder().encode("Hello, ZilPay!");

  const encrypted = AESCipherV3.encrypt(content, key);
  const decrypted = AESCipherV3.decrypt(encrypted, key);

  expect(new TextDecoder().decode(decrypted)).toBe("Hello, ZilPay!");
});

test("decrypt with wrong key does not return original content", () => {
  const key = new TextEncoder().encode("correctKey123456"); // 16-byte key
  const wrongKey = new TextEncoder().encode("wrongKey12345678"); // 16-byte key

  const content = new TextEncoder().encode("Secret message");
  const encrypted = AESCipherV3.encrypt(content, key);

  const decrypted = AESCipherV3.decrypt(encrypted, wrongKey);

  expect(decrypted).not.toEqual(content);
  expect(new TextDecoder().decode(decrypted)).not.toBe(
    new TextDecoder().decode(content),
  );
});

test("encrypt throws if key length is invalid", () => {
  const invalidKey = new TextEncoder().encode("shortkey"); // <16 bytes
  const content = new TextEncoder().encode("Data");

  expect(() => AESCipherV3.encrypt(content, invalidKey)).toThrowError(
    ErrorMessages.InvalidKeyLength,
  );
});

test("test AES-v2", async () => {
  let key = "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8";
  let content =
    "8bfed20592daf43ca798ee263fcca946013876e00f34aeab3f0836872ccc19da";
  let encrypted =
    "U2FsdGVkX19nN1qtOBORWCorbwujy5Nxm7bfehROWZn/vLrxMXuXJE3Bs1PLx2j0V/xd8Ts3e1QUv5EK9Hx4k+jnUVGFtB0Wcg+oVN4/3KcR5U54gxJUf9UTR6kWSQe5";
  let decrypted = await AESCipherV2.decrypt(encrypted, key);

  expect(decrypted).toEqual(content);
});

test("decrypt Storage v2 AES-v2", async () => {
  let vault = STORAGE_V2.vault;
  let password = utils.utf8.toBytes(PASSWORD);
  let keyBytes = await sha256(password);
  let key = utils.hex.fromBytes(keyBytes);
  let decrypted = await AESCipherV2.decrypt(vault, key);

  expect(decrypted).toEqual(WORDS);
});

test("decrypt accounts Storage v2 AES-v2", async () => {
  let accounts = JSON.parse(STORAGE_V2["wallet-identities"]);
  let identities = accounts.identities;
  let importedAccount = identities[1];
  let privKey = importedAccount.privKey;

  let password = utils.utf8.toBytes(PASSWORD);
  let keyBytes = await sha256(password);
  let key = utils.hex.fromBytes(keyBytes);

  let decrypted = await AESCipherV2.decrypt(privKey, key);

  expect(decrypted).toEqual(IMPORTED_KEY);
});

```

`zil-pay/__tests__/crypto/argon2.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import { deriveArgon2Key } from "../../crypto/argon2";
import { Config, Variant, Version } from "@hicaru/argon2-pure.js";
import { APP_ID } from "../../config/argon2";

describe("argon2", () => {
  it("should derive the correct key", () => {
    const password = new TextEncoder().encode("test_password");
    const salt = "some_salt";
    const config = new Config(
      APP_ID,
      64,
      2,
      65536,
      new Uint8Array(),
      1,
      Variant.Argon2id,
      Version.Version13,
    );
    const key = deriveArgon2Key(password, salt, config);
    const expected = new Uint8Array([
      241, 5, 105, 168, 214, 152, 5, 38, 199, 60, 34, 215, 245, 198, 217, 49,
      108, 140, 86, 183, 92, 152, 168, 92, 64, 48, 241, 204, 238, 247, 198, 88,
      18, 126, 75, 177, 211, 74, 244, 234, 39, 92, 32, 255, 148, 131, 9, 175,
      213, 251, 48, 220, 238, 146, 16, 147, 132, 15, 46, 51, 176, 134, 238, 69,
    ]);

    expect(key).toEqual(expected);
  });
});

```

`zil-pay/__tests__/crypto/b64.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import { base64ToUint8Array, uint8ArrayToBase64 } from "../../crypto/b64";

describe("base64 Conversion Functions", () => {
  describe("base64ToUint8Array", () => {
    it("converts valid base64 string to Uint8Array", () => {
      const base64 = "SGVsbG8="; // "Hello"
      const expected = new Uint8Array([72, 101, 108, 108, 111]);
      expect(base64ToUint8Array(base64)).toEqual(expected);
    });

    it("handles empty base64 string", () => {
      expect(base64ToUint8Array("")).toEqual(new Uint8Array([]));
    });

    it("throws error for invalid base64 string", () => {
      expect(() => base64ToUint8Array("invalid!")).toThrow(
        "Invalid base64 string",
      );
    });
  });

  describe("uint8ArrayToBase64", () => {
    it("converts Uint8Array to valid base64 string", () => {
      const uint8Array = new Uint8Array([72, 101, 108, 108, 111]); // "Hello"
      expect(uint8ArrayToBase64(uint8Array)).toBe("SGVsbG8=");
    });

    it("handles empty Uint8Array", () => {
      expect(uint8ArrayToBase64(new Uint8Array([]))).toBe("");
    });
  });

  describe("round-trip conversion", () => {
    it("converts base64 to Uint8Array and back", () => {
      const original = "SGVsbG8=";
      const uint8Array = base64ToUint8Array(original);
      expect(uint8ArrayToBase64(uint8Array)).toBe(original);
    });

    it("converts Uint8Array to base64 and back", () => {
      const original = new Uint8Array([72, 101, 108, 108, 111]);
      const base64 = uint8ArrayToBase64(original);
      expect(base64ToUint8Array(base64)).toEqual(original);
    });
  });
});

```

`zil-pay/__tests__/crypto/bip32.test.ts`:

```ts
import { describe, it, expect, vi } from "vitest";
import {
  derivePrivateKey,
  deriveChildKey,
  ChildNumber,
  Bip32Error,
  deriveMasterKey,
  Bip32ErrorCode,
} from "../../crypto/bip32";
import { Bip39 } from "../../crypto/bip39";
import { WORD_LIST } from "./word_list";
import { utils } from "aes-js";

describe("BIP-32 Derivation", () => {
  it("should derive correct private key from BIP-39 mnemonic", async () => {
    const phrase =
      "panda eyebrow bullet gorilla call smoke muffin taste mesh discover soft ostrich alcohol speed nation flash devote level hobby quick inner drive ghost inside";
    const expectedSecretKey =
      "ff1e68eb7bf2f48651c47ef0177eb815857322257c5894bb4cfd1176c9989314";
    const seed = await Bip39.mnemonicToSeed(phrase, "", WORD_LIST);
    const privateKey = await derivePrivateKey(seed, "m/44'/60'/0'/0/0");

    expect(utils.hex.fromBytes(privateKey)).toEqual(expectedSecretKey);
  });
});

describe("ChildNumber", () => {
  it("should correctly parse a hardened child number", () => {
    const childNumber = ChildNumber.fromString("44'");
    expect(childNumber.value).toBe(44 | 0x80000000);
    expect(childNumber.isHardened()).toBe(true);
  });

  it("should correctly parse a non-hardened child number", () => {
    const childNumber = ChildNumber.fromString("0");
    expect(childNumber.value).toBe(0);
    expect(childNumber.isHardened()).toBe(false);
  });

  it("should throw an error for invalid child number string", () => {
    expect(() => ChildNumber.fromString("invalid")).toThrow(Bip32Error);
  });

  it("should throw an error for negative child number", () => {
    expect(() => ChildNumber.fromString("-1")).toThrow(Bip32Error);
  });
});

describe("derivePrivateKey Error Handling", () => {
  it("should throw an error for invalid path", async () => {
    const seed = utils.hex.toBytes("000102030405060708090a0b0c0d0e0f");
    await expect(derivePrivateKey(seed, "invalid/path")).rejects.toThrow(
      Bip32Error,
    );
  });

  it("should throw an error for invalid child number in path", async () => {
    const seed = utils.hex.toBytes("000102030405060708090a0b0c0d0e0f");
    await expect(
      derivePrivateKey(seed, "m/44'/invalid'/0'/0/0"),
    ).rejects.toThrow(Bip32Error);
  });
});

describe("deriveChildKey", () => {
  const parentKey = utils.hex.toBytes(
    "e8f32e723decf4051aefc8e2e8929c9c53337309202da64260e18c95815ff8a1",
  );
  const chainCode = utils.hex.toBytes(
    "044108d81081692c577005ce106a7980ade51d384664082531e457e515d086c1",
  );

  it("should throw Bip32Error if hmacSha512 fails during child derivation", async () => {
    vi.spyOn(globalThis.crypto.subtle, "sign").mockImplementationOnce(
      async () => {
        throw new Error("Mock HMAC failure during child derivation");
      },
    );

    const childNumber = ChildNumber.fromString("0");

    await expect(
      deriveChildKey(parentKey, chainCode, childNumber),
    ).rejects.toThrow(Bip32Error);
    await expect(
      deriveChildKey(parentKey, chainCode, childNumber),
    ).rejects.toThrow(
      new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid parent key"),
    );
  });
});

```

`zil-pay/__tests__/crypto/bip39.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import { Bip39, Bip39Error } from "../../crypto/bip39";
import { utils } from "aes-js";
import { sha256 } from "../../crypto/sha256";
import { WORD_LIST } from "./word_list";

const TEST_VECTORS = [
  {
    entropy: "00000000000000000000000000000000",
    mnemonic:
      "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
    seed: "c55257c360c07c72029aebc1b53c05ed0362ada38ead3e3e9efa3708e53495531f09a6987599d18264c1e1c92f2cf141630c7a3c4ab7c81b2f001698e7463b04",
  },
  {
    entropy: "7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
    mnemonic:
      "legal winner thank year wave sausage worth useful legal winner thank yellow",
    seed: "2e8905819b8723fe2c1d161860e5ee1830318dbf49a83bd451cfb8440c28bd6fa457fe1296106559a3c80937a1c1069be3a3a5bd381ee6260e8d9739fce1f607",
  },
  {
    entropy: "80808080808080808080808080808080",
    mnemonic:
      "letter advice cage absurd amount doctor acoustic avoid letter advice cage above",
    seed: "d71de856f81a8acc65e6fc851a38d4d7ec216fd0796d0a6827a3ad6ed5511a30fa280f12eb2e47ed2ac03b5c462a0358d18d69fe4f985ec81778c1b370b652a8",
  },
  {
    entropy: "ffffffffffffffffffffffffffffffff",
    mnemonic: "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",
    seed: "ac27495480225222079d7be181583751e86f571027b0497b5b5d11218e0a8a13332572917f0f8e5a589620c6f15b11c61dee327651a14c34e18231052e48c069",
  },
  {
    entropy: "000000000000000000000000000000000000000000000000",
    mnemonic:
      "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon agent",
    seed: "035895f2f481b1b0f01fcf8c289c794660b289981a78f8106447707fdd9666ca06da5a9a565181599b79f53b844d8a71dd9f439c52a3d7b3e8a79c906ac845fa",
  },
  {
    entropy: "7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
    mnemonic:
      "legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal will",
    seed: "f2b94508732bcbacbcc020faefecfc89feafa6649a5491b8c952cede496c214a0c7b3c392d168748f2d4a612bada0753b52a1c7ac53c1e93abd5c6320b9e95dd",
  },
  {
    entropy: "808080808080808080808080808080808080808080808080",
    mnemonic:
      "letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter always",
    seed: "107d7c02a5aa6f38c58083ff74f04c607c2d2c0ecc55501dadd72d025b751bc27fe913ffb796f841c49b1d33b610cf0e91d3aa239027f5e99fe4ce9e5088cd65",
  },
  {
    entropy: "ffffffffffffffffffffffffffffffffffffffffffffffff",
    mnemonic:
      "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo when",
    seed: "0cd6e5d827bb62eb8fc1e262254223817fd068a74b5b449cc2f667c3f1f985a76379b43348d952e2265b4cd129090758b3e3c2c49103b5051aac2eaeb890a528",
  },
  {
    entropy: "0000000000000000000000000000000000000000000000000000000000000000",
    mnemonic:
      "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art",
    seed: "bda85446c68413707090a52022edd26a1c9462295029f2e60cd7c4f2bbd3097170af7a4d73245cafa9c3cca8d561a7c3de6f5d4a10be8ed2a5e608d68f92fcc8",
  },
  {
    entropy: "7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
    mnemonic:
      "legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth title",
    seed: "bc09fca1804f7e69da93c2f2028eb238c227f2e9dda30cd63699232578480a4021b146ad717fbb7e451ce9eb835f43620bf5c514db0f8add49f5d121449d3e87",
  },
  {
    entropy: "8080808080808080808080808080808080808080808080808080808080808080",
    mnemonic:
      "letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic bless",
    seed: "c0c519bd0e91a2ed54357d9d1ebef6f5af218a153624cf4f2da911a0ed8f7a09e2ef61af0aca007096df430022f7a2b6fb91661a9589097069720d015e4e982f",
  },
  {
    entropy: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
    mnemonic:
      "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo vote",
    seed: "dd48c104698c30cfe2b6142103248622fb7bb0ff692eebb00089b32d22484e1613912f0a5b694407be899ffd31ed3992c456cdf60f5d4564b8ba3f05a69890ad",
  },
  {
    entropy: "9e885d952ad362caeb4efe34a8e91bd2",
    mnemonic:
      "ozone drill grab fiber curtain grace pudding thank cruise elder eight picnic",
    seed: "274ddc525802f7c828d8ef7ddbcdc5304e87ac3535913611fbbfa986d0c9e5476c91689f9c8a54fd55bd38606aa6a8595ad213d4c9c9f9aca3fb217069a41028",
  },
  {
    entropy: "6610b25967cdcca9d59875f5cb50b0ea75433311869e930b",
    mnemonic:
      "gravity machine north sort system female filter attitude volume fold club stay feature office ecology stable narrow fog",
    seed: "628c3827a8823298ee685db84f55caa34b5cc195a778e52d45f59bcf75aba68e4d7590e101dc414bc1bbd5737666fbbef35d1f1903953b66624f910feef245ac",
  },
  {
    entropy: "68a79eaca2324873eacc50cb9c6eca8cc68ea5d936f98787c60c7ebc74e6ce7c",
    mnemonic:
      "hamster diagram private dutch cause delay private meat slide toddler razor book happy fancy gospel tennis maple dilemma loan word shrug inflict delay length",
    seed: "64c87cde7e12ecf6704ab95bb1408bef047c22db4cc7491c4271d170a1b213d20b385bc1588d9c7b38f1b39d415665b8a9030c9ec653d75e65f847d8fc1fc440",
  },
  {
    entropy: "c0ba5a8e914111210f2bd131f3d5e08d",
    mnemonic:
      "scheme spot photo card baby mountain device kick cradle pact join borrow",
    seed: "ea725895aaae8d4c1cf682c1bfd2d358d52ed9f0f0591131b559e2724bb234fca05aa9c02c57407e04ee9dc3b454aa63fbff483a8b11de949624b9f1831a9612",
  },
  {
    entropy: "6d9be1ee6ebd27a258115aad99b7317b9c8d28b6d76431c3",
    mnemonic:
      "horn tenant knee talent sponsor spell gate clip pulse soap slush warm silver nephew swap uncle crack brave",
    seed: "fd579828af3da1d32544ce4db5c73d53fc8acc4ddb1e3b251a31179cdb71e853c56d2fcb11aed39898ce6c34b10b5382772db8796e52837b54468aeb312cfc3d",
  },
  {
    entropy: "9f6a2878b2520799a44ef18bc7df394e7061a224d2c33cd015b157d746869863",
    mnemonic:
      "panda eyebrow bullet gorilla call smoke muffin taste mesh discover soft ostrich alcohol speed nation flash devote level hobby quick inner drive ghost inside",
    seed: "72be8e052fc4919d2adf28d5306b5474b0069df35b02303de8c1729c9538dbb6fc2d731d5f832193cd9fb6aeecbc469594a70e3dd50811b5067f3b88b28c3e8d",
  },
  {
    entropy: "23db8160a31d3e0dca3688ed941adbf3",
    mnemonic:
      "cat swing flag economy stadium alone churn speed unique patch report train",
    seed: "deb5f45449e615feff5640f2e49f933ff51895de3b4381832b3139941c57b59205a42480c52175b6efcffaa58a2503887c1e8b363a707256bdd2b587b46541f5",
  },
  {
    entropy: "8197a4a47f0425faeaa69deebc05ca29c0a5b5cc76ceacc0",
    mnemonic:
      "light rule cinnamon wrap drastic word pride squirrel upgrade then income fatal apart sustain crack supply proud access",
    seed: "4cbdff1ca2db800fd61cae72a57475fdc6bab03e441fd63f96dabd1f183ef5b782925f00105f318309a7e9c3ea6967c7801e46c8a58082674c860a37b93eda02",
  },
  {
    entropy: "066dca1a2bb7e8a1db2832148ce9933eea0f3ac9548d793112d9a95c9407efad",
    mnemonic:
      "all hour make first leader extend hole alien behind guard gospel lava path output census museum junior mass reopen famous sing advance salt reform",
    seed: "26e975ec644423f4a4c4f4215ef09b4bd7ef924e85d1d17c4cf3f136c2863cf6df0a475045652c57eb5fb41513ca2a2d67722b77e954b4b3fc11f7590449191d",
  },
  {
    entropy: "f30f8c1da665478f49b001d94c5fc452",
    mnemonic:
      "vessel ladder alter error federal sibling chat ability sun glass valve picture",
    seed: "2aaa9242daafcee6aa9d7269f17d4efe271e1b9a529178d7dc139cd18747090bf9d60295d0ce74309a78852a9caadf0af48aae1c6253839624076224374bc63f",
  },
  {
    entropy: "c10ec20dc3cd9f652c7fac2f1230f7a3c828389a14392f05",
    mnemonic:
      "scissors invite lock maple supreme raw rapid void congress muscle digital elegant little brisk hair mango congress clump",
    seed: "7b4a10be9d98e6cba265566db7f136718e1398c71cb581e1b2f464cac1ceedf4f3e274dc270003c670ad8d02c4558b2f8e39edea2775c9e232c7cb798b069e88",
  },
  {
    entropy: "f585c11aec520db57dd353c69554b21a89b20fb0650966fa0a9d6f74fd989d8f",
    mnemonic:
      "void come effort suffer camp survey warrior heavy shoot primary clutch crush open amazing screen patrol group space point ten exist slush involve unfold",
    seed: "01f5bced59dec48e362f2c45b5de68b9fd6c92c6634f44d6d40aab69056506f0e35524a518034ddc1192e1dacd32c1ed3eaa3c3b131c88ed8e7e54c49a5d0998",
  },
];

describe("bip39", () => {
  it("test entropyToMnemonic", async () => {
    const entropy = utils.hex.toBytes("ffffffffffffffffffffffffffffffff");
    const mnemonic = await Bip39.entropyToMnemonic(entropy, WORD_LIST);

    expect(mnemonic.phrase).equal(
      "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",
    );
  });

  it.each(TEST_VECTORS)(
    "validates vector: $mnemonic",
    async ({ entropy, mnemonic, seed }) => {
      const entropyBytes = Uint8Array.from(
        entropy.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16)),
      );
      const seedBytes = Uint8Array.from(
        seed.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16)),
      );

      // Test entropy to mnemonic
      const generatedMnemonic = await Bip39.entropyToMnemonic(
        entropyBytes,
        WORD_LIST,
      );
      expect(generatedMnemonic.phrase).toBe(mnemonic);

      // Test mnemonic validation
      await expect(Bip39.validateMnemonic(mnemonic, WORD_LIST)).resolves.toBe(
        true,
      );

      // Test mnemonic to seed
      const generatedSeed = await Bip39.mnemonicToSeed(
        mnemonic,
        "TREZOR",
        WORD_LIST,
      );
      expect(generatedSeed).toEqual(seedBytes);

      // // Test mnemonic to entropy
      const recoveredEntropy = await Bip39.mnemonicToEntropy(
        mnemonic,
        WORD_LIST,
      );
      expect(recoveredEntropy).toEqual(entropyBytes);
    },
  );

  it.each([12, 15, 18, 21, 24])(
    "generates mnemonic with %i words",
    async (wordCount) => {
      const entropyBits = (wordCount * 11 * 32) / 33;
      const mnemonic = await Bip39.generateMnemonic(entropyBits, WORD_LIST);

      expect(mnemonic.words.length).toBe(wordCount);
      expect(mnemonic.phrase.split(" ").length).toBe(wordCount);
    },
  );
});

describe("bip39_checksum", () => {
  const vectors = [
    "00000000000000000000000000000000",
    "7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
    "80808080808080808080808080808080",
    "ffffffffffffffffffffffffffffffff",
    "000000000000000000000000000000000000000000000000",
    "7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
    "808080808080808080808080808080808080808080808080",
    "ffffffffffffffffffffffffffffffffffffffffffffffff",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f",
    "8080808080808080808080808080808080808080808080808080808080808080",
    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
    "9e885d952ad362caeb4efe34a8e91bd2",
    "6610b25967cdcca9d59875f5cb50b0ea75433311869e930b",
    "68a79eaca2324873eacc50cb9c6eca8cc68ea5d936f98787c60c7ebc74e6ce7c",
    "c0ba5a8e914111210f2bd131f3d5e08d",
    "6d9be1ee6ebd27a258115aad99b7317b9c8d28b6d76431c3",
    "9f6a2878b2520799a44ef18bc7df394e7061a224d2c33cd015b157d746869863",
    "23db8160a31d3e0dca3688ed941adbf3",
    "8197a4a47f0425faeaa69deebc05ca29c0a5b5cc76ceacc0",
    "066dca1a2bb7e8a1db2832148ce9933eea0f3ac9548d793112d9a95c9407efad",
    "f30f8c1da665478f49b001d94c5fc452",
    "c10ec20dc3cd9f652c7fac2f1230f7a3c828389a14392f05",
    "f585c11aec520db57dd353c69554b21a89b20fb0650966fa0a9d6f74fd989d8f",
  ];

  it.each(vectors)("verifies checksum for entropy: %s", async (entropyHex) => {
    const entropy = Uint8Array.from(
      entropyHex.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16)),
    );
    const mnemonic = await Bip39.entropyToMnemonic(entropy, WORD_LIST);

    const ENT = entropy.length * 8; // Длина энтропии в битах
    const CS = ENT / 32; // Длина контрольной суммы

    const hash = await sha256(entropy);
    const computedChecksum = hash[0] >> (8 - CS);

    const bits = mnemonic.words
      .map((word) => {
        const index = WORD_LIST.indexOf(word);
        return index.toString(2).padStart(11, "0");
      })
      .join("");
    const checksum = parseInt(bits.slice(ENT, ENT + CS), 2);

    expect(computedChecksum).toBe(checksum);
  });
});

describe("bip39_invalid_mnemonic", () => {
  it("should throw UnknownWord error for invalid word at position 0", async () => {
    const invalidMnemonic =
      "getter advice cage absurd amount doctor acoustic avoid letter advice cage above";
    await expect(
      Bip39.validateMnemonic(invalidMnemonic, WORD_LIST),
    ).rejects.toThrow(Bip39Error.InvalidWord);
  });

  it("should throw UnknownWord error for invalid word at position 2", async () => {
    const invalidMnemonic =
      "letter advice cagex absurd amount doctor acoustic avoid letter advice cage above";
    await expect(
      Bip39.validateMnemonic(invalidMnemonic, WORD_LIST),
    ).rejects.toThrow(Bip39Error.InvalidWord);
  });

  it("should throw BadWordCount error for 11 words", async () => {
    const invalidMnemonic =
      "advice cage absurd amount doctor acoustic avoid letter advice cage above";
    await expect(
      Bip39.validateMnemonic(invalidMnemonic, WORD_LIST),
    ).rejects.toThrow(Bip39Error.InvalidWordCount);
  });

  it("should throw InvalidChecksum error for invalid checksum", async () => {
    const invalidMnemonic =
      "primary advice cage absurd amount doctor acoustic avoid letter advice cage above";
    await expect(
      Bip39.validateMnemonic(invalidMnemonic, WORD_LIST),
    ).rejects.toThrow(Bip39Error.InvalidChecksum);
  });
});

describe("bip39_invalid_entropy", () => {
  it("should throw BadEntropyBitCount for entropy not divisible by 32 bits", async () => {
    const entropy = new Uint8Array(17); // 136 бит
    await expect(Bip39.entropyToMnemonic(entropy, WORD_LIST)).rejects.toThrow(
      Bip39Error.InvalidEntropy,
    );
  });

  it("should throw BadEntropyBitCount for entropy less than 128 bits", async () => {
    const entropy = new Uint8Array(4); // 32 бита
    await expect(Bip39.entropyToMnemonic(entropy, WORD_LIST)).rejects.toThrow(
      Bip39Error.InvalidEntropy,
    );
  });

  it("should throw BadEntropyBitCount for entropy greater than 256 bits", async () => {
    const entropy = new Uint8Array(36); // 288 бит
    await expect(Bip39.entropyToMnemonic(entropy, WORD_LIST)).rejects.toThrow(
      Bip39Error.InvalidEntropy,
    );
  });
});

```

`zil-pay/__tests__/crypto/keychain.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import {
  KeyChain,
  CipherOrders,
  AES_GCM_KEY_SIZE,
  KEYCHAIN_BYTES_SIZE,
  deriveKeyFromSeed,
} from "../../crypto/keychain";
import { PubKey, PrivKey } from "@hicaru/ntrup.js";
import { Config, Variant, Version } from "@hicaru/argon2-pure.js";
import { APP_ID } from "../../config/argon2";
import { randomBytes } from "../../crypto/random";
import { NTRU_CONFIG } from "../../crypto/ntrup";
import { utils } from "aes-js";
import { PASSWORD, STORAGE_V2, WORDS } from "../data";
import { sha256 } from "../../crypto/sha256";

const LIGHT_ARGON2_CONFIG = new Config(
  APP_ID,
  64,
  1,
  64,
  new Uint8Array([]),
  1,
  Variant.Argon2id,
  Version.Version13,
);

describe("KeyChain", () => {
  it("test derive key from seed and index", async () => {
    const seed = Uint8Array.from([
      42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
      42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
    ]);
    const r1 = await deriveKeyFromSeed(seed, 1);
    const r2 = await deriveKeyFromSeed(seed, 2);

    expect(r1).toEqual(
      Uint8Array.from([
        110, 184, 151, 158, 154, 167, 152, 8, 9, 51, 232, 16, 76, 69, 174, 96,
        19, 234, 70, 139, 138, 205, 60, 15, 254, 119, 216, 112, 88, 218, 122, 9,
      ]),
    );
    expect(r2).toEqual(
      Uint8Array.from([
        64, 210, 75, 227, 185, 9, 209, 199, 53, 232, 57, 9, 149, 24, 239, 67,
        71, 55, 108, 54, 149, 48, 252, 151, 140, 50, 74, 170, 67, 174, 246, 190,
      ]),
    );
  });

  it("should initialize from seed", async () => {
    const seed = randomBytes(32);
    const keychain = await KeyChain.fromSeed(seed);

    expect(keychain).toBeDefined();
    expect(keychain.aesKey).toBeInstanceOf(Uint8Array);
    expect(keychain.aesKey.length).toBe(AES_GCM_KEY_SIZE);
    expect(keychain.ntrupKeys.pk).toBeInstanceOf(PubKey);
    expect(keychain.ntrupKeys.sk).toBeInstanceOf(PrivKey);
    expect(keychain.kuznechikKey).toBeInstanceOf(Uint8Array);
  });

  it("should initialize from password", async () => {
    const password = randomBytes(32);
    const fingerprint = "";

    const keychain = await KeyChain.fromPass(
      password,
      fingerprint,
      LIGHT_ARGON2_CONFIG,
    );

    expect(keychain).toBeDefined();
    expect(keychain.aesKey).toBeInstanceOf(Uint8Array);
    expect(keychain.aesKey.length).toBe(AES_GCM_KEY_SIZE);
    expect(keychain.ntrupKeys.pk).toBeInstanceOf(PubKey);
    expect(keychain.ntrupKeys.sk).toBeInstanceOf(PrivKey);
    expect(keychain.kuznechikKey).toBeInstanceOf(Uint8Array);
  });

  it("should serialize to bytes and deserialize correctly", async () => {
    const seed = randomBytes(32);
    const keychain = await KeyChain.fromSeed(seed);

    const bytes = keychain.toBytes();
    const restoredKeychain = await KeyChain.fromBytes(bytes);

    expect(bytes.length).toBe(KEYCHAIN_BYTES_SIZE);
    expect(restoredKeychain.aesKey).toEqual(keychain.aesKey);
    expect(restoredKeychain.ntrupKeys.pk.toBytes(NTRU_CONFIG)).toEqual(
      keychain.ntrupKeys.pk.toBytes(NTRU_CONFIG),
    );
    expect(restoredKeychain.ntrupKeys.sk.toBytes(NTRU_CONFIG)).toEqual(
      keychain.ntrupKeys.sk.toBytes(NTRU_CONFIG),
    );
    expect(restoredKeychain.kuznechikKey).toEqual(keychain.kuznechikKey);
  });

  it("should encrypt and decrypt correctly", async () => {
    const seed = randomBytes(32);
    const plaintext = randomBytes(1024);
    const keychain = await KeyChain.fromSeed(seed);
    const options = [
      CipherOrders.AESGCM256,
      CipherOrders.NTRUP761,
      CipherOrders.KUZNECHIK,
    ];

    const ciphertext = await keychain.encrypt(plaintext, options);
    const decrypted = await keychain.decrypt(ciphertext, options);

    expect(ciphertext).not.toEqual(plaintext);
    expect(decrypted).toEqual(plaintext);

    const invalidOptions = [CipherOrders.NTRUP761, CipherOrders.AESGCM256];
    await expect(
      keychain.decrypt(ciphertext, invalidOptions),
    ).rejects.toThrow();
  });

  it("should make and verify proof correctly", async () => {
    const seed = randomBytes(32);
    const keychain = await KeyChain.fromSeed(seed);
    const options = [
      CipherOrders.NTRUP761,
      CipherOrders.AESGCM256,
      CipherOrders.KUZNECHIK,
    ];
    const proofSeed = randomBytes(32);

    const proofCipher = await keychain.makeProof(proofSeed, options);
    const retrievedSeed = await keychain.getProof(proofCipher, options);

    expect(proofCipher).not.toEqual(proofSeed);
    expect(retrievedSeed).toEqual(proofSeed);
  });

  it("should decrypt old AESCBC encrypted data correctly", async () => {
    let password = utils.utf8.toBytes(PASSWORD);
    let keyBytes = await sha256(password);
    let key = utils.hex.fromBytes(keyBytes);
    let aesKey = new TextEncoder().encode(key);

    const dummySeed = randomBytes(32);
    const dummyKeychain = await KeyChain.fromSeed(dummySeed);
    const ntrupKeys = dummyKeychain.ntrupKeys;
    const kuznechikKey = dummyKeychain.kuznechikKey;

    const keychain = new KeyChain(ntrupKeys, aesKey, kuznechikKey);

    let vault = STORAGE_V2.vault;
    let ciphertext = new TextEncoder().encode(vault);

    const decrypted = await keychain.decrypt(ciphertext, [CipherOrders.AESCBC]);
    const decryptedStr = new TextDecoder().decode(decrypted);

    expect(decryptedStr).toEqual(WORDS);
  });
});

```

`zil-pay/__tests__/crypto/kuznechik.test.ts`:

```ts
import { describe, test, expect } from "vitest";
import { kuznechikEncrypt, kuznechikDecrypt } from "../../crypto/kuznechik";
import { MIN_GAMMA_SIZE } from "@hicaru/kuznechik.js";

describe("kuznechik_encrypt and kuznechik_decrypt", () => {
  const key = new Uint8Array(32).fill(0x01);
  const plaintext = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

  test("encrypt and decrypt should return original plaintext", () => {
    const ciphertext = kuznechikEncrypt(key, plaintext);
    const decrypted = kuznechikDecrypt(key, ciphertext);
    expect(decrypted).toEqual(plaintext);
  });

  test("ciphertext length should be plaintext length plus MIN_GAMMA_SIZE", () => {
    const ciphertext = kuznechikEncrypt(key, plaintext);
    expect(ciphertext.length).toBe(plaintext.length + MIN_GAMMA_SIZE);
  });

  test("encrypt and decrypt empty plaintext", () => {
    const emptyPlaintext = new Uint8Array(0);
    const ciphertext = kuznechikEncrypt(key, emptyPlaintext);
    expect(ciphertext.length).toBe(MIN_GAMMA_SIZE);
    const decrypted = kuznechikDecrypt(key, ciphertext);
    expect(decrypted).toEqual(emptyPlaintext);
  });

  test("decrypt with short ciphertext should throw error", () => {
    const shortCiphertext = new Uint8Array(MIN_GAMMA_SIZE - 1);
    expect(() => kuznechikDecrypt(key, shortCiphertext)).toThrow();
  });

  test("encrypt with invalid key size should throw error", () => {
    const invalidKey = new Uint8Array(31);
    expect(() => kuznechikEncrypt(invalidKey, plaintext)).toThrow();
  });

  test("decrypt with different key should not return original plaintext", () => {
    const differentKey = new Uint8Array(32).fill(0x02);
    const ciphertext = kuznechikEncrypt(key, plaintext);
    const decrypted = kuznechikDecrypt(differentKey, ciphertext);
    expect(decrypted).not.toEqual(plaintext);
  });
});

```

`zil-pay/__tests__/crypto/ntrup.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import { ntruDecrypt, ntruEncrypt, ntruKeysFromSeed } from "../../crypto/ntrup";
import { sha512 } from "../../crypto/sha512";
import { utils } from "aes-js";
import { params761 } from "@hicaru/ntrup.js";

describe("NTRU", () => {
  describe("keys", () => {
    it("converts Uint8Array to valid base64 string", async () => {
      let bytes = utils.utf8.toBytes("hello");
      const seed = await sha512(bytes);
      let { pk, sk } = ntruKeysFromSeed(seed);

      expect(utils.hex.fromBytes(pk.toBytes(params761))).toEqual(
        utils.hex.fromBytes([
          8, 8, 0, 21, 249, 176, 1, 159, 3, 97, 248, 156, 249, 223, 249, 50,
          249, 238, 5, 123, 8, 32, 253, 63, 1, 76, 252, 108, 2, 44, 1, 122, 2,
          158, 0, 24, 7, 17, 7, 210, 0, 117, 3, 125, 250, 219, 1, 248, 253, 226,
          6, 102, 3, 47, 6, 62, 250, 6, 6, 62, 6, 227, 249, 217, 7, 199, 7, 88,
          255, 106, 5, 54, 247, 90, 251, 22, 253, 243, 1, 218, 2, 190, 250, 15,
          252, 231, 3, 54, 255, 174, 5, 242, 6, 254, 0, 197, 248, 177, 252, 252,
          1, 201, 2, 197, 254, 197, 3, 227, 251, 68, 248, 92, 252, 12, 252, 233,
          6, 54, 250, 72, 250, 36, 0, 72, 4, 200, 247, 194, 255, 42, 6, 145,
          255, 87, 5, 40, 255, 27, 255, 224, 255, 112, 249, 2, 249, 133, 249,
          252, 0, 11, 253, 174, 252, 149, 7, 90, 6, 207, 255, 250, 254, 85, 4,
          97, 247, 214, 5, 126, 8, 87, 253, 232, 252, 97, 251, 255, 251, 73, 1,
          151, 8, 201, 4, 254, 3, 219, 254, 51, 248, 208, 3, 195, 6, 13, 2, 128,
          251, 217, 247, 245, 7, 130, 250, 43, 253, 100, 254, 180, 251, 6, 255,
          167, 253, 53, 248, 6, 249, 224, 8, 68, 254, 103, 248, 132, 8, 144, 2,
          107, 254, 163, 251, 201, 247, 14, 0, 116, 3, 99, 8, 191, 252, 4, 255,
          246, 250, 52, 247, 219, 248, 143, 8, 65, 4, 227, 0, 30, 253, 197, 254,
          105, 0, 187, 7, 201, 1, 120, 250, 79, 255, 65, 252, 28, 6, 134, 250,
          85, 0, 194, 3, 236, 8, 26, 248, 234, 6, 217, 3, 55, 250, 56, 5, 123,
          8, 55, 254, 73, 253, 120, 5, 214, 255, 33, 1, 51, 250, 185, 7, 241,
          249, 120, 254, 181, 8, 239, 5, 122, 8, 112, 247, 148, 254, 237, 251,
          27, 253, 132, 0, 15, 253, 100, 253, 194, 253, 52, 3, 105, 0, 95, 248,
          233, 250, 86, 254, 124, 7, 80, 1, 45, 6, 103, 6, 176, 2, 26, 252, 198,
          2, 188, 254, 89, 1, 223, 248, 144, 3, 169, 254, 195, 251, 34, 254,
          127, 249, 71, 254, 149, 251, 75, 5, 36, 5, 171, 3, 203, 8, 1, 255, 64,
          5, 160, 249, 126, 247, 53, 252, 253, 251, 197, 4, 29, 247, 52, 7, 176,
          1, 66, 5, 129, 250, 197, 254, 46, 255, 94, 5, 245, 1, 160, 253, 245,
          254, 200, 251, 158, 7, 128, 249, 138, 5, 159, 248, 79, 5, 130, 2, 239,
          1, 158, 0, 118, 6, 59, 252, 92, 7, 246, 0, 141, 0, 147, 2, 169, 0,
          115, 8, 119, 247, 220, 6, 90, 4, 12, 8, 232, 253, 242, 250, 216, 255,
          149, 2, 87, 248, 130, 248, 144, 255, 34, 247, 120, 1, 110, 248, 159,
          248, 255, 7, 182, 0, 243, 7, 130, 248, 88, 254, 239, 1, 135, 0, 45,
          249, 21, 7, 202, 255, 106, 252, 137, 8, 5, 7, 101, 0, 8, 2, 36, 1,
          142, 7, 236, 4, 251, 247, 254, 252, 106, 0, 220, 2, 101, 247, 94, 249,
          127, 3, 217, 0, 62, 0, 56, 248, 182, 250, 9, 250, 32, 253, 11, 4, 167,
          249, 123, 5, 201, 3, 26, 5, 184, 2, 154, 5, 17, 254, 81, 253, 62, 2,
          63, 8, 60, 253, 61, 5, 166, 250, 14, 255, 210, 3, 123, 8, 228, 8, 183,
          254, 126, 5, 151, 255, 121, 248, 22, 250, 126, 5, 202, 249, 113, 1, 9,
          250, 205, 255, 6, 5, 63, 6, 52, 7, 22, 1, 178, 249, 56, 6, 224, 1, 48,
          247, 57, 249, 173, 2, 215, 251, 239, 255, 137, 251, 106, 6, 131, 8,
          182, 248, 201, 5, 51, 7, 213, 253, 241, 8, 181, 6, 2, 252, 247, 247,
          113, 4, 55, 248, 150, 6, 61, 247, 157, 250, 19, 250, 153, 2, 193, 252,
          105, 255, 149, 2, 242, 7, 202, 3, 75, 253, 0, 7, 76, 3, 78, 6, 52, 1,
          245, 251, 121, 252, 47, 250, 186, 250, 11, 250, 232, 254, 223, 252,
          153, 0, 6, 249, 180, 3, 142, 4, 56, 247, 33, 249, 52, 251, 70, 6, 73,
          1, 49, 255, 220, 5, 174, 255, 191, 251, 208, 1, 125, 0, 215, 253, 81,
          247, 137, 247, 61, 1, 157, 255, 247, 247, 40, 255, 76, 251, 10, 247,
          194, 251, 158, 5, 157, 248, 218, 4, 253, 248, 196, 254, 97, 249, 170,
          4, 145, 6, 139, 247, 229, 7, 196, 251, 0, 255, 106, 255, 209, 2, 168,
          0, 187, 5, 86, 252, 132, 0, 199, 2, 112, 248, 231, 247, 253, 3, 155,
          250, 35, 252, 83, 3, 146, 8, 212, 3, 174, 250, 121, 3, 207, 255, 130,
          254, 138, 4, 247, 249, 159, 0, 236, 249, 193, 249, 167, 5, 48, 250,
          237, 249, 8, 8, 77, 250, 238, 0, 117, 249, 60, 7, 38, 1, 13, 5, 206,
          248, 213, 2, 240, 6, 127, 248, 231, 1, 238, 250, 192, 6, 210, 248,
          156, 8, 66, 6, 93, 7, 70, 2, 227, 247, 125, 0, 226, 251, 11, 1, 119,
          252, 6, 1, 106, 6, 66, 255, 92, 253, 82, 0, 242, 2, 186, 254, 117, 2,
          155, 252, 137, 3, 180, 3, 93, 4, 231, 4, 35, 5, 160, 8, 47, 254, 75,
          1, 225, 251, 209, 252, 149, 0, 93, 252, 150, 7, 108, 254, 91, 0, 43,
          249, 207, 253, 181, 250, 8, 7, 140, 249, 246, 249, 199, 252, 154, 253,
          105, 248, 48, 252, 176, 5, 0, 253, 226, 3, 245, 1, 8, 253, 61, 0, 156,
          248, 30, 252, 20, 253, 254, 8, 23, 2, 217, 252, 59, 0, 159, 2, 239, 1,
          114, 249, 150, 248, 153, 3, 1, 252, 238, 8, 230, 249, 4, 252, 54, 248,
          187, 251, 126, 8, 116, 1, 72, 252, 192, 255, 212, 5, 220, 4, 164, 7,
          212, 253, 207, 2, 200, 6, 158, 3, 250, 251, 175, 0, 40, 250, 183, 250,
          96, 6, 38, 1, 163, 255, 125, 255, 167, 251, 10, 254, 84, 1, 249, 2,
          169, 250, 127, 5, 106, 247, 22, 4, 98, 3, 87, 250, 30, 248, 63, 247,
          41, 250, 35, 4, 8, 250, 34, 255, 45, 254, 124, 250, 75, 2, 108, 1,
          216, 251, 34, 2, 117, 3, 169, 252, 49, 251, 250, 7, 130, 255, 107,
          252, 81, 252, 83, 2, 30, 7, 243, 6, 202, 253, 240, 249, 207, 3, 174,
          251, 131, 253, 64, 8, 247, 0, 151, 8, 168, 6, 58, 251, 210, 254, 117,
          5, 137, 251, 219, 6, 14, 255, 30, 249, 126, 5, 90, 249, 244, 251, 165,
          248, 228, 3, 122, 7, 56, 8, 92, 0, 29, 1, 130, 1, 46, 252, 28, 254,
          72, 254, 45, 255, 228, 1, 78, 253, 53, 247, 14, 4, 94, 3, 66, 3, 109,
          8, 55, 3, 124, 251, 135, 254, 105, 249, 178, 7, 125, 7, 2, 2, 181, 4,
          27, 251, 11, 4, 106, 3, 166, 253, 74, 250, 46, 247, 189, 8, 93, 254,
          58, 247, 63, 3, 33, 247, 190, 250, 164, 250, 40, 253, 219, 255, 111,
          252, 185, 4, 192, 248, 62, 248, 87, 7, 4, 7, 247, 1, 185, 252, 13, 2,
          202, 247, 27, 6, 201, 250, 34, 255, 12, 4, 138, 5, 239, 2, 65, 6, 105,
          254, 67, 3, 117, 3, 146, 2, 75, 254, 22, 254, 0, 247, 78, 247, 151,
          252, 42, 8, 74, 251, 172, 255, 1, 5, 122, 249, 160, 251, 223, 4, 255,
          252, 112, 5, 228, 8, 152, 255, 230, 2, 233, 252, 119, 2, 183, 6, 143,
          253, 10, 0, 84, 247, 213, 7, 192, 4, 26, 8, 146, 1, 69, 0, 11, 251,
          147, 1, 237, 250, 247, 251, 241, 255, 112, 5, 207, 2, 249, 252, 70,
          252, 168, 2, 160, 248, 132, 5, 97, 248, 221, 255, 213, 254, 67, 0, 22,
          248, 115, 8, 80, 8, 96, 2, 249, 2, 208, 255, 7, 253, 73, 253, 86, 0,
          227, 251, 213, 251, 11, 249, 130, 252, 220, 255, 254, 3, 152, 5, 74,
          8, 242, 250, 135, 1, 159, 254, 33, 8, 16, 250, 138, 250, 136, 6, 112,
          7, 208, 250, 221, 248, 209, 1, 244, 254, 15, 3, 242, 247, 166, 253,
          31, 255, 111, 253, 165, 254, 119, 251, 138, 248, 11, 249, 210, 2, 208,
          1, 241, 4, 120, 250, 179, 5, 96, 3, 217, 255, 43, 2, 56, 7, 122, 250,
          125, 249, 16, 253, 240, 1, 105, 0, 43, 0, 152, 1, 129, 254, 190, 3,
          230, 7, 197, 0, 59, 5, 19, 250, 169, 250, 26, 5, 238, 251, 190, 251,
          42, 3, 171, 254, 209, 5, 17, 254, 221, 2, 29, 249, 53, 3, 23, 252,
          150, 7, 106, 249, 160, 2, 23, 254, 250, 8, 233, 4, 108, 254, 30, 1,
          63, 250, 15, 5, 21, 0, 107, 6, 221, 248, 72, 1, 151, 248, 200, 7, 146,
          7, 228, 255, 67,
        ]),
      );

      expect(utils.hex.fromBytes(sk.toBytes(params761))).toEqual(
        utils.hex.fromBytes([
          37, 6, 97, 20, 8, 41, 102, 136, 0, 8, 89, 132, 66, 37, 69, 170, 66,
          10, 134, 85, 10, 165, 145, 68, 37, 166, 106, 104, 37, 149, 149, 106,
          36, 146, 169, 20, 9, 17, 6, 134, 150, 10, 137, 0, 148, 5, 86, 133, 85,
          85, 144, 69, 161, 98, 100, 130, 26, 41, 130, 132, 33, 68, 169, 149,
          137, 85, 24, 86, 81, 137, 33, 40, 38, 66, 137, 40, 0, 134, 81, 86,
          149, 96, 166, 2, 90, 137, 164, 164, 90, 17, 152, 130, 128, 166, 66,
          97, 128, 150, 16, 68, 69, 9, 0, 148, 73, 90, 6, 73, 65, 164, 66, 20,
          6, 73, 6, 160, 138, 133, 102, 72, 97, 5, 90, 160, 88, 146, 4, 24, 128,
          160, 10, 136, 128, 37, 4, 70, 74, 80, 64, 5, 101, 138, 86, 168, 130,
          160, 26, 64, 5, 97, 144, 9, 136, 164, 24, 80, 106, 153, 4, 1, 145,
          164, 82, 73, 101, 85, 66, 20, 1, 96, 26, 102, 25, 162, 17, 5, 137, 26,
          136, 152, 150, 65, 102, 165, 90, 73, 69, 104, 161, 36, 0, 90, 100, 74,
          85, 98, 165, 70, 166, 85, 21, 90, 22, 85, 85, 134, 97, 84, 86, 149,
          98, 24, 153, 85, 69, 84, 149, 85, 89, 69, 82, 105, 64, 89, 130, 106,
          89, 90, 149, 149, 86, 153, 137, 133, 102, 90, 69, 73, 153, 68, 84,
          102, 68, 37, 133, 85, 25, 68, 97, 101, 85, 85, 81, 85, 85, 66, 100,
          68, 81, 85, 21, 85, 37, 64, 84, 132, 148, 101, 66, 101, 86, 21, 82,
          101, 85, 101, 89, 22, 101, 149, 37, 102, 85, 81, 101, 149, 145, 86,
          66, 85, 22, 89, 101, 5, 6, 128, 85, 85, 89, 153, 86, 21, 86, 25, 25,
          21, 101, 88, 133, 149, 89, 165, 165, 145, 153, 21, 145, 130, 81, 145,
          38, 101, 88, 89, 85, 102, 89, 85, 89, 65, 149, 86, 85, 102, 101, 85,
          68, 101, 85, 105, 149, 149, 102, 149, 81, 100, 104, 85, 149, 85, 25,
          97, 21, 86, 89, 1, 40, 69, 89, 69, 90, 85, 149, 146, 86, 40, 149, 134,
          82, 21, 168, 69, 4, 84, 85, 149, 69, 69, 73, 89, 138, 1,
        ]),
      );
    });
  });

  it("test bytes encrypt/decrypt", async () => {
    let bytes = utils.utf8.toBytes("hello");
    const seed = await sha512(bytes);
    let { pk, sk } = ntruKeysFromSeed(seed);
    const ciphertext = ntruEncrypt(pk, bytes);
    const decrypted = ntruDecrypt(sk, ciphertext);

    expect(decrypted).toEqual(bytes);
  });
});

```

`zil-pay/__tests__/crypto/number.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import {
  uint8ArrayToBigIntBigEndian,
  uint8ArrayToBigIntLittleEndian,
} from "../../crypto/number";
import { randomBytes } from "../../crypto/random";

describe("uint8ArrayToBigIntBigEndian", () => {
  it("should correctly convert a non-empty big-endian Uint8Array to bigint", () => {
    const length = 8;
    const byteArray = randomBytes(length);
    const bigIntValue = uint8ArrayToBigIntBigEndian(byteArray);
    expect(typeof bigIntValue).toBe("bigint");
  });

  it("should return 0n for an empty Uint8Array", () => {
    const emptyArray = new Uint8Array([]);
    expect(uint8ArrayToBigIntBigEndian(emptyArray)).toBe(0n);
  });
});

describe("uint8ArrayToBigIntLittleEndian", () => {
  it("should correctly convert a non-empty little-endian Uint8Array to bigint", () => {
    const length = 8;
    const byteArray = randomBytes(length);
    const littleEndianArray = new Uint8Array([...byteArray].reverse());
    const bigIntValue = uint8ArrayToBigIntLittleEndian(littleEndianArray);
    expect(typeof bigIntValue).toBe("bigint");
  });

  it("should return 0n for an empty Uint8Array", () => {
    const emptyArray = new Uint8Array([]);
    expect(uint8ArrayToBigIntLittleEndian(emptyArray)).toBe(0n);
  });
});

```

`zil-pay/__tests__/crypto/pbkdf2.test.ts`:

```ts
import { test, expect, vi } from "vitest";
import { pbkdf2 } from "../../crypto/pbkdf2";
import { ShaAlgorithms } from "../../config/pbkdf2";
import { utils } from "aes-js";

test("pbkdf2 calls Web Crypto API correctly with default SHA-512", async () => {
  const password = new TextEncoder().encode("password");
  const salt = new TextEncoder().encode("salt");
  const iterations = 1000;
  const result = await pbkdf2(password, salt, iterations, ShaAlgorithms.Sha512);
  const shouldBe =
    "afe6c5530785b6cc6b1c6453384731bd5ee432ee549fd42fb6695779ad8a1c5bf59de69c48f774efc4007d5298f9033c0241d5ab69305e7b64eceeb8d834cfec";

  expect(utils.hex.fromBytes(result)).toBe(shouldBe);
});

```

`zil-pay/__tests__/crypto/pubkey.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import { fromZILPrivateKey } from "../../crypto/zilliqa/pubkey";
import { utils } from "aes-js";

describe("test cases pubkey", () => {
  it("test zil private key to pub key", async () => {
    let sk = Uint8Array.from(
      utils.hex.toBytes(
        "3a649fbe8198729669affd1e9ae93e9e81fd25b71ea5f79792bec9fa6ac9ed92",
      ),
    );
    let pk = fromZILPrivateKey(sk);
    let pkHex = utils.hex.fromBytes(pk);

    expect(pkHex).toEqual(
      "025ded2f80f60d6c98d16ea5e1b2787427f44b8fcf11b5cacd56911e6c0e4c184c",
    );
  });
});

```

`zil-pay/__tests__/crypto/random.test.ts`:

```ts
import { test, expect, vi } from "vitest";
import { randomBytes } from "../../crypto/random";

test("randomBytes generates a non-zero Uint8Array of the specified length", () => {
  const length = 16;
  const result = randomBytes(length);

  expect(result).toBeInstanceOf(Uint8Array);
  expect(result.length).toBe(length);

  const zeroArray = new Uint8Array(length);
  expect(result).not.toEqual(zeroArray);

  expect(result.some((byte) => byte !== 0)).toBe(true);
});

test("randomBytes uses window.crypto.getRandomValues to seed the ChaCha20 RNG", () => {
  const spyGetRandomValues = vi.spyOn(window.crypto, "getRandomValues");
  const length = 8;

  randomBytes(length);

  expect(spyGetRandomValues).toHaveBeenCalled();
  spyGetRandomValues.mockRestore();
});

```

`zil-pay/__tests__/crypto/schnorr.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import { signInner, verify } from "../../crypto/zilliqa/schnorr";
import { utils } from "aes-js";
import { uint8ArrayToBigIntBigEndian } from "../../crypto/number";

describe("Schnorr Signature Tests", () => {
  it("should sign and verify correctly", async () => {
    const cases: [
      message: string,
      publicKey: string,
      secretKey: string,
      k: string,
      r: string,
      s: string,
    ][] = [
      [
        "A7F1D92A82C8D8FE434D98558CE2B347171198542F112D0558F56BD68807999248336241F30D23E55F30D1C8ED610C4B0235398184B814A29CB45A672ACAE548E9C5F1B0C4158AE59B4D39F6F7E8A105D3FEEDA5D5F3D9E45BFA6CC351E220AE0CE106986D61FF34A11E19FD3650E9B7818FC33A1E0FC02C44557AC8AB50C9B2DEB2F6B5E24C4FDD9F8867BDCE1FF261008E7897970E346207D75E47A158298E5BA2F56246869CC42E362A02731264E60687EF5309D108534F51F8658FB4F080B7CB19EE9AEBD718CC4FA27C8C37DFC1ADA5D133D13ABE03F021E9B1B78CCBD82F7FF2B38C6D48D01E481B2D4FAF7171805FD7F2D39EF4C4F19B9496E81DAB8193B3737E1B27D9C43957166441B93515E8F03C95D8E8CE1E1864FAAD68DDFC5932130109390B0F1FE5CA716805F8362E98DCCAADC86ADBED25801A9A9DCFA6264319DDAFE83A89C51F3C6D199D38DE10E660C37BE872C3F2B31660DE8BC95902B9103262CDB941F77376F5D3DBB7A3D5A387797FC4819A035ECA704CEDB37110EE7F206B0C8805AAEBF4963E7C4708CE8D4E092366E71792A8A3B2BBCDEE321B3E15380C541EF0930888969F7457AFE18588826A419D58311C1784B5484EECDB393F6A0ACA11B91DF0866B500B8DEE501FD7EB9BCE09A17D74124B4605ADFC0777BED9816D8D7E8488544A18D8045CB3283B0A752B881B5F500FADB59010E63D",
        "039E43C9810E6CC09F46AAD38E716DAE3191629534967DC457D3A687D2E2CDDC6A",
        "0F494B8312E8D257E51730C78F8FE3B47B6840C59AAAEC7C2EBE404A2DE8B25A",
        "532B2267C4A3054F380B3357339BDFB379E88366FE61B42ACA05F69BC3F6F54E",
        "3AF3D288E830E96FF8ED0769F45ABDA774CD989E2AE32EF9E985C8505F14FF98",
        "E191EB14A70B5B53ADA45AFFF4A04578F5D8BB2B1C8A22985EA159B53826CDE7",
      ],
      [
        "1B664F8BDA2DBF33CB6BE21C8EB3ECA9D9D5BF144C08E9577ED0D1E5E560875109B340980580473DBC2E689A3BE838E77A0A3348FE960EC9BF81DA36F1868CA5D24788FA4C0C778BF0D12314285495636516CF40861B3D737FD35DBB591C5B5D25916EB1D86176B14E0E67D2D03957F0CF6C87834BF328540588360BA7C7C5F88541634FB7BADE5F94FF671D1FEBDCBDA116D2DA779038ED7679896C29198B2657B58C50EA054F644F4129C8BA8D8D544B727633DD40754398046796E038626FEF9237CE5B615BC08677EE5ABFBD85F73F7F8868CB1B5FBA4C1309F16061AA133821FBE2A758D2BBE6AA040A940D41B7D3B869CEE945150AA4A40E6FF719EEC24B2681CD5CE06B50273436584066046656D5EFED7315759189D68815DDB9E5F8D7FD53B6EC096616A773B9421F6704CED36EF4E484BA0C6C5A4855C71C33A54AC82BE803E5CFD175779FC444B7E6AA9001EEFABEBC0CF99754887C7B0A27AFDDC415F8A02C5AF1EFEA26AD1E5D92B1E29A8FAF5B2186C3094F4A137BCFAA65D7B274214DB64C86F3085B24938E1832FB310A6F064181E298D23062ABC817BA173023C8C04C5C3A1ECBF4AF72372B381FF69865C8F0E3C70B931C45A7419B3C441842EBFACC3D070AC3B433CD120B6E85B72DADCF40B23B173C34F6BE1B1901F6621F1497B085CF8E999D986EF8FF3A889A0238979983A8686F69E10EF9249A87",
        "0245DC2911EDC02F2774E0A40FBEB0112EA60BF513F9EC50889D59FC94C97EC18F",
        "8D566BB87EF69FFDA622E0A59FBAAFE57F486CE65844343A5D9B97DE9C4F619A",
        "948AFFFF6E068CA2F2757BFD6085D6E4C3084B038E5533C5927ECB19EA0D329C",
        "DFEE66E2C4799E73F0F778126A23032608408C27C2E7B3FA45A626BB9BDEB53C",
        "75445CC9DBFE4E7BC64E020FA22CACFA4C40D5AA84DD6AEF661564FCA9746C40",
      ],
      [
        "3444C8501F19A8A78670F748FA401C4020AE086D7157A3837EC721DEF0D6E095928C5B78ED9B95560CE33D5B22778BE66DCEF2D21878D481DFF41A4DEDCAFDCAEAB4BD78629D7EC40FD26F1DD954CA84A3B53B84E9903056E840837A1390F37BB8ADE799DAC1E465D811916547EB4B6A163082E9833634A1224C54F681B8DC70A792C0CB4671D4970CCC80E2168CE920CC8FA07B1F90E9898D16019913ED5B8EE8A8DE7AB6F7895601FD20E49FD73E6F5D24C0D97E67871539F0E4E32CCB6677AFF03356D1F3790945E94039E51A63B3C840B74E3053D95CA71C0D3AC20A9065828D30AB5BFB6188A8F291FB1EB4E1EED03E2F5F558C00D8E3084120DEEB8BFE908429B36A896A45D624E79372CC18DF37DB2D20C9726D4FEF7BECF220138B53BC54C2DA461A9955AFF33F2F93DD96464BF3E883FC5750BDBE79BC2F82427F41DE42659AC4B111D7CEF8085003469DF8C9D3541480C6841707CE4C8F3D003AF982AD35C2733D0FA3B1EE52A6DAB36203D99AEC179A565B5050F480235C3BC560AA28EF5DD5525BFA254E584A86FDBD4BCC5B56551BAD00255CB72F806D7F3C533321B0864007AFBA4E0FF9638517FA8D788F52766F3A28C57C428BFDD4234AA760CE8044DF1E1FBA58E8B1D9C5A79D2AC4592FC31702F7E83351D2160C09C5CEA554F2C93A61C040E225612DF2B550900B097E18638350E3BA15C9AD53CE1861",
        "02237627FE7374061FBD80AEA842DCE76D9206F0DDC7B319F3B30FA75DBD4F009A",
        "009755F442D66585A10B80A49850C77764AD029D1BEA73F4DA45AB331306E6E5",
        "2D78C77B736AD0A00FDF60695C01E96520656C13DC890A5B864672C6CED1C49A",
        "4B73D4D919D7B4DEF330391899EA02023851CABE044E34E18EAE3E10588CECCD",
        "D5DE85C4BDEA5910DC36AEF5660774D65291322C1E87FDA0D00C864E8C5FED29",
      ],
    ];

    for (const [
      messageHex,
      publicKeyHex,
      secretKeyHex,
      kHex,
      expectedR,
      expectedS,
    ] of cases) {
      const message = utils.hex.toBytes(messageHex);
      const publicKey = utils.hex.toBytes(publicKeyHex);
      const secretKey = utils.hex.toBytes(secretKeyHex);
      const kBytes = utils.hex.toBytes(kHex);
      const k = uint8ArrayToBigIntBigEndian(kBytes);

      const signature = await signInner(k, message, secretKey);

      expect(signature?.r.toString(16)).toBe(expectedR.toLowerCase());
      expect(signature?.s.toString(16)).toBe(expectedS.toLowerCase());

      const isValid = await verify(message, publicKey, signature!);
      expect(isValid).toBe(true);
    }
  });
});

```

`zil-pay/__tests__/crypto/sha256.test.ts`:

```ts
import { test, expect } from "vitest";
import { sha256 } from "../../crypto/sha256";
import { utils } from "aes-js";

test('sha256 hashes "test" correctly', async () => {
  const input = new TextEncoder().encode("test");
  const hash = await sha256(input);
  const hexString = utils.hex.fromBytes(hash);

  expect(hexString).toBe(
    "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
  );
});

```

`zil-pay/__tests__/crypto/sha512.test.ts`:

```ts
import { test, expect } from "vitest";
import { sha512 } from "../../crypto/sha512";
import { utils } from "aes-js";

test('sha512 hashes "test" correctly', async () => {
  const input = new TextEncoder().encode("test");
  const buffer = await sha512(input);
  const hashArray = new Uint8Array(buffer);
  const hexString = utils.hex.fromBytes(hashArray);
  expect(hexString).toBe(
    "ee26b0dd4af7e749aa1a8ee3c10ae9923f618980772e473f8819a5d4940e0db27ac185f8a0e1d5f84f88bc887fd67b143732c304cc5fa9ad8e6f57f50028a8ff",
  );
});

```

`zil-pay/__tests__/crypto/word_list.ts`:

```ts
export const WORD_LIST = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
];

```

`zil-pay/__tests__/data.ts`:

```ts
export const WORDS =
  "rule hard brush glare magic east glimpse tank junk will media submit";
export const PASSWORD = "iA3J&UKNRSp7Y3&yhzo68gjib9L&Vh*W1mT1zS6T";
export const KEY =
  "717da2dd3d2ca78461d814c0bfbdbaf3e676be396585f83a0fbee04e89e0a64d";
export const IMPORTED_KEY =
  "7e5727ce710c2e96c152a7a1e5c571c6695539866b407a578575981e92177ae4";
export const STORAGE_V2 = {
  "address-format": "bech32",
  blocknumber: "0",
  connect: "undefined",
  "connection-list": "[]",
  contacts: "[]",
  "phishing-detection": "1",
  "popup-enabled": "1",
  "rate-of-currencies": '{"usd":0.01126979,"btc":1.07634e-7,"eth":0.0000045}',
  "selected-currency": "usd",
  "selected-local": "auto",
  "ssn-list":
    '{"selected":0,"list":[{"address":"0x0000000000000000000000000000000000000000","api":"https://api.zilliqa.com","id":1,"name":"Main","ok":true,"time":420}]}',
  theme: "light",
  time_before_lock: "3",
  "tokens-list/mainnet":
    '[{"base16":"0x0000000000000000000000000000000000000000","bech32":"zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz","decimals":12,"name":"Zilliqa","symbol":"ZIL","rate":1},{"base16":"0xfbd07e692543d3064b9cf570b27faabfd7948da4","bech32":"zil1l0g8u6f9g0fsvjuu74ctyla2hltefrdyt7k5f4","decimals":18,"name":"ZilPay wallet","symbol":"ZLP","rate":2.7688998049}]',
  vault:
    "U2FsdGVkX19+DrC9DG/qvYEC6koZfMhpQl6K4eVH5GSE1qXyn4vENND7zZFNT5R4yZM/45MiWMTw+Olu2Va948mputTGoby3VfmNmIm1uiVgRYt6hycdMiUBFuWs0KqN",
  "wallet-identities":
    '{"selectedAddress":1,"identities":[{"name":"Account 0","bech32":"zil1ntrynx04349sk6py7uyata03gka6qswg7um95y","index":0,"base16":"0x9ac64999F58d4b0B6824f709D5f5f145BBA041c8","type":2,"pubKey":"0316f2d913f13c6aa15ad5c80b58464d25b6363a1b9d997260e8061977a3f43e10","zrc2":{"0x0000000000000000000000000000000000000000":"0","0xfbd07e692543d3064b9cf570b27faabfd7948da4":"0"},"nft":{}},{"name":"Imported 0","bech32":"zil14at57zaj4pe3tuy734usy2xnlquapkd4d0ne43","index":0,"base16":"0xaf574f0BB2a87315F09e8d790228D3F839D0d9B5","type":1,"pubKey":"0232970d0472220180c1779610f0ffae5a1ad79048b4f01f366c52d99317534024","privKey":"U2FsdGVkX1+E7PpB7lTzKwR7J0aWq1xJWMTNRrxo3Vd76jcnA7GmMTS9DtkRQCkAWJdYemsAVH90lMRGzLFOYPYxd6UhNsPWiGD7MlNxvfHtRdL64G+tdULtICMXB23F","zrc2":{"0x0000000000000000000000000000000000000000":"0","0xfbd07e692543d3064b9cf570b27faabfd7948da4":"0"},"nft":{}}]}',
};
export const STORAGE_V3 = {
  "address-format": "bech32",
  "badge-counter": "0",
  blocknumber: "0",
  "confirm/mainnet": "[]",
  connect: "undefined",
  "connection-list": "[]",
  contacts: "[]",
  "dex-proto":
    '{"liquidityFee":0,"protocolFee":0,"slippage":1,"blocks":10,"rewarded":"0x0000000000000000000000000000000000000000","contract":{"mainnet":"0x30dfe64740ed459ea115b517bd737bbadf21b838","testnet":"0xb0c677b5ba660925a8f1d5d9687d0c2c379e16ee","private":""}}',
  "guard-configuration": "SHA-512:442368",
  "phishing-detection": "1",
  "popup-enabled": "1",
  "rate-of-currencies":
    '{"aed":0.04247757,"amd":4.44,"ars":13.71,"aud":0.01781949,"bdt":1.41,"bhd":0.00435975,"brl":0.065154,"btc":1.099e-7,"cad":0.01581764,"chf":0.00947171,"clp":10.85,"cny":0.083074,"cop":47.37,"crc":5.88,"czk":0.251386,"dkk":0.075591,"dop":0.682575,"eth":0.0000044,"eur":0.01013389,"gbp":0.0085369,"gel":0.0317456,"gtq":0.088835,"hkd":0.090732,"hnl":0.300787,"huf":4.08,"idr":188.38,"ils":0.04029691,"inr":0.99304,"jpy":1.65,"kes":1.5,"krw":15.73,"lbp":1035.62,"lkr":3.46,"ltc":0.00013082,"mmk":24.26,"mxn":0.222062,"myr":0.04908136,"ngn":18.22,"nok":0.116999,"nzd":0.01918035,"pen":0.04188673,"php":0.643042,"pkr":3.26,"pln":0.04338162,"ron":0.05104161,"rub":0.917076,"sar":0.0433747,"sek":0.110942,"sgd":0.01488506,"svc":0.101144,"thb":0.377194,"try":0.454718,"twd":0.346177,"uah":0.479191,"usd":0.01156488,"vnd":301.88,"xrp":0.00524131,"zar":0.206394}',
  "selected-currency": "btc",
  "selected-local": "auto",
  "ssn-list":
    '{"selected":0,"list":[{"address":"0x0000000000000000000000000000000000000000","api":"https://api.zilliqa.com","id":1,"name":"Main","ok":true,"time":420}]}',
  theme: "light",
  time_before_lock: "3",
  "tokens-list/mainnet":
    '[{"base16":"0x0000000000000000000000000000000000000000","bech32":"zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz","decimals":12,"name":"Zilliqa","symbol":"ZIL","rate":1,"pool":[]},{"base16":"0xfbd07e692543d3064b9cf570b27faabfd7948da4","bech32":"zil1l0g8u6f9g0fsvjuu74ctyla2hltefrdyt7k5f4","decimals":18,"name":"ZilPay wallet","symbol":"ZLP","rate":2.7915277475,"pool":["65618957804322222","23506468048851034758203"]},{"base16":"0xe6f14afc8739a4ead0a542c07d3ff978190e3b92","bech32":"zil1umc54ly88xjw4599gtq860le0qvsuwuj72s246","decimals":12,"name":"StZIL","symbol":"stZIL","rate":1.2063766095,"pool":["363937420859731210","301678114446274419"]}]',
  vault:
    "ZGM1ODdhZGI0YWVhY2E3Njk4MDJlYTEyMzMxOGY5OGZlMjMxMzNhYzY1ZDc4ZTUzYjFiZmI0YTYxNDY5OTAzZGQ2NDAzNWFjZmQzNGVkODZjYzc3NTc0NWE4NjI4N2Y3NWI0OTdiYzk4OGFjMzg0MDM5MWY5MGJjY2FmMjllNmU4NmEyMjJkMy8zODIzZWMwNmEyMDA4ZDZhODcyMTY3MzAwMzlmZTBlYw==",
  "wallet-identities":
    '{"selectedAddress":1,"identities":[{"name":"Account 0","bech32":"zil1ntrynx04349sk6py7uyata03gka6qswg7um95y","index":0,"base16":"0x9ac64999F58d4b0B6824f709D5f5f145BBA041c8","type":2,"pubKey":"0316f2d913f13c6aa15ad5c80b58464d25b6363a1b9d997260e8061977a3f43e10","zrc2":{"0x0000000000000000000000000000000000000000":"0","0xfbd07e692543d3064b9cf570b27faabfd7948da4":"0","0xe6f14afc8739a4ead0a542c07d3ff978190e3b92":"0"},"nft":{}},{"name":"Imported 0","bech32":"zil14at57zaj4pe3tuy734usy2xnlquapkd4d0ne43","index":0,"base16":"0xaf574f0BB2a87315F09e8d790228D3F839D0d9B5","type":1,"pubKey":"0232970d0472220180c1779610f0ffae5a1ad79048b4f01f366c52d99317534024","privKey":"OGRmNzA0YzAzM2Q4ZmVhODM4ODFlMmYyZjI3ZDIyMzQ4NTM1ZmZiZDVjNDMzNmM1MDBjZWM4YzU4ZDg2YWU5Yi82NTVkYWRjZWZkNDZiODEyOWRhYzZhZTUxMjE2NTdiMQ==","zrc2":{"0x0000000000000000000000000000000000000000":"0","0xfbd07e692543d3064b9cf570b27faabfd7948da4":"0","0xe6f14afc8739a4ead0a542c07d3ff978190e3b92":"0"},"nft":{}}]}',
};
export const EXTENSION_ID = "klnaejjgbibmhlephnhpmaofohgkpgkd";

```

`zil-pay/__tests__/setupTests.ts`:

```ts
import { vi } from "vitest";
import sinonChrome from "sinon-chrome";
import { EXTENSION_ID } from "./data";

global.chrome = sinonChrome;
global.chrome.runtime.id = EXTENSION_ID;

const mockGetRandomValues = (array: Uint8Array): Uint8Array => {
  for (let i = 0; i < array.length; i++) {
    array[i] = Math.floor(Math.random() * 256);
  }
  return array;
};

(global as any).window = {
  crypto: {
    getRandomValues: vi.fn(mockGetRandomValues),
  },
};

```

`zil-pay/__tests__/stream/stream.test.ts`:

```ts
import { describe, it, expect, beforeEach, vi } from "vitest";
import { Message, ReqBody } from "lib/streem/message";
import { Runtime } from "lib/runtime/extensionizer";

vi.mock("lib/runtime/extensionizer", () => ({
  Runtime: {
    runtime: {
      sendMessage: vi.fn(),
    },
  },
}));

describe("Basic Test Message - Error Handling", () => {
  const mockConsoleError = vi.fn();

  beforeEach(() => {
    console.error = mockConsoleError;
    (Runtime.runtime.sendMessage as ReturnType<typeof vi.fn>).mockClear();
  });

  it("should catch sendMessage error and log it", async () => {
    const message = Message.signal("ERROR_MESSAGE");
    const sendMessageMock = Runtime.runtime.sendMessage as ReturnType<
      typeof vi.fn
    >;
    const errorMessage = "Simulated send error";
    sendMessageMock.mockImplementation(() => {
      throw new Error(errorMessage);
    });

    await expect(message.send()).rejects.toThrow("service_worker_stopped");
    expect(sendMessageMock).toHaveBeenCalledTimes(10);
    expect(mockConsoleError).toHaveBeenCalledWith(
      message,
      new Error(errorMessage),
    );
  });
});

describe("Basic Test Message - Successful Send and Receive", () => {
  beforeEach(() => {
    (Runtime.runtime.sendMessage as ReturnType<typeof vi.fn>).mockClear();
  });

  it("should send the message and receive a response", async () => {
    const body: ReqBody<{ data: string }> = {
      type: "TEST_MESSAGE",
      payload: { data: "test" },
    };
    const message = new Message(body);
    const mockResponse = { result: "success" };

    (
      Runtime.runtime.sendMessage as ReturnType<typeof vi.fn>
    ).mockImplementation((_msg, callback) => {
      callback(mockResponse);
    });

    const response = await message.send();

    expect(Runtime.runtime.sendMessage).toHaveBeenCalledOnce();
    expect(Runtime.runtime.sendMessage).toHaveBeenCalledWith(
      body,
      expect.any(Function),
    );
    expect(response).toEqual(mockResponse);
  });
});

```

`zil-pay/__tests__/types/checker.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import { TypeOf } from "lib/types/checker.ts";

describe("TypeOf", () => {
  it("should correctly identify arrays", () => {
    expect(TypeOf.isArray([])).toBe(true);
    expect(TypeOf.isArray([1, 2, 3])).toBe(true);
    expect(TypeOf.isArray(new Array(3))).toBe(true);
    expect(TypeOf.isArray({})).toBe(false);
    expect(TypeOf.isArray(null)).toBe(false);
    expect(TypeOf.isArray(undefined)).toBe(false);
    expect(TypeOf.isArray("abc")).toBe(false);
  });

  it("should correctly identify plain objects", () => {
    expect(TypeOf.isObject({})).toBe(true);
    expect(TypeOf.isObject({ a: 1, b: 2 })).toBe(true);
    expect(TypeOf.isObject(new Object())).toBe(true);
    expect(TypeOf.isObject([])).toBe(false);
    expect(TypeOf.isObject(null)).toBe(false);
    expect(TypeOf.isObject(undefined)).toBe(false);
    expect(TypeOf.isObject("abc")).toBe(false);
    expect(TypeOf.isObject(new Date())).toBe(false);
    expect(TypeOf.isObject(new Error())).toBe(false);
    class MyClass {}
    expect(TypeOf.isObject(new MyClass())).toBe(false);
  });

  it("should correctly identify numbers", () => {
    expect(TypeOf.isNumber(0)).toBe(true);
    expect(TypeOf.isNumber(10)).toBe(true);
    expect(TypeOf.isNumber(-5)).toBe(true);
    expect(TypeOf.isNumber(3.14)).toBe(true);
    expect(TypeOf.isNumber(NaN)).toBe(false);
    expect(TypeOf.isNumber(Infinity)).toBe(true);
    expect(TypeOf.isNumber(-Infinity)).toBe(true);
    expect(TypeOf.isNumber("10")).toBe(false);
    expect(TypeOf.isNumber(null)).toBe(false);
    expect(TypeOf.isNumber(undefined)).toBe(false);
    expect(TypeOf.isNumber({})).toBe(false);
  });

  it("should correctly identify integers", () => {
    expect(TypeOf.isInt(0)).toBe(true);
    expect(TypeOf.isInt(10)).toBe(true);
    expect(TypeOf.isInt(-5)).toBe(true);
    expect(TypeOf.isInt(3.14)).toBe(false);
    expect(TypeOf.isInt(NaN)).toBe(false);
    expect(TypeOf.isInt(Infinity)).toBe(false);
    expect(TypeOf.isInt("10")).toBe(false);
    expect(TypeOf.isInt(null)).toBe(false);
    expect(TypeOf.isInt(undefined)).toBe(false);
    expect(TypeOf.isInt({})).toBe(false);
    expect(TypeOf.isInt(Number.MAX_SAFE_INTEGER)).toBe(true);
    expect(TypeOf.isInt(Number.MIN_SAFE_INTEGER)).toBe(true);
  });

  it("should correctly identify error objects", () => {
    expect(TypeOf.isError(new Error())).toBe(true);
    expect(TypeOf.isError(new TypeError())).toBe(true);
    expect(TypeOf.isError(new SyntaxError())).toBe(true);
    expect(TypeOf.isError({})).toBe(false);
    expect(TypeOf.isError(null)).toBe(false);
    expect(TypeOf.isError(undefined)).toBe(false);
    expect(TypeOf.isError("Error")).toBe(false);
  });

  it("should correctly identify strings", () => {
    expect(TypeOf.isString("")).toBe(true);
    expect(TypeOf.isString("abc")).toBe(true);
    expect(TypeOf.isString(new String("abc"))).toBe(true);
    expect(TypeOf.isString(123)).toBe(false);
    expect(TypeOf.isString(null)).toBe(false);
    expect(TypeOf.isString(undefined)).toBe(false);
    expect(TypeOf.isString({})).toBe(false);
  });

  it("should correctly identify booleans", () => {
    expect(TypeOf.isBoolean(true)).toBe(true);
    expect(TypeOf.isBoolean(false)).toBe(true);
    expect(TypeOf.isBoolean(new Boolean(true))).toBe(true);
    expect(TypeOf.isBoolean(0)).toBe(false);
    expect(TypeOf.isBoolean(1)).toBe(false);
    expect(TypeOf.isBoolean(null)).toBe(false);
    expect(TypeOf.isBoolean(undefined)).toBe(false);
    expect(TypeOf.isBoolean({})).toBe(false);
  });

  it("should correctly identify null", () => {
    expect(TypeOf.isNull(null)).toBe(true);
    expect(TypeOf.isNull(undefined)).toBe(false);
    expect(TypeOf.isNull(0)).toBe(false);
    expect(TypeOf.isNull("")).toBe(false);
    expect(TypeOf.isNull({})).toBe(false);
  });

  it("should correctly identify undefined", () => {
    expect(TypeOf.isUndefined(undefined)).toBe(true);
    expect(TypeOf.isUndefined(null)).toBe(false);
    expect(TypeOf.isUndefined(0)).toBe(false);
    expect(TypeOf.isUndefined("")).toBe(false);
    expect(TypeOf.isUndefined({})).toBe(false);
  });

  it("should correctly identify empty objects", () => {
    expect(TypeOf.isEmptyObject({})).toBe(true);
    expect(TypeOf.isEmptyObject({ a: 1 })).toBe(false);
    expect(TypeOf.isEmptyObject(new Object())).toBe(true);
    expect(TypeOf.isEmptyObject(null)).toBe(false);
    expect(TypeOf.isEmptyObject(undefined)).toBe(false);
    expect(TypeOf.isEmptyObject([])).toBe(false);
  });

  it("should correctly identify empty arrays", () => {
    expect(TypeOf.isEmptyArray([])).toBe(true);
    expect(TypeOf.isEmptyArray([1, 2, 3])).toBe(false);
    expect(TypeOf.isEmptyArray(new Array(0))).toBe(true);
    expect(TypeOf.isEmptyArray(null)).toBe(false);
    expect(TypeOf.isEmptyArray(undefined)).toBe(false);
    expect(TypeOf.isEmptyArray({})).toBe(false);
  });
});

```

`zil-pay/__tests__/zilliqa/address.test.ts`:

```ts
import { describe, expect, it } from "vitest";
import {
  toChecksumHexAddress,
  toChecksumBytesAddress,
} from "lib/zilliqa/checksum";
import { fromZilPubKey } from "lib/zilliqa/pubkey.ts";
import { utils } from "aes-js";
import { toBech32Address, fromBech32Address } from "lib/zilliqa/bech32";

describe("Address Conversion Tests", () => {
  describe("toChecksumAddress", () => {
    it("should correctly checksum a valid lowercase address", async () => {
      const address = "8617b72e22090f0c13167865147ec48a6db788ff";
      const checksummed = await toChecksumHexAddress(address);
      expect(checksummed).toBe("0x8617B72E22090f0c13167865147eC48a6dB788ff");
    });

    it("should correctly checksum another valid address", async () => {
      const address = "0000000000000000000000000000000000000000";
      const checksummed = await toChecksumHexAddress(address);
      expect(checksummed).toBe("0x0000000000000000000000000000000000000000");
    });

    it("should correctly derive a bech32 address from a public key", async () => {
      const pubkeyHex =
        "03150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da";
      const pubkeyBytes = utils.hex.toBytes(pubkeyHex);
      const addrBytes = await fromZilPubKey(pubkeyBytes);
      const checksummed = await toChecksumBytesAddress(addrBytes);

      expect(checksummed).toBe("0xEBd8b370Dddb636FAF641040D2181c55190840fb");
    });
  });

  describe("toBech32Address", () => {
    it("should correctly encode a valid hexadecimal address to Bech32", async () => {
      const hexAddress = "0x7793a8e8c09d189d4d421ce5bc5b3674656c5ac1";
      const bech32Address = await toBech32Address(hexAddress);
      expect(bech32Address).toBe("zil1w7f636xqn5vf6n2zrnjmckekw3jkckkpyrd6z8");
    });
  });

  describe("fromBech32Address", () => {
    it("should correctly decode a valid Bech32 address to a checksummed hexadecimal address", async () => {
      const bech32Address = "zil1w7f636xqn5vf6n2zrnjmckekw3jkckkpyrd6z8";
      const hexAddress = await fromBech32Address(bech32Address);
      expect(hexAddress).toBe("0x7793a8e8c09D189D4d421CE5Bc5b3674656C5Ac1");
    });

    it("should throw an error for an invalid Bech32 address length", async () => {
      const invalidBech32 = "zi21w7f636xqn5vf6n2zrnjmckekw3jkckkpyrd6z8";
      await expect(fromBech32Address(invalidBech32)).rejects.toThrow(
        "Invalid Bech32 address.",
      );
    });

    it("should throw an error for a Bech32 address with an incorrect HRP", async () => {
      const wrongHRP = "btc1qwertzuiopasdfghjklmnbvcxy";
      await expect(fromBech32Address(wrongHRP)).rejects.toThrow(
        "Invalid Bech32 address.",
      );
    });
  });
});

```

`zil-pay/background/secure/migrator.ts`:

```ts
import { BackgroundState, AppearancesTheme } from '../storage/background';
import { ChainConfig } from '../storage/chain';
import { FToken } from '../storage/ftoken';
import { AuthMethod, Wallet, WalletTypes } from '../storage/wallet';
import { Account } from '../storage/account';
import { AddressType } from '../storage/address-type';
import { WalletSettings, RatesApiOptions } from '../storage/settings';
import { WalletArgon2Params } from '../storage/argon';

interface WalletIdentities {
  selectedAddress: number;
  identities: {
    name: string;
    bech32: string;
    index: number;
    base16: string;
    type: number;
    pubKey: string;
    privKey?: string;
    zrc2: Record<string, string>;
    nft: Record<string, unknown>;
  }[];
}

interface TokenData {
  base16: string;
  bech32: string;
  decimals: number;
  name: string;
  symbol: string;
  rate: number;
  pool?: string[];
}

type TokenWithBase16 = { ftoken: FToken; base16: string };

const ZILLIQA_MAINNET_CHAIN = new ChainConfig({
    name: 'Zilliqa',
    chain: 'ZIL',
    logo: 'https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/%{shortName}%/chain/%{dark,light}%.svg',
    rpc: [
      'https://api.zilliqa.com',
      'https://ssn.zilpay.io/api',
      'https://zilliqa.avely.fi/api',
      'https://ssn.zillet.io',
    ],
    features: [],
    ftokens: [
      new FToken({
        native: true,
        logo: 'https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/%{contract_address}%/%{dark,light}%.webp',
        addr: '0x0000000000000000000000000000000000000000',
        name: 'Zilliqa',
        symbol: 'ZIL',
        decimals: 18,
        addrType: AddressType.EthCheckSum,
        balances: {},
        rate: 0,
        default_: true,
        chainHash: 1
      }),
      new FToken({
        native: true,
        logo: 'https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/%{contract_address}%/%{dark,light}%.webp',
        addr: 'zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz',
        name: 'Zilliqa',
        symbol: 'ZIL',
        decimals: 12,
        addrType: AddressType.Bech32,
        balances: {},
        rate: 0,
        default_: true,
        chainHash: 1
      }),
    ],
    chainIds: new BigUint64Array([32769n, 1n]),
    infoURL: 'https://www.zilliqa.com/',
    shortName: 'zilliqa',
    slip44: 313,
    explorers: [
      {
        name: 'Viewblock',
        url: 'https://viewblock.io/zilliqa',
        icon: 'https://viewblock.io/apple-touch-icon.png',
        standard: 'EIP3091',
      },
      {
        name: 'Otterscan',
        icon: 'https://otterscan.zilliqa.com/assets/otter-DYFeLtFi.png',
        url: 'https://otterscan.zilliqa.com/',
        standard: 'EIP3091',
      },
    ],
    chainId: 1,
    chainHash: 1,
    diffBlockTime: 30,
    ens: null,
    fallbackEnabled: false,
    testnet: false
});

export function migrateToV4(storage: Record<string, unknown>): BackgroundState {
  if (storage['storageVersion'] == 4) {
    return new BackgroundState(storage);
  } else {
      return migrateFromV2orV3(storage);
  }
}

function parseTokens(tokensJson: string, chainHash: number): TokenWithBase16[] {
    const tokens: TokenData[] = JSON.parse(tokensJson);
    return tokens.map(token => ({
      ftoken: new FToken({
        name: token.name,
        symbol: token.symbol,
        decimals: token.decimals,
        addr: token.bech32,
        addrType: AddressType.Bech32,
        logo: `https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/${token.bech32}/%{dark,light}%.webp`,
        balances: {},
        rate: token.rate,
        default_: token.symbol === 'ZIL',
        native: token.base16 === '0x0000000000000000000000000000000000000000',
        chainHash,
      }),
      base16: token.base16,
    }));
  }

function migrateFromV2orV3(storage: Record<string, unknown>): BackgroundState {
    const walletIdentities: WalletIdentities = JSON.parse(storage['wallet-identities'] as string);
    const mainChain = ZILLIQA_MAINNET_CHAIN;
    
    const parsedTokens = parseTokens(storage['tokens-list/mainnet'] as string, mainChain.chainHash);

    const accounts = walletIdentities.identities.map(identity => new Account({
        addr: identity.bech32,
        addrType: AddressType.Bech32,
        name: identity.name,
        pubKey: identity.pubKey,
        chainHash: mainChain.chainHash,
        chainId: mainChain.chainId,
        slip44: mainChain.slip44,
        index: identity.index,
    }));

    const walletTokens = parsedTokens.map(({ ftoken, base16 }) => {
        const balances: Record<number, string> = {};
        accounts.forEach((_, index) => {
            const identity = walletIdentities.identities[index];
            balances[index] = identity.zrc2[base16.toLowerCase()] || '0';
        });
        return new FToken({ ...ftoken, balances });
    });

    const isV3 = 'guard-configuration' in storage;
    const wallet = new Wallet({
        walletType: WalletTypes.SecretPhrase,
        walletName: 'Zilliqa Wallet',
        authType: AuthMethod.None,
        walletAddress: accounts[0].addr,
        accounts,
        selectedAccount: walletIdentities.selectedAddress,
        tokens: walletTokens, 
        settings: new WalletSettings({
            cipherOrders: [],
            argonParams: new WalletArgon2Params({
                memory: 1024,
                iterations: 3,
                threads: 1,
                secret: '',
            }),
            currencyConvert: storage['selected-currency'],
            ipfsNode: null,
            ensEnabled: false,
            tokensListFetcher: false,
            nodeRankingEnabled: false,
            maxConnections: 10,
            requestTimeoutSecs: 30,
            ratesApiOptions: RatesApiOptions.CoinGecko,
        }),
        defaultChainHash: mainChain.chainHash,
        vault: storage.vault,
    });

    const backgroundState = new BackgroundState({
        wallets: [wallet],
        notificationsGlobalEnabled: true,
        locale: 'auto',
        appearances: AppearancesTheme.System,
        abbreviatedNumber: true,
        hideBalance: false,
        storageVersion: 4,
        chains: [mainChain], 
    });

    return backgroundState;
}


```

`zil-pay/background/secure/storage.ts`:

```ts
import { BrowserStorage } from '../../lib/storage';
import { base64ToUint8Array, uint8ArrayToBase64 } from '../../crypto/b64';

export class AuthStorage {
  #vault: Uint8Array;

  sync(data: Record<string, unknown>): void {
    this.#validateAndSetVault(data);
  }


  #validateAndSetVault(data: Record<string, unknown>): void {
    const vaultStr = data['vault'];
    if (typeof vaultStr !== 'string') {
      throw new Error('Invalid vault: must be a string');
    }
    try {
      this.#vault = base64ToUint8Array(vaultStr);
    } catch (err) {
      throw new Error(`Failed to decode vault: ${err.message}`);
    }
  }

  async setVault(vault: Uint8Array): Promise<void> {
    const vaultStr = uint8ArrayToBase64(vault);
    await BrowserStorage.set({ vault: vaultStr });
    this.#vault = vault;
  }

  getVault(): Uint8Array | null {
    return this.#vault;
  }
}

```

`zil-pay/background/services/guard.ts`:

```ts
import { utils } from 'aes-js';
import { sha256 } from '../../crypto/sha256';
import { pbkdf2 } from '../../crypto/pbkdf2';
import { Bip39 } from '../../crypto/bip39';
import { Cipher } from '../../crypto/aes256';

import { BrowserStorage, buildObject, StorageKeyValue } from '../../lib/storage';
import { getManifestVersion, Runtime , assert, EXTENSION_ID } from '../../lib/runtime';
import { TypeOf } from '../../lib/types';

import { ShaAlgorithms } from '../../config/sha';
import { Common } from '../../config/common';
import { OldFields } from '../../config/fields';
import { ManifestVersions } from '../../config/manifest';

/**
 * Defines keys used for session storage.
 */
export enum SessionKeys {
  EndSession = "BEARBY_END_SESSION",
  Hash = "BEABRY_HASH",
  PrivateExtendedKey = "EXTENDED_KEY"
}

/**
 * Defines error messages used throughout the AuthGuard class.
 */
export enum ErrorMessages {
  GuardNotSynced = 'Guard is not synced',
  WalletNotReady = 'Wallet is not sync.',
  IncorrectPassword = 'Incorect password',
  WalletNotEnabled = 'Wallet is not enabled.',
  IncorrectConfigParams = 'Incorrect Config params',
  MustBeInt = 'Must be Int.',
  IncorrectParams = 'Incorrect argument',
  InvalidFormat = "Invalid data format encountered during decryption.",
  InvalidKeyLength = "Invalid key length provided. Key must be 16, 24, or 32 bytes.",
}

/**
 * Manages wallet authentication, session, and encryption/decryption of sensitive data.
 */
export class AuthGuard {
  #hash = new WeakMap<AuthGuard, Uint8Array>();
  #oldHash = new WeakMap<AuthGuard, Uint8Array>();
  #algorithm = ShaAlgorithms.sha256;
  #iteractions = 0;

  #isEnable = false;

  #isReady = false;

  #privateExtendedKey?: Uint8Array;
  #encryptMnemonic?: Uint8Array;

  #endSession = new Date(-1);
  #time = Common.TIME_BEFORE_LOCK;

  /**
   * Retrieves the decrypted seed. Requires an active session.
   * @returns The decrypted seed as a Uint8Array.
   */
  get seed() {
    this.checkSession();

    const session = this.#hash.get(this) as Uint8Array;
    const decryptSeedBytes = Cipher.decrypt(
      this.#privateExtendedKey as Uint8Array,
      session
    );

    return Uint8Array.from(decryptSeedBytes);
  }

  /**
   * Gets the configured lock time in hours.
   * @returns The lock time as a number.
   */
  get lockTime() {
    return Number(this.#time);
  }

  /**
   * Checks if the session is currently enabled and active.
   * @returns True if the session is enabled and not expired, false otherwise.
   */
  get isEnable() {
    const now = new Date().getTime();
    const timeDifference = this.#endSession.getTime() - now;

    return timeDifference > 0 && this.#isEnable;
  }

  /**
   * Checks if the wallet is ready (i.e., mnemonic is loaded).
   * @returns True if the wallet is ready, false otherwise.
   */
  get isReady() {
    return this.#isReady;
  }

  /**
   * Provides the current state of the AuthGuard.
   * @returns An object containing the session enable status, wallet readiness, iterations, and algorithm.
   */
  get state() {
    return {
      isEnable: this.isEnable,
      isReady: this.isReady,
      iteractions: this.#iteractions,
      algorithm: this.#algorithm
    };
  }

  /**
   * Gets the encrypted mnemonic.
   * @returns The encrypted mnemonic as a Uint8Array, or undefined if not set.
   */
  get encryptedMnemonic() {
    return this.#encryptMnemonic;
  }

  /**
   * Synchronizes the AuthGuard state with data from browser storage and session storage.
   */
  async sync() {
    const data = await BrowserStorage.get(
      OldFields.VAULT,
      OldFields.LOCK_TIME,
      OldFields.GUARD_CONFIG
    ) as StorageKeyValue;

    if (data && data[OldFields.VAULT]) {
      this.#encryptMnemonic = Buffer.from(data[OldFields.VAULT], 'base64');
      this.#isReady = Boolean(this.#encryptMnemonic);
    }

    if (data && data[OldFields.GUARD_CONFIG]) {
      const [algorithm, iteractions] = String(data[OldFields.GUARD_CONFIG]).split(':');

      if (algorithm === ShaAlgorithms.sha256 || algorithm === ShaAlgorithms.Sha512) {
        this.#algorithm = algorithm;
      }

      if (!isNaN(Number(iteractions))) {
        this.#iteractions = Number(iteractions);
      }
    }

    if (data[OldFields.LOCK_TIME]) {
      this.#time = Number(data[OldFields.LOCK_TIME]);
    } else {
      await BrowserStorage.set(
        buildObject(OldFields.LOCK_TIME, String(Common.TIME_BEFORE_LOCK))
      );
    }

    if (ManifestVersions.V3 === getManifestVersion()) {
      const data = await Runtime.storage.session.get([
        SessionKeys.EndSession,
        SessionKeys.Hash,
        SessionKeys.PrivateExtendedKey
      ]);

      try {
        if (data[SessionKeys.EndSession]) {
          this.#endSession = new Date(data[SessionKeys.EndSession]);
        }
        if (data[SessionKeys.Hash]) {
          const hash = utils.hex.toBytes(data[SessionKeys.Hash]);
          this.#hash.set(this, hash);
          this.#isEnable = true;
        }
        if (data[SessionKeys.PrivateExtendedKey]) {
          this.#privateExtendedKey = utils.hex.toBytes(data[SessionKeys.PrivateExtendedKey]);
        }
      } catch (err) {
        console.warn('guard.sync', err);
      }
    }
  }

  /**
   * Sets the guard configuration, including the hashing algorithm and iterations.
   * @param algorithm The SHA algorithm to use (sha256 or sha512).
   * @param iteractions The number of iterations for key derivation. Must be a non-negative even number.
   */
  async setGuardConfig(algorithm: string, iteractions: number) {
    assert(
      algorithm === ShaAlgorithms.sha256 || algorithm === ShaAlgorithms.Sha512,
      ErrorMessages.IncorrectConfigParams
    );
    assert(iteractions >= 0, ErrorMessages.IncorrectConfigParams);
    assert(iteractions % 2 === 0, ErrorMessages.IncorrectConfigParams);

    this.#algorithm = algorithm as ShaAlgorithms;
    this.#iteractions = iteractions;

    const newConfig = `${algorithm}:${iteractions}`;

    await BrowserStorage.set(
      buildObject(OldFields.GUARD_CONFIG, newConfig)
    );
  }

  /**
   * Sets the logout timer for the session.
   * @param timer The time in hours before the session automatically logs out. Must be a positive integer.
   */
  async setLogOutTimer(timer: number) {
    assert(TypeOf.isInt(timer), ErrorMessages.MustBeInt);
    assert(timer > 0, ErrorMessages.IncorrectParams);

    this.#time = timer;

    await BrowserStorage.set(
      buildObject(OldFields.LOCK_TIME, String(this.lockTime))
    );
  }

  /**
   * Exports the decrypted mnemonic using the provided password.
   * @param password The password to decrypt the mnemonic.
   * @returns The decrypted mnemonic as a UTF-8 string.
   * @throws Error if the wallet is not ready, guard is not synced, or password is incorrect.
   */
  async exportMnemonic(password: string) {
    assert(this.isReady, ErrorMessages.WalletNotReady);

    try {
      assert(Boolean(this.#encryptMnemonic), ErrorMessages.GuardNotSynced);

      const hash = await this.#getKeyring(password);
      const mnemonicBytes = Cipher.decrypt(this.#encryptMnemonic as Uint8Array, hash);

      return utils.utf8.fromBytes(mnemonicBytes);
    } catch (err) {
      this.logout();
      throw new Error(ErrorMessages.IncorrectPassword);
    }
  }

  /**
   * Retrieves mnemonic and keys from old storage format.
   * @param password The password to decrypt old storage data.
   * @returns An object containing the mnemonic and an array of old guard vault keys.
   */
  async getFromOldStorage(password: string) {
    const data = await BrowserStorage.get(
      OldFields.VAULT,
      OldFields.VAULT_IMPORTED,
    );
    const hash = OldAes.hash(password);
    const encryptedKeys = data[OldFields.VAULT_IMPORTED];
    const mnemonic = OldAes.decrypt(data[OldFields.VAULT], hash);
    let keys: OldGuardVaultKeys[] = [];

    if (encryptedKeys) {
      try {
        keys = JSON.parse(OldAes.decrypt(encryptedKeys, hash));
      } catch {
        // Handle parsing error silently
      }
    }

    return {
      mnemonic,
      keys
    };
  }

  /**
   * Unlocks the wallet using the provided password, decrypting the mnemonic and setting up the session.
   * @param password The password to unlock the wallet.
   * @throws Error if the wallet is not ready, guard is not synced, or password is incorrect.
   */
  async unlock(password: string) {
    assert(this.isReady, ErrorMessages.WalletNotReady);

    try {
      assert(Boolean(this.#encryptMnemonic), ErrorMessages.GuardNotSynced);

      const hash = await this.#getKeyring(password);
      const oldHash = await sha256(utils.utf8.toBytes(password));
      const mnemonicBytes = Cipher.decrypt(this.#encryptMnemonic as Uint8Array, hash);
      const mnemonic = utils.utf8.fromBytes(mnemonicBytes);

      const seed = await Bip39.mnemonicToSeed(mnemonic);

      this.#privateExtendedKey = Cipher.encrypt(seed, hash);

      this.#isEnable = true;
      this.#updateSession();
      this.#hash.set(this, hash);
      this.#oldHash.set(this, oldHash);

      if (ManifestVersions.V3 === getManifestVersion()) {
        Runtime.storage.session.set({
          [SessionKeys.EndSession]: Number(this.#endSession),
          [SessionKeys.Hash]: utils.hex.fromBytes(hash),
          [SessionKeys.PrivateExtendedKey]: utils.hex.fromBytes(this.#privateExtendedKey),
        });
      }
    } catch (err) {
      this.logout();
      throw new Error(`${ErrorMessages.IncorrectPassword}, ${err.message}`);
    }
  }

  /**
   * Sets up the wallet vault with a new mnemonic and password, encrypting the mnemonic and private extended key.
   * @param mnemonic The mnemonic phrase.
   * @param password The password to encrypt the mnemonic.
   * @param wordList The word list for BIP39.
   * @param passphrase Optional passphrase for BIP39.
   */
  async setupVault(mnemonic: string, password: string, wordList: string[], passphrase?: string ) {
    const mnemonicBuf = utils.utf8.toBytes(mnemonic);
    const hash = await this.#getKeyring(password);
    const seed = await Bip39.mnemonicToSeed(
      mnemonic,
      passphrase,
      wordList,
    );

    this.#encryptMnemonic = Cipher.encrypt(mnemonicBuf, hash);
    this.#privateExtendedKey = Cipher.encrypt(seed, hash);

    this.#isReady = true;
    this.#isEnable = true;
    this.#updateSession();
    this.#hash.set(this, hash);

    await BrowserStorage.set(
      buildObject(OldFields.VAULT, Buffer.from(this.#encryptMnemonic).toString('base64'))
    );
  }

  /**
   * Encrypts a private key using the current session hash.
   * @param privKey The private key as a Uint8Array.
   * @returns The encrypted private key as a base64 string.
   */
  encryptPrivateKey(privKey: Uint8Array) {
    const hash = this.#hash.get(this) as Uint8Array;
    const encrypted = Cipher.encrypt(privKey, hash);

    return Buffer.from(encrypted).toString('base64');
  }

  /**
   * Decrypts a private key. Tries to decrypt with old hash first, then with current session hash.
   * @param content The encrypted private key as a base64 string.
   * @returns The decrypted private key as a hex string.
   */
  decryptPrivateKey(content: string): string {
    const hash = this.#hash.get(this) as Uint8Array;
    const oldHash = this.#oldHash.get(this) as Uint8Array;
    let privateKey: string;

    try {
      privateKey = OldAes.decrypt(content, Buffer.from(oldHash).toString('hex'));

    } catch {
      const bytes = Cipher.decrypt(Buffer.from(content, 'base64'), hash);

      privateKey = Buffer.from(bytes).toString('hex');
    }

    return privateKey;
  }

  /**
   * Checks if the session is active and the wallet is ready. Throws an error if not.
   */
  checkSession() {
    assert(this.#isReady, ErrorMessages.WalletNotReady);
    assert(this.#isEnable, ErrorMessages.WalletNotEnabled);
  }

  /**
   * Logs out the current session, disabling it and clearing session-related data.
   */
  async logout() {
    this.#isEnable = false;
    this.#endSession = new Date(-1);

    this.#hash.delete(this);
  }

  /**
   * Updates the session end time based on the configured lock time.
   */
  async #updateSession() {
    const now = new Date().getTime();
    const h = Number(this.#time);
    const newSession = new Date();

    newSession.setTime(now + (h * 60 * 60 * 1000));

    this.#endSession = newSession;
  }

  /**
   * Derives a key from the password using either SHA256 or PBKDF2, based on configuration.
   * @param password The password to derive the key from.
   * @returns The derived key as a Uint8Array.
   */
  async #getKeyring(password: string) {
    const salt = utils.utf8.toBytes(EXTENSION_ID);
    const passwordBytes = utils.utf8.toBytes(password);

    if (this.#algorithm === ShaAlgorithms.sha256 && this.#iteractions === 0) {
      return await sha256(passwordBytes);
    }

    const key = await pbkdf2(passwordBytes, salt, this.#iteractions, this.#algorithm);

    return await sha256(key);
  }
}


```

`zil-pay/background/storage/account.ts`:

```ts
import { AddressType } from './address-type';

export class Account {
  addr: string;
  addrType: AddressType;
  name: string;
  pubKey: string;
  chainHash: number;
  chainId: number;
  slip44: number;
  index: number;

  constructor(data: Record<string, unknown>) {
    this.addr = data.addr as string;
    this.addrType = data.addrType as AddressType;
    this.name = data.name as string;
    this.pubKey = data.pubKey as string;
    this.chainHash = data.chainHash as number;
    this.chainId = data.chainId as number;
    this.slip44 = data.slip44 as number;
    this.index = data.index as number;
  }
}

```

`zil-pay/background/storage/address-type.ts`:

```ts
export enum AddressType {
  Bech32,
  EthCheckSum
}


```

`zil-pay/background/storage/argon.ts`:

```ts
import { Variant, Version, Config } from '@hicaru/argon2-pure.js';
import { APP_ID } from '../../config/argon2';
import { Argon2Config } from '../../crypto/argon2';
import { utils } from 'aes-js';

export class WalletArgon2Params {
  memory: number;
  iterations: number;
  threads: number;
  secret: string;

  get argonConfgi(): Argon2Config {
    return new Config(
      APP_ID,
      64,
      this.threads,
      this.memory,
      utils.hex.toBytes(this.secret),
      this.iterations,
      Variant.Argon2id,
      Version.Version13,

    );
  }

  constructor(data: Record<string, unknown>) {
    this.memory = data.memory as number;
    this.iterations = data.iterations as number;
    this.threads = data.threads as number;
    this.secret = data.secret as string;
  }
}

```

`zil-pay/background/storage/background.ts`:

```ts
import { ChainConfig } from './chain';
import { Wallet } from './wallet';

export enum AppearancesTheme {
  System,
  Dark,
  Light
}

export class BackgroundState {
  wallets: Wallet[];
  notificationsGlobalEnabled: boolean;
  locale: string | null;
  appearances: AppearancesTheme;
  abbreviatedNumber: boolean;
  hideBalance: boolean;
  storageVersion: number;
  chains: ChainConfig[];

  constructor(data: Record<string, unknown>) {
    this.wallets = (data.wallets as Record<string, unknown>[]).map(
      (w) => new Wallet(w)
    );
    this.notificationsGlobalEnabled = data.notificationsGlobalEnabled as boolean;
    this.locale = data.locale as string | null ?? null;
    this.appearances = data.appearances as AppearancesTheme;
    this.abbreviatedNumber = data.abbreviatedNumber as boolean;
    this.hideBalance= data.hideBalance as boolean;
    this.chains = (data.chains as Record<string, unknown>[]).map(
      (c) => new ChainConfig(c)
    );
  }
}

```

`zil-pay/background/storage/chain.ts`:

```ts
import { FToken } from './ftoken';
import { Explorer } from './explorer';

export class ChainConfig {
  name: string;
  logo: string;
  chain: string;
  shortName: string;
  rpc: string[];
  features: number[];
  chainId: number;
  chainIds: BigUint64Array;
  slip44: number;
  diffBlockTime: number;
  chainHash: number;
  ens: string | null;
  explorers: Explorer[];
  fallbackEnabled: boolean;
  testnet: boolean | null;
  ftokens: FToken[];

  constructor(data: Record<string, unknown>) {
    this.name = data.name as string;
    this.logo = data.logo as string;
    this.chain = data.chain as string;
    this.shortName = data.shortName as string;
    this.rpc = data.rpc as string[];
    this.features = data.features as number[];
    this.chainId = data.chainId as number;
    this.chainIds = data.chainIds as BigUint64Array;
    this.slip44 = data.slip44 as number;
    this.diffBlockTime = data.diffBlockTime as number;
    this.chainHash = data.chainHash as number;
    this.ens = data.ens as string | null ?? null;
    this.explorers = (data.explorers as Record<string, unknown>[]).map(
      (e) => new Explorer(e)
    );
    this.fallbackEnabled = data.fallbackEnabled as boolean;
    this.testnet = data.testnet as boolean | null ?? null;
    this.ftokens = (data.ftokens as Record<string, unknown>[]).map(
      (t) => new FToken(t)
    );
  }
}

```

`zil-pay/background/storage/explorer.ts`:

```ts
export class Explorer {
  name: string;
  url: string;
  icon: string | null;
  standard: number;

  constructor(data: Record<string, unknown>) {
    this.name = data.name as string;
    this.url = data.url as string;
    this.icon = data.icon as string | null ?? null;
    this.standard = data.standard as number;
  }
}

```

`zil-pay/background/storage/ftoken.ts`:

```ts
import { AddressType } from './address-type';
 
export class FToken {
  name: string;
  symbol: string;
  decimals: number;
  addr: string;
  addrType: AddressType;
  logo: string | null;
  balances: Record<number, string>;
  rate: number;
  default_: boolean;
  native: boolean;
  chainHash: number;

  constructor(data: Record<string, unknown>) {
    this.name = data.name as string;
    this.symbol = data.symbol as string;
    this.decimals = data.decimals as number;
    this.addr = data.addr as string;
    this.addrType = data.addrType as AddressType;
    this.logo = data.logo as string | null ?? null;
    this.balances = data.balances as Record<number, string>;
    this.rate = data.rate as number;
    this.default_ = data.default_ as boolean;
    this.native = data.native as boolean;
    this.chainHash = data.chainHash as number;
  }
}

```

`zil-pay/background/storage/notification.ts`:

```ts
export class Notification {
  transactions: boolean;

  constructor(data: Record<string, unknown>) {
    this.transactions = data.transactions as boolean;
  }
}

```

`zil-pay/background/storage/settings.ts`:

```ts
import { WalletArgon2Params } from './argon';
import { CipherOrders } from '../../crypto/keychain';

export enum RatesApiOptions {
  CoinGecko
} 

export class WalletSettings {
  cipherOrders: CipherOrders[];
  argonParams: WalletArgon2Params;
  currencyConvert: string;
  ipfsNode: string | null;
  ensEnabled: boolean;
  tokensListFetcher: boolean;
  nodeRankingEnabled: boolean;
  maxConnections: number;
  requestTimeoutSecs: number;
  ratesApiOptions: RatesApiOptions;

  constructor(data: Record<string, unknown>) {
    this.cipherOrders = data.cipherOrders as CipherOrders[];
    this.argonParams = new WalletArgon2Params(data.argonParams as Record<string, unknown>);
    this.currencyConvert = data.currencyConvert as string;
    this.ipfsNode = data.ipfsNode as string || null;
    this.ensEnabled = data.ensEnabled as boolean;
    this.tokensListFetcher = data.tokensListFetcher as boolean;
    this.nodeRankingEnabled = data.nodeRankingEnabled as boolean;
    this.maxConnections = data.maxConnections as number;
    this.requestTimeoutSecs = data.requestTimeoutSecs as number;
    this.ratesApiOptions = data.ratesApiOptions as RatesApiOptions;
  }
}

```

`zil-pay/background/storage/wallet.ts`:

```ts
import { Account } from './account';
import { FToken } from './ftoken';
import { WalletSettings } from './settings';

export enum WalletTypes {
    Ledger,
    SecretPhrase,
    SecretKey,
}

export enum AuthMethod {
    Biometric,
    None,
}

export class Wallet {
  walletType: WalletTypes;
  walletName: string;
  authType: AuthMethod;
  walletAddress: string;
  accounts: Account[];
  selectedAccount: number;
  tokens: FToken[];
  settings: WalletSettings;
  defaultChainHash: number;
  vault: string;

  constructor(data: Record<string, unknown>) {
    this.walletType = data.walletType as WalletTypes;
    this.vault = data.vault as string;
    this.walletName = data.walletName as string;
    this.authType = data.authType as AuthMethod;
    this.walletAddress = data.walletAddress as string;
    this.accounts = (data.accounts as Record<string, unknown>[]).map(
      (a) => new Account(a)
    );
    this.selectedAccount = data.selectedAccount as number;
    this.tokens = (data.tokens as Record<string, unknown>[]).map(
      (t) => new FToken(t)
    );
    this.settings = new WalletSettings(data.settings as Record<string, unknown>);
    this.defaultChainHash = data.defaultChainHash as number;
  }
}

```

`zil-pay/config/argon2.ts`:

```ts
import { utils } from "aes-js";

export const WALLET_SALT = utils.utf8.toBytes(
  "ZILPAY:54040c2f-1ec1-4eb1-9595-6e4294d14fd6",
);
export const APP_ID = utils.utf8.toBytes("ZilPay-wallet-app");

```

`zil-pay/config/common.ts`:

```ts
export enum Common {
  TIME_BEFORE_LOCK = 3,
  POPUP_WIDTH = 320,
  POPUP_HEIGHT = 600,
  PROMT_PAGE = "index.html",
  NONCE_DIFFICULTY = 10,
  MAX_TX_QUEUE = 20,
}

export const WORKER_POOLING = 8000; // Seconds

```

`zil-pay/config/fields.ts`:

```ts
export enum OldFields {
  VAULT = "vault",
  VAULT_IMPORTED = "importedvault",
  CONFIG = "config",
  OLD_WALLET = "wallet",
  WALLET = "wallet-identities",
  SELECTED_NET = "selectednet",
  BLOCK_NUMBER = "blocknumber",
  TRANSACTIONS = "transactions",
  ENCRYPT_DATA = "encryption-data",
  DECRYPT_DATA = "decryption-data",
  CONFIRM_TX = "confirm",
  CONFIRM_MESSAGE = "confirm-message",
  STATIC = "static",
  LOCK_TIME = "time_before_lock",
  GUARD_CONFIG = "guard-configuration",
  CONNECT_DAPP = "connect",
  CONNECT_LIST = "connection-list",
  THEME = "theme",
  CONTACTS = "contacts",
  SELECTED_COIN = "selectedcoin",
  TOKENS = "tokens-list",
  COLLECTION = "collections-list",
  SSN = "ssn-list",
  GAS = "chain-gas",
  RATE_CURRENCIES = "rate-of-currencies",
  SELECTED_CURRENCY = "selected-currency",
  LOCALE = "selected-local",
  FORMAT = "address-format",
  POPUP_ENABLED = "popup-enabled",
  PHISHING = "phishing-detection",
  DEX = "dex-proto",
  BADGE_COUNTER = "badge-counter",
}

```

`zil-pay/config/manifest.ts`:

```ts
export enum ManifestVersions {
  V2 = 2,
  V3 = 3,
}

```

`zil-pay/config/pbkdf2.ts`:

```ts
export enum ShaAlgorithms {
  Sha512 = "SHA-512",
  sha256 = "SHA-256",
}

```

`zil-pay/config/sha.ts`:

```ts
export enum ShaAlgorithms {
  Sha512 = "SHA-512",
  sha256 = "SHA-256",
}

```

`zil-pay/crypto/aes256.ts`:

```ts
import { Counter, ModeOfOperation, utils } from "aes-js";
import { randomBytes } from "../crypto/random";
import { md5 } from "js-md5";
import { base64ToUint8Array } from "./b64";

export enum ErrorMessages {
  InvalidKeyLength = "Invalid key length provided. Key must be 16, 24, or 32 bytes.",
  IncorrectParams = "Password is not correct",
}

export const AESCipherV3 = Object.freeze({
  encrypt(content: Uint8Array, key: Uint8Array): Uint8Array {
    if (![16, 24, 32].includes(key.length)) {
      throw new Error(ErrorMessages.InvalidKeyLength);
    }

    const entropy = randomBytes(16);
    const iv = new Counter(entropy);
    const aesCtr = new ModeOfOperation.ctr(key, iv);
    const encrypted = aesCtr.encrypt(content);
    const bytes = utils.utf8.toBytes(
      `${utils.hex.fromBytes(encrypted)}/${utils.hex.fromBytes(entropy)}`,
    );
    return bytes;
  },
  decrypt(bytes: Uint8Array, key: Uint8Array): Uint8Array {
    if (![16, 24, 32].includes(key.length)) {
      throw new Error(ErrorMessages.InvalidKeyLength);
    }

    const [encrypted, iv] = utils.utf8.fromBytes(bytes).split("/");
    const counter = new Counter(utils.hex.toBytes(iv));
    const aesCtr = new ModeOfOperation.ctr(key, counter);
    return aesCtr.decrypt(utils.hex.toBytes(encrypted));
  },
});

export const AESCipherV2 = Object.freeze({
  async decrypt(data: string, key: string): Promise<any> {
    const combined = base64ToUint8Array(data);

    const prefix = new TextDecoder().decode(combined.slice(0, 8));
    if (prefix !== "Salted__") {
      throw new Error(ErrorMessages.IncorrectParams);
    }

    const salt = combined.slice(8, 16);
    const ciphertext = combined.slice(16);
    const passwordBytes = new TextEncoder().encode(key);
    const { key: derivedKey, iv } = await AESCipherV2.evpKDF(
      passwordBytes,
      salt,
      32,
      16,
    );

    const cryptoKey = await crypto.subtle.importKey(
      "raw",
      derivedKey,
      { name: "AES-CBC" },
      false,
      ["decrypt"],
    );

    let decrypted: ArrayBuffer;
    try {
      decrypted = await crypto.subtle.decrypt(
        { name: "AES-CBC", iv },
        cryptoKey,
        ciphertext,
      );
    } catch {
      throw new Error("ErrorMessages.IncorrectPassword");
    }

    const content = new TextDecoder().decode(decrypted);
    if (!content) {
      throw new Error("ErrorMessages.IncorrectPassword");
    }

    try {
      return JSON.parse(content);
    } catch {
      return content;
    }
  },
  async evpKDF(
    password: Uint8Array,
    salt: Uint8Array,
    keySize: number,
    ivSize: number,
  ): Promise<{ key: Uint8Array; iv: Uint8Array }> {
    const totalSize = keySize + ivSize;
    let derived = new Uint8Array(0);
    let previousBlock = new Uint8Array(0);

    while (derived.length < totalSize) {
      const input = new Uint8Array([...previousBlock, ...password, ...salt]);
      const block = await AESCipherV2.md5Hash(input);
      derived = new Uint8Array([...derived, ...block]);
      previousBlock = Uint8Array.from(block);
    }

    const key = derived.slice(0, keySize);
    const iv = derived.slice(keySize, keySize + ivSize);
    return { key, iv };
  },

  async md5Hash(data: Uint8Array): Promise<Uint8Array> {
    const hasher = md5.create();
    hasher.update(data);
    const hash = hasher.arrayBuffer();
    return new Uint8Array(hash);
  },
});

```

`zil-pay/crypto/argon2.ts`:

```ts
import { Config, hashRaw } from "@hicaru/argon2-pure.js";
import { WALLET_SALT } from "../config/argon2";

export type Argon2Config = Config;

export function deriveArgon2Key(
  password: Uint8Array,
  salt: string,
  config: Argon2Config,
) {
  const textEncoder = new TextEncoder();
  const saltBytes = textEncoder.encode(salt);

  const combinedSalt = new Uint8Array(saltBytes.length + WALLET_SALT.length);

  combinedSalt.set(saltBytes, 0);
  combinedSalt.set(WALLET_SALT, saltBytes.length);

  const hash = hashRaw(password, combinedSalt, config);

  return hash;
}

```

`zil-pay/crypto/b64.ts`:

```ts
/**
 * Converts a base64 string to a Uint8Array.
 * @param base64 - The base64 string to convert.
 * @returns A Uint8Array containing the decoded data.
 * @throws {Error} If the input string is not a valid base64 string.
 */
export function base64ToUint8Array(base64: string): Uint8Array {
  try {
    const binaryString = atob(base64);
    const length = binaryString.length;
    const bytes = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  } catch (error) {
    throw new Error("Invalid base64 string");
  }
}

/**
 * Converts a Uint8Array to a base64 string.
 * @param uint8Array - The Uint8Array to convert.
 * @returns A base64 string representing the input data.
 */
export function uint8ArrayToBase64(uint8Array: Uint8Array): string {
  const binaryString = String.fromCharCode(...uint8Array);
  return btoa(binaryString);
}

```

`zil-pay/crypto/bip32.ts`:

```ts
import * as secp256k1 from "noble-secp256k1";
import {
  bigIntToUint8ArrayBigEndian,
  uint8ArrayToBigIntBigEndian,
} from "./number";
import { ShaAlgorithms } from "../config/pbkdf2";

// Constants
const HARDENED_BIT = 0x80000000;
const BITCOIN_SEED = new TextEncoder().encode("Bitcoin seed");

// Error enum
export enum Bip32ErrorCode {
  InvalidChild = "InvalidChild",
  InvalidPath = "InvalidPath",
  InvalidKey = "InvalidKey",
  HmacError = "HmacError",
}

// Error class
export class Bip32Error extends Error {
  constructor(code: Bip32ErrorCode, message: string) {
    super(message);
    this.name = `Bip32Error:${code}`;
  }
}

/**
 * Represents a child number in a BIP-32 derivation path.
 */
export class ChildNumber {
  constructor(public value: number) {}

  /**
   * Checks if the child number is hardened.
   * @returns {boolean} True if hardened, false otherwise.
   */
  isHardened(): boolean {
    return this.value < 0;
  }

  /**
   * Converts the child number to a 4-byte Uint8Array.
   * @returns {Uint8Array} The byte representation.
   */
  toBytes(): Uint8Array {
    const buffer = new Uint8Array(4);
    buffer[0] = (this.value >>> 24) & 0xff;
    buffer[1] = (this.value >>> 16) & 0xff;
    buffer[2] = (this.value >>> 8) & 0xff;
    buffer[3] = this.value & 0xff;
    return buffer;
  }

  /**
   * Creates a ChildNumber from a string representation.
   * @param {string} s - The string representation (e.g., "0'", "1").
   * @returns {ChildNumber} The parsed ChildNumber.
   * @throws {Bip32Error} If the string is invalid.
   */
  static fromString(s: string): ChildNumber {
    let numStr = s;
    let hardened = false;
    if (s.endsWith("'")) {
      numStr = s.slice(0, -1);
      hardened = true;
    }
    const index = parseInt(numStr, 10);
    if (isNaN(index) || index < 0) {
      throw new Bip32Error(
        Bip32ErrorCode.InvalidChild,
        `Failed to parse child number: ${s}`,
      );
    }
    const value = hardened ? index | HARDENED_BIT : index;
    return new ChildNumber(value);
  }
}

/**
 * Computes an HMAC-SHA512 hash of the data using the provided key.
 * @param {Uint8Array} key - The HMAC key.
 * @param {Uint8Array} data - The data to hash.
 * @returns {Promise<Uint8Array>} The HMAC result.
 * @throws {Bip32Error} If HMAC computation fails.
 */
async function hmacSha512(
  key: Uint8Array,
  data: Uint8Array,
): Promise<Uint8Array> {
  try {
    const importedKey = await globalThis.crypto.subtle.importKey(
      "raw",
      key,
      {
        name: "HMAC",
        hash: { name: ShaAlgorithms.Sha512 },
      },
      false,
      ["sign"],
    );

    const signature = await globalThis.crypto.subtle.sign(
      "HMAC",
      importedKey,
      data,
    );

    return new Uint8Array(signature);
  } catch (error) {
    throw new Bip32Error(
      Bip32ErrorCode.HmacError,
      `HMAC computation failed: ${error}`,
    );
  }
}

/**
 * Derives the master private key and chain code from a seed.
 * @param {Uint8Array} seed - The seed bytes.
 * @returns {Promise<{ key: Uint8Array; chainCode: Uint8Array }>} The master key and chain code.
 * @throws {Bip32Error} If the master key is invalid.
 */
export async function deriveMasterKey(
  seed: Uint8Array,
): Promise<{ key: Uint8Array; chainCode: Uint8Array }> {
  const hmacResult = await hmacSha512(BITCOIN_SEED, seed);
  const key = new Uint8Array(hmacResult.slice(0, 32));
  const chainCode = new Uint8Array(hmacResult.slice(32, 64));

  if (!secp256k1.utils.isValidPrivateKey(key)) {
    throw new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid master key");
  }

  return { key, chainCode };
}

/**
 * Derives a child private key and chain code from a parent key, chain code, and child number.
 * @param {Uint8Array} parentKey - The parent private key.
 * @param {Uint8Array} chainCode - The parent chain code.
 * @param {ChildNumber} child - The child number.
 * @returns {Promise<{ key: Uint8Array; chainCode: Uint8Array }>} The child key and chain code.
 * @throws {Bip32Error} If the child key is invalid.
 */
export async function deriveChildKey(
  parentKey: Uint8Array,
  chainCode: Uint8Array,
  child: ChildNumber,
): Promise<{ key: Uint8Array; chainCode: Uint8Array }> {
  if (!secp256k1.utils.isValidPrivateKey(parentKey)) {
    throw new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid parent key");
  }

  let dataToHash: Uint8Array;

  if (child.isHardened()) {
    dataToHash = new Uint8Array([0, ...parentKey, ...child.toBytes()]);
  } else {
    const publicKey = secp256k1.getPublicKey(parentKey, true);
    dataToHash = new Uint8Array([...publicKey, ...child.toBytes()]);
  }

  const hmacResult = await hmacSha512(chainCode, dataToHash);
  const childKeyPart = new Uint8Array(hmacResult.slice(0, 32));
  const newChainCode = new Uint8Array(hmacResult.slice(32, 64));

  const curveOrder = BigInt(
    "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141",
  );

  let parentScalar = uint8ArrayToBigIntBigEndian(parentKey);
  let childScalar = uint8ArrayToBigIntBigEndian(childKeyPart);

  // Ensure childScalar is within the curve order
  childScalar = childScalar % curveOrder;

  // Add scalars and reduce modulo curve order
  let sum = (parentScalar + childScalar) % curveOrder;

  // Handle the case where sum is 0 (invalid private key)
  if (sum === 0n) {
    throw new Bip32Error(
      Bip32ErrorCode.InvalidKey,
      "Invalid child key: sum is zero",
    );
  }

  const resultKey = bigIntToUint8ArrayBigEndian(sum, 32);

  if (!secp256k1.utils.isValidPrivateKey(resultKey)) {
    throw new Bip32Error(Bip32ErrorCode.InvalidKey, "Invalid child key");
  }

  return { key: resultKey, chainCode: newChainCode };
}

/**
 * Derives a private key from a seed and a BIP-32 derivation path.
 * @param {Uint8Array} seed - The seed bytes.
 * @param {string} path - The BIP-32 derivation path (e.g., "m/44'/60'/0'/0/0").
 * @returns {Promise<Uint8Array>} The derived private key.
 * @throws {Bip32Error} If the path is invalid or derivation fails.
 */
export async function derivePrivateKey(
  seed: Uint8Array,
  path: string,
): Promise<Uint8Array> {
  if (!path.startsWith("m/")) {
    throw new Bip32Error(
      Bip32ErrorCode.InvalidPath,
      "Path must start with 'm/'",
    );
  }

  const pathParts = path
    .slice(2)
    .split("/")
    .filter((part) => part !== "");

  let { key, chainCode } = await deriveMasterKey(seed);

  for (const part of pathParts) {
    const childNumber = ChildNumber.fromString(part);
    const result = await deriveChildKey(key, chainCode, childNumber);
    key = result.key;
    chainCode = result.chainCode;
  }

  return key;
}

```

`zil-pay/crypto/bip39.ts`:

```ts
import { pbkdf2 } from "./pbkdf2";
import { ShaAlgorithms } from "../config/pbkdf2";
import { randomBytes } from "./random";
import { assert } from "../lib/runtime/assert";
import { sha256 } from "./sha256";

// BIP-39 constants
const ENTROPY_BITS = [128, 160, 192, 224, 256];
const PBKDF2_ITERATIONS = 2048;
const SEED_LENGTH = 64; // 512 bits

export interface Mnemonic {
  phrase: string;
  words: string[];
}

export enum Bip39Error {
  InvalidEntropy = "Invalid entropy length. Must be 128, 160, 192, 224, or 256 bits.",
  InvalidMnemonic = "Invalid mnemonic phrase.",
  InvalidWord = "Mnemonic contains invalid word(s) not in wordlist.",
  InvalidWordCount = "Invalid number of words. Must be 12, 15, 18, 21, or 24.",
  InvalidChecksum = "Mnemonic checksum is invalid.",
}

export const Bip39 = Object.freeze({
  /**
   * Generates a BIP-39 mnemonic from random entropy.
   * @param entropyBits - Number of entropy bits (128, 160, 192, 224, or 256).
   * @returns A mnemonic object with phrase and words.
   * @throws Error if entropyBits is invalid.
   */
  async generateMnemonic(
    entropyBits: number = 128,
    wordList: string[],
  ): Promise<Mnemonic> {
    assert(ENTROPY_BITS.includes(entropyBits), Bip39Error.InvalidEntropy);

    const entropyBytes = entropyBits / 8;
    const entropy = randomBytes(entropyBytes);
    const checksumBits = entropyBits / 32;
    const totalBits = entropyBits + checksumBits;
    const wordCount = totalBits / 11;

    // Compute SHA-256 checksum
    const hash = await sha256(entropy);
    const checksum = hash[0] >> (8 - checksumBits);

    // Combine entropy and checksum
    const entropyBitsStr = Array.from(entropy)
      .map((byte) => byte.toString(2).padStart(8, "0"))
      .join("");
    const checksumBitsStr = checksum.toString(2).padStart(checksumBits, "0");
    const bits = entropyBitsStr + checksumBitsStr;

    // Split into 11-bit chunks to select words
    const words: string[] = [];
    for (let i = 0; i < wordCount; i++) {
      const start = i * 11;
      const chunk = bits.slice(start, start + 11);
      const index = parseInt(chunk, 2);
      words.push(wordList[index]);
    }

    return {
      phrase: words.join(" "),
      words,
    };
  },

  /**
   * Validates a BIP-39 mnemonic phrase.
   * @param mnemonic - The mnemonic phrase to validate.
   * @returns True if valid, throws error otherwise.
   * @throws Error if mnemonic is invalid.
   */
  async validateMnemonic(
    mnemonic: string,
    wordList: string[],
  ): Promise<boolean> {
    const words = mnemonic.trim().split(/\s+/);
    const wordCount = words.length;
    const validWordCounts = [12, 15, 18, 21, 24];

    assert(validWordCounts.includes(wordCount), Bip39Error.InvalidWordCount);

    // Verify all words are in wordlist
    for (const word of words) {
      assert(wordList.includes(word), `${Bip39Error.InvalidWord}, ${word}`);
    }

    // Reconstruct entropy and checksum
    const bits = words
      .map((word) => {
        const index = wordList.indexOf(word);
        return index.toString(2).padStart(11, "0");
      })
      .join("");

    const entropyBits = wordCount * 11 - wordCount / 3;
    const entropy = bits.slice(0, entropyBits);
    const checksum = bits.slice(entropyBits);

    // Convert entropy bits to bytes
    const entropyBytes = new Uint8Array(entropyBits / 8);
    for (let i = 0; i < entropyBytes.length; i++) {
      entropyBytes[i] = parseInt(entropy.slice(i * 8, (i + 1) * 8), 2);
    }

    // Verify checksum
    const hash = await sha256(entropyBytes);
    const computedChecksum = hash[0] >> (8 - wordCount / 3);
    const expectedChecksum = parseInt(checksum, 2);

    assert(computedChecksum === expectedChecksum, Bip39Error.InvalidChecksum);

    return true;
  },

  /**
   * Derives a seed from a BIP-39 mnemonic using PBKDF2.
   * @param mnemonic - The mnemonic phrase.
   * @param passphrase - Optional passphrase (default: empty string).
   * @returns A 512-bit seed as Uint8Array.
   * @throws Error if mnemonic is invalid.
   */
  async mnemonicToSeed(
    mnemonic: string,
    passphrase: string = "",
    wordList: string[],
  ): Promise<Uint8Array> {
    assert(
      await Bip39.validateMnemonic(mnemonic, wordList),
      Bip39Error.InvalidMnemonic,
    );

    const password = new TextEncoder().encode(mnemonic);
    const salt = new TextEncoder().encode(`mnemonic${passphrase}`);
    const seed = await pbkdf2(
      password,
      salt,
      PBKDF2_ITERATIONS,
      ShaAlgorithms.Sha512,
    );

    assert(seed.length === SEED_LENGTH, "Invalid seed length.");

    return seed;
  },

  /**
   * Converts a mnemonic to entropy.
   * @param mnemonic - The mnemonic phrase.
   * @returns The original entropy as Uint8Array.
   * @throws Error if mnemonic is invalid.
   */
  async mnemonicToEntropy(
    mnemonic: string,
    wordList: string[],
  ): Promise<Uint8Array> {
    assert(
      await Bip39.validateMnemonic(mnemonic, wordList),
      Bip39Error.InvalidMnemonic,
    );

    const words = mnemonic.trim().split(/\s+/);
    const wordCount = words.length;
    const entropyBits = wordCount * 11 - wordCount / 3;

    const bits = words
      .map((word) => {
        const index = wordList.indexOf(word);
        return index.toString(2).padStart(11, "0");
      })
      .join("");

    const entropy = bits.slice(0, entropyBits);
    const entropyBytes = new Uint8Array(entropyBits / 8);
    for (let i = 0; i < entropyBytes.length; i++) {
      entropyBytes[i] = parseInt(entropy.slice(i * 8, (i + 1) * 8), 2);
    }

    return entropyBytes;
  },

  /**
   * Converts entropy to a BIP-39 mnemonic phrase.
   * @param entropy - The entropy as a Uint8Array (must be 16, 20, 24, 28, or 32 bytes).
   * @param wordList - The BIP-39 wordlist.
   * @returns A mnemonic object with phrase and words.
   * @throws Error if entropy length is invalid.
   */
  async entropyToMnemonic(
    entropy: Uint8Array,
    wordList: string[],
  ): Promise<Mnemonic> {
    const entropyBits = entropy.length * 8;
    assert(ENTROPY_BITS.includes(entropyBits), Bip39Error.InvalidEntropy);

    const checksumBits = entropyBits / 32;
    const totalBits = entropyBits + checksumBits;
    const wordCount = totalBits / 11;

    // Compute SHA-256 checksum
    const hash = await sha256(entropy);
    const checksum = hash[0] >> (8 - checksumBits);

    // Combine entropy and checksum
    const entropyBitsStr = Array.from(entropy)
      .map((byte) => byte.toString(2).padStart(8, "0"))
      .join("");
    const checksumBitsStr = checksum.toString(2).padStart(checksumBits, "0");
    const bits = entropyBitsStr + checksumBitsStr;

    // Split into 11-bit chunks to select words
    const words: string[] = [];
    for (let i = 0; i < wordCount; i++) {
      const start = i * 11;
      const chunk = bits.slice(start, start + 11);
      const index = parseInt(chunk, 2);
      words.push(wordList[index]);
    }

    return {
      phrase: words.join(" "),
      words,
    };
  },
});

```

`zil-pay/crypto/keychain.ts`:

```ts
import { PrivKey, PubKey } from "@hicaru/ntrup.js";
import {
  NTRU_CONFIG,
  ntruDecrypt,
  ntruEncrypt,
  ntruKeysFromSeed,
} from "./ntrup";
import { sha256 } from "./sha256";
import { deriveArgon2Key, Argon2Config } from "./argon2";
import {
  kuznechikDecrypt,
  kuznechikEncrypt,
  KUZNECHIK_KEY_SIZE,
} from "./kuznechik";
import { AESCipherV3, AESCipherV2 } from "./aes256";

export const PUBLICKEYS_BYTES = NTRU_CONFIG.PUBLICKEYS_BYTES;
export const SECRETKEYS_BYTES = NTRU_CONFIG.SECRETKEYS_BYTES;
export const AES_GCM_KEY_SIZE = KUZNECHIK_KEY_SIZE;
export const KEYCHAIN_BYTES_SIZE =
  PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE + KUZNECHIK_KEY_SIZE;

export async function deriveKeyFromSeed(
  seed: Uint8Array,
  idx: number,
): Promise<Uint8Array> {
  const hasher = new Uint8Array([...seed, idx]);
  return sha256(hasher);
}

export enum CipherOrders {
  AESCBC,
  AESGCM256,
  KUZNECHIK,
  NTRUP761,
}

export class KeyChain {
  public ntrupKeys: { pk: PubKey; sk: PrivKey };
  public aesKey: Uint8Array;
  public kuznechikKey: Uint8Array;

  constructor(
    ntrupKeys: { pk: PubKey; sk: PrivKey },
    aesKey: Uint8Array,
    kuznechikKey: Uint8Array,
  ) {
    this.ntrupKeys = ntrupKeys;
    this.aesKey = aesKey;
    this.kuznechikKey = kuznechikKey;
  }

  static async fromSeed(seed: Uint8Array): Promise<KeyChain> {
    const ntrupKeys = ntruKeysFromSeed(seed);
    const aesKey = await deriveKeyFromSeed(seed, 0);
    const kuznechikKey = await deriveKeyFromSeed(seed, 1);
    return new KeyChain(ntrupKeys, aesKey, kuznechikKey);
  }

  static async fromPass(
    password: Uint8Array,
    fingerprint: string,
    argonConfig: Argon2Config,
  ): Promise<KeyChain> {
    const seed = deriveArgon2Key(password, fingerprint, argonConfig);
    return KeyChain.fromSeed(seed);
  }

  static async fromBytes(bytes: Uint8Array): Promise<KeyChain> {
    if (bytes.length !== KEYCHAIN_BYTES_SIZE) {
      throw new Error("Invalid byte length");
    }
    const pkBytes = bytes.slice(0, PUBLICKEYS_BYTES);
    const skBytes = bytes.slice(
      PUBLICKEYS_BYTES,
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES,
    );
    const aesKey = bytes.slice(
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES,
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE,
    );
    const kuznechikKey = bytes.slice(
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE,
      KEYCHAIN_BYTES_SIZE,
    );

    const pk = PubKey.import(pkBytes, NTRU_CONFIG);
    const sk = PrivKey.import(skBytes, NTRU_CONFIG);

    return new KeyChain({ pk, sk }, aesKey, kuznechikKey);
  }

  toBytes(): Uint8Array {
    const pkBytes = this.ntrupKeys.pk.toBytes(NTRU_CONFIG);
    const skBytes = this.ntrupKeys.sk.toBytes(NTRU_CONFIG);
    const aesKey = this.aesKey;
    const kuznechikKey = this.kuznechikKey;

    const res = new Uint8Array(KEYCHAIN_BYTES_SIZE);
    res.set(pkBytes, 0);
    res.set(skBytes, PUBLICKEYS_BYTES);
    res.set(aesKey, PUBLICKEYS_BYTES + SECRETKEYS_BYTES);
    res.set(
      kuznechikKey,
      PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE,
    );
    return res;
  }

  async encrypt(
    plaintext: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    let data = plaintext;
    for (const o of options) {
      switch (o) {
        case CipherOrders.AESCBC:
          throw new Error("OLD method, AESCBC");
        case CipherOrders.AESGCM256:
          data = AESCipherV3.encrypt(data, this.aesKey);
          break;
        case CipherOrders.KUZNECHIK:
          data = kuznechikEncrypt(this.kuznechikKey, data);
          break;
        case CipherOrders.NTRUP761:
          data = ntruEncrypt(this.ntrupKeys.pk, data);
          break;
      }
    }
    return data;
  }

  async decrypt(
    ciphertext: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    let data = ciphertext;
    for (const o of options.slice().reverse()) {
      switch (o) {
        case CipherOrders.AESCBC:
          const aesKeyStr = new TextDecoder().decode(this.aesKey);
          const dataStr = new TextDecoder().decode(data);
          const decryptedStr = await AESCipherV2.decrypt(dataStr, aesKeyStr);
          data = new TextEncoder().encode(decryptedStr);
          break;
        case CipherOrders.AESGCM256:
          data = AESCipherV3.decrypt(data, this.aesKey);
          break;
        case CipherOrders.KUZNECHIK:
          data = kuznechikDecrypt(this.kuznechikKey, data);
          break;
        case CipherOrders.NTRUP761:
          data = ntruDecrypt(this.ntrupKeys.sk, data);
          break;
      }
    }
    return data;
  }

  async makeProof(
    seed: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    return this.encrypt(seed, options);
  }

  async getProof(
    cipherProof: Uint8Array,
    options: CipherOrders[],
  ): Promise<Uint8Array> {
    return this.decrypt(cipherProof, options);
  }
}

```

`zil-pay/crypto/kuznechik.ts`:

```ts
import {
  KeyStore,
  AlgOfb,
  MIN_GAMMA_SIZE,
  MASTER_KEY_SIZE,
} from "@hicaru/kuznechik.js";
import { randomBytes } from "./random";

export const KUZNECHIK_KEY_SIZE = MASTER_KEY_SIZE;

export function kuznechikEncrypt(
  key: Uint8Array,
  plaintext: Uint8Array,
): Uint8Array {
  const keyStore = new KeyStore();
  keyStore.setMasterKey(key);
  const gamma = randomBytes(MIN_GAMMA_SIZE);
  const alg = new AlgOfb(keyStore);
  alg.setGamma(gamma);
  const encrypted = alg.encrypt(plaintext);
  const finalCiphertext = new Uint8Array(encrypted.length + gamma.length);
  finalCiphertext.set(encrypted, 0);
  finalCiphertext.set(gamma, encrypted.length);
  return finalCiphertext;
}

export function kuznechikDecrypt(
  key: Uint8Array,
  ciphertext: Uint8Array,
): Uint8Array {
  const gamma = ciphertext.slice(ciphertext.length - MIN_GAMMA_SIZE);
  const actualCiphertext = ciphertext.slice(
    0,
    ciphertext.length - MIN_GAMMA_SIZE,
  );
  const keyStore = new KeyStore();
  keyStore.setMasterKey(key);
  const alg = new AlgOfb(keyStore);
  alg.setGamma(gamma);
  const plaintext = alg.decrypt(actualCiphertext);
  return plaintext;
}

```

`zil-pay/crypto/ntrup.ts`:

```ts
import { ChaCha20Rng, ChaChaRng } from "@hicaru/chacharand.js";
import {
  bytesRqDecode,
  ErrorType,
  generateKeyPair,
  packBytes,
  params761,
  ParamsConfig,
  PrivKey,
  PubKey,
  R3,
  r3DecodeChunks,
  r3EncodeChunks,
  r3Encrypt,
  r3MergeWChunks,
  r3SplitWChunks,
  Rq,
  rqDecrypt,
  unpackBytes,
} from "@hicaru/ntrup.js";
import { randomBytes } from "../crypto/random";

export const NTRU_CONFIG = params761;

function bytesEncrypt(
  rng: ChaChaRng,
  plaintext: Uint8Array,
  pubKey: PubKey,
  params: ParamsConfig,
): Uint8Array {
  const unlimitedPoly = r3DecodeChunks(plaintext);
  const getU32 = () => rng.nextU32();
  const { chunks, size, seed } = r3SplitWChunks(unlimitedPoly, getU32, params);
  const encryptedBytes: Uint8Array[] = [];

  for (const chunk of chunks) {
    const r3 = R3.from(chunk, params);
    const hr = r3Encrypt(r3, pubKey, params);
    const rqBytes = hr.toBytes(params);
    encryptedBytes.push(rqBytes);
  }

  const totalLength = encryptedBytes.reduce((sum, arr) => sum + arr.length, 0);
  const dataBytes = new Uint8Array(totalLength);

  let offset = 0;

  for (const arr of encryptedBytes) {
    dataBytes.set(arr, offset);
    offset += arr.length;
  }

  return packBytes(dataBytes, size, seed);
}

function bytesDecrypt(
  cipher: Uint8Array,
  privKey: PrivKey,
  params: ParamsConfig,
): Uint8Array {
  const { dataBytes, size, seed } = unpackBytes(cipher);
  const chunkCount = Math.floor(dataBytes.length / params.RQ_BYTES);

  if (dataBytes.length % params.RQ_BYTES !== 0) {
    throw ErrorType.InvalidRqChunkSize;
  }

  const decryptedChunks: Int8Array[] = [];

  for (let i = 0; i < chunkCount; i++) {
    const start = i * params.RQ_BYTES;
    const end = start + params.RQ_BYTES;
    const chunkBytes = dataBytes.subarray(start, end);
    if (chunkBytes.length !== params.RQ_BYTES) {
      throw ErrorType.InvalidRqChunkSize;
    }
    const coeffs = bytesRqDecode(chunkBytes, params);
    const rq = Rq.from(coeffs, params);
    const r3 = rqDecrypt(rq, privKey, params);
    decryptedChunks.push(r3.coeffs);
  }

  const outR3 = r3MergeWChunks(decryptedChunks, size, seed, params);

  return r3EncodeChunks(outR3);
}

export function ntruKeysFromSeed(seedBytes: Uint8Array): {
  pk: PubKey;
  sk: PrivKey;
} {
  const seedPq = seedBytes.slice(0, 32);
  const pqRng = ChaCha20Rng(seedPq);

  return generateKeyPair(pqRng, NTRU_CONFIG);
}

export function ntruEncrypt(pk: PubKey, plaintext: Uint8Array) {
  const seed = randomBytes(32);
  const rng = ChaCha20Rng(seed);
  return bytesEncrypt(rng, plaintext, pk, NTRU_CONFIG);
}

export function ntruDecrypt(sk: PrivKey, ciphertext: Uint8Array) {
  return bytesDecrypt(ciphertext, sk, NTRU_CONFIG);
}

```

`zil-pay/crypto/number.ts`:

```ts
/**
 * Converts a Uint8Array to a bigint, assuming big-endian byte order.
 * In big-endian, the most significant byte is placed at the beginning of the array.
 * This format is commonly used in network protocols and cryptography.
 *
 * @param array - The Uint8Array to convert to a bigint.
 * @returns The bigint representation of the input Uint8Array.
 * @throws TypeError if the input parameter is not an instance of Uint8Array.
 */
export function uint8ArrayToBigIntBigEndian(array: Uint8Array): bigint {
  if (!(array instanceof Uint8Array)) {
    array = Uint8Array.from(array);
  }

  let result: bigint = 0n;
  for (const byte of array) {
    result = (result << 8n) | BigInt(byte);
  }
  return result;
}

/**
 * Converts a Uint8Array to a bigint, assuming little-endian byte order.
 * In little-endian, the least significant byte is placed at the beginning of the array.
 * This format is sometimes used for representing numbers in computer memory.
 *
 * @param array - The Uint8Array to convert to a bigint.
 * @returns The bigint representation of the input Uint8Array.
 * @throws TypeError if the input parameter is not an instance of Uint8Array.
 */
export function uint8ArrayToBigIntLittleEndian(array: Uint8Array): bigint {
  if (!(array instanceof Uint8Array)) {
    array = Uint8Array.from(array);
  }

  let result: bigint = 0n;
  for (let i = array.length - 1; i >= 0; i--) {
    result = (result << 8n) | BigInt(array[i]);
  }
  return result;
}

/**
 * Converts a bigint to a big-endian Uint8Array of specified length.
 * @param value - The bigint to convert.
 * @param length - The desired length of the output array.
 * @returns The Uint8Array representation of the bigint.
 */
export function bigIntToUint8ArrayBigEndian(
  value: bigint,
  length: number,
): Uint8Array {
  const hex = value.toString(16).padStart(length * 2, "0");
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    bytes[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
  }
  return bytes;
}

```

`zil-pay/crypto/pbkdf2.ts`:

```ts
import { ShaAlgorithms } from "../config/pbkdf2";

export async function pbkdf2(
  password: Uint8Array,
  salt: Uint8Array,
  iterations: number,
  algorithms = ShaAlgorithms.Sha512,
) {
  const passphraseKey = await globalThis.crypto.subtle.importKey(
    "raw",
    password,
    { name: "PBKDF2" },
    false,
    ["deriveBits", "deriveKey"],
  );
  const webKey = await globalThis.crypto.subtle.deriveKey(
    {
      salt,
      iterations,
      name: "PBKDF2",
      hash: algorithms,
    },
    passphraseKey,
    {
      name: "HMAC",
      hash: algorithms,
      length: 512,
    },
    true,
    ["sign", "verify"],
  );
  const hash = await globalThis.crypto.subtle.exportKey("raw", webKey);

  return new Uint8Array(hash);
}

```

`zil-pay/crypto/proto/zq1.ts`:

```ts
export interface ByteArray {
  data: Uint8Array;
}

export function encodeByteArray(message: ByteArray): Uint8Array {
  let bb = popByteBuffer();
  _encodeByteArray(message, bb);
  return toUint8Array(bb);
}

function _encodeByteArray(message: ByteArray, bb: ByteBuffer): void {
  // required bytes data = 1;
  let $data = message.data;
  if ($data !== undefined) {
    writeVarint32(bb, 10);
    writeVarint32(bb, $data.length), writeBytes(bb, $data);
  }
}

export function decodeByteArray(binary: Uint8Array): ByteArray {
  return _decodeByteArray(wrapByteBuffer(binary));
}

function _decodeByteArray(bb: ByteBuffer): ByteArray {
  let message: ByteArray = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required bytes data = 1;
      case 1: {
        message.data = readBytes(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.data === undefined)
    throw new Error("Missing required field: data");

  return message;
}

export interface ProtoTransactionCoreInfo {
  version?: number;
  nonce?: Long;
  toaddr?: Uint8Array;
  senderpubkey?: ByteArray;
  amount?: ByteArray;
  gasprice?: ByteArray;
  gaslimit?: Long;
  code?: Uint8Array;
  data?: Uint8Array;
}

export function encodeProtoTransactionCoreInfo(message: ProtoTransactionCoreInfo): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransactionCoreInfo(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransactionCoreInfo(message: ProtoTransactionCoreInfo, bb: ByteBuffer): void {
  // optional uint32 version = 1;
  let $version = message.version;
  if ($version !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32(bb, $version);
  }

  // optional uint64 nonce = 2;
  let $nonce = message.nonce;
  if ($nonce !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $nonce);
  }

  // optional bytes toaddr = 3;
  let $toaddr = message.toaddr;
  if ($toaddr !== undefined) {
    writeVarint32(bb, 26);
    writeVarint32(bb, $toaddr.length), writeBytes(bb, $toaddr);
  }

  // optional ByteArray senderpubkey = 4;
  let $senderpubkey = message.senderpubkey;
  if ($senderpubkey !== undefined) {
    writeVarint32(bb, 34);
    let nested = popByteBuffer();
    _encodeByteArray($senderpubkey, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ByteArray amount = 5;
  let $amount = message.amount;
  if ($amount !== undefined) {
    writeVarint32(bb, 42);
    let nested = popByteBuffer();
    _encodeByteArray($amount, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ByteArray gasprice = 6;
  let $gasprice = message.gasprice;
  if ($gasprice !== undefined) {
    writeVarint32(bb, 50);
    let nested = popByteBuffer();
    _encodeByteArray($gasprice, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional uint64 gaslimit = 7;
  let $gaslimit = message.gaslimit;
  if ($gaslimit !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, $gaslimit);
  }

  // optional bytes code = 8;
  let $code = message.code;
  if ($code !== undefined) {
    writeVarint32(bb, 66);
    writeVarint32(bb, $code.length), writeBytes(bb, $code);
  }

  // optional bytes data = 9;
  let $data = message.data;
  if ($data !== undefined) {
    writeVarint32(bb, 74);
    writeVarint32(bb, $data.length), writeBytes(bb, $data);
  }
}

export function decodeProtoTransactionCoreInfo(binary: Uint8Array): ProtoTransactionCoreInfo {
  return _decodeProtoTransactionCoreInfo(wrapByteBuffer(binary));
}

function _decodeProtoTransactionCoreInfo(bb: ByteBuffer): ProtoTransactionCoreInfo {
  let message: ProtoTransactionCoreInfo = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional uint32 version = 1;
      case 1: {
        message.version = readVarint32(bb) >>> 0;
        break;
      }

      // optional uint64 nonce = 2;
      case 2: {
        message.nonce = readVarint64(bb, /* unsigned */ true);
        break;
      }

      // optional bytes toaddr = 3;
      case 3: {
        message.toaddr = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional ByteArray senderpubkey = 4;
      case 4: {
        let limit = pushTemporaryLength(bb);
        message.senderpubkey = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      // optional ByteArray amount = 5;
      case 5: {
        let limit = pushTemporaryLength(bb);
        message.amount = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      // optional ByteArray gasprice = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        message.gasprice = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      // optional uint64 gaslimit = 7;
      case 7: {
        message.gaslimit = readVarint64(bb, /* unsigned */ true);
        break;
      }

      // optional bytes code = 8;
      case 8: {
        message.code = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional bytes data = 9;
      case 9: {
        message.data = readBytes(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface ProtoTransaction {
  tranid?: Uint8Array;
  info?: ProtoTransactionCoreInfo;
  signature?: ByteArray;
}

export function encodeProtoTransaction(message: ProtoTransaction): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransaction(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransaction(message: ProtoTransaction, bb: ByteBuffer): void {
  // optional bytes tranid = 1;
  let $tranid = message.tranid;
  if ($tranid !== undefined) {
    writeVarint32(bb, 10);
    writeVarint32(bb, $tranid.length), writeBytes(bb, $tranid);
  }

  // optional ProtoTransactionCoreInfo info = 2;
  let $info = message.info;
  if ($info !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodeProtoTransactionCoreInfo($info, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ByteArray signature = 3;
  let $signature = message.signature;
  if ($signature !== undefined) {
    writeVarint32(bb, 26);
    let nested = popByteBuffer();
    _encodeByteArray($signature, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }
}

export function decodeProtoTransaction(binary: Uint8Array): ProtoTransaction {
  return _decodeProtoTransaction(wrapByteBuffer(binary));
}

function _decodeProtoTransaction(bb: ByteBuffer): ProtoTransaction {
  let message: ProtoTransaction = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional bytes tranid = 1;
      case 1: {
        message.tranid = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional ProtoTransactionCoreInfo info = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.info = _decodeProtoTransactionCoreInfo(bb);
        bb.limit = limit;
        break;
      }

      // optional ByteArray signature = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        message.signature = _decodeByteArray(bb);
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface ProtoTransactionReceipt {
  receipt?: Uint8Array;
  cumgas?: Long;
}

export function encodeProtoTransactionReceipt(message: ProtoTransactionReceipt): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransactionReceipt(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransactionReceipt(message: ProtoTransactionReceipt, bb: ByteBuffer): void {
  // optional bytes receipt = 1;
  let $receipt = message.receipt;
  if ($receipt !== undefined) {
    writeVarint32(bb, 10);
    writeVarint32(bb, $receipt.length), writeBytes(bb, $receipt);
  }

  // optional uint64 cumgas = 2;
  let $cumgas = message.cumgas;
  if ($cumgas !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $cumgas);
  }
}

export function decodeProtoTransactionReceipt(binary: Uint8Array): ProtoTransactionReceipt {
  return _decodeProtoTransactionReceipt(wrapByteBuffer(binary));
}

function _decodeProtoTransactionReceipt(bb: ByteBuffer): ProtoTransactionReceipt {
  let message: ProtoTransactionReceipt = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional bytes receipt = 1;
      case 1: {
        message.receipt = readBytes(bb, readVarint32(bb));
        break;
      }

      // optional uint64 cumgas = 2;
      case 2: {
        message.cumgas = readVarint64(bb, /* unsigned */ true);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface ProtoTransactionWithReceipt {
  transaction?: ProtoTransaction;
  receipt?: ProtoTransactionReceipt;
}

export function encodeProtoTransactionWithReceipt(message: ProtoTransactionWithReceipt): Uint8Array {
  let bb = popByteBuffer();
  _encodeProtoTransactionWithReceipt(message, bb);
  return toUint8Array(bb);
}

function _encodeProtoTransactionWithReceipt(message: ProtoTransactionWithReceipt, bb: ByteBuffer): void {
  // optional ProtoTransaction transaction = 1;
  let $transaction = message.transaction;
  if ($transaction !== undefined) {
    writeVarint32(bb, 10);
    let nested = popByteBuffer();
    _encodeProtoTransaction($transaction, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional ProtoTransactionReceipt receipt = 2;
  let $receipt = message.receipt;
  if ($receipt !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodeProtoTransactionReceipt($receipt, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }
}

export function decodeProtoTransactionWithReceipt(binary: Uint8Array): ProtoTransactionWithReceipt {
  return _decodeProtoTransactionWithReceipt(wrapByteBuffer(binary));
}

function _decodeProtoTransactionWithReceipt(bb: ByteBuffer): ProtoTransactionWithReceipt {
  let message: ProtoTransactionWithReceipt = {} as any;

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional ProtoTransaction transaction = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        message.transaction = _decodeProtoTransaction(bb);
        bb.limit = limit;
        break;
      }

      // optional ProtoTransactionReceipt receipt = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.receipt = _decodeProtoTransactionReceipt(bb);
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export interface Long {
  low: number;
  high: number;
  unsigned: boolean;
}

interface ByteBuffer {
  bytes: Uint8Array;
  offset: number;
  limit: number;
}

function pushTemporaryLength(bb: ByteBuffer): number {
  let length = readVarint32(bb);
  let limit = bb.limit;
  bb.limit = bb.offset + length;
  return limit;
}

function skipUnknownField(bb: ByteBuffer, type: number): void {
  switch (type) {
    case 0: while (readByte(bb) & 0x80) { } break;
    case 2: skip(bb, readVarint32(bb)); break;
    case 5: skip(bb, 4); break;
    case 1: skip(bb, 8); break;
    default: throw new Error("Unimplemented type: " + type);
  }
}

function stringToLong(value: string): Long {
  return {
    low: value.charCodeAt(0) | (value.charCodeAt(1) << 16),
    high: value.charCodeAt(2) | (value.charCodeAt(3) << 16),
    unsigned: false,
  };
}

function longToString(value: Long): string {
  let low = value.low;
  let high = value.high;
  return String.fromCharCode(
    low & 0xFFFF,
    low >>> 16,
    high & 0xFFFF,
    high >>> 16);
}

// The code below was modified from https://github.com/protobufjs/bytebuffer.js
// which is under the Apache License 2.0.

let f32 = new Float32Array(1);
let f32_u8 = new Uint8Array(f32.buffer);

let f64 = new Float64Array(1);
let f64_u8 = new Uint8Array(f64.buffer);

function intToLong(value: number): Long {
  value |= 0;
  return {
    low: value,
    high: value >> 31,
    unsigned: value >= 0,
  };
}

let bbStack: ByteBuffer[] = [];

function popByteBuffer(): ByteBuffer {
  const bb = bbStack.pop();
  if (!bb) return { bytes: new Uint8Array(64), offset: 0, limit: 0 };
  bb.offset = bb.limit = 0;
  return bb;
}

function pushByteBuffer(bb: ByteBuffer): void {
  bbStack.push(bb);
}

function wrapByteBuffer(bytes: Uint8Array): ByteBuffer {
  return { bytes, offset: 0, limit: bytes.length };
}

function toUint8Array(bb: ByteBuffer): Uint8Array {
  let bytes = bb.bytes;
  let limit = bb.limit;
  return bytes.length === limit ? bytes : bytes.subarray(0, limit);
}

function skip(bb: ByteBuffer, offset: number): void {
  if (bb.offset + offset > bb.limit) {
    throw new Error('Skip past limit');
  }
  bb.offset += offset;
}

function isAtEnd(bb: ByteBuffer): boolean {
  return bb.offset >= bb.limit;
}

function grow(bb: ByteBuffer, count: number): number {
  let bytes = bb.bytes;
  let offset = bb.offset;
  let limit = bb.limit;
  let finalOffset = offset + count;
  if (finalOffset > bytes.length) {
    let newBytes = new Uint8Array(finalOffset * 2);
    newBytes.set(bytes);
    bb.bytes = newBytes;
  }
  bb.offset = finalOffset;
  if (finalOffset > limit) {
    bb.limit = finalOffset;
  }
  return offset;
}

function advance(bb: ByteBuffer, count: number): number {
  let offset = bb.offset;
  if (offset + count > bb.limit) {
    throw new Error('Read past limit');
  }
  bb.offset += count;
  return offset;
}

function readBytes(bb: ByteBuffer, count: number): Uint8Array {
  let offset = advance(bb, count);
  return bb.bytes.subarray(offset, offset + count);
}

function writeBytes(bb: ByteBuffer, buffer: Uint8Array): void {
  let offset = grow(bb, buffer.length);
  bb.bytes.set(buffer, offset);
}

function readString(bb: ByteBuffer, count: number): string {
  // Sadly a hand-coded UTF8 decoder is much faster than subarray+TextDecoder in V8
  let offset = advance(bb, count);
  let fromCharCode = String.fromCharCode;
  let bytes = bb.bytes;
  let invalid = '\uFFFD';
  let text = '';

  for (let i = 0; i < count; i++) {
    let c1 = bytes[i + offset], c2: number, c3: number, c4: number, c: number;

    // 1 byte
    if ((c1 & 0x80) === 0) {
      text += fromCharCode(c1);
    }

    // 2 bytes
    else if ((c1 & 0xE0) === 0xC0) {
      if (i + 1 >= count) text += invalid;
      else {
        c2 = bytes[i + offset + 1];
        if ((c2 & 0xC0) !== 0x80) text += invalid;
        else {
          c = ((c1 & 0x1F) << 6) | (c2 & 0x3F);
          if (c < 0x80) text += invalid;
          else {
            text += fromCharCode(c);
            i++;
          }
        }
      }
    }

    // 3 bytes
    else if ((c1 & 0xF0) == 0xE0) {
      if (i + 2 >= count) text += invalid;
      else {
        c2 = bytes[i + offset + 1];
        c3 = bytes[i + offset + 2];
        if (((c2 | (c3 << 8)) & 0xC0C0) !== 0x8080) text += invalid;
        else {
          c = ((c1 & 0x0F) << 12) | ((c2 & 0x3F) << 6) | (c3 & 0x3F);
          if (c < 0x0800 || (c >= 0xD800 && c <= 0xDFFF)) text += invalid;
          else {
            text += fromCharCode(c);
            i += 2;
          }
        }
      }
    }

    // 4 bytes
    else if ((c1 & 0xF8) == 0xF0) {
      if (i + 3 >= count) text += invalid;
      else {
        c2 = bytes[i + offset + 1];
        c3 = bytes[i + offset + 2];
        c4 = bytes[i + offset + 3];
        if (((c2 | (c3 << 8) | (c4 << 16)) & 0xC0C0C0) !== 0x808080) text += invalid;
        else {
          c = ((c1 & 0x07) << 0x12) | ((c2 & 0x3F) << 0x0C) | ((c3 & 0x3F) << 0x06) | (c4 & 0x3F);
          if (c < 0x10000 || c > 0x10FFFF) text += invalid;
          else {
            c -= 0x10000;
            text += fromCharCode((c >> 10) + 0xD800, (c & 0x3FF) + 0xDC00);
            i += 3;
          }
        }
      }
    }

    else text += invalid;
  }

  return text;
}

function writeString(bb: ByteBuffer, text: string): void {
  // Sadly a hand-coded UTF8 encoder is much faster than TextEncoder+set in V8
  let n = text.length;
  let byteCount = 0;

  // Write the byte count first
  for (let i = 0; i < n; i++) {
    let c = text.charCodeAt(i);
    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {
      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;
    }
    byteCount += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }
  writeVarint32(bb, byteCount);

  let offset = grow(bb, byteCount);
  let bytes = bb.bytes;

  // Then write the bytes
  for (let i = 0; i < n; i++) {
    let c = text.charCodeAt(i);
    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {
      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;
    }
    if (c < 0x80) {
      bytes[offset++] = c;
    } else {
      if (c < 0x800) {
        bytes[offset++] = ((c >> 6) & 0x1F) | 0xC0;
      } else {
        if (c < 0x10000) {
          bytes[offset++] = ((c >> 12) & 0x0F) | 0xE0;
        } else {
          bytes[offset++] = ((c >> 18) & 0x07) | 0xF0;
          bytes[offset++] = ((c >> 12) & 0x3F) | 0x80;
        }
        bytes[offset++] = ((c >> 6) & 0x3F) | 0x80;
      }
      bytes[offset++] = (c & 0x3F) | 0x80;
    }
  }
}

function writeByteBuffer(bb: ByteBuffer, buffer: ByteBuffer): void {
  let offset = grow(bb, buffer.limit);
  let from = bb.bytes;
  let to = buffer.bytes;

  // This for loop is much faster than subarray+set on V8
  for (let i = 0, n = buffer.limit; i < n; i++) {
    from[i + offset] = to[i];
  }
}

function readByte(bb: ByteBuffer): number {
  return bb.bytes[advance(bb, 1)];
}

function writeByte(bb: ByteBuffer, value: number): void {
  let offset = grow(bb, 1);
  bb.bytes[offset] = value;
}

function readFloat(bb: ByteBuffer): number {
  let offset = advance(bb, 4);
  let bytes = bb.bytes;

  // Manual copying is much faster than subarray+set in V8
  f32_u8[0] = bytes[offset++];
  f32_u8[1] = bytes[offset++];
  f32_u8[2] = bytes[offset++];
  f32_u8[3] = bytes[offset++];
  return f32[0];
}

function writeFloat(bb: ByteBuffer, value: number): void {
  let offset = grow(bb, 4);
  let bytes = bb.bytes;
  f32[0] = value;

  // Manual copying is much faster than subarray+set in V8
  bytes[offset++] = f32_u8[0];
  bytes[offset++] = f32_u8[1];
  bytes[offset++] = f32_u8[2];
  bytes[offset++] = f32_u8[3];
}

function readDouble(bb: ByteBuffer): number {
  let offset = advance(bb, 8);
  let bytes = bb.bytes;

  // Manual copying is much faster than subarray+set in V8
  f64_u8[0] = bytes[offset++];
  f64_u8[1] = bytes[offset++];
  f64_u8[2] = bytes[offset++];
  f64_u8[3] = bytes[offset++];
  f64_u8[4] = bytes[offset++];
  f64_u8[5] = bytes[offset++];
  f64_u8[6] = bytes[offset++];
  f64_u8[7] = bytes[offset++];
  return f64[0];
}

function writeDouble(bb: ByteBuffer, value: number): void {
  let offset = grow(bb, 8);
  let bytes = bb.bytes;
  f64[0] = value;

  // Manual copying is much faster than subarray+set in V8
  bytes[offset++] = f64_u8[0];
  bytes[offset++] = f64_u8[1];
  bytes[offset++] = f64_u8[2];
  bytes[offset++] = f64_u8[3];
  bytes[offset++] = f64_u8[4];
  bytes[offset++] = f64_u8[5];
  bytes[offset++] = f64_u8[6];
  bytes[offset++] = f64_u8[7];
}

function readInt32(bb: ByteBuffer): number {
  let offset = advance(bb, 4);
  let bytes = bb.bytes;
  return (
    bytes[offset] |
    (bytes[offset + 1] << 8) |
    (bytes[offset + 2] << 16) |
    (bytes[offset + 3] << 24)
  );
}

function writeInt32(bb: ByteBuffer, value: number): void {
  let offset = grow(bb, 4);
  let bytes = bb.bytes;
  bytes[offset] = value;
  bytes[offset + 1] = value >> 8;
  bytes[offset + 2] = value >> 16;
  bytes[offset + 3] = value >> 24;
}

function readInt64(bb: ByteBuffer, unsigned: boolean): Long {
  return {
    low: readInt32(bb),
    high: readInt32(bb),
    unsigned,
  };
}

function writeInt64(bb: ByteBuffer, value: Long): void {
  writeInt32(bb, value.low);
  writeInt32(bb, value.high);
}

function readVarint32(bb: ByteBuffer): number {
  let c = 0;
  let value = 0;
  let b: number;
  do {
    b = readByte(bb);
    if (c < 32) value |= (b & 0x7F) << c;
    c += 7;
  } while (b & 0x80);
  return value;
}

function writeVarint32(bb: ByteBuffer, value: number): void {
  value >>>= 0;
  while (value >= 0x80) {
    writeByte(bb, (value & 0x7f) | 0x80);
    value >>>= 7;
  }
  writeByte(bb, value);
}

function readVarint64(bb: ByteBuffer, unsigned: boolean): Long {
  let part0 = 0;
  let part1 = 0;
  let part2 = 0;
  let b: number;

  b = readByte(bb); part0 = (b & 0x7F); if (b & 0x80) {
    b = readByte(bb); part0 |= (b & 0x7F) << 7; if (b & 0x80) {
      b = readByte(bb); part0 |= (b & 0x7F) << 14; if (b & 0x80) {
        b = readByte(bb); part0 |= (b & 0x7F) << 21; if (b & 0x80) {

          b = readByte(bb); part1 = (b & 0x7F); if (b & 0x80) {
            b = readByte(bb); part1 |= (b & 0x7F) << 7; if (b & 0x80) {
              b = readByte(bb); part1 |= (b & 0x7F) << 14; if (b & 0x80) {
                b = readByte(bb); part1 |= (b & 0x7F) << 21; if (b & 0x80) {

                  b = readByte(bb); part2 = (b & 0x7F); if (b & 0x80) {
                    b = readByte(bb); part2 |= (b & 0x7F) << 7;
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return {
    low: part0 | (part1 << 28),
    high: (part1 >>> 4) | (part2 << 24),
    unsigned,
  };
}

function writeVarint64(bb: ByteBuffer, value: Long): void {
  let part0 = value.low >>> 0;
  let part1 = ((value.low >>> 28) | (value.high << 4)) >>> 0;
  let part2 = value.high >>> 24;

  // ref: src/google/protobuf/io/coded_stream.cc
  let size =
    part2 === 0 ?
      part1 === 0 ?
        part0 < 1 << 14 ?
          part0 < 1 << 7 ? 1 : 2 :
          part0 < 1 << 21 ? 3 : 4 :
        part1 < 1 << 14 ?
          part1 < 1 << 7 ? 5 : 6 :
          part1 < 1 << 21 ? 7 : 8 :
      part2 < 1 << 7 ? 9 : 10;

  let offset = grow(bb, size);
  let bytes = bb.bytes;

  switch (size) {
    case 10: bytes[offset + 9] = (part2 >>> 7) & 0x01;
    case 9: bytes[offset + 8] = size !== 9 ? part2 | 0x80 : part2 & 0x7F;
    case 8: bytes[offset + 7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
    case 7: bytes[offset + 6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
    case 6: bytes[offset + 5] = size !== 6 ? (part1 >>> 7) | 0x80 : (part1 >>> 7) & 0x7F;
    case 5: bytes[offset + 4] = size !== 5 ? part1 | 0x80 : part1 & 0x7F;
    case 4: bytes[offset + 3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
    case 3: bytes[offset + 2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
    case 2: bytes[offset + 1] = size !== 2 ? (part0 >>> 7) | 0x80 : (part0 >>> 7) & 0x7F;
    case 1: bytes[offset] = size !== 1 ? part0 | 0x80 : part0 & 0x7F;
  }
}

function readVarint32ZigZag(bb: ByteBuffer): number {
  let value = readVarint32(bb);

  // ref: src/google/protobuf/wire_format_lite.h
  return (value >>> 1) ^ -(value & 1);
}

function writeVarint32ZigZag(bb: ByteBuffer, value: number): void {
  // ref: src/google/protobuf/wire_format_lite.h
  writeVarint32(bb, (value << 1) ^ (value >> 31));
}

function readVarint64ZigZag(bb: ByteBuffer): Long {
  let value = readVarint64(bb, /* unsigned */ false);
  let low = value.low;
  let high = value.high;
  let flip = -(low & 1);

  // ref: src/google/protobuf/wire_format_lite.h
  return {
    low: ((low >>> 1) | (high << 31)) ^ flip,
    high: (high >>> 1) ^ flip,
    unsigned: false,
  };
}

function writeVarint64ZigZag(bb: ByteBuffer, value: Long): void {
  let low = value.low;
  let high = value.high;
  let flip = high >> 31;

  // ref: src/google/protobuf/wire_format_lite.h
  writeVarint64(bb, {
    low: (low << 1) ^ flip,
    high: ((high << 1) | (low >>> 31)) ^ flip,
    unsigned: false,
  });
}

```

`zil-pay/crypto/pubkey.ts`:

```ts
import { utils } from "aes-js";

const SECRET_KEY_SIZE = 32;

export enum SecretKeyType {
  Secp256k1Sha256Zilliqa,
  Secp256k1Keccak256Ethereum,
}

export enum SecretKeyError {
  SecretKeySliceError = "Secret key slice error",
  InvalidHex = "Invalid hex string",
  InvalidLength = "Invalid key length",
  InvalidKeyType = "Invalid key type",
}

export class SecretKey {
  public type: SecretKeyType;
  public data: Uint8Array;

  constructor(type: SecretKeyType, data: Uint8Array) {
    this.type = type;
    this.data = data;

    if (data.length !== SECRET_KEY_SIZE) {
      throw new Error(SecretKeyError.InvalidLength);
    }
  }

  toBytes(): Uint8Array {
    const result = new Uint8Array(SECRET_KEY_SIZE + 1);
    result[0] = this.type === SecretKeyType.Secp256k1Sha256Zilliqa ? 0 : 1;
    result.set(this.data, 1);
    return result;
  }

  static fromBytes(bytes: Uint8Array): SecretKey {
    const keyType = bytes[0];
    const keyData = bytes.slice(1);

    if (keyData.length !== SECRET_KEY_SIZE) {
      throw new Error(SecretKeyError.SecretKeySliceError);
    }

    const keyDataArray = new Uint8Array(keyData);

    switch (keyType) {
      case 0:
        return new SecretKey(
          SecretKeyType.Secp256k1Sha256Zilliqa,
          keyDataArray,
        );
      case 1:
        return new SecretKey(
          SecretKeyType.Secp256k1Keccak256Ethereum,
          keyDataArray,
        );
      default:
        throw new Error(SecretKeyError.InvalidKeyType);
    }
  }

  toHexString(): string {
    return utils.hex.fromBytes(this.toBytes());
  }

  static fromString(s: string): SecretKey {
    try {
      const data = utils.hex.toBytes(s);

      if (!data || data.length === 0) {
        throw new Error(SecretKeyError.InvalidHex);
      }

      const prefix = data[0];
      const keyData = data.slice(1);

      if (keyData.length !== SECRET_KEY_SIZE) {
        throw new Error(SecretKeyError.InvalidLength);
      }

      const keyDataArray = new Uint8Array(keyData);

      let type: SecretKeyType;
      switch (prefix) {
        case 0:
          type = SecretKeyType.Secp256k1Sha256Zilliqa;
          break;
        case 1:
          type = SecretKeyType.Secp256k1Keccak256Ethereum;
          break;
        default:
          throw new Error(SecretKeyError.InvalidKeyType);
      }

      return new SecretKey(type, keyDataArray);
    } catch (error) {
      throw new Error(SecretKeyError.InvalidHex);
    }
  }
}

```

`zil-pay/crypto/random.ts`:

```ts
import { ChaCha20Rng } from "@hicaru/chacharand.js";

export function randomBytes(length: number): Uint8Array {
  const buffer = new Uint8Array(length);
  const randomSeed = new Uint8Array(32);

  window.crypto.getRandomValues(randomSeed);

  const rng = ChaCha20Rng(randomSeed);

  rng.fillBytes(buffer);

  return buffer;
}

```

`zil-pay/crypto/sha256.ts`:

```ts
import { ShaAlgorithms } from "config/pbkdf2";

export async function sha256(value: Uint8Array) {
  if (!(value instanceof Uint8Array)) {
    value = Uint8Array.from(value);
  }

  const crypto = globalThis.crypto;
  const hash = await crypto.subtle.digest(ShaAlgorithms.sha256, value);
  return new Uint8Array(hash);
}

```

`zil-pay/crypto/sha512.ts`:

```ts
import { ShaAlgorithms } from "../config/pbkdf2";

export async function sha512(value: Uint8Array): Promise<Uint8Array> {
  const crypto = globalThis.crypto;
  const hash = await crypto.subtle.digest(ShaAlgorithms.Sha512, value);

  return new Uint8Array(hash);
}

```

`zil-pay/crypto/uuid.ts`:

```ts
import { randomBytes } from "./random";

/**
 * Generates a version 4 UUID.
 * Uses the native `crypto.randomUUID` if available, otherwise falls back to a
 * custom implementation using the `randomBytes` function.
 * @returns A UUID string.
 */
export function uuid(): string {
  if (window.crypto.randomUUID) {
    return window.crypto.randomUUID();
  }

  const bytes = randomBytes(16);

  bytes[6] = (bytes[6] & 0x0f) | 0x40;
  bytes[8] = (bytes[8] & 0x3f) | 0x80;
  const hex = Array.from(bytes, (byte) =>
    byte.toString(16).padStart(2, "0"),
  ).join("");

  return `${hex.substring(0, 8)}-${hex.substring(8, 12)}-${hex.substring(12, 16)}-${hex.substring(16, 20)}-${hex.substring(20)}`;
}

```

`zil-pay/crypto/zilliqa/pubkey.ts`:

```ts
import { getPublicKey } from 'noble-secp256k1';

export function fromZILPrivateKey(privateKey: Uint8Array): Uint8Array {
  const publicKey = getPublicKey(Uint8Array.from(privateKey), true);
  return publicKey;
}


```

`zil-pay/crypto/zilliqa/schnorr.ts`:

```ts
import * as secp256k1 from 'noble-secp256k1';
import { randomBytes } from '../random';
import { sha256 } from '../sha256';
import { uint8ArrayToBigIntBigEndian } from '../number';
import { fromZILPrivateKey } from './pubkey';

const MAX_TRY_SIGN = 100_000_000;

export async function sign(message: Uint8Array, secretKey: Uint8Array): Promise<secp256k1.Signature> {
  let safeCounter = 0;

  while (safeCounter < MAX_TRY_SIGN) {
    // Generate random k (nonce) as a 32-byte array
    const kBytes = randomBytes(32);
    // Convert to scalar (bigint) modulo curve order n
    const k = uint8ArrayToBigIntBigEndian(kBytes) % secp256k1.CURVE.n;

    const signature = await signInner(k, message, secretKey);
    if (signature) {
      return signature;
    }

    safeCounter++;
  }

  throw new Error('InvalidSignTry: Exceeded maximum signing attempts');
}

export async function signInner(k: bigint, message: Uint8Array, secretKey: Uint8Array): Promise<secp256k1.Signature | null> {
  // Compute public key from secret key (compressed, 33 bytes)
  const publicKey = fromZILPrivateKey(secretKey);

  // Compute commitment Q = k * G (where G is the generator point)
  const QPoint = secp256k1.Point.BASE.multiply(k);
  const Q = QPoint.toRawBytes(true); // Compressed Q

  // Compute challenge r = H(Q || publicKey || message) mod n
  const hasherInput = new Uint8Array([...Q, ...publicKey, ...message]);
  const hash = await sha256(hasherInput);
  const r = uint8ArrayToBigIntBigEndian(hash) % secp256k1.CURVE.n;

  // If r = 0 mod n, signature is invalid, return null
  if (r === 0n) {
    return null;
  }

  // Compute s = k - r * secretKey mod n
  const secretKeyScalar = uint8ArrayToBigIntBigEndian(secretKey);
  const rTimesSecret = (r * secretKeyScalar) % secp256k1.CURVE.n;
  const s = (k - rTimesSecret + secp256k1.CURVE.n) % secp256k1.CURVE.n;

  // If s = 0 mod n, signature is invalid, return null
  if (s === 0n) {
    return null;
  }

  // Return signature (r, s)
  return new secp256k1.Signature(r, s);
}

export async function verify(
  message: Uint8Array,
  publicKey: Uint8Array,
  signature: secp256k1.Signature
): Promise<boolean> {
  const r = signature.r;
  const s = signature.s;

  // Compute Q = s * G + r * publicKey
  const sG = secp256k1.Point.BASE.multiply(s); // s * G
  const publicKeyPoint = secp256k1.Point.fromHex(Uint8Array.from(publicKey));
  const rPub = publicKeyPoint.multiply(r); // r * publicKey
  const QPoint = sG.add(rPub);
  const Q = QPoint.toRawBytes(true); // Compressed Q

  // If Q is the point at infinity, verification fails
  if (QPoint.equals(secp256k1.Point.ZERO)) {
    return false;
  }

  // Compute r' = H(Q || publicKey || message) mod n
  const hasherInput = new Uint8Array([...Q, ...publicKey, ...message]);
  const hash = await sha256(hasherInput);
  const rDash = uint8ArrayToBigIntBigEndian(hash) % secp256k1.CURVE.n;

  // Verification succeeds if r' == r
  return rDash === r;
}



```

`zil-pay/lib/array/chunk.ts`:

```ts
/**
 * Splits an array into chunks of a specified size.
 * @template T - The type of elements in the input array.
 * @param array - The input array to be chunked.
 * @param size - The size of each chunk (must be greater than 0).
 * @returns A new array containing the chunks.
 * @throws {Error} If the size is not a positive number.
 */
export function chunk<T>(array: T[], size: number): T[][] {
    if (size <= 0) {
        throw new Error("Size must be a positive number.");
    }

    const result: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
        result.push(array.slice(i, i + size));
    }
    return result;
}


```

`zil-pay/lib/array/shuffle.ts`:

```ts
/**
 * Shuffles the elements of an array in place using the Fisher-Yates algorithm.
 * @template T - The type of elements in the array.
 * @param array - The array to shuffle.
 */
export function shuffle<T>(array: T[]): T[] {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}


```

`zil-pay/lib/popup/clipboard.ts`:

```ts
/**
 * Asynchronously copies the provided text to the user's clipboard using the modern
 * `navigator.clipboard` API. If the modern API is not available, it attempts
 * to use the deprecated `document.execCommand('copy')` as a fallback.
 *
 * @param text The string to be copied to the clipboard.
 * @returns A Promise that resolves to `true` if the copy operation was successful,
 * or `false` if it failed (e.g., due to browser limitations or user denial of permissions).
 */
export async function clipboardCopy(text: string): Promise<boolean> {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (_) {
      return fallbackCopyToClipboard(text);
    }
  } else {
    // Fallback for browsers that do not support the modern Clipboard API.
    return fallbackCopyToClipboard(text);
  }
}

/**
 * Attempts to copy text to the clipboard using the deprecated `document.execCommand('copy')` method.
 * This method is less reliable and may require user interaction or specific browser permissions.
 *
 * @param text The string to be copied to the clipboard.
 * @returns `true` if the copy command was successful, `false` otherwise.
 */
function fallbackCopyToClipboard(text: string): boolean {
  try {
    const span = document.createElement('span');
    span.textContent = text;
    span.style.whiteSpace = 'pre';
    span.style.userSelect = 'all';
    document.body.appendChild(span);
    const selection = window.getSelection();
    const range = window.document.createRange();
    selection?.removeAllRanges();
    range.selectNode(span);
    selection?.addRange(range);
    const successful = window.document.execCommand('copy');
    selection?.removeAllRanges();
    document.body.removeChild(span);
    return successful;
  } catch (err) {
    console.error('Failed to copy text using document.execCommand:', err);
    return false;
  }
}

```

`zil-pay/lib/popup/printer.ts`:

```ts
interface PrintMnemonicOptions {
  phrase: string;
  translations: string[];
  title: string;
}

export const printMnemonic = (options: PrintMnemonicOptions) => {
  const { phrase, translations, title } = options;
  return `<!DOCTYPE html>
<html id="print-wallet">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f8f9fa; /* Light background for printing */
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
    }

    .print-container {
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      width: 80%; /* Occupies most of the width */
      max-width: 700px; /* Limits maximum width */
      padding: 30px;
      margin-bottom: 50px; /* Bottom margin */
    }

    .print-text {
      text-align: center;
    }

    p {
      margin-bottom: 1em;
      font-size: 1rem;
    }

    h3 {
      color: #555;
      letter-spacing: 0.03rem;
      margin-top: 1.5em;
      margin-bottom: 1em;
      font-size: 1.4rem;
      font-weight: 500;
    }

    .phrase {
      font-family: Menlo, Monaco, Consolas, 'Courier New', monospace !important;
      font-weight: bold !important;
      font-size: 1.2rem;
      background-color: #f0f8ff; /* Light background for the phrase */
      color: #1e3a8a; /* Accent color for the phrase */
      padding: 1rem;
      border: 1px solid #aed9fe;
      border-radius: 4px;
      margin: 2rem auto;
      max-width: 90%;
      word-break: break-word;
    }

    .footer {
      margin-top: 2em;
      font-size: 0.9rem;
      color: #777;
    }

    .footer a {
      color: #777;
      text-decoration: none;
    }

    @media print {
      body {
        background-color: #fff; /* White background when printing */
      }
      .print-container {
        border: 1px solid #000; /* Black border when printing */
        box-shadow: none; /* Removes shadow when printing */
      }
    }
  </style>
</head>
<body>
  <main class="print-container" id="print-container">
    <article class="print-text">
      <p>
        ${translations[0]}<br>
        ${translations[1]}<br>
        ${translations[2]}
      </p>
      <h3>${translations[3]}</h3>
      <div class="phrase">${phrase}</div>
      <p>
        ${translations[4]}
      </p>
      <p>
        ${translations[5]}
      </p>
      <p>
        ${translations[6]}
      </p>
      <aside class="footer">
        <a href="https://zilpay.io/" rel="noopener noreferrer" target="_blank">ZilPay Wallet</a>
      </aside>
    </article>
  </main>
</body>
</html>
`;
};

```

`zil-pay/lib/popup/warp-message.ts`:

```ts
export type Params = object[] | string[] | number[] | (string | string[] | number[])[];

export interface SendResponseParams {
  resolve?: unknown;
  reject?: unknown;
}
export type StreamResponse = (params: SendResponseParams) => void;

export interface ProxyContentType {
  params: Params;
  method: string;
  uuid: string;
}

export function warpMessage<T>(msg: SendResponseParams): T | undefined {
  if (!msg) {
    return;
  }

  if (msg.reject) {
    throw new Error(String(msg.reject));
  }

  return msg.resolve as T;
}

```

`zil-pay/lib/runtime/assert.ts`:

```ts
export function assert(expressions: boolean, msg: string) {
  if (!expressions) {
    throw new Error(msg);
  }
}

```

`zil-pay/lib/runtime/ext-id.ts`:

```ts
import { Runtime } from "./extensionizer";

export const EXTENSION_ID = Runtime.runtime.id;

```

`zil-pay/lib/runtime/extensionizer.ts`:

```ts
export const Runtime = globalThis.chrome;

```

`zil-pay/lib/runtime/get-url.ts`:

```ts
import { Runtime } from "./extensionizer";

export function getExtensionURL(content: string) {
  return Runtime.runtime.getURL(content);
}


```

`zil-pay/lib/runtime/index.ts`:

```ts
export * from './assert';
export * from './ext-id';
export * from './extensionizer';
export * from './manifest';
export * from './get-url';


```

`zil-pay/lib/runtime/manifest.ts`:

```ts
import { Runtime } from './extensionizer';

export function getManifestVersion() {
  return Runtime.runtime.getManifest().manifest_version;
}

```

`zil-pay/lib/storage/builder.ts`:

```ts
import type { OldFields } from 'config/fields';
import { TypeOf } from '../types/checker';

export type StorageKeyValue = {
    [key: string]: string;
};

/**
 * Builds a payload object for writing to browser storage.
 * Serializes objects and arrays to JSON strings.
 *
 * @example
 * import { buildObject, BrowserStorage } from 'lib/storage';
 *
 * const storage = Object.freeze(new BrowserStorage()); // Предполагается, что BrowserStorage - Singleton
 * storage.set(buildObject('key', 'any payload'));
 * storage.set(buildObject('objectKey', { a: 1, b: 2 }));
 * storage.set(buildObject('arrayKey', [1, 2, 3]));
 */
export function buildObject(key: OldFields | string, value: string | object | any[]): StorageKeyValue { // Added any[]
    let data: string;

    if (TypeOf.isObject(value) || TypeOf.isArray(value)) {
        try {
            data = JSON.stringify(value);
        } catch (error) {
            // Handle the error appropriately.  For example:
            console.error('Error serializing value to JSON:', error);
            // Consider throwing the error, returning a default value, or logging.
            return { [key]: '' }; // Return empty string,  or throw error.  IMPORTANT
        }
    } else {
        data = String(value);
    }

    return {
        [key]: data,
    };
}


```

`zil-pay/lib/storage/index.ts`:

```ts
export * from './builder';
export * from './storage';

```

`zil-pay/lib/storage/storage.ts`:

```ts
import type { StorageKeyValue } from './builder';
import type { OldFields } from 'config/fields';
import { Runtime } from 'lib/runtime/extensionizer';

type StorageChangesCallback = { [key: string]: chrome.storage.StorageChange; };

/**
 * Default class for working with browser Storage.
 * @example
 * import { BrowserStorage } from 'lib/storage'
 * BrowserStorage.get('KEY').then(data => { ... });
 */
export const BrowserStorage = Object.freeze({
    /**
     * Subscribes to storage changes.
     * @param callback - The callback function to be called when storage changes.
     * @returns An object with an unsubscribe method.
     */
    subscribe(callback: (changes: StorageChangesCallback) => void) {
        const listener = (changes: StorageChangesCallback) => {
            try {
                callback(changes);
            } catch (error) {
                console.error("Error in storage change callback:", error);
            }
        };

        Runtime.storage.onChanged.addListener(listener);

        return {
            unsubscribe() {
                Runtime.storage.onChanged.removeListener(listener);
            },
        };
    },

    /**
     * Sets multiple key-value pairs in storage.
     * @param items - An array of key-value objects to be stored.
     * @returns A promise that resolves when all items are set.
     */
    async set(...items: StorageKeyValue[]): Promise<void> {
        if (items.length === 0) return;

        const data: StorageKeyValue = {};
        for (const item of items) {
            Object.assign(data, item); // Merge all items into a single object.  Handles duplicate keys.
        }

        return new Promise((resolve, reject) => {
            Runtime.storage.local.set(data, () => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError); // Reject on error
                } else {
                    resolve();
                }
            });
        });
    },

    /**
     * Gets values from storage for the given keys.
     * @param keys - An array of keys to retrieve from storage.
     * @returns A promise that resolves with the retrieved data.  If one key is provided, the value is returned.  If multiple, an object is returned.
     */
    async get(...keys: (OldFields | string)[]): Promise<StorageKeyValue | any> { // Use 'any' for more flexibility
        return new Promise((resolve, reject) => {
            Runtime.storage.local.get(keys, (result) => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                  if (keys.length === 1) {
                    resolve(result[keys[0]]);
                  } else {
                    resolve(result);
                  }
                }
            });
        });
    },

    /**
     * Gets all items from storage.
     * @returns A promise that resolves with an object containing all stored items.
     */
    async getAll(): Promise<StorageKeyValue> {
        return new Promise((resolve, reject) => {
            Runtime.storage.local.get(null, (items) => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    resolve(items);
                }
            });
        });
    },

    /**
     * Removes items from storage for the given keys.
     * @param keys - An array of keys to remove from storage.
     * @returns A promise that resolves when the items are removed.
     */
    async rm(...keys: (OldFields | string)[]): Promise<void> {
        return new Promise((resolve, reject) => {
            Runtime.storage.local.remove(keys, () => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    resolve();
                }
            });
        });
    },

    /**
     * Clears all items from storage.
     * @returns A promise that resolves when the storage is cleared.
     */
    async clear(): Promise<void> {
        return new Promise((resolve, reject) => {
            Runtime.storage.local.clear(() => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    resolve();
                }
            });
        });
    },
});


```

`zil-pay/lib/streem/keys.ts`:

```ts
const app = 'zil-pay';

export const MTypeTabContent = {
  CONTENT: `@/${app}/content-script`,
  INJECTED: `@/${app}/injected-script`
};

export const MTypePopupWallet = {
  GET_RANDOM_SEED: `@/${app}/generate-random-seed`,
  CREATE_ACCOUNT_BY_SEED: `@/${app}/set-account-by-seed-words`,
  SET_PASSWORD: `@/${app}/popup-set-password`,
  LOG_OUT: `@/${app}/popup-logout`,
  SET_SEED_AND_PASSWORD: `@/${app}/popup-set-seed-words-and-password`,
  WALET_PASSWORD_CHANGE: `@/${app}/change-password`,
  GET_WALLET_STATE: `@/${app}/get-wallet-state`,
  EXPORT_SEED: `@/${app}/popup-export-seed-words`,
  EXPORT_PRIVATE_KEY: `@/${app}/popup-export-private-key`,
  EXPORT_QR_CODE_WALLET: `@/${app}/export-qr-code-wallet`,
  IMPORT_PRIVATE_KEY: `@/${app}/popup-import-private-key`,
  IMPORT_TRACK_ACCOUNT: `@/${app}/popup-import-track-account`,
  IMPORT_KEYSTORE: `@/${app}/popup-import-keystore`,
  ENCRYPT_WALLET: `@/${app}/encrypt-wallet-aes`,
  RES_ENCRYPTION: `@/${app}/response-encryption`,
  RES_DECRYPTION: `@/${app}/response-decryption`,
};

export const MTypePopupAccount = {
  RM_ACCOUNT: `@/${app}/remove-selected-account`,
  SELECT_ACCOUNT: `@/${app}/select-account`,
  SET_ACCOUNT_NAME: `@/${app}/set-account-name`,
  UPDATE_BALANCE: `@/${app}/popup-account-balance-upadte`,
};

export const MTypePopupTransaction = {
  UPDATE_TXNS: `@/${app}/check-processed-txns`,
  REJECT_CONFIRM_TX: `@/${app}/popup-reject-confirm-tx`,
  REJECT_ALL_CONFIRM_TXNS: `@/${app}/popup-reject-al-confirm-txns`,
  SEND_TO_SIGN_TX: `@/${app}/popup-send-to-sign-tx`,
  GET_REQUIRED_PARAMS: `@/${app}/get-required-params`,
  CLEAR_ALL_TXNS: `@/${app}/clear-all-txns`,
  GET_CURRENT_NONCE: `@/${app}/get-current-nonce`,
  RESET_NONCE: `@/${app}/reset-nonce`,
};

export const MTypePopupToken = {
  GET_ZRC2_STATE: `@/${app}/get-zrc2-token-info`,
  ADD_ZRC2_TOKEN: `@/${app}/add-new-zrc2-token`,
  RM_TOKEN: `@/${app}/remove-token`,
  GET_ZRC2_ALLOWANCES_FOR_SWAP: `@/${app}/get-zrc2-allowances-for-swap`,
};

export const MTypePopupNFT = {
  UPDATE_NFT_LIST: `@/${app}/update-nft-list`,
  GET_NFT_LIST: `@/${app}/get-nft-list`,
  FETCH_NFT: `@/${app}/fetch-nft`,
  ADD_NFT: `@/${app}/add-nft`,
  REMOVE_NFT: `@/${app}/remove-nft`,
};

export const MTypePopupNetwork = {
  SELECT_SSN: `@/${app}/select-from-ssn-list`,
  RESET_NETWROK: `@/${app}/reset-netwrok-settings`,
  SET_NET_CONFIG: `@/${app}/set-netwrok-config`,
  SELECT_NETWORK: `@/${app}/select-network`,
  UPDATE_SSN_LIST: `@/${app}/update-ssn-list`,
  GET_LATEST_BLOCK: `@/${app}/get-latest-block-number`,
};

export const MTypePopupDApp = {
  USER_RESPONSE_DAPP: `@/${app}/user-response-connect-dapp`,
  RM_APP: `@/${app}/remove-dapp`,
  CLEAR_APPS: `@/${app}/clear-all-apps`,
  SET_PHISHING_DETECTION: `@/${app}/set-phishing-detection`,
};

export const MTypePopupContact = {
  ADD_CONTACT: `@/${app}/add-a-contact`,
  RM_CONTACT: `@/${app}/remove-a-contact`,
};

export const MTypePopupSettings = {
  CHANGE_CURRENCY: `@/${app}/change-currency`,
  UPDATE_RATE: `@/${app}/update-rate`,
  RESET_CURRENCY: `@/${app}/reset-currency`,
  SET_THEME: `@/${app}/set-theme-mode`,
  RESET_THEME: `@/${app}/reset-theme`,
  SET_LOCALE: `@/${app}/set-locale`,
  RESET_LOCALE: `@/${app}/reset-locale`,
  SET_GAS_MULTIPLIER: `@/${app}/set-gas-multiplier`,
  RESET_GAS: `@/${app}/reset-gas`,
  SET_LOCK_TIME: `@/${app}/set-lock-timer`,
  SET_ADDRESS_FORMAT: `@/${app}/set-address-format`,
  SET_PROMT_ENABLED: `@/${app}/set-promt-enabled`,
};

export const MTypePopupSign = {
  REJECT_SIGN_MESSAGE: `@/${app}/reject-sign-message`,
  SIGN_MESSAGE_APPROVE: `@/${app}/approve-sign-message`,
};

export const MTypePopupUtil = {
  FROM_BECH32: `@/${app}/convert-from-bech32`,
};

export const MTypePopupDex = {
  UPDATE_DEX_DATA: `@/${app}/update-dex-data`,
  UPDATE_DEX_SETTINGS: `@/${app}/update-dex-settings`,
};

export const MTypePopupStake = {
  GET_STAKE_PROPS: `@/${app}/get-stake-props`,
};

export const MTypePopupLedger = {
  ADD_LEDGER_ACCOUNT: `@/${app}/add-ledger-account`,
};

export const MTypeTab = {
  GET_WALLET_DATA: `@/${app}/injected-get-wallet-data`,
  ADDRESS_CHANGED: `@/${app}/address-changed`,
  NETWORK_CHANGED: `@/${app}/network-changed`,
  LOCK_STAUS: `@/${app}/lack-status-updated`,
  CONTENT_PROXY_MEHTOD: `@/${app}/request-through-content`,
  CONTENT_PROXY_RESULT: `@/${app}/response-from-content`,
  CALL_TO_SIGN_TX: `@/${app}/request-to-sign-tx`,
  TX_RESULT: `@/${app}/response-tx-result`,
  SIGN_MESSAGE: `@/${app}/request-to-sign-message`,
  SING_MESSAGE_RES: `@/${app}/response-sign-message`,
  NEW_BLOCK: `@/${app}/new-block-created`,
  ADD_ENCRYPTION: `@/${app}/request-add-encryption`,
  RES_ENCRYPTION: `@/${app}/response-encryption`,
  ADD_DECRYPTION: `@/${app}/add-decryption`,
  RES_DECRYPTION: `@/${app}/response-decryption`,
  CONNECT_APP: `@/${app}/request-to-connect-dapp`,
  RESPONSE_TO_DAPP: `@/${app}/response-dapp-connect`,
  DISCONNECT_APP: `@/${app}/request-to-disconnect-dapp`
};


```

`zil-pay/lib/streem/message.ts`:

```ts
import { Runtime } from "lib/runtime/extensionizer";


export interface ReqBody<T = unknown> {
    type: string;
    payload?: T;
    domain?: string;
    from?: string;
}

export class Message<T = unknown> {
    constructor(public readonly body: ReqBody<T>) {}

    static signal(type: string): Message<object> {
        return new Message({ type });
    }

    async send(): Promise<T> {
        for (let i = 0; i < 10; i++) {
            try {
                const res = await this.#trySend();
                if (res) return res;
            } catch {}
        }
        throw new Error("service_worker_stopped");
    }

    #trySend(): Promise<T> {
        return new Promise((resolve) => {
          try {
            let data = JSON.parse(JSON.stringify(this.body));
            Runtime.runtime.sendMessage(data, resolve);
          } catch (err) {
            console.error(this, err);
            window.location.reload();
          }
        });
    }
}

```

`zil-pay/lib/streem/secure-message.ts`:

```ts
import type { ReqBody } from './message';
import type { TabStream } from './tab-stream';

export class SecureContentMessage<T = unknown> {
    constructor(public readonly body: ReqBody<T>) {}

    get type() { return this.body.type; }
    get payload() { return this.body.payload; }

    send(stream: TabStream, recipient: string) {
        stream.send(this.body, recipient);
    }
}

```

`zil-pay/lib/streem/tab-stream.ts`:

```ts
import type { ReqBody } from './message';
import { Runtime } from "lib/runtime";
import { MTypeTabContent } from './keys';

export class TabStream {
    constructor(public readonly eventName: string) {}

    listen(cb: (payload: ReqBody) => void) {
        globalThis.document?.addEventListener(this.eventName, (event: Event) => {
            const detail = (event as CustomEvent).detail;
            if (detail) {
                try {
                    cb(JSON.parse(detail));
                } catch (e) {
                    console.error("Error parsing event detail", e, event);
                }
            }
        });
    }

    send(data: ReqBody, to: string) {
        data.from = this.eventName;
        if (Object.values(MTypeTabContent).includes(to)) {
            this.#dispatch(JSON.stringify(data), to);
        }
    }

    #dispatch(data: string, to: string) {
        globalThis.document?.dispatchEvent(this.#getEvent(data, to));
    }

    #getEvent(detail: string, to: string) {
        return new CustomEvent(to, { detail });
    }

    /**
     * Sends a signal message to the specified tab.
     * @param tabId - The ID of the tab.
     * @param message - The message to send.
     */
    async sendSignalToTab(tabId: number, message: ReqBody): Promise<void> {
        try {
            await Runtime.tabs.sendMessage(tabId, message);
        } catch (error) {
            console.error(`Failed to send signal to tab ${tabId}:`, error);
            throw error; // Re-throw the error to be handled by the caller
        }
    }

    /**
      * Sends message to all tabs except the excluded tabIds
      * @param message
      * @param excludedTabIds
      */
    async sendToAllTabs(message: ReqBody, excludedTabIds: number[] = []): Promise<void> {
        try {
            const tabs = await Runtime.tabs.query({});
            for (const tab of tabs) {
                if (tab?.id && !excludedTabIds.includes(tab.id)) {
                    await Runtime.tabs.sendMessage(tab.id, message);
                }
            }
        } catch (error) {
            console.error("Failed to send message to all tabs:", error);
            throw error; // Re-throw the error
        }
    }
}

```

`zil-pay/lib/streem/tabs-message.ts`:

```ts
import type { ReqBody } from './message';
import { Runtime } from "lib/runtime";


export class TabsMessage<T = any> {
    constructor(public readonly body: ReqBody<T>) {}

    static async getTabs(): Promise<chrome.tabs.Tab[]> {
        return Runtime.tabs.query({});
    }

    async signal(domain: string): Promise<string> {
        return new Promise<string>((resolve, reject) => {
            Runtime.tabs.query({ active: true, currentWindow: true }, (tabs: chrome.tabs.Tab[]) => {
                const tab = tabs[0];
                if (!tab) {
                    reject(new Error("no active tabs"));
                    return;
                }

                const { hostname } = new URL(tab.url!);

                if (hostname !== domain) {
                    reject(new Error("invalid domain"));
                    return;
                }
                Runtime.tabs.sendMessage(Number(tab.id), this.body)
                    .then(() => resolve(""))
                    .catch(reject);
            });
        });
    }



    async send(...domains: string[]): Promise<void> {
        const tabs = await TabsMessage.getTabs();

        tabs.forEach(async (tab) => {
            if (tab?.url && domains.includes(new URL(tab.url).hostname)) {
                try {
                    await Runtime.tabs.sendMessage(Number(tab.id), this.body);
                } catch (err) {
                    console.error(`Failed to send message to tab ${tab.id}`, err);
                }
            }
        });
    }

    async sendAll(): Promise<void> {
        const tabs = (await TabsMessage.getTabs())
            .filter((tab) => tab?.url && !tab.url.startsWith("chrome://"));

        try {
            for (const tab of tabs) {
                await Runtime.tabs.sendMessage(Number(tab.id), this.body);
            }
        } catch (err) {
            console.error("TabsMessage", err);
        }
    }
}

```

`zil-pay/lib/types/checker.ts`:

```ts
type Arg = unknown;

export const TypeOf = Object.freeze({
    /**
     * Checks if the given argument is an array.
     * @param arg The argument to check.
     * @returns True if the argument is an array, false otherwise.
     */
    isArray(arg: Arg): boolean {
        return Array.isArray(arg);
    },

    /**
     * Checks if the given argument is a plain object.
     * @param arg The argument to check.
     * @returns True if the argument is a plain object, false otherwise.
     */
    isObject(arg: Arg): boolean {
        return typeof arg === 'object' && arg !== null && !Array.isArray(arg) && !(arg instanceof Date) && !(arg instanceof Error) && Object.getPrototypeOf(arg) === Object.prototype;
    },

    /**
     * Checks if the given argument is a number.
     * @param arg The argument to check.
     * @returns True if the argument is a number, false otherwise.
     */
    isNumber(arg: Arg): boolean {
        return typeof arg === 'number' && !isNaN(arg as number);
    },

    /**
     * Checks if the given argument is an integer.
     * @param arg The argument to check.
     * @returns True if the argument is an integer, false otherwise.
     */
    isInt(arg: Arg): boolean {
        return Number.isInteger(arg as number);
    },

    /**
     * Checks if the given argument is an error object.
     * @param arg The argument to check.
     * @returns True if the argument is an error object, false otherwise.
     */
    isError(arg: Arg): boolean {
        return arg instanceof Error;
    },

    /**
     * Checks if the given argument is a string.
     * @param arg The argument to check.
     * @returns True if the argument is a string, false otherwise.
     */
    isString(arg: Arg): boolean {
        return typeof arg === 'string' || arg instanceof String;
    },

    /**
     * Checks if the given argument is a boolean.
     * @param arg The argument to check.
     * @returns True if the argument is a boolean, false otherwise.
     */
    isBoolean(arg: Arg): boolean {
        return typeof arg === 'boolean' || arg instanceof Boolean;
    },

    /**
     * Checks if the given argument is null.
     * @param arg The argument to check.
     * @returns True if the argument is null, false otherwise.
     */
    isNull(arg: Arg): boolean {
        return arg === null;
    },

    /**
     * Checks if the given argument is undefined.
     * @param arg The argument to check.
     * @returns True if the argument is undefined, false otherwise.
     */
    isUndefined(arg: Arg): boolean {
        return arg === undefined;
    },

    /**
     * Checks if the given argument is an empty object.
     * @param arg The argument to check.
     * @returns True if the argument is an empty object, false otherwise.
     */
    isEmptyObject(arg: Arg): boolean {
        return this.isObject(arg) && Object.keys(arg as object).length === 0;
    },

    /**
     * Checks if the given argument is an empty array.
     * @param arg The argument to check.
     * @returns True if the argument is an empty array, false otherwise.
     */
    isEmptyArray(arg: Arg): boolean {
        return this.isArray(arg) && (arg as Array<unknown>).length === 0;
    },
});


```

`zil-pay/lib/types/index.ts`:

```ts
export * from './checker';


```

`zil-pay/lib/zilliqa/bech32.ts`:

```ts
import { assert } from 'lib/runtime/assert';
import { CHARSET, HRP, GENERATOR } from 'lib/zilliqa/config';
import { toChecksumHexAddress } from 'lib/zilliqa/checksum';
import { utils } from 'aes-js';


/**
 * Calculates the polynomial modulo for Bech32 checksum calculation.
 *
 * @param values The Uint8Array of input values.
 * @returns The polynomial modulo result.
 */
const polymod = (values: Uint8Array): number => {
    let chk: number = 1;
    for (let p: number = 0; p < values.length; ++p) {
        const top: number = chk >> 25;
        chk = ((chk & 0x1ffffff) << 5) ^ values[p];
        for (let i: number = 0; i < 5; ++i) {
            if ((top >> i) & 1) {
                chk ^= GENERATOR[i];
            }
        }
    }
    return chk;
};

/**
 * Expands the Human-Readable Part (HRP) into a Uint8Array for checksum calculation.
 *
 * @param hrp The Human-Readable Part string.
 * @returns The Uint8Array representation of the expanded HRP.
 */
const hrpExpand = (hrp: string): Uint8Array => {
    const ret: number[] = [];
    for (let i: number = 0; i < hrp.length; ++i) {
        ret.push(hrp.charCodeAt(i) >> 5);
    }
    ret.push(0);
    for (let i: number = 0; i < hrp.length; ++i) {
        ret.push(hrp.charCodeAt(i) & 31);
    }
    return new Uint8Array(ret);
};

/**
 * Converts an array of numbers of `fromWidth` bits to an array of numbers of `toWidth` bits.
 *
 * @param data The input array of numbers.
 * @param fromWidth The number of bits per input number.
 * @param toWidth The number of bits per output number.
 * @param pad Whether to pad the output if the input is not a multiple of `fromWidth`.
 * @returns A new Uint8Array containing the converted bits, or null if input is invalid.
 */
export function convertBits(data: Uint8Array, fromWidth: number, toWidth: number, pad: boolean = true): Uint8Array | null {
    let acc: number = 0;
    let bits: number = 0;
    const ret: number[] = [];
    const maxv: number = (1 << toWidth) - 1;

    for (const value of data) {
        if (value < 0 || (value >> fromWidth) !== 0) {
            return null;
        }
        acc = (acc << fromWidth) | value;
        bits += fromWidth;
        while (bits >= toWidth) {
            bits -= toWidth;
            ret.push((acc >> bits) & maxv);
        }
    }

    if (pad) {
        if (bits > 0) {
            ret.push((acc << (toWidth - bits)) & maxv);
        }
    } else if (bits >= fromWidth || (acc << (toWidth - bits)) & maxv) {
        return null;
    }

    return new Uint8Array(ret);
}

/**
 * Verifies the checksum of a Bech32 encoded string.
 *
 * @param hrp The Human-Readable Part of the Bech32 string.
 * @param data The Uint8Array of the data part of the Bech32 string.
 * @returns True if the checksum is valid, false otherwise.
 */
function verifyChecksum(hrp: string, data: Uint8Array): boolean {
    return polymod(new Uint8Array([...hrpExpand(hrp), ...data])) === 1;
}

/**
 * Creates the checksum for a given HRP and data.
 *
 * @param hrp The Human-Readable Part string.
 * @param data The Uint8Array of the data to be checksummed.
 * @returns A Uint8Array representing the checksum.
 */
function createChecksum(hrp: string, data: Uint8Array): Uint8Array {
    const values: Uint8Array = new Uint8Array([...hrpExpand(hrp), ...data, 0, 0, 0, 0, 0, 0]);
    const mod: number = polymod(values) ^ 1;
    const ret: number[] = [];
    for (let p: number = 0; p < 6; ++p) {
        ret.push((mod >> (5 * (5 - p))) & 31);
    }
    return new Uint8Array(ret);
}

/**
 * Encodes data with a Human-Readable Part (HRP) into a Bech32 string.
 *
 * @param hrp The Human-Readable Part string.
 * @param data The Uint8Array of data to encode.
 * @returns The Bech32 encoded string.
 */
export const encode = (hrp: string, data: Uint8Array): string => {
    const checksum: Uint8Array = createChecksum(hrp, data);
    const combined: Uint8Array = new Uint8Array([...data, ...checksum]);
    let ret: string = hrp + '1';
    for (const value of combined) {
        ret += CHARSET.charAt(value);
    }
    return ret;
};

/**
 * Decodes a Bech32 encoded string into its Human-Readable Part (HRP) and data.
 *
 * @param bechString The Bech32 encoded string to decode.
 * @returns An object containing the HRP and the Uint8Array of data, or null if decoding fails.
 */
export const decode = (bechString: string): { hrp: string; data: Uint8Array } | null => {
    let hasLower: boolean = false;
    let hasUpper: boolean = false;
    for (let i: number = 0; i < bechString.length; ++i) {
        const charCode: number = bechString.charCodeAt(i);
        if (charCode < 33 || charCode > 126) {
            return null;
        }
        if (charCode >= 97 && charCode <= 122) {
            hasLower = true;
        }
        if (charCode >= 65 && charCode <= 90) {
            hasUpper = true;
        }
    }

    if (hasLower && hasUpper) {
        return null;
    }

    const lowerBechString: string = bechString.toLowerCase();
    const pos: number = lowerBechString.lastIndexOf('1');

    if (pos < 1 || pos + 7 > lowerBechString.length || lowerBechString.length > 90) {
        return null;
    }

    const hrp: string = lowerBechString.substring(0, pos);
    const data: number[] = [];
    for (let i: number = pos + 1; i < lowerBechString.length; ++i) {
        const d: number = CHARSET.indexOf(lowerBechString.charAt(i));
        if (d === -1) {
            return null;
        }
        data.push(d);
    }

    const dataBytes: Uint8Array = new Uint8Array(data);
    if (!verifyChecksum(hrp, dataBytes)) {
        return null;
    }

    return { hrp, data: dataBytes.slice(0, dataBytes.length - 6) };
};

/**
 * Checks if a string starts with the '0x' prefix (case-insensitive).
 *
 * @param str The string to check.
 * @returns True if the string starts with '0x', false otherwise.
 */
function hasHexPrefix(str: string): boolean {
    return str.toLowerCase().startsWith('0x');
}

/**
 * Validates if a string is a valid hexadecimal Zilliqa address.
 *
 * @param address The string to validate.
 * @returns True if the string is a valid hexadecimal address, false otherwise.
 */
function isValidHexAddress(address: string): boolean {
    return !address || typeof address !== 'string' || (!hasHexPrefix(address) ? address.length !== 40 : address.length !== 42) || !/^[0-9a-fA-F]+$/.test(hasHexPrefix(address) ? address.slice(2) : address);
}

/**
 * Converts a hexadecimal address to a Bech32 encoded Zilliqa address.
 *
 * @param address The hexadecimal address string (with or without '0x' prefix).
 * @returns The Bech32 encoded Zilliqa address.
 * @throws {Error} If the provided address is invalid or conversion fails.
 */
export const toBech32Address = async (address: string): Promise<string> => {
    assert(!isValidHexAddress(address), 'Invalid address provided.');

    const hexString: string = hasHexPrefix(address) ? address.slice(2) : address;
    const addressBytes: Uint8Array | null = utils.hex.toBytes(hexString);
    assert(addressBytes !== null, 'Cannot convert hex string to bytes.');

    const addrBz: Uint8Array | null = convertBits(addressBytes, 8, 5);
    assert(addrBz !== null, 'Cannot convert bytes to Bech32 bits.');

    return encode(HRP, addrBz!);
};

/**
 * Converts a Bech32 encoded Zilliqa address to a checksummed hexadecimal address.
 *
 * @param address The Bech32 encoded Zilliqa address.
 * @returns The checksummed hexadecimal address string with the '0x' prefix.
 * @throws {Error} If the provided Bech32 address is invalid or conversion fails.
 */
export const fromBech32Address = async (address: string): Promise<string> => {
    const res = decode(address);
    assert(res !== null, 'Invalid Bech32 address.');

    // Explicitly assert the type of 'res' after the null check
    const { hrp, data } = res as { hrp: string; data: Uint8Array };
    assert(hrp === HRP, `Expected HRP '${HRP}', but got '${hrp}'.`);

    const buf: Uint8Array | null = convertBits(data, 5, 8, false);
    assert(buf !== null, 'Cannot convert Bech32 bits to bytes.');

    const hexAddress: string = Array.from(buf!)
        .map((b: number) => b.toString(16).padStart(2, '0'))
        .join('');

    return toChecksumHexAddress(`0x${hexAddress}`);
};

```

`zil-pay/lib/zilliqa/checksum.ts`:

```ts
import { sha256 } from 'crypto/sha256';
import { utils } from 'aes-js';

/**
 * Checks if a string starts with the '0x' prefix (case-insensitive).
 *
 * @param str The string to check.
 * @returns True if the string starts with '0x', false otherwise.
 */
export function hasHexPrefix(str: string): boolean {
  return str.toLowerCase().startsWith('0x');
}

/**
 * Calculates the checksummed hexadecimal address from a byte array.
 *
 * @param addressBytes The address as a Uint8Array.
 * @returns The checksummed hexadecimal address string with the '0x' prefix.
 */
export async function toChecksumBytesAddress(addressBytes: Uint8Array): Promise<string> {
  const addressHex = utils.hex.fromBytes(addressBytes);
  const hashBytes = await sha256(addressBytes);
  const hashBigInt = BigInt(`0x${utils.hex.fromBytes(hashBytes)}`);
  let checksumAddress = '0x';

  for (let i = 0; i < addressHex.length; i++) {
    const char = addressHex[i];
    if (/[0-9]/.test(char)) {
      checksumAddress += char;
    } else {
      const bitPosition = BigInt(255 - 6 * i);
      const mask = BigInt(2) ** bitPosition;
      const shouldBeUpper = (hashBigInt & mask) >= BigInt(1);

      if (shouldBeUpper) {
        checksumAddress += char.toUpperCase();
      } else {
        checksumAddress += char.toLowerCase();
      }
    }
  }

  return checksumAddress;
}

/**
 * Calculates the checksummed hexadecimal address from a hexadecimal string.
 *
 * @param address The hexadecimal address string, optionally with the '0x' prefix.
 * @returns The checksummed hexadecimal address string with the '0x' prefix.
 */
export async function toChecksumHexAddress(address: string): Promise<string> {
  let lowerCaseAddress = address.toLowerCase();
  if (hasHexPrefix(address)) {
    lowerCaseAddress = lowerCaseAddress.slice(2);
  }

  const addressBytes = new Uint8Array(utils.hex.toBytes(lowerCaseAddress));
  return toChecksumBytesAddress(addressBytes);
}

```

`zil-pay/lib/zilliqa/config.ts`:

```ts
export const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
export const HRP = 'zil';
export const GENERATOR = [
  0x3b6a57b2,
  0x26508e6d,
  0x1ea119fa,
  0x3d4233dd,
  0x2a1462b3
];

```

`zil-pay/lib/zilliqa/pubkey.ts`:

```ts
import { sha256 } from 'crypto/sha256';

export async function fromZilPubKey(pubKey: Uint8Array): Promise<Uint8Array> {
  const hashBytes = await sha256(pubKey);
  const addressBytes = hashBytes.slice(12);

  if (addressBytes.length !== 20) {
    throw new Error('Invalid public key length or unexpected hash output length.');
  }

  return addressBytes;
}

```

`zil-pay/popup/main.ts`:

```ts
import { mount } from "svelte";
import App from "./App.svelte";

export default mount(App, {
  target: document.body,
});

```

`zil-pay/vitest.config.ts`:

```ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    setupFiles: '__tests__/setupTests.ts',
    include: ['__tests__/**/*.test.{ts,tsx}'],
  },
});

```