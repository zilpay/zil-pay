Project Path: streem

Source Tree:

```txt
streem
├── TabsMessage.ts
├── keys.ts
├── message.ts
├── secure-message.ts
├── tab-stream.ts
└── tabs-message.ts

```

`streem/keys.ts`:

```ts
const app = 'zil-pay';

export const MTypeTabContent = {
  CONTENT: `@/${app}/content-script`,
  INJECTED: `@/${app}/injected-script`
};

export const MTypePopupWallet = {
  GET_RANDOM_SEED: `@/${app}/generate-random-seed`,
  CREATE_ACCOUNT_BY_SEED: `@/${app}/set-account-by-seed-words`,
  SET_PASSWORD: `@/${app}/popup-set-password`,
  LOG_OUT: `@/${app}/popup-logout`,
  SET_SEED_AND_PASSWORD: `@/${app}/popup-set-seed-words-and-password`,
  WALET_PASSWORD_CHANGE: `@/${app}/change-password`,
  GET_WALLET_STATE: `@/${app}/get-wallet-state`,
  EXPORT_SEED: `@/${app}/popup-export-seed-words`,
  EXPORT_PRIVATE_KEY: `@/${app}/popup-export-private-key`,
  EXPORT_QR_CODE_WALLET: `@/${app}/export-qr-code-wallet`,
  IMPORT_PRIVATE_KEY: `@/${app}/popup-import-private-key`,
  IMPORT_TRACK_ACCOUNT: `@/${app}/popup-import-track-account`,
  IMPORT_KEYSTORE: `@/${app}/popup-import-keystore`,
  ENCRYPT_WALLET: `@/${app}/encrypt-wallet-aes`,
  RES_ENCRYPTION: `@/${app}/response-encryption`,
  RES_DECRYPTION: `@/${app}/response-decryption`,
};

export const MTypePopupAccount = {
  RM_ACCOUNT: `@/${app}/remove-selected-account`,
  SELECT_ACCOUNT: `@/${app}/select-account`,
  SET_ACCOUNT_NAME: `@/${app}/set-account-name`,
  UPDATE_BALANCE: `@/${app}/popup-account-balance-upadte`,
};

export const MTypePopupTransaction = {
  UPDATE_TXNS: `@/${app}/check-processed-txns`,
  REJECT_CONFIRM_TX: `@/${app}/popup-reject-confirm-tx`,
  REJECT_ALL_CONFIRM_TXNS: `@/${app}/popup-reject-al-confirm-txns`,
  SEND_TO_SIGN_TX: `@/${app}/popup-send-to-sign-tx`,
  GET_REQUIRED_PARAMS: `@/${app}/get-required-params`,
  CLEAR_ALL_TXNS: `@/${app}/clear-all-txns`,
  GET_CURRENT_NONCE: `@/${app}/get-current-nonce`,
  RESET_NONCE: `@/${app}/reset-nonce`,
};

export const MTypePopupToken = {
  GET_ZRC2_STATE: `@/${app}/get-zrc2-token-info`,
  ADD_ZRC2_TOKEN: `@/${app}/add-new-zrc2-token`,
  RM_TOKEN: `@/${app}/remove-token`,
  GET_ZRC2_ALLOWANCES_FOR_SWAP: `@/${app}/get-zrc2-allowances-for-swap`,
};

export const MTypePopupNFT = {
  UPDATE_NFT_LIST: `@/${app}/update-nft-list`,
  GET_NFT_LIST: `@/${app}/get-nft-list`,
  FETCH_NFT: `@/${app}/fetch-nft`,
  ADD_NFT: `@/${app}/add-nft`,
  REMOVE_NFT: `@/${app}/remove-nft`,
};

export const MTypePopupNetwork = {
  SELECT_SSN: `@/${app}/select-from-ssn-list`,
  RESET_NETWROK: `@/${app}/reset-netwrok-settings`,
  SET_NET_CONFIG: `@/${app}/set-netwrok-config`,
  SELECT_NETWORK: `@/${app}/select-network`,
  UPDATE_SSN_LIST: `@/${app}/update-ssn-list`,
  GET_LATEST_BLOCK: `@/${app}/get-latest-block-number`,
};

export const MTypePopupDApp = {
  USER_RESPONSE_DAPP: `@/${app}/user-response-connect-dapp`,
  RM_APP: `@/${app}/remove-dapp`,
  CLEAR_APPS: `@/${app}/clear-all-apps`,
  SET_PHISHING_DETECTION: `@/${app}/set-phishing-detection`,
};

export const MTypePopupContact = {
  ADD_CONTACT: `@/${app}/add-a-contact`,
  RM_CONTACT: `@/${app}/remove-a-contact`,
};

export const MTypePopupSettings = {
  CHANGE_CURRENCY: `@/${app}/change-currency`,
  UPDATE_RATE: `@/${app}/update-rate`,
  RESET_CURRENCY: `@/${app}/reset-currency`,
  SET_THEME: `@/${app}/set-theme-mode`,
  RESET_THEME: `@/${app}/reset-theme`,
  SET_LOCALE: `@/${app}/set-locale`,
  RESET_LOCALE: `@/${app}/reset-locale`,
  SET_GAS_MULTIPLIER: `@/${app}/set-gas-multiplier`,
  RESET_GAS: `@/${app}/reset-gas`,
  SET_LOCK_TIME: `@/${app}/set-lock-timer`,
  SET_ADDRESS_FORMAT: `@/${app}/set-address-format`,
  SET_PROMT_ENABLED: `@/${app}/set-promt-enabled`,
};

export const MTypePopupSign = {
  REJECT_SIGN_MESSAGE: `@/${app}/reject-sign-message`,
  SIGN_MESSAGE_APPROVE: `@/${app}/approve-sign-message`,
};

export const MTypePopupUtil = {
  FROM_BECH32: `@/${app}/convert-from-bech32`,
};

export const MTypePopupDex = {
  UPDATE_DEX_DATA: `@/${app}/update-dex-data`,
  UPDATE_DEX_SETTINGS: `@/${app}/update-dex-settings`,
};

export const MTypePopupStake = {
  GET_STAKE_PROPS: `@/${app}/get-stake-props`,
};

export const MTypePopupLedger = {
  ADD_LEDGER_ACCOUNT: `@/${app}/add-ledger-account`,
};

export const MTypeTab = {
  GET_WALLET_DATA: `@/${app}/injected-get-wallet-data`,
  ADDRESS_CHANGED: `@/${app}/address-changed`,
  NETWORK_CHANGED: `@/${app}/network-changed`,
  LOCK_STAUS: `@/${app}/lack-status-updated`,
  CONTENT_PROXY_MEHTOD: `@/${app}/request-through-content`,
  CONTENT_PROXY_RESULT: `@/${app}/response-from-content`,
  CALL_TO_SIGN_TX: `@/${app}/request-to-sign-tx`,
  TX_RESULT: `@/${app}/response-tx-result`,
  SIGN_MESSAGE: `@/${app}/request-to-sign-message`,
  SING_MESSAGE_RES: `@/${app}/response-sign-message`,
  NEW_BLOCK: `@/${app}/new-block-created`,
  ADD_ENCRYPTION: `@/${app}/request-add-encryption`,
  RES_ENCRYPTION: `@/${app}/response-encryption`,
  ADD_DECRYPTION: `@/${app}/add-decryption`,
  RES_DECRYPTION: `@/${app}/response-decryption`,
  CONNECT_APP: `@/${app}/request-to-connect-dapp`,
  RESPONSE_TO_DAPP: `@/${app}/response-dapp-connect`,
  DISCONNECT_APP: `@/${app}/request-to-disconnect-dapp`
};


```

`streem/message.ts`:

```ts
import { Runtime } from "lib/runtime/extensionizer";


export interface ReqBody<T = unknown> {
    type: string;
    payload?: T;
    domain?: string;
    from?: string;
}

export class Message<T = unknown> {
    constructor(public readonly body: ReqBody<T>) {}

    static signal(type: string): Message<object> {
        return new Message({ type });
    }

    async send(): Promise<T> {
        for (let i = 0; i < 100; i++) {
            try {
                const res = await this.#trySend();
                if (res) return res;
            } catch {}
        }
        throw new Error("service_worker_stopped");
    }

    #trySend(): Promise<T> {
        return new Promise((resolve, reject) => {
            try {
                Runtime.sendMessage(this.body)
                  .then(resolve)
                  .catch((err: Error) => {
                    console.error(this, err);
                    window.location.reload();
                    reject(err);
                  });
            } catch (err) {
                console.error(this, err);
                window.location.reload();
                reject(err);
            }
        });
    }
}

```

`streem/secure-message.ts`:

```ts
import type { ReqBody } from './message';
import type { TabStream } from './tab-stream';

export class SecureContentMessage<T = unknown> {
    constructor(public readonly body: ReqBody<T>) {}

    get type() { return this.body.type; }
    get payload() { return this.body.payload; }

    send(stream: TabStream, recipient: string) {
        stream.send(this.body, recipient);
    }
}

```

`streem/tab-stream.ts`:

```ts
import type { ReqBody } from './message';
import { Runtime } from "lib/runtime";
import { MTypeTabContent } from './keys';

export class TabStream {
    constructor(public readonly eventName: string) {}

    listen(cb: (payload: ReqBody) => void) {
        globalThis.document?.addEventListener(this.eventName, (event: Event) => {
            const detail = (event as CustomEvent).detail;
            if (detail) {
                try {
                    cb(JSON.parse(detail));
                } catch (e) {
                    console.error("Error parsing event detail", e, event);
                }
            }
        });
    }

    send(data: ReqBody, to: string) {
        data.from = this.eventName;
        if (Object.values(MTypeTabContent).includes(to)) {
            this.#dispatch(JSON.stringify(data), to);
        }
    }

    #dispatch(data: string, to: string) {
        globalThis.document?.dispatchEvent(this.#getEvent(data, to));
    }

    #getEvent(detail: string, to: string) {
        return new CustomEvent(to, { detail });
    }

    /**
     * Sends a signal message to the specified tab.
     * @param tabId - The ID of the tab.
     * @param message - The message to send.
     */
    async sendSignalToTab(tabId: number, message: ReqBody): Promise<void> {
        try {
            await Runtime.tabs.sendMessage(tabId, message);
        } catch (error) {
            console.error(`Failed to send signal to tab ${tabId}:`, error);
            throw error; // Re-throw the error to be handled by the caller
        }
    }

    /**
      * Sends message to all tabs except the excluded tabIds
      * @param message
      * @param excludedTabIds
      */
    async sendToAllTabs(message: ReqBody, excludedTabIds: number[] = []): Promise<void> {
        try {
            const tabs = await Runtime.tabs.query({});
            for (const tab of tabs) {
                if (tab?.id && !excludedTabIds.includes(tab.id)) {
                    await Runtime.tabs.sendMessage(tab.id, message);
                }
            }
        } catch (error) {
            console.error("Failed to send message to all tabs:", error);
            throw error; // Re-throw the error
        }
    }
}

```

`streem/tabs-message.ts`:

```ts
import type { ReqBody } from './message';
import { Runtime } from "lib/runtime";


export class TabsMessage<T = any> {
    constructor(public readonly body: ReqBody<T>) {}

    static async getTabs(): Promise<chrome.tabs.Tab[]> {
        return Runtime.tabs.query({});
    }

    async signal(domain: string): Promise<string> {
        return new Promise<string>((resolve, reject) => {
            Runtime.tabs.query({ active: true, currentWindow: true }, (tabs: chrome.tabs.Tab[]) => {
                const tab = tabs[0];
                if (!tab) {
                    reject(new Error("no active tabs"));
                    return;
                }

                const { hostname } = new URL(tab.url!);

                if (hostname !== domain) {
                    reject(new Error("invalid domain"));
                    return;
                }
                Runtime.tabs.sendMessage(Number(tab.id), this.body)
                    .then(() => resolve(""))
                    .catch(reject);
            });
        });
    }



    async send(...domains: string[]): Promise<void> {
        const tabs = await TabsMessage.getTabs();

        tabs.forEach(async (tab) => {
            if (tab?.url && domains.includes(new URL(tab.url).hostname)) {
                try {
                    await Runtime.tabs.sendMessage(Number(tab.id), this.body);
                } catch (err) {
                    console.error(`Failed to send message to tab ${tab.id}`, err);
                }
            }
        });
    }

    async sendAll(): Promise<void> {
        const tabs = (await TabsMessage.getTabs())
            .filter((tab) => tab?.url && !tab.url.startsWith("chrome://"));

        try {
            for (const tab of tabs) {
                await Runtime.tabs.sendMessage(Number(tab.id), this.body);
            }
        } catch (err) {
            console.error("TabsMessage", err);
        }
    }
}

```